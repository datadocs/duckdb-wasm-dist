"use strict";
var duckdb = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "../../node_modules/js-sha256/src/sha256.js"(exports, module) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createOutputMethod(type, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createHmacOutputMethod(type, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):perf_hooks
  var require_perf_hooks = __commonJS({
    "(disabled):perf_hooks"() {
    }
  });

  // src/bindings/duckdb-mvp.js
  var require_duckdb_mvp = __commonJS({
    "src/bindings/duckdb-mvp.js"(exports2, module2) {
      "use strict";
      var DuckDB3 = (() => {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined")
          _scriptDir = _scriptDir || __filename;
        return function(DuckDB4 = {}) {
          var Module = typeof DuckDB4 != "undefined" ? DuckDB4 : {};
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise((resolve, reject) => {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = Object.assign({}, Module);
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = (status, toThrow) => {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window == "object";
          var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
          var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary, setWindowTitle;
          if (ENVIRONMENT_IS_NODE) {
            var fs = require_fs();
            var nodePath = require_path();
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = (filename, binary) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              return fs.readFileSync(filename, binary ? void 0 : "utf8");
            };
            readBinary = (filename) => {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              return ret;
            };
            readAsync = (filename, onload, onerror, binary = true) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
                if (err2)
                  onerror(err2);
                else
                  onload(binary ? data.buffer : data);
              });
            };
            if (!Module["thisProgram"] && process.argv.length > 1) {
              thisProgram = process.argv[1].replace(/\\/g, "/");
            }
            arguments_ = process.argv.slice(2);
            quit_ = (status, toThrow) => {
              process.exitCode = status;
              throw toThrow;
            };
            Module["inspect"] = () => "[Emscripten Module object]";
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document != "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            {
              read_ = (url) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = (url) => {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = (url, onload, onerror) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = () => {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload(xhr.response);
                    return;
                  }
                  onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
              };
            }
            setWindowTitle = (title) => document.title = title;
          } else {
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.error.bind(console);
          Object.assign(Module, moduleOverrides);
          moduleOverrides = null;
          if (Module["arguments"])
            arguments_ = Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          var noExitRuntime = Module["noExitRuntime"] || true;
          if (typeof WebAssembly != "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;
          function assert(condition, text) {
            if (!condition) {
              abort(text);
            }
          }
          var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
          }
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeKeepaliveCounter = 0;
          function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
          }
          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what);
            }
            what = "Aborted(" + what + ")";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -sASSERTIONS for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
          }
          function isFileURI(filename) {
            return filename.startsWith("file://");
          }
          var wasmBinaryFile;
          wasmBinaryFile = "./duckdb-mvp.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary2(file) {
            try {
              if (file == wasmBinaryFile && wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(file);
              }
              throw "both async and sync fetching of the wasm failed";
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise(binaryFile) {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch == "function") {
                return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
                  if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + binaryFile + "'";
                  }
                  return response["arrayBuffer"]();
                }).catch(() => getBinary2(binaryFile));
              }
            }
            return Promise.resolve().then(() => getBinary2(binaryFile));
          }
          function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary) => {
              return WebAssembly.instantiate(binary, imports);
            }).then((instance9) => {
              return instance9;
            }).then(receiver, (reason) => {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync(binary, binaryFile, imports, callback) {
            if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
              return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
                var result = WebAssembly.instantiateStreaming(response, imports);
                return result.then(callback, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(binaryFile, imports, callback);
                });
              });
            } else {
              return instantiateArrayBuffer(binaryFile, imports, callback);
            }
          }
          function createWasm() {
            var info = { "a": wasmImports };
            function receiveInstance(instance9, module3) {
              var exports3 = instance9.exports;
              Module["asm"] = exports3;
              wasmMemory = Module["asm"]["Ra"];
              updateMemoryViews();
              wasmTable = Module["asm"]["Ua"];
              addOnInit(Module["asm"]["Sa"]);
              removeRunDependency("wasm-instantiate");
              return exports3;
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"]);
            }
            if (Module["instantiateWasm"]) {
              try {
                return Module["instantiateWasm"](info, receiveInstance);
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                readyPromiseReject(e);
              }
            }
            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
          }
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              callbacks.shift()(Module);
            }
          }
          function _XML_GetBuffer() {
            err("missing function: XML_GetBuffer");
            abort(-1);
          }
          function _XML_GetErrorCode() {
            err("missing function: XML_GetErrorCode");
            abort(-1);
          }
          function _XML_Parse() {
            err("missing function: XML_Parse");
            abort(-1);
          }
          function _XML_ParseBuffer() {
            err("missing function: XML_ParseBuffer");
            abort(-1);
          }
          function _XML_ParserCreate() {
            err("missing function: XML_ParserCreate");
            abort(-1);
          }
          function _XML_ParserFree() {
            err("missing function: XML_ParserFree");
            abort(-1);
          }
          function _XML_ResumeParser() {
            err("missing function: XML_ResumeParser");
            abort(-1);
          }
          function _XML_SetCharacterDataHandler() {
            err("missing function: XML_SetCharacterDataHandler");
            abort(-1);
          }
          function _XML_SetElementHandler() {
            err("missing function: XML_SetElementHandler");
            abort(-1);
          }
          function _XML_SetUserData() {
            err("missing function: XML_SetUserData");
            abort(-1);
          }
          function _XML_StopParser() {
            err("missing function: XML_StopParser");
            abort(-1);
          }
          function ExceptionInfo(excPtr) {
            this.excPtr = excPtr;
            this.ptr = excPtr - 24;
            this.set_type = function(type) {
              HEAPU32[this.ptr + 4 >>> 2] = type;
            };
            this.get_type = function() {
              return HEAPU32[this.ptr + 4 >>> 2];
            };
            this.set_destructor = function(destructor) {
              HEAPU32[this.ptr + 8 >>> 2] = destructor;
            };
            this.get_destructor = function() {
              return HEAPU32[this.ptr + 8 >>> 2];
            };
            this.set_caught = function(caught) {
              caught = caught ? 1 : 0;
              HEAP8[this.ptr + 12 >>> 0] = caught;
            };
            this.get_caught = function() {
              return HEAP8[this.ptr + 12 >>> 0] != 0;
            };
            this.set_rethrown = function(rethrown) {
              rethrown = rethrown ? 1 : 0;
              HEAP8[this.ptr + 13 >>> 0] = rethrown;
            };
            this.get_rethrown = function() {
              return HEAP8[this.ptr + 13 >>> 0] != 0;
            };
            this.init = function(type, destructor) {
              this.set_adjusted_ptr(0);
              this.set_type(type);
              this.set_destructor(destructor);
            };
            this.set_adjusted_ptr = function(adjustedPtr) {
              HEAPU32[this.ptr + 16 >>> 2] = adjustedPtr;
            };
            this.get_adjusted_ptr = function() {
              return HEAPU32[this.ptr + 16 >>> 2];
            };
            this.get_exception_ptr = function() {
              var isPointer = ___cxa_is_pointer_type(this.get_type());
              if (isPointer) {
                return HEAPU32[this.excPtr >>> 2];
              }
              var adjusted = this.get_adjusted_ptr();
              if (adjusted !== 0)
                return adjusted;
              return this.excPtr;
            };
          }
          var exceptionLast = 0;
          var uncaughtExceptionCount = 0;
          function ___cxa_throw(ptr, type, destructor) {
            var info = new ExceptionInfo(ptr);
            info.init(type, destructor);
            exceptionLast = ptr;
            uncaughtExceptionCount++;
            throw exceptionLast;
          }
          var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html";
          function ___dlsym(handle, symbol, ra) {
            abort(dlopenMissingError);
          }
          var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
          function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heapOrArray[endPtr] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
              return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            }
            var str = "";
            while (idx < endPtr) {
              var u0 = heapOrArray[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heapOrArray[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heapOrArray[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            ptr >>>= 0;
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
          }
          var SYSCALLS = { varargs: void 0, get: function() {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
            return ret;
          }, getStr: function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          } };
          function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
            var total = 0;
            var srcReadLow = readfds ? HEAP32[readfds >>> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2] : 0;
            var srcWriteLow = writefds ? HEAP32[writefds >>> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2] : 0;
            var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0;
            var dstReadLow = 0, dstReadHigh = 0;
            var dstWriteLow = 0, dstWriteHigh = 0;
            var dstExceptLow = 0, dstExceptHigh = 0;
            var allLow = (readfds ? HEAP32[readfds >>> 2] : 0) | (writefds ? HEAP32[writefds >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2] : 0);
            var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0);
            var check = function(fd2, low, high, val) {
              return fd2 < 32 ? low & val : high & val;
            };
            for (var fd = 0; fd < nfds; fd++) {
              var mask = 1 << fd % 32;
              if (!check(fd, allLow, allHigh, mask)) {
                continue;
              }
              var stream = SYSCALLS.getStreamFromFD(fd);
              var flags = SYSCALLS.DEFAULT_POLLMASK;
              if (stream.stream_ops.poll) {
                flags = stream.stream_ops.poll(stream);
              }
              if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
                total++;
              }
              if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
                total++;
              }
              if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
                total++;
              }
            }
            if (readfds) {
              HEAP32[readfds >>> 2] = dstReadLow;
              HEAP32[readfds + 4 >>> 2] = dstReadHigh;
            }
            if (writefds) {
              HEAP32[writefds >>> 2] = dstWriteLow;
              HEAP32[writefds + 4 >>> 2] = dstWriteHigh;
            }
            if (exceptfds) {
              HEAP32[exceptfds >>> 2] = dstExceptLow;
              HEAP32[exceptfds + 4 >>> 2] = dstExceptHigh;
            }
            return total;
          }
          function SOCKFS() {
            err("missing function: $SOCKFS");
            abort(-1);
          }
          function FS() {
            err("missing function: $FS");
            abort(-1);
          }
          function getSocketFromFD(fd) {
            var socket = SOCKFS.getSocket(fd);
            if (!socket)
              throw new FS.ErrnoError(8);
            return socket;
          }
          function inetNtop4(addr) {
            return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
          }
          function inetNtop6(ints) {
            var str = "";
            var word = 0;
            var longest = 0;
            var lastzero = 0;
            var zstart = 0;
            var len = 0;
            var i = 0;
            var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
            var hasipv4 = true;
            var v4part = "";
            for (i = 0; i < 5; i++) {
              if (parts[i] !== 0) {
                hasipv4 = false;
                break;
              }
            }
            if (hasipv4) {
              v4part = inetNtop4(parts[6] | parts[7] << 16);
              if (parts[5] === -1) {
                str = "::ffff:";
                str += v4part;
                return str;
              }
              if (parts[5] === 0) {
                str = "::";
                if (v4part === "0.0.0.0")
                  v4part = "";
                if (v4part === "0.0.0.1")
                  v4part = "1";
                str += v4part;
                return str;
              }
            }
            for (word = 0; word < 8; word++) {
              if (parts[word] === 0) {
                if (word - lastzero > 1) {
                  len = 0;
                }
                lastzero = word;
                len++;
              }
              if (len > longest) {
                longest = len;
                zstart = word - longest + 1;
              }
            }
            for (word = 0; word < 8; word++) {
              if (longest > 1) {
                if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
                  if (word === zstart) {
                    str += ":";
                    if (zstart === 0)
                      str += ":";
                  }
                  continue;
                }
              }
              str += Number(_ntohs(parts[word] & 65535)).toString(16);
              str += word < 7 ? ":" : "";
            }
            return str;
          }
          function readSockaddr(sa, salen) {
            var family = HEAP16[sa >>> 1];
            var port = _ntohs(HEAPU16[sa + 2 >>> 1]);
            var addr;
            switch (family) {
              case 2:
                if (salen !== 16) {
                  return { errno: 28 };
                }
                addr = HEAP32[sa + 4 >>> 2];
                addr = inetNtop4(addr);
                break;
              case 10:
                if (salen !== 28) {
                  return { errno: 28 };
                }
                addr = [HEAP32[sa + 8 >>> 2], HEAP32[sa + 12 >>> 2], HEAP32[sa + 16 >>> 2], HEAP32[sa + 20 >>> 2]];
                addr = inetNtop6(addr);
                break;
              default:
                return { errno: 5 };
            }
            return { family, addr, port };
          }
          function inetPton4(str) {
            var b = str.split(".");
            for (var i = 0; i < 4; i++) {
              var tmp2 = Number(b[i]);
              if (isNaN(tmp2))
                return null;
              b[i] = tmp2;
            }
            return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
          }
          function jstoi_q(str) {
            return parseInt(str);
          }
          function inetPton6(str) {
            var words;
            var w, offset, z;
            var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
            var parts = [];
            if (!valid6regx.test(str)) {
              return null;
            }
            if (str === "::") {
              return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            if (str.startsWith("::")) {
              str = str.replace("::", "Z:");
            } else {
              str = str.replace("::", ":Z:");
            }
            if (str.indexOf(".") > 0) {
              str = str.replace(new RegExp("[.]", "g"), ":");
              words = str.split(":");
              words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
              words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
              words = words.slice(0, words.length - 2);
            } else {
              words = str.split(":");
            }
            offset = 0;
            z = 0;
            for (w = 0; w < words.length; w++) {
              if (typeof words[w] == "string") {
                if (words[w] === "Z") {
                  for (z = 0; z < 8 - words.length + 1; z++) {
                    parts[w + z] = 0;
                  }
                  offset = z - 1;
                } else {
                  parts[w + offset] = _htons(parseInt(words[w], 16));
                }
              } else {
                parts[w + offset] = words[w];
              }
            }
            return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
          }
          var DNS = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name: function(name) {
            var res = inetPton4(name);
            if (res !== null) {
              return name;
            }
            res = inetPton6(name);
            if (res !== null) {
              return name;
            }
            var addr;
            if (DNS.address_map.addrs[name]) {
              addr = DNS.address_map.addrs[name];
            } else {
              var id = DNS.address_map.id++;
              assert(id < 65535, "exceeded max address mappings of 65535");
              addr = "172.29." + (id & 255) + "." + (id & 65280);
              DNS.address_map.names[addr] = name;
              DNS.address_map.addrs[name] = addr;
            }
            return addr;
          }, lookup_addr: function(addr) {
            if (DNS.address_map.names[addr]) {
              return DNS.address_map.names[addr];
            }
            return null;
          } };
          function getSocketAddress(addrp, addrlen, allowNull) {
            if (allowNull && addrp === 0)
              return null;
            var info = readSockaddr(addrp, addrlen);
            if (info.errno)
              throw new FS.ErrnoError(info.errno);
            info.addr = DNS.lookup_addr(info.addr) || info.addr;
            return info;
          }
          function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
            var sock = getSocketFromFD(fd);
            var info = getSocketAddress(addr, addrlen);
            sock.sock_ops.bind(sock, info.addr, info.port);
            return 0;
          }
          function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
            var sock = getSocketFromFD(fd);
            var info = getSocketAddress(addr, addrlen);
            sock.sock_ops.connect(sock, info.addr, info.port);
            return 0;
          }
          function ___syscall_faccessat(dirfd, path, amode, flags) {
          }
          function ___syscall_fcntl64(fd, cmd, varargs) {
            SYSCALLS.varargs = varargs;
            return 0;
          }
          function ___syscall_fstat64(fd, buf) {
          }
          function ___syscall_ftruncate64(fd, length_low, length_high) {
          }
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          }
          function ___syscall_getdents64(fd, dirp, count) {
          }
          function zeroMemory(address, size) {
            HEAPU8.fill(0, address, address + size);
            return address;
          }
          function writeSockaddr(sa, family, addr, port, addrlen) {
            switch (family) {
              case 2:
                addr = inetPton4(addr);
                zeroMemory(sa, 16);
                if (addrlen) {
                  HEAP32[addrlen >>> 2] = 16;
                }
                HEAP16[sa >>> 1] = family;
                HEAP32[sa + 4 >>> 2] = addr;
                HEAP16[sa + 2 >>> 1] = _htons(port);
                break;
              case 10:
                addr = inetPton6(addr);
                zeroMemory(sa, 28);
                if (addrlen) {
                  HEAP32[addrlen >>> 2] = 28;
                }
                HEAP32[sa >>> 2] = family;
                HEAP32[sa + 8 >>> 2] = addr[0];
                HEAP32[sa + 12 >>> 2] = addr[1];
                HEAP32[sa + 16 >>> 2] = addr[2];
                HEAP32[sa + 20 >>> 2] = addr[3];
                HEAP16[sa + 2 >>> 1] = _htons(port);
                break;
              default:
                return 5;
            }
            return 0;
          }
          function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
            var sock = getSocketFromFD(fd);
            if (!sock.daddr) {
              return -53;
            }
            var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
            return 0;
          }
          function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
            var sock = getSocketFromFD(fd);
            if (level === 1) {
              if (optname === 4) {
                HEAP32[optval >>> 2] = sock.error;
                HEAP32[optlen >>> 2] = 4;
                sock.error = null;
                return 0;
              }
            }
            return -50;
          }
          function ___syscall_ioctl(fd, op, varargs) {
            SYSCALLS.varargs = varargs;
            return 0;
          }
          function ___syscall_lstat64(path, buf) {
          }
          function ___syscall_mkdirat(dirfd, path, mode) {
          }
          function ___syscall_newfstatat(dirfd, path, buf, flags) {
          }
          function ___syscall_openat(dirfd, path, flags, varargs) {
            SYSCALLS.varargs = varargs;
          }
          function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
            var sock = getSocketFromFD(fd);
            var msg = sock.sock_ops.recvmsg(sock, len);
            if (!msg)
              return 0;
            if (addr) {
              var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
            }
            HEAPU8.set(msg.buffer, buf >>> 0);
            return msg.buffer.byteLength;
          }
          function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
          }
          function ___syscall_rmdir(path) {
          }
          function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
          }
          function ___syscall_socket(domain, type, protocol) {
          }
          function ___syscall_stat64(path, buf) {
          }
          function ___syscall_unlinkat(dirfd, path, flags) {
          }
          var nowIsMonotonic = true;
          function __emscripten_get_now_is_monotonic() {
            return nowIsMonotonic;
          }
          function readI53FromI64(ptr) {
            return HEAPU32[ptr >>> 2] + HEAP32[ptr + 4 >>> 2] * 4294967296;
          }
          function isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
          var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          function ydayFromDate(date) {
            var leap = isLeapYear(date.getFullYear());
            var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
            var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
            return yday;
          }
          function __localtime_js(time, tmPtr) {
            var date = new Date(readI53FromI64(time) * 1e3);
            HEAP32[tmPtr >>> 2] = date.getSeconds();
            HEAP32[tmPtr + 4 >>> 2] = date.getMinutes();
            HEAP32[tmPtr + 8 >>> 2] = date.getHours();
            HEAP32[tmPtr + 12 >>> 2] = date.getDate();
            HEAP32[tmPtr + 16 >>> 2] = date.getMonth();
            HEAP32[tmPtr + 20 >>> 2] = date.getFullYear() - 1900;
            HEAP32[tmPtr + 24 >>> 2] = date.getDay();
            var yday = ydayFromDate(date) | 0;
            HEAP32[tmPtr + 28 >>> 2] = yday;
            HEAP32[tmPtr + 36 >>> 2] = -(date.getTimezoneOffset() * 60);
            var start = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start.getTimezoneOffset();
            var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
            HEAP32[tmPtr + 32 >>> 2] = dst;
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var c = str.charCodeAt(i);
              if (c <= 127) {
                len++;
              } else if (c <= 2047) {
                len += 2;
              } else if (c >= 55296 && c <= 57343) {
                len += 4;
                ++i;
              } else {
                len += 3;
              }
            }
            return len;
          }
          function stringToNewUTF8(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret)
              stringToUTF8(str, ret, size);
            return ret;
          }
          function __tzset_js(timezone, daylight, tzname) {
            var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
            var winter = new Date(currentYear, 0, 1);
            var summer = new Date(currentYear, 6, 1);
            var winterOffset = winter.getTimezoneOffset();
            var summerOffset = summer.getTimezoneOffset();
            var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
            HEAPU32[timezone >>> 2] = stdTimezoneOffset * 60;
            HEAP32[daylight >>> 2] = Number(winterOffset != summerOffset);
            function extractZone(date) {
              var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
              return match ? match[1] : "GMT";
            }
            var winterName = extractZone(winter);
            var summerName = extractZone(summer);
            var winterNamePtr = stringToNewUTF8(winterName);
            var summerNamePtr = stringToNewUTF8(summerName);
            if (summerOffset < winterOffset) {
              HEAPU32[tzname >>> 2] = winterNamePtr;
              HEAPU32[tzname + 4 >>> 2] = summerNamePtr;
            } else {
              HEAPU32[tzname >>> 2] = summerNamePtr;
              HEAPU32[tzname + 4 >>> 2] = winterNamePtr;
            }
          }
          function _abort() {
            abort("");
          }
          function _dlopen(filename, flags) {
            abort(dlopenMissingError);
          }
          function _duckdb_web_fs_directory_create(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
          }
          function _duckdb_web_fs_directory_exists(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
          }
          function _duckdb_web_fs_directory_list_files(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
          }
          function _duckdb_web_fs_directory_remove(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
          }
          function _duckdb_web_fs_file_close(fileId) {
            return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
          }
          function _duckdb_web_fs_file_exists(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
          }
          function _duckdb_web_fs_file_get_last_modified_time(fileId) {
            return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
          }
          function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
            return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
          }
          function _duckdb_web_fs_file_open(fileId, flags) {
            return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags);
          }
          function _duckdb_web_fs_file_read(fileId, buf, size, location) {
            return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
          }
          function _duckdb_web_fs_file_truncate(fileId, newSize) {
            return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
          }
          function _duckdb_web_fs_file_write(fileId, buf, size, location) {
            return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
          }
          function _duckdb_web_fs_get_default_data_protocol(Module2) {
            return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
          }
          function _duckdb_web_fs_glob(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
          }
          function _duckdb_web_test_platform_feature(feature) {
            return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
          }
          function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
            return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
          }
          function _emscripten_date_now() {
            return Date.now();
          }
          function getHeapMax() {
            return 4294901760;
          }
          function _emscripten_get_heap_max() {
            return getHeapMax();
          }
          var _emscripten_get_now;
          if (ENVIRONMENT_IS_NODE) {
            global.performance = require_perf_hooks().performance;
          }
          _emscripten_get_now = () => performance.now();
          function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          function emscripten_realloc_buffer(size) {
            var b = wasmMemory.buffer;
            var pages = size - b.byteLength + 65535 >>> 16;
            try {
              wasmMemory.grow(pages);
              updateMemoryViews();
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            var oldSize = HEAPU8.length;
            requestedSize = requestedSize >>> 0;
            var maxHeapSize = getHeapMax();
            if (requestedSize > maxHeapSize) {
              return false;
            }
            var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
              var replacement = emscripten_realloc_buffer(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          var ENV = {};
          function getExecutableName() {
            return thisProgram || "./this.program";
          }
          function getEnvStrings() {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
              for (var x in ENV) {
                if (ENV[x] === void 0)
                  delete env[x];
                else
                  env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(`${x}=${env[x]}`);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          }
          function stringToAscii(str, buffer) {
            for (var i = 0; i < str.length; ++i) {
              HEAP8[buffer++ >>> 0] = str.charCodeAt(i);
            }
            HEAP8[buffer >>> 0] = 0;
          }
          function _environ_get(__environ, environ_buf) {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              HEAPU32[__environ + i * 4 >>> 2] = ptr;
              stringToAscii(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          }
          function _environ_sizes_get(penviron_count, penviron_buf_size) {
            var strings = getEnvStrings();
            HEAPU32[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            HEAPU32[penviron_buf_size >>> 2] = bufSize;
            return 0;
          }
          function _fd_close(fd) {
            return 52;
          }
          function _fd_fdstat_get(fd, pbuf) {
            var rightsBase = 0;
            var rightsInheriting = 0;
            var flags = 0;
            {
              var type = 2;
              if (fd == 0) {
                rightsBase = 2;
              } else if (fd == 1 || fd == 2) {
                rightsBase = 64;
              }
              flags = 1;
            }
            HEAP8[pbuf >>> 0] = type;
            HEAP16[pbuf + 2 >>> 1] = flags;
            tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2] = tempI64[0], HEAP32[pbuf + 12 >>> 2] = tempI64[1];
            tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2] = tempI64[0], HEAP32[pbuf + 20 >>> 2] = tempI64[1];
            return 0;
          }
          function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            return 52;
          }
          function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            return 52;
          }
          function _fd_read(fd, iov, iovcnt, pnum) {
            return 52;
          }
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            return 70;
          }
          function _fd_sync(fd) {
            return 52;
          }
          var printCharBuffers = [null, [], []];
          function printChar(stream, curr) {
            var buffer = printCharBuffers[stream];
            if (curr === 0 || curr === 10) {
              (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
              buffer.length = 0;
            } else {
              buffer.push(curr);
            }
          }
          function _fd_write(fd, iov, iovcnt, pnum) {
            var num = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAPU32[iov >>> 2];
              var len = HEAPU32[iov + 4 >>> 2];
              iov += 8;
              for (var j = 0; j < len; j++) {
                printChar(fd, HEAPU8[ptr + j >>> 0]);
              }
              num += len;
            }
            HEAPU32[pnum >>> 2] = num;
            return 0;
          }
          function _getaddrinfo(node, service, hint, out2) {
            var addr = 0;
            var port = 0;
            var flags = 0;
            var family = 0;
            var type = 0;
            var proto = 0;
            var ai;
            function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
              var sa, salen, ai2;
              var errno;
              salen = family2 === 10 ? 28 : 16;
              addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
              sa = _malloc(salen);
              errno = writeSockaddr(sa, family2, addr2, port2);
              assert(!errno);
              ai2 = _malloc(32);
              HEAP32[ai2 + 4 >>> 2] = family2;
              HEAP32[ai2 + 8 >>> 2] = type2;
              HEAP32[ai2 + 12 >>> 2] = proto2;
              HEAPU32[ai2 + 24 >>> 2] = canon;
              HEAPU32[ai2 + 20 >>> 2] = sa;
              if (family2 === 10) {
                HEAP32[ai2 + 16 >>> 2] = 28;
              } else {
                HEAP32[ai2 + 16 >>> 2] = 16;
              }
              HEAP32[ai2 + 28 >>> 2] = 0;
              return ai2;
            }
            if (hint) {
              flags = HEAP32[hint >>> 2];
              family = HEAP32[hint + 4 >>> 2];
              type = HEAP32[hint + 8 >>> 2];
              proto = HEAP32[hint + 12 >>> 2];
            }
            if (type && !proto) {
              proto = type === 2 ? 17 : 6;
            }
            if (!type && proto) {
              type = proto === 17 ? 2 : 1;
            }
            if (proto === 0) {
              proto = 6;
            }
            if (type === 0) {
              type = 1;
            }
            if (!node && !service) {
              return -2;
            }
            if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
              return -1;
            }
            if (hint !== 0 && HEAP32[hint >>> 2] & 2 && !node) {
              return -1;
            }
            if (flags & 32) {
              return -2;
            }
            if (type !== 0 && type !== 1 && type !== 2) {
              return -7;
            }
            if (family !== 0 && family !== 2 && family !== 10) {
              return -6;
            }
            if (service) {
              service = UTF8ToString(service);
              port = parseInt(service, 10);
              if (isNaN(port)) {
                if (flags & 1024) {
                  return -2;
                }
                return -8;
              }
            }
            if (!node) {
              if (family === 0) {
                family = 2;
              }
              if ((flags & 1) === 0) {
                if (family === 2) {
                  addr = _htonl(2130706433);
                } else {
                  addr = [0, 0, 0, 1];
                }
              }
              ai = allocaddrinfo(family, type, proto, null, addr, port);
              HEAPU32[out2 >>> 2] = ai;
              return 0;
            }
            node = UTF8ToString(node);
            addr = inetPton4(node);
            if (addr !== null) {
              if (family === 0 || family === 2) {
                family = 2;
              } else if (family === 10 && flags & 8) {
                addr = [0, 0, _htonl(65535), addr];
                family = 10;
              } else {
                return -2;
              }
            } else {
              addr = inetPton6(node);
              if (addr !== null) {
                if (family === 0 || family === 10) {
                  family = 10;
                } else {
                  return -2;
                }
              }
            }
            if (addr != null) {
              ai = allocaddrinfo(family, type, proto, node, addr, port);
              HEAPU32[out2 >>> 2] = ai;
              return 0;
            }
            if (flags & 4) {
              return -2;
            }
            node = DNS.lookup_name(node);
            addr = inetPton4(node);
            if (family === 0) {
              family = 2;
            } else if (family === 10) {
              addr = [0, 0, _htonl(65535), addr];
            }
            ai = allocaddrinfo(family, type, proto, null, addr, port);
            HEAPU32[out2 >>> 2] = ai;
            return 0;
          }
          function initRandomFill() {
            if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
              return (view) => crypto.getRandomValues(view);
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = __require("crypto");
                var randomFillSync = crypto_module["randomFillSync"];
                if (randomFillSync) {
                  return (view) => crypto_module["randomFillSync"](view);
                }
                var randomBytes = crypto_module["randomBytes"];
                return (view) => (view.set(randomBytes(view.byteLength)), view);
              } catch (e) {
              }
            }
            abort("initRandomDevice");
          }
          function randomFill(view) {
            return (randomFill = initRandomFill())(view);
          }
          function _getentropy(buffer, size) {
            randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
            return 0;
          }
          function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
            var info = readSockaddr(sa, salen);
            if (info.errno) {
              return -6;
            }
            var port = info.port;
            var addr = info.addr;
            var overflowed = false;
            if (node && nodelen) {
              var lookup;
              if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
                if (flags & 8) {
                  return -2;
                }
              } else {
                addr = lookup;
              }
              var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
              if (numBytesWrittenExclNull + 1 >= nodelen) {
                overflowed = true;
              }
            }
            if (serv && servlen) {
              port = "" + port;
              var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
              if (numBytesWrittenExclNull + 1 >= servlen) {
                overflowed = true;
              }
            }
            if (overflowed) {
              return -12;
            }
            return 0;
          }
          function arraySum(array, index) {
            var sum2 = 0;
            for (var i = 0; i <= index; sum2 += array[i++]) {
            }
            return sum2;
          }
          var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          function writeArrayToMemory(array, buffer) {
            HEAP8.set(array, buffer >>> 0);
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = HEAP32[tm + 40 >>> 2];
            var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value == "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                }
                return thisDate.getFullYear();
              }
              return thisDate.getFullYear() - 1;
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              }
              return "PM";
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var days = date2.tm_yday + 7 - date2.tm_wday;
              return leadingNulls(Math.floor(days / 7), 2);
            }, "%V": function(date2) {
              var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
              if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
                val++;
              }
              if (!val) {
                val = 52;
                var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
                if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                  val++;
                }
              } else if (val == 53) {
                var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
                if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                  val = 1;
              }
              return leadingNulls(val, 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
              return leadingNulls(Math.floor(days / 7), 2);
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            pattern = pattern.replace(/%%/g, "\0\0");
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.includes(rule)) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            pattern = pattern.replace(/\0\0/g, "%");
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm, loc) {
            return _strftime(s, maxsize, format, tm);
          }
          function _ucnv_close_64() {
            err("missing function: ucnv_close_64");
            abort(-1);
          }
          function _ucnv_convertEx_64() {
            err("missing function: ucnv_convertEx_64");
            abort(-1);
          }
          function _ucnv_open_64() {
            err("missing function: ucnv_open_64");
            abort(-1);
          }
          function _ucnv_toAlgorithmic_64() {
            err("missing function: ucnv_toAlgorithmic_64");
            abort(-1);
          }
          function _ucsdet_close_64() {
            err("missing function: ucsdet_close_64");
            abort(-1);
          }
          function _ucsdet_detect_64() {
            err("missing function: ucsdet_detect_64");
            abort(-1);
          }
          function _ucsdet_getConfidence_64() {
            err("missing function: ucsdet_getConfidence_64");
            abort(-1);
          }
          function _ucsdet_getName_64() {
            err("missing function: ucsdet_getName_64");
            abort(-1);
          }
          function _ucsdet_open_64() {
            err("missing function: ucsdet_open_64");
            abort(-1);
          }
          function _ucsdet_setText_64() {
            err("missing function: ucsdet_setText_64");
            abort(-1);
          }
          function _unzClose() {
            err("missing function: unzClose");
            abort(-1);
          }
          function _unzCloseCurrentFile() {
            err("missing function: unzCloseCurrentFile");
            abort(-1);
          }
          function _unzGetCurrentFileInfo() {
            err("missing function: unzGetCurrentFileInfo");
            abort(-1);
          }
          function _unzGetCurrentFileInfo64() {
            err("missing function: unzGetCurrentFileInfo64");
            abort(-1);
          }
          function _unzGetGlobalInfo() {
            err("missing function: unzGetGlobalInfo");
            abort(-1);
          }
          function _unzGoToFirstFile() {
            err("missing function: unzGoToFirstFile");
            abort(-1);
          }
          function _unzGoToNextFile() {
            err("missing function: unzGoToNextFile");
            abort(-1);
          }
          function _unzLocateFile() {
            err("missing function: unzLocateFile");
            abort(-1);
          }
          function _unzOpen() {
            err("missing function: unzOpen");
            abort(-1);
          }
          function _unzOpen2() {
            err("missing function: unzOpen2");
            abort(-1);
          }
          function _unzOpenCurrentFile() {
            err("missing function: unzOpenCurrentFile");
            abort(-1);
          }
          function _unzReadCurrentFile() {
            err("missing function: unzReadCurrentFile");
            abort(-1);
          }
          function _proc_exit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
              if (Module["onExit"])
                Module["onExit"](code);
              ABORT = true;
            }
            quit_(code, new ExitStatus(code));
          }
          function exitJS(status, implicit) {
            EXITSTATUS = status;
            _proc_exit(status);
          }
          function handleException(e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return EXITSTATUS;
            }
            quit_(1, e);
          }
          function getCFunc(ident) {
            var func = Module["_" + ident];
            return func;
          }
          function stringToUTF8OnStack(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8(str, ret, size);
            return ret;
          }
          function ccall(ident, returnType, argTypes, args, opts) {
            var toC = { "string": (str) => {
              var ret2 = 0;
              if (str !== null && str !== void 0 && str !== 0) {
                ret2 = stringToUTF8OnStack(str);
              }
              return ret2;
            }, "array": (arr) => {
              var ret2 = stackAlloc(arr.length);
              writeArrayToMemory(arr, ret2);
              return ret2;
            } };
            function convertReturnValue(ret2) {
              if (returnType === "string") {
                return UTF8ToString(ret2);
              }
              if (returnType === "boolean")
                return Boolean(ret2);
              return ret2;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args) {
              for (var i = 0; i < args.length; i++) {
                var converter = toC[argTypes[i]];
                if (converter) {
                  if (stack === 0)
                    stack = stackSave();
                  cArgs[i] = converter(args[i]);
                } else {
                  cArgs[i] = args[i];
                }
              }
            }
            var ret = func.apply(null, cArgs);
            function onDone(ret2) {
              if (stack !== 0)
                stackRestore(stack);
              return convertReturnValue(ret2);
            }
            ret = onDone(ret);
            return ret;
          }
          var wasmImports = { "g": _XML_GetBuffer, "V": _XML_GetErrorCode, "da": _XML_Parse, "n": _XML_ParseBuffer, "p": _XML_ParserCreate, "d": _XML_ParserFree, "B": _XML_ResumeParser, "f": _XML_SetCharacterDataHandler, "b": _XML_SetElementHandler, "o": _XML_SetUserData, "h": _XML_StopParser, "a": ___cxa_throw, "La": ___dlsym, "Fa": ___syscall__newselect, "Ja": ___syscall_bind, "Ia": ___syscall_connect, "Ba": ___syscall_faccessat, "e": ___syscall_fcntl64, "Aa": ___syscall_fstat64, "O": ___syscall_ftruncate64, "va": ___syscall_getdents64, "Da": ___syscall_getpeername, "Ea": ___syscall_getsockopt, "K": ___syscall_ioctl, "xa": ___syscall_lstat64, "wa": ___syscall_mkdirat, "ya": ___syscall_newfstatat, "L": ___syscall_openat, "Ga": ___syscall_recvfrom, "ta": ___syscall_renameat, "F": ___syscall_rmdir, "Ha": ___syscall_sendto, "H": ___syscall_socket, "za": ___syscall_stat64, "G": ___syscall_unlinkat, "Na": __emscripten_get_now_is_monotonic, "fa": __localtime_js, "ga": __tzset_js, "j": _abort, "Ma": _dlopen, "ma": _duckdb_web_fs_directory_create, "na": _duckdb_web_fs_directory_exists, "ka": _duckdb_web_fs_directory_list_files, "la": _duckdb_web_fs_directory_remove, "D": _duckdb_web_fs_file_close, "ia": _duckdb_web_fs_file_exists, "N": _duckdb_web_fs_file_get_last_modified_time, "ja": _duckdb_web_fs_file_move, "pa": _duckdb_web_fs_file_open, "q": _duckdb_web_fs_file_read, "oa": _duckdb_web_fs_file_truncate, "E": _duckdb_web_fs_file_write, "qa": _duckdb_web_fs_get_default_data_protocol, "ha": _duckdb_web_fs_glob, "C": _duckdb_web_test_platform_feature, "ra": _duckdb_web_udf_scalar_call, "M": _emscripten_date_now, "Oa": _emscripten_get_heap_max, "i": _emscripten_get_now, "Ka": _emscripten_memcpy_big, "Qa": _emscripten_resize_heap, "T": _environ_get, "W": _environ_sizes_get, "l": _fd_close, "ea": _fd_fdstat_get, "Q": _fd_pread, "P": _fd_pwrite, "J": _fd_read, "R": _fd_seek, "ua": _fd_sync, "w": _fd_write, "I": _getaddrinfo, "sa": _getentropy, "Ca": _getnameinfo, "Pa": _strftime_l, "c": _ucnv_close_64, "X": _ucnv_convertEx_64, "v": _ucnv_open_64, "Z": _ucnv_toAlgorithmic_64, "Y": _ucsdet_close_64, "aa": _ucsdet_detect_64, "$": _ucsdet_getConfidence_64, "_": _ucsdet_getName_64, "ca": _ucsdet_open_64, "ba": _ucsdet_setText_64, "k": _unzClose, "u": _unzCloseCurrentFile, "z": _unzGetCurrentFileInfo, "r": _unzGetCurrentFileInfo64, "U": _unzGetGlobalInfo, "A": _unzGoToFirstFile, "y": _unzGoToNextFile, "t": _unzLocateFile, "x": _unzOpen, "S": _unzOpen2, "s": _unzOpenCurrentFile, "m": _unzReadCurrentFile };
          var asm = createWasm();
          var ___wasm_call_ctors = function() {
            return (___wasm_call_ctors = Module["asm"]["Sa"]).apply(null, arguments);
          };
          var _main = Module["_main"] = function() {
            return (_main = Module["_main"] = Module["asm"]["Ta"]).apply(null, arguments);
          };
          var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = function() {
            return (_duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = Module["asm"]["Va"]).apply(null, arguments);
          };
          var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = function() {
            return (_duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = Module["asm"]["Wa"]).apply(null, arguments);
          };
          var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = function() {
            return (_duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = Module["asm"]["Xa"]).apply(null, arguments);
          };
          var _duckdb_web_reset = Module["_duckdb_web_reset"] = function() {
            return (_duckdb_web_reset = Module["_duckdb_web_reset"] = Module["asm"]["Ya"]).apply(null, arguments);
          };
          var _duckdb_web_connect = Module["_duckdb_web_connect"] = function() {
            return (_duckdb_web_connect = Module["_duckdb_web_connect"] = Module["asm"]["Za"]).apply(null, arguments);
          };
          var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = function() {
            return (_duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = Module["asm"]["_a"]).apply(null, arguments);
          };
          var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = function() {
            return (_duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = Module["asm"]["$a"]).apply(null, arguments);
          };
          var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = function() {
            return (_duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = Module["asm"]["ab"]).apply(null, arguments);
          };
          var _duckdb_web_open = Module["_duckdb_web_open"] = function() {
            return (_duckdb_web_open = Module["_duckdb_web_open"] = Module["asm"]["bb"]).apply(null, arguments);
          };
          var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = function() {
            return (_duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = Module["asm"]["cb"]).apply(null, arguments);
          };
          var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = function() {
            return (_duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = Module["asm"]["db"]).apply(null, arguments);
          };
          var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = function() {
            return (_duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = Module["asm"]["eb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = function() {
            return (_duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = Module["asm"]["fb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = function() {
            return (_duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = Module["asm"]["gb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = function() {
            return (_duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = Module["asm"]["hb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = function() {
            return (_duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = Module["asm"]["ib"]).apply(null, arguments);
          };
          var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = function() {
            return (_duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = Module["asm"]["jb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = function() {
            return (_duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = Module["asm"]["kb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = function() {
            return (_duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = Module["asm"]["lb"]).apply(null, arguments);
          };
          var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = function() {
            return (_duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = Module["asm"]["mb"]).apply(null, arguments);
          };
          var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = function() {
            return (_duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = Module["asm"]["nb"]).apply(null, arguments);
          };
          var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = function() {
            return (_duckdb_web_get_version = Module["_duckdb_web_get_version"] = Module["asm"]["ob"]).apply(null, arguments);
          };
          var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = function() {
            return (_duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = Module["asm"]["pb"]).apply(null, arguments);
          };
          var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = function() {
            return (_duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = Module["asm"]["qb"]).apply(null, arguments);
          };
          var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = function() {
            return (_duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = Module["asm"]["rb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = function() {
            return (_duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = Module["asm"]["sb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = function() {
            return (_duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = Module["asm"]["tb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = function() {
            return (_duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = Module["asm"]["ub"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = function() {
            return (_duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = Module["asm"]["vb"]).apply(null, arguments);
          };
          var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = function() {
            return (_duckdb_web_query_run = Module["_duckdb_web_query_run"] = Module["asm"]["wb"]).apply(null, arguments);
          };
          var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = function() {
            return (_duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = Module["asm"]["xb"]).apply(null, arguments);
          };
          var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = function() {
            return (_duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = Module["asm"]["yb"]).apply(null, arguments);
          };
          var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = function() {
            return (_duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = Module["asm"]["zb"]).apply(null, arguments);
          };
          var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = function() {
            return (_duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = Module["asm"]["Ab"]).apply(null, arguments);
          };
          var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = function() {
            return (_duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = Module["asm"]["Bb"]).apply(null, arguments);
          };
          var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = function() {
            return (_duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = Module["asm"]["Cb"]).apply(null, arguments);
          };
          var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = function() {
            return (_duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = Module["asm"]["Db"]).apply(null, arguments);
          };
          var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = function() {
            return (_duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = Module["asm"]["Eb"]).apply(null, arguments);
          };
          var ___errno_location = function() {
            return (___errno_location = Module["asm"]["__errno_location"]).apply(null, arguments);
          };
          var _htonl = function() {
            return (_htonl = Module["asm"]["Fb"]).apply(null, arguments);
          };
          var _htons = function() {
            return (_htons = Module["asm"]["Gb"]).apply(null, arguments);
          };
          var _ntohs = function() {
            return (_ntohs = Module["asm"]["Hb"]).apply(null, arguments);
          };
          var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["Ib"]).apply(null, arguments);
          };
          var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["Jb"]).apply(null, arguments);
          };
          var stackSave = function() {
            return (stackSave = Module["asm"]["Kb"]).apply(null, arguments);
          };
          var stackRestore = function() {
            return (stackRestore = Module["asm"]["Lb"]).apply(null, arguments);
          };
          var stackAlloc = function() {
            return (stackAlloc = Module["asm"]["Mb"]).apply(null, arguments);
          };
          var ___cxa_is_pointer_type = function() {
            return (___cxa_is_pointer_type = Module["asm"]["Nb"]).apply(null, arguments);
          };
          Module["stackAlloc"] = stackAlloc;
          Module["stackSave"] = stackSave;
          Module["stackRestore"] = stackRestore;
          Module["ccall"] = ccall;
          var calledRun;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain() {
            var entryFunction = _main;
            var argc = 0;
            var argv = 0;
            try {
              var ret = entryFunction(argc, argv);
              exitJS(ret, true);
              return ret;
            } catch (e) {
              return handleException(e);
            }
          }
          function run() {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain();
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          run();
          return DuckDB4.ready;
        };
      })();
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = DuckDB3;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return DuckDB3;
        });
      else if (typeof exports2 === "object")
        exports2["DuckDB"] = DuckDB3;
    }
  });

  // src/bindings/duckdb-eh.js
  var require_duckdb_eh = __commonJS({
    "src/bindings/duckdb-eh.js"(exports2, module2) {
      "use strict";
      var DuckDB3 = (() => {
        var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
        if (typeof __filename !== "undefined")
          _scriptDir = _scriptDir || __filename;
        return function(DuckDB4 = {}) {
          var Module = typeof DuckDB4 != "undefined" ? DuckDB4 : {};
          var readyPromiseResolve, readyPromiseReject;
          Module["ready"] = new Promise((resolve, reject) => {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
          });
          var moduleOverrides = Object.assign({}, Module);
          var arguments_ = [];
          var thisProgram = "./this.program";
          var quit_ = (status, toThrow) => {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window == "object";
          var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
          var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
          var scriptDirectory = "";
          function locateFile(path) {
            if (Module["locateFile"]) {
              return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary, setWindowTitle;
          if (ENVIRONMENT_IS_NODE) {
            var fs = require_fs();
            var nodePath = require_path();
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
            } else {
              scriptDirectory = __dirname + "/";
            }
            read_ = (filename, binary) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              return fs.readFileSync(filename, binary ? void 0 : "utf8");
            };
            readBinary = (filename) => {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              return ret;
            };
            readAsync = (filename, onload, onerror, binary = true) => {
              filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
              fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
                if (err2)
                  onerror(err2);
                else
                  onload(binary ? data.buffer : data);
              });
            };
            if (!Module["thisProgram"] && process.argv.length > 1) {
              thisProgram = process.argv[1].replace(/\\/g, "/");
            }
            arguments_ = process.argv.slice(2);
            quit_ = (status, toThrow) => {
              process.exitCode = status;
              throw toThrow;
            };
            Module["inspect"] = () => "[Emscripten Module object]";
          } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document != "undefined" && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
              scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
              scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            } else {
              scriptDirectory = "";
            }
            {
              read_ = (url) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = (url) => {
                  var xhr = new XMLHttpRequest();
                  xhr.open("GET", url, false);
                  xhr.responseType = "arraybuffer";
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = (url, onload, onerror) => {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = () => {
                  if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                    onload(xhr.response);
                    return;
                  }
                  onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
              };
            }
            setWindowTitle = (title) => document.title = title;
          } else {
          }
          var out = Module["print"] || console.log.bind(console);
          var err = Module["printErr"] || console.error.bind(console);
          Object.assign(Module, moduleOverrides);
          moduleOverrides = null;
          if (Module["arguments"])
            arguments_ = Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          if (Module["quit"])
            quit_ = Module["quit"];
          var wasmBinary;
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          var noExitRuntime = Module["noExitRuntime"] || true;
          if (typeof WebAssembly != "object") {
            abort("no native wasm support detected");
          }
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;
          function assert(condition, text) {
            if (!condition) {
              abort(text);
            }
          }
          var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
          function updateMemoryViews() {
            var b = wasmMemory.buffer;
            Module["HEAP8"] = HEAP8 = new Int8Array(b);
            Module["HEAP16"] = HEAP16 = new Int16Array(b);
            Module["HEAP32"] = HEAP32 = new Int32Array(b);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
            Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
            Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
            Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
            Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
          }
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeKeepaliveCounter = 0;
          function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
          }
          function preRun() {
            if (Module["preRun"]) {
              if (typeof Module["preRun"] == "function")
                Module["preRun"] = [Module["preRun"]];
              while (Module["preRun"].length) {
                addOnPreRun(Module["preRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }
          function initRuntime() {
            runtimeInitialized = true;
            callRuntimeCallbacks(__ATINIT__);
          }
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }
          function postRun() {
            if (Module["postRun"]) {
              if (typeof Module["postRun"] == "function")
                Module["postRun"] = [Module["postRun"]];
              while (Module["postRun"].length) {
                addOnPostRun(Module["postRun"].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }
          function addOnInit(cb) {
            __ATINIT__.unshift(cb);
          }
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;
          function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
          }
          function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
              Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          function abort(what) {
            if (Module["onAbort"]) {
              Module["onAbort"](what);
            }
            what = "Aborted(" + what + ")";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -sASSERTIONS for more info.";
            if (runtimeInitialized) {
              ___trap();
            }
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
          }
          var dataURIPrefix = "data:application/octet-stream;base64,";
          function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
          }
          function isFileURI(filename) {
            return filename.startsWith("file://");
          }
          var wasmBinaryFile;
          wasmBinaryFile = "./duckdb-eh.wasm";
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }
          function getBinary2(file) {
            try {
              if (file == wasmBinaryFile && wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(file);
              }
              throw "both async and sync fetching of the wasm failed";
            } catch (err2) {
              abort(err2);
            }
          }
          function getBinaryPromise(binaryFile) {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch == "function") {
                return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
                  if (!response["ok"]) {
                    throw "failed to load wasm binary file at '" + binaryFile + "'";
                  }
                  return response["arrayBuffer"]();
                }).catch(() => getBinary2(binaryFile));
              }
            }
            return Promise.resolve().then(() => getBinary2(binaryFile));
          }
          function instantiateArrayBuffer(binaryFile, imports, receiver) {
            return getBinaryPromise(binaryFile).then((binary) => {
              return WebAssembly.instantiate(binary, imports);
            }).then((instance9) => {
              return instance9;
            }).then(receiver, (reason) => {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync(binary, binaryFile, imports, callback) {
            if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
              return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
                var result = WebAssembly.instantiateStreaming(response, imports);
                return result.then(callback, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(binaryFile, imports, callback);
                });
              });
            } else {
              return instantiateArrayBuffer(binaryFile, imports, callback);
            }
          }
          function createWasm() {
            var info = { "a": wasmImports };
            function receiveInstance(instance9, module3) {
              var exports3 = instance9.exports;
              Module["asm"] = exports3;
              wasmMemory = Module["asm"]["Qa"];
              updateMemoryViews();
              wasmTable = Module["asm"]["Ta"];
              addOnInit(Module["asm"]["Ra"]);
              removeRunDependency("wasm-instantiate");
              return exports3;
            }
            addRunDependency("wasm-instantiate");
            function receiveInstantiationResult(result) {
              receiveInstance(result["instance"]);
            }
            if (Module["instantiateWasm"]) {
              try {
                return Module["instantiateWasm"](info, receiveInstance);
              } catch (e) {
                err("Module.instantiateWasm callback failed with error: " + e);
                readyPromiseReject(e);
              }
            }
            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
            return {};
          }
          var tempDouble;
          var tempI64;
          function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = `Program terminated with exit(${status})`;
            this.status = status;
          }
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              callbacks.shift()(Module);
            }
          }
          function _XML_GetBuffer() {
            err("missing function: XML_GetBuffer");
            abort(-1);
          }
          function _XML_GetErrorCode() {
            err("missing function: XML_GetErrorCode");
            abort(-1);
          }
          function _XML_Parse() {
            err("missing function: XML_Parse");
            abort(-1);
          }
          function _XML_ParseBuffer() {
            err("missing function: XML_ParseBuffer");
            abort(-1);
          }
          function _XML_ParserCreate() {
            err("missing function: XML_ParserCreate");
            abort(-1);
          }
          function _XML_ParserFree() {
            err("missing function: XML_ParserFree");
            abort(-1);
          }
          function _XML_ResumeParser() {
            err("missing function: XML_ResumeParser");
            abort(-1);
          }
          function _XML_SetCharacterDataHandler() {
            err("missing function: XML_SetCharacterDataHandler");
            abort(-1);
          }
          function _XML_SetElementHandler() {
            err("missing function: XML_SetElementHandler");
            abort(-1);
          }
          function _XML_SetUserData() {
            err("missing function: XML_SetUserData");
            abort(-1);
          }
          function _XML_StopParser() {
            err("missing function: XML_StopParser");
            abort(-1);
          }
          var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html";
          function ___dlsym(handle, symbol, ra) {
            abort(dlopenMissingError);
          }
          var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
          function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
            idx >>>= 0;
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heapOrArray[endPtr] && !(endPtr >= endIdx))
              ++endPtr;
            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
              return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
            }
            var str = "";
            while (idx < endPtr) {
              var u0 = heapOrArray[idx++];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heapOrArray[idx++] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heapOrArray[idx++] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
            return str;
          }
          function UTF8ToString(ptr, maxBytesToRead) {
            ptr >>>= 0;
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
          }
          var SYSCALLS = { varargs: void 0, get: function() {
            SYSCALLS.varargs += 4;
            var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
            return ret;
          }, getStr: function(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          } };
          function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
            var total = 0;
            var srcReadLow = readfds ? HEAP32[readfds >>> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2] : 0;
            var srcWriteLow = writefds ? HEAP32[writefds >>> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2] : 0;
            var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0;
            var dstReadLow = 0, dstReadHigh = 0;
            var dstWriteLow = 0, dstWriteHigh = 0;
            var dstExceptLow = 0, dstExceptHigh = 0;
            var allLow = (readfds ? HEAP32[readfds >>> 2] : 0) | (writefds ? HEAP32[writefds >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2] : 0);
            var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0);
            var check = function(fd2, low, high, val) {
              return fd2 < 32 ? low & val : high & val;
            };
            for (var fd = 0; fd < nfds; fd++) {
              var mask = 1 << fd % 32;
              if (!check(fd, allLow, allHigh, mask)) {
                continue;
              }
              var stream = SYSCALLS.getStreamFromFD(fd);
              var flags = SYSCALLS.DEFAULT_POLLMASK;
              if (stream.stream_ops.poll) {
                flags = stream.stream_ops.poll(stream);
              }
              if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
                fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
                total++;
              }
              if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
                fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
                total++;
              }
              if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
                fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
                total++;
              }
            }
            if (readfds) {
              HEAP32[readfds >>> 2] = dstReadLow;
              HEAP32[readfds + 4 >>> 2] = dstReadHigh;
            }
            if (writefds) {
              HEAP32[writefds >>> 2] = dstWriteLow;
              HEAP32[writefds + 4 >>> 2] = dstWriteHigh;
            }
            if (exceptfds) {
              HEAP32[exceptfds >>> 2] = dstExceptLow;
              HEAP32[exceptfds + 4 >>> 2] = dstExceptHigh;
            }
            return total;
          }
          function SOCKFS() {
            err("missing function: $SOCKFS");
            abort(-1);
          }
          function FS() {
            err("missing function: $FS");
            abort(-1);
          }
          function getSocketFromFD(fd) {
            var socket = SOCKFS.getSocket(fd);
            if (!socket)
              throw new FS.ErrnoError(8);
            return socket;
          }
          function inetNtop4(addr) {
            return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
          }
          function inetNtop6(ints) {
            var str = "";
            var word = 0;
            var longest = 0;
            var lastzero = 0;
            var zstart = 0;
            var len = 0;
            var i = 0;
            var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
            var hasipv4 = true;
            var v4part = "";
            for (i = 0; i < 5; i++) {
              if (parts[i] !== 0) {
                hasipv4 = false;
                break;
              }
            }
            if (hasipv4) {
              v4part = inetNtop4(parts[6] | parts[7] << 16);
              if (parts[5] === -1) {
                str = "::ffff:";
                str += v4part;
                return str;
              }
              if (parts[5] === 0) {
                str = "::";
                if (v4part === "0.0.0.0")
                  v4part = "";
                if (v4part === "0.0.0.1")
                  v4part = "1";
                str += v4part;
                return str;
              }
            }
            for (word = 0; word < 8; word++) {
              if (parts[word] === 0) {
                if (word - lastzero > 1) {
                  len = 0;
                }
                lastzero = word;
                len++;
              }
              if (len > longest) {
                longest = len;
                zstart = word - longest + 1;
              }
            }
            for (word = 0; word < 8; word++) {
              if (longest > 1) {
                if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
                  if (word === zstart) {
                    str += ":";
                    if (zstart === 0)
                      str += ":";
                  }
                  continue;
                }
              }
              str += Number(_ntohs(parts[word] & 65535)).toString(16);
              str += word < 7 ? ":" : "";
            }
            return str;
          }
          function readSockaddr(sa, salen) {
            var family = HEAP16[sa >>> 1];
            var port = _ntohs(HEAPU16[sa + 2 >>> 1]);
            var addr;
            switch (family) {
              case 2:
                if (salen !== 16) {
                  return { errno: 28 };
                }
                addr = HEAP32[sa + 4 >>> 2];
                addr = inetNtop4(addr);
                break;
              case 10:
                if (salen !== 28) {
                  return { errno: 28 };
                }
                addr = [HEAP32[sa + 8 >>> 2], HEAP32[sa + 12 >>> 2], HEAP32[sa + 16 >>> 2], HEAP32[sa + 20 >>> 2]];
                addr = inetNtop6(addr);
                break;
              default:
                return { errno: 5 };
            }
            return { family, addr, port };
          }
          function inetPton4(str) {
            var b = str.split(".");
            for (var i = 0; i < 4; i++) {
              var tmp2 = Number(b[i]);
              if (isNaN(tmp2))
                return null;
              b[i] = tmp2;
            }
            return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
          }
          function jstoi_q(str) {
            return parseInt(str);
          }
          function inetPton6(str) {
            var words;
            var w, offset, z;
            var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
            var parts = [];
            if (!valid6regx.test(str)) {
              return null;
            }
            if (str === "::") {
              return [0, 0, 0, 0, 0, 0, 0, 0];
            }
            if (str.startsWith("::")) {
              str = str.replace("::", "Z:");
            } else {
              str = str.replace("::", ":Z:");
            }
            if (str.indexOf(".") > 0) {
              str = str.replace(new RegExp("[.]", "g"), ":");
              words = str.split(":");
              words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
              words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
              words = words.slice(0, words.length - 2);
            } else {
              words = str.split(":");
            }
            offset = 0;
            z = 0;
            for (w = 0; w < words.length; w++) {
              if (typeof words[w] == "string") {
                if (words[w] === "Z") {
                  for (z = 0; z < 8 - words.length + 1; z++) {
                    parts[w + z] = 0;
                  }
                  offset = z - 1;
                } else {
                  parts[w + offset] = _htons(parseInt(words[w], 16));
                }
              } else {
                parts[w + offset] = words[w];
              }
            }
            return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
          }
          var DNS = { address_map: { id: 1, addrs: {}, names: {} }, lookup_name: function(name) {
            var res = inetPton4(name);
            if (res !== null) {
              return name;
            }
            res = inetPton6(name);
            if (res !== null) {
              return name;
            }
            var addr;
            if (DNS.address_map.addrs[name]) {
              addr = DNS.address_map.addrs[name];
            } else {
              var id = DNS.address_map.id++;
              assert(id < 65535, "exceeded max address mappings of 65535");
              addr = "172.29." + (id & 255) + "." + (id & 65280);
              DNS.address_map.names[addr] = name;
              DNS.address_map.addrs[name] = addr;
            }
            return addr;
          }, lookup_addr: function(addr) {
            if (DNS.address_map.names[addr]) {
              return DNS.address_map.names[addr];
            }
            return null;
          } };
          function getSocketAddress(addrp, addrlen, allowNull) {
            if (allowNull && addrp === 0)
              return null;
            var info = readSockaddr(addrp, addrlen);
            if (info.errno)
              throw new FS.ErrnoError(info.errno);
            info.addr = DNS.lookup_addr(info.addr) || info.addr;
            return info;
          }
          function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
            var sock = getSocketFromFD(fd);
            var info = getSocketAddress(addr, addrlen);
            sock.sock_ops.bind(sock, info.addr, info.port);
            return 0;
          }
          function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
            var sock = getSocketFromFD(fd);
            var info = getSocketAddress(addr, addrlen);
            sock.sock_ops.connect(sock, info.addr, info.port);
            return 0;
          }
          function ___syscall_faccessat(dirfd, path, amode, flags) {
          }
          function ___syscall_fcntl64(fd, cmd, varargs) {
            SYSCALLS.varargs = varargs;
            return 0;
          }
          function ___syscall_fstat64(fd, buf) {
          }
          function ___syscall_ftruncate64(fd, length_low, length_high) {
          }
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            outIdx >>>= 0;
            if (!(maxBytesToWrite > 0))
              return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = 65536 + ((u & 1023) << 10) | u1 & 1023;
              }
              if (u <= 127) {
                if (outIdx >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 192 | u >> 6;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 224 | u >> 12;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              } else {
                if (outIdx + 3 >= endIdx)
                  break;
                heap[outIdx++ >>> 0] = 240 | u >> 18;
                heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
                heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
                heap[outIdx++ >>> 0] = 128 | u & 63;
              }
            }
            heap[outIdx >>> 0] = 0;
            return outIdx - startIdx;
          }
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          }
          function ___syscall_getdents64(fd, dirp, count) {
          }
          function zeroMemory(address, size) {
            HEAPU8.fill(0, address, address + size);
            return address;
          }
          function writeSockaddr(sa, family, addr, port, addrlen) {
            switch (family) {
              case 2:
                addr = inetPton4(addr);
                zeroMemory(sa, 16);
                if (addrlen) {
                  HEAP32[addrlen >>> 2] = 16;
                }
                HEAP16[sa >>> 1] = family;
                HEAP32[sa + 4 >>> 2] = addr;
                HEAP16[sa + 2 >>> 1] = _htons(port);
                break;
              case 10:
                addr = inetPton6(addr);
                zeroMemory(sa, 28);
                if (addrlen) {
                  HEAP32[addrlen >>> 2] = 28;
                }
                HEAP32[sa >>> 2] = family;
                HEAP32[sa + 8 >>> 2] = addr[0];
                HEAP32[sa + 12 >>> 2] = addr[1];
                HEAP32[sa + 16 >>> 2] = addr[2];
                HEAP32[sa + 20 >>> 2] = addr[3];
                HEAP16[sa + 2 >>> 1] = _htons(port);
                break;
              default:
                return 5;
            }
            return 0;
          }
          function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
            var sock = getSocketFromFD(fd);
            if (!sock.daddr) {
              return -53;
            }
            var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
            return 0;
          }
          function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
            var sock = getSocketFromFD(fd);
            if (level === 1) {
              if (optname === 4) {
                HEAP32[optval >>> 2] = sock.error;
                HEAP32[optlen >>> 2] = 4;
                sock.error = null;
                return 0;
              }
            }
            return -50;
          }
          function ___syscall_ioctl(fd, op, varargs) {
            SYSCALLS.varargs = varargs;
            return 0;
          }
          function ___syscall_lstat64(path, buf) {
          }
          function ___syscall_mkdirat(dirfd, path, mode) {
          }
          function ___syscall_newfstatat(dirfd, path, buf, flags) {
          }
          function ___syscall_openat(dirfd, path, flags, varargs) {
            SYSCALLS.varargs = varargs;
          }
          function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
            var sock = getSocketFromFD(fd);
            var msg = sock.sock_ops.recvmsg(sock, len);
            if (!msg)
              return 0;
            if (addr) {
              var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
            }
            HEAPU8.set(msg.buffer, buf >>> 0);
            return msg.buffer.byteLength;
          }
          function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
          }
          function ___syscall_rmdir(path) {
          }
          function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
          }
          function ___syscall_socket(domain, type, protocol) {
          }
          function ___syscall_stat64(path, buf) {
          }
          function ___syscall_unlinkat(dirfd, path, flags) {
          }
          var nowIsMonotonic = true;
          function __emscripten_get_now_is_monotonic() {
            return nowIsMonotonic;
          }
          function readI53FromI64(ptr) {
            return HEAPU32[ptr >>> 2] + HEAP32[ptr + 4 >>> 2] * 4294967296;
          }
          function isLeapYear(year) {
            return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
          }
          var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
          var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
          function ydayFromDate(date) {
            var leap = isLeapYear(date.getFullYear());
            var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
            var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
            return yday;
          }
          function __localtime_js(time, tmPtr) {
            var date = new Date(readI53FromI64(time) * 1e3);
            HEAP32[tmPtr >>> 2] = date.getSeconds();
            HEAP32[tmPtr + 4 >>> 2] = date.getMinutes();
            HEAP32[tmPtr + 8 >>> 2] = date.getHours();
            HEAP32[tmPtr + 12 >>> 2] = date.getDate();
            HEAP32[tmPtr + 16 >>> 2] = date.getMonth();
            HEAP32[tmPtr + 20 >>> 2] = date.getFullYear() - 1900;
            HEAP32[tmPtr + 24 >>> 2] = date.getDay();
            var yday = ydayFromDate(date) | 0;
            HEAP32[tmPtr + 28 >>> 2] = yday;
            HEAP32[tmPtr + 36 >>> 2] = -(date.getTimezoneOffset() * 60);
            var start = new Date(date.getFullYear(), 0, 1);
            var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
            var winterOffset = start.getTimezoneOffset();
            var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
            HEAP32[tmPtr + 32 >>> 2] = dst;
          }
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var c = str.charCodeAt(i);
              if (c <= 127) {
                len++;
              } else if (c <= 2047) {
                len += 2;
              } else if (c >= 55296 && c <= 57343) {
                len += 4;
                ++i;
              } else {
                len += 3;
              }
            }
            return len;
          }
          function stringToNewUTF8(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = _malloc(size);
            if (ret)
              stringToUTF8(str, ret, size);
            return ret;
          }
          function __tzset_js(timezone, daylight, tzname) {
            var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
            var winter = new Date(currentYear, 0, 1);
            var summer = new Date(currentYear, 6, 1);
            var winterOffset = winter.getTimezoneOffset();
            var summerOffset = summer.getTimezoneOffset();
            var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
            HEAPU32[timezone >>> 2] = stdTimezoneOffset * 60;
            HEAP32[daylight >>> 2] = Number(winterOffset != summerOffset);
            function extractZone(date) {
              var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
              return match ? match[1] : "GMT";
            }
            var winterName = extractZone(winter);
            var summerName = extractZone(summer);
            var winterNamePtr = stringToNewUTF8(winterName);
            var summerNamePtr = stringToNewUTF8(summerName);
            if (summerOffset < winterOffset) {
              HEAPU32[tzname >>> 2] = winterNamePtr;
              HEAPU32[tzname + 4 >>> 2] = summerNamePtr;
            } else {
              HEAPU32[tzname >>> 2] = summerNamePtr;
              HEAPU32[tzname + 4 >>> 2] = winterNamePtr;
            }
          }
          function _abort() {
            abort("");
          }
          function _dlopen(filename, flags) {
            abort(dlopenMissingError);
          }
          function _duckdb_web_fs_directory_create(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
          }
          function _duckdb_web_fs_directory_exists(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
          }
          function _duckdb_web_fs_directory_list_files(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
          }
          function _duckdb_web_fs_directory_remove(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
          }
          function _duckdb_web_fs_file_close(fileId) {
            return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
          }
          function _duckdb_web_fs_file_exists(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
          }
          function _duckdb_web_fs_file_get_last_modified_time(fileId) {
            return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
          }
          function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
            return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
          }
          function _duckdb_web_fs_file_open(fileId, flags) {
            return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags);
          }
          function _duckdb_web_fs_file_read(fileId, buf, size, location) {
            return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
          }
          function _duckdb_web_fs_file_truncate(fileId, newSize) {
            return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
          }
          function _duckdb_web_fs_file_write(fileId, buf, size, location) {
            return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
          }
          function _duckdb_web_fs_get_default_data_protocol(Module2) {
            return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
          }
          function _duckdb_web_fs_glob(path, pathLen) {
            return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
          }
          function _duckdb_web_test_platform_feature(feature) {
            return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
          }
          function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
            return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
          }
          function _emscripten_date_now() {
            return Date.now();
          }
          function getHeapMax() {
            return 4294901760;
          }
          function _emscripten_get_heap_max() {
            return getHeapMax();
          }
          var _emscripten_get_now;
          if (ENVIRONMENT_IS_NODE) {
            global.performance = require_perf_hooks().performance;
          }
          _emscripten_get_now = () => performance.now();
          function _emscripten_memcpy_big(dest, src, num) {
            HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
          }
          function emscripten_realloc_buffer(size) {
            var b = wasmMemory.buffer;
            var pages = size - b.byteLength + 65535 >>> 16;
            try {
              wasmMemory.grow(pages);
              updateMemoryViews();
              return 1;
            } catch (e) {
            }
          }
          function _emscripten_resize_heap(requestedSize) {
            var oldSize = HEAPU8.length;
            requestedSize = requestedSize >>> 0;
            var maxHeapSize = getHeapMax();
            if (requestedSize > maxHeapSize) {
              return false;
            }
            var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
            for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
              var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
              overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
              var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
              var replacement = emscripten_realloc_buffer(newSize);
              if (replacement) {
                return true;
              }
            }
            return false;
          }
          var ENV = {};
          function getExecutableName() {
            return thisProgram || "./this.program";
          }
          function getEnvStrings() {
            if (!getEnvStrings.strings) {
              var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
              var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
              for (var x in ENV) {
                if (ENV[x] === void 0)
                  delete env[x];
                else
                  env[x] = ENV[x];
              }
              var strings = [];
              for (var x in env) {
                strings.push(`${x}=${env[x]}`);
              }
              getEnvStrings.strings = strings;
            }
            return getEnvStrings.strings;
          }
          function stringToAscii(str, buffer) {
            for (var i = 0; i < str.length; ++i) {
              HEAP8[buffer++ >>> 0] = str.charCodeAt(i);
            }
            HEAP8[buffer >>> 0] = 0;
          }
          function _environ_get(__environ, environ_buf) {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              HEAPU32[__environ + i * 4 >>> 2] = ptr;
              stringToAscii(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          }
          function _environ_sizes_get(penviron_count, penviron_buf_size) {
            var strings = getEnvStrings();
            HEAPU32[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            HEAPU32[penviron_buf_size >>> 2] = bufSize;
            return 0;
          }
          function _fd_close(fd) {
            return 52;
          }
          function _fd_fdstat_get(fd, pbuf) {
            var rightsBase = 0;
            var rightsInheriting = 0;
            var flags = 0;
            {
              var type = 2;
              if (fd == 0) {
                rightsBase = 2;
              } else if (fd == 1 || fd == 2) {
                rightsBase = 64;
              }
              flags = 1;
            }
            HEAP8[pbuf >>> 0] = type;
            HEAP16[pbuf + 2 >>> 1] = flags;
            tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2] = tempI64[0], HEAP32[pbuf + 12 >>> 2] = tempI64[1];
            tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2] = tempI64[0], HEAP32[pbuf + 20 >>> 2] = tempI64[1];
            return 0;
          }
          function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            return 52;
          }
          function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
            return 52;
          }
          function _fd_read(fd, iov, iovcnt, pnum) {
            return 52;
          }
          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            return 70;
          }
          function _fd_sync(fd) {
            return 52;
          }
          var printCharBuffers = [null, [], []];
          function printChar(stream, curr) {
            var buffer = printCharBuffers[stream];
            if (curr === 0 || curr === 10) {
              (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
              buffer.length = 0;
            } else {
              buffer.push(curr);
            }
          }
          function _fd_write(fd, iov, iovcnt, pnum) {
            var num = 0;
            for (var i = 0; i < iovcnt; i++) {
              var ptr = HEAPU32[iov >>> 2];
              var len = HEAPU32[iov + 4 >>> 2];
              iov += 8;
              for (var j = 0; j < len; j++) {
                printChar(fd, HEAPU8[ptr + j >>> 0]);
              }
              num += len;
            }
            HEAPU32[pnum >>> 2] = num;
            return 0;
          }
          function _getaddrinfo(node, service, hint, out2) {
            var addr = 0;
            var port = 0;
            var flags = 0;
            var family = 0;
            var type = 0;
            var proto = 0;
            var ai;
            function allocaddrinfo(family2, type2, proto2, canon, addr2, port2) {
              var sa, salen, ai2;
              var errno;
              salen = family2 === 10 ? 28 : 16;
              addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
              sa = _malloc(salen);
              errno = writeSockaddr(sa, family2, addr2, port2);
              assert(!errno);
              ai2 = _malloc(32);
              HEAP32[ai2 + 4 >>> 2] = family2;
              HEAP32[ai2 + 8 >>> 2] = type2;
              HEAP32[ai2 + 12 >>> 2] = proto2;
              HEAPU32[ai2 + 24 >>> 2] = canon;
              HEAPU32[ai2 + 20 >>> 2] = sa;
              if (family2 === 10) {
                HEAP32[ai2 + 16 >>> 2] = 28;
              } else {
                HEAP32[ai2 + 16 >>> 2] = 16;
              }
              HEAP32[ai2 + 28 >>> 2] = 0;
              return ai2;
            }
            if (hint) {
              flags = HEAP32[hint >>> 2];
              family = HEAP32[hint + 4 >>> 2];
              type = HEAP32[hint + 8 >>> 2];
              proto = HEAP32[hint + 12 >>> 2];
            }
            if (type && !proto) {
              proto = type === 2 ? 17 : 6;
            }
            if (!type && proto) {
              type = proto === 17 ? 2 : 1;
            }
            if (proto === 0) {
              proto = 6;
            }
            if (type === 0) {
              type = 1;
            }
            if (!node && !service) {
              return -2;
            }
            if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
              return -1;
            }
            if (hint !== 0 && HEAP32[hint >>> 2] & 2 && !node) {
              return -1;
            }
            if (flags & 32) {
              return -2;
            }
            if (type !== 0 && type !== 1 && type !== 2) {
              return -7;
            }
            if (family !== 0 && family !== 2 && family !== 10) {
              return -6;
            }
            if (service) {
              service = UTF8ToString(service);
              port = parseInt(service, 10);
              if (isNaN(port)) {
                if (flags & 1024) {
                  return -2;
                }
                return -8;
              }
            }
            if (!node) {
              if (family === 0) {
                family = 2;
              }
              if ((flags & 1) === 0) {
                if (family === 2) {
                  addr = _htonl(2130706433);
                } else {
                  addr = [0, 0, 0, 1];
                }
              }
              ai = allocaddrinfo(family, type, proto, null, addr, port);
              HEAPU32[out2 >>> 2] = ai;
              return 0;
            }
            node = UTF8ToString(node);
            addr = inetPton4(node);
            if (addr !== null) {
              if (family === 0 || family === 2) {
                family = 2;
              } else if (family === 10 && flags & 8) {
                addr = [0, 0, _htonl(65535), addr];
                family = 10;
              } else {
                return -2;
              }
            } else {
              addr = inetPton6(node);
              if (addr !== null) {
                if (family === 0 || family === 10) {
                  family = 10;
                } else {
                  return -2;
                }
              }
            }
            if (addr != null) {
              ai = allocaddrinfo(family, type, proto, node, addr, port);
              HEAPU32[out2 >>> 2] = ai;
              return 0;
            }
            if (flags & 4) {
              return -2;
            }
            node = DNS.lookup_name(node);
            addr = inetPton4(node);
            if (family === 0) {
              family = 2;
            } else if (family === 10) {
              addr = [0, 0, _htonl(65535), addr];
            }
            ai = allocaddrinfo(family, type, proto, null, addr, port);
            HEAPU32[out2 >>> 2] = ai;
            return 0;
          }
          function initRandomFill() {
            if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
              return (view) => crypto.getRandomValues(view);
            } else if (ENVIRONMENT_IS_NODE) {
              try {
                var crypto_module = __require("crypto");
                var randomFillSync = crypto_module["randomFillSync"];
                if (randomFillSync) {
                  return (view) => crypto_module["randomFillSync"](view);
                }
                var randomBytes = crypto_module["randomBytes"];
                return (view) => (view.set(randomBytes(view.byteLength)), view);
              } catch (e) {
              }
            }
            abort("initRandomDevice");
          }
          function randomFill(view) {
            return (randomFill = initRandomFill())(view);
          }
          function _getentropy(buffer, size) {
            randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
            return 0;
          }
          function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
            var info = readSockaddr(sa, salen);
            if (info.errno) {
              return -6;
            }
            var port = info.port;
            var addr = info.addr;
            var overflowed = false;
            if (node && nodelen) {
              var lookup;
              if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
                if (flags & 8) {
                  return -2;
                }
              } else {
                addr = lookup;
              }
              var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
              if (numBytesWrittenExclNull + 1 >= nodelen) {
                overflowed = true;
              }
            }
            if (serv && servlen) {
              port = "" + port;
              var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
              if (numBytesWrittenExclNull + 1 >= servlen) {
                overflowed = true;
              }
            }
            if (overflowed) {
              return -12;
            }
            return 0;
          }
          function arraySum(array, index) {
            var sum2 = 0;
            for (var i = 0; i <= index; sum2 += array[i++]) {
            }
            return sum2;
          }
          var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
          function addDays(date, days) {
            var newDate = new Date(date.getTime());
            while (days > 0) {
              var leap = isLeapYear(newDate.getFullYear());
              var currentMonth = newDate.getMonth();
              var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
              if (days > daysInCurrentMonth - newDate.getDate()) {
                days -= daysInCurrentMonth - newDate.getDate() + 1;
                newDate.setDate(1);
                if (currentMonth < 11) {
                  newDate.setMonth(currentMonth + 1);
                } else {
                  newDate.setMonth(0);
                  newDate.setFullYear(newDate.getFullYear() + 1);
                }
              } else {
                newDate.setDate(newDate.getDate() + days);
                return newDate;
              }
            }
            return newDate;
          }
          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull)
              u8array.length = numBytesWritten;
            return u8array;
          }
          function writeArrayToMemory(array, buffer) {
            HEAP8.set(array, buffer >>> 0);
          }
          function _strftime(s, maxsize, format, tm) {
            var tm_zone = HEAP32[tm + 40 >>> 2];
            var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
            var pattern = UTF8ToString(format);
            var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
            for (var rule in EXPANSION_RULES_1) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
            }
            var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
            function leadingSomething(value, digits, character) {
              var str = typeof value == "number" ? value.toString() : value || "";
              while (str.length < digits) {
                str = character[0] + str;
              }
              return str;
            }
            function leadingNulls(value, digits) {
              return leadingSomething(value, digits, "0");
            }
            function compareByDay(date1, date2) {
              function sgn(value) {
                return value < 0 ? -1 : value > 0 ? 1 : 0;
              }
              var compare;
              if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
                if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                  compare = sgn(date1.getDate() - date2.getDate());
                }
              }
              return compare;
            }
            function getFirstWeekStartDate(janFourth) {
              switch (janFourth.getDay()) {
                case 0:
                  return new Date(janFourth.getFullYear() - 1, 11, 29);
                case 1:
                  return janFourth;
                case 2:
                  return new Date(janFourth.getFullYear(), 0, 3);
                case 3:
                  return new Date(janFourth.getFullYear(), 0, 2);
                case 4:
                  return new Date(janFourth.getFullYear(), 0, 1);
                case 5:
                  return new Date(janFourth.getFullYear() - 1, 11, 31);
                case 6:
                  return new Date(janFourth.getFullYear() - 1, 11, 30);
              }
            }
            function getWeekBasedYear(date2) {
              var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
              var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
              var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
              var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
              var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
              if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
                if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                  return thisDate.getFullYear() + 1;
                }
                return thisDate.getFullYear();
              }
              return thisDate.getFullYear() - 1;
            }
            var EXPANSION_RULES_2 = { "%a": function(date2) {
              return WEEKDAYS[date2.tm_wday].substring(0, 3);
            }, "%A": function(date2) {
              return WEEKDAYS[date2.tm_wday];
            }, "%b": function(date2) {
              return MONTHS[date2.tm_mon].substring(0, 3);
            }, "%B": function(date2) {
              return MONTHS[date2.tm_mon];
            }, "%C": function(date2) {
              var year = date2.tm_year + 1900;
              return leadingNulls(year / 100 | 0, 2);
            }, "%d": function(date2) {
              return leadingNulls(date2.tm_mday, 2);
            }, "%e": function(date2) {
              return leadingSomething(date2.tm_mday, 2, " ");
            }, "%g": function(date2) {
              return getWeekBasedYear(date2).toString().substring(2);
            }, "%G": function(date2) {
              return getWeekBasedYear(date2);
            }, "%H": function(date2) {
              return leadingNulls(date2.tm_hour, 2);
            }, "%I": function(date2) {
              var twelveHour = date2.tm_hour;
              if (twelveHour == 0)
                twelveHour = 12;
              else if (twelveHour > 12)
                twelveHour -= 12;
              return leadingNulls(twelveHour, 2);
            }, "%j": function(date2) {
              return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
            }, "%m": function(date2) {
              return leadingNulls(date2.tm_mon + 1, 2);
            }, "%M": function(date2) {
              return leadingNulls(date2.tm_min, 2);
            }, "%n": function() {
              return "\n";
            }, "%p": function(date2) {
              if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
                return "AM";
              }
              return "PM";
            }, "%S": function(date2) {
              return leadingNulls(date2.tm_sec, 2);
            }, "%t": function() {
              return "	";
            }, "%u": function(date2) {
              return date2.tm_wday || 7;
            }, "%U": function(date2) {
              var days = date2.tm_yday + 7 - date2.tm_wday;
              return leadingNulls(Math.floor(days / 7), 2);
            }, "%V": function(date2) {
              var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
              if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
                val++;
              }
              if (!val) {
                val = 52;
                var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
                if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                  val++;
                }
              } else if (val == 53) {
                var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
                if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                  val = 1;
              }
              return leadingNulls(val, 2);
            }, "%w": function(date2) {
              return date2.tm_wday;
            }, "%W": function(date2) {
              var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
              return leadingNulls(Math.floor(days / 7), 2);
            }, "%y": function(date2) {
              return (date2.tm_year + 1900).toString().substring(2);
            }, "%Y": function(date2) {
              return date2.tm_year + 1900;
            }, "%z": function(date2) {
              var off = date2.tm_gmtoff;
              var ahead = off >= 0;
              off = Math.abs(off) / 60;
              off = off / 60 * 100 + off % 60;
              return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
            }, "%Z": function(date2) {
              return date2.tm_zone;
            }, "%%": function() {
              return "%";
            } };
            pattern = pattern.replace(/%%/g, "\0\0");
            for (var rule in EXPANSION_RULES_2) {
              if (pattern.includes(rule)) {
                pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
              }
            }
            pattern = pattern.replace(/\0\0/g, "%");
            var bytes = intArrayFromString(pattern, false);
            if (bytes.length > maxsize) {
              return 0;
            }
            writeArrayToMemory(bytes, s);
            return bytes.length - 1;
          }
          function _strftime_l(s, maxsize, format, tm, loc) {
            return _strftime(s, maxsize, format, tm);
          }
          function _ucnv_close_64() {
            err("missing function: ucnv_close_64");
            abort(-1);
          }
          function _ucnv_convertEx_64() {
            err("missing function: ucnv_convertEx_64");
            abort(-1);
          }
          function _ucnv_open_64() {
            err("missing function: ucnv_open_64");
            abort(-1);
          }
          function _ucnv_toAlgorithmic_64() {
            err("missing function: ucnv_toAlgorithmic_64");
            abort(-1);
          }
          function _ucsdet_close_64() {
            err("missing function: ucsdet_close_64");
            abort(-1);
          }
          function _ucsdet_detect_64() {
            err("missing function: ucsdet_detect_64");
            abort(-1);
          }
          function _ucsdet_getConfidence_64() {
            err("missing function: ucsdet_getConfidence_64");
            abort(-1);
          }
          function _ucsdet_getName_64() {
            err("missing function: ucsdet_getName_64");
            abort(-1);
          }
          function _ucsdet_open_64() {
            err("missing function: ucsdet_open_64");
            abort(-1);
          }
          function _ucsdet_setText_64() {
            err("missing function: ucsdet_setText_64");
            abort(-1);
          }
          function _unzClose() {
            err("missing function: unzClose");
            abort(-1);
          }
          function _unzCloseCurrentFile() {
            err("missing function: unzCloseCurrentFile");
            abort(-1);
          }
          function _unzGetCurrentFileInfo() {
            err("missing function: unzGetCurrentFileInfo");
            abort(-1);
          }
          function _unzGetCurrentFileInfo64() {
            err("missing function: unzGetCurrentFileInfo64");
            abort(-1);
          }
          function _unzGetGlobalInfo() {
            err("missing function: unzGetGlobalInfo");
            abort(-1);
          }
          function _unzGoToFirstFile() {
            err("missing function: unzGoToFirstFile");
            abort(-1);
          }
          function _unzGoToNextFile() {
            err("missing function: unzGoToNextFile");
            abort(-1);
          }
          function _unzLocateFile() {
            err("missing function: unzLocateFile");
            abort(-1);
          }
          function _unzOpen() {
            err("missing function: unzOpen");
            abort(-1);
          }
          function _unzOpen2() {
            err("missing function: unzOpen2");
            abort(-1);
          }
          function _unzOpenCurrentFile() {
            err("missing function: unzOpenCurrentFile");
            abort(-1);
          }
          function _unzReadCurrentFile() {
            err("missing function: unzReadCurrentFile");
            abort(-1);
          }
          function _proc_exit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
              if (Module["onExit"])
                Module["onExit"](code);
              ABORT = true;
            }
            quit_(code, new ExitStatus(code));
          }
          function exitJS(status, implicit) {
            EXITSTATUS = status;
            _proc_exit(status);
          }
          function handleException(e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return EXITSTATUS;
            }
            quit_(1, e);
          }
          function getCFunc(ident) {
            var func = Module["_" + ident];
            return func;
          }
          function stringToUTF8OnStack(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8(str, ret, size);
            return ret;
          }
          function ccall(ident, returnType, argTypes, args, opts) {
            var toC = { "string": (str) => {
              var ret2 = 0;
              if (str !== null && str !== void 0 && str !== 0) {
                ret2 = stringToUTF8OnStack(str);
              }
              return ret2;
            }, "array": (arr) => {
              var ret2 = stackAlloc(arr.length);
              writeArrayToMemory(arr, ret2);
              return ret2;
            } };
            function convertReturnValue(ret2) {
              if (returnType === "string") {
                return UTF8ToString(ret2);
              }
              if (returnType === "boolean")
                return Boolean(ret2);
              return ret2;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args) {
              for (var i = 0; i < args.length; i++) {
                var converter = toC[argTypes[i]];
                if (converter) {
                  if (stack === 0)
                    stack = stackSave();
                  cArgs[i] = converter(args[i]);
                } else {
                  cArgs[i] = args[i];
                }
              }
            }
            var ret = func.apply(null, cArgs);
            function onDone(ret2) {
              if (stack !== 0)
                stackRestore(stack);
              return convertReturnValue(ret2);
            }
            ret = onDone(ret);
            return ret;
          }
          var wasmImports = { "f": _XML_GetBuffer, "V": _XML_GetErrorCode, "W": _XML_Parse, "m": _XML_ParseBuffer, "o": _XML_ParserCreate, "b": _XML_ParserFree, "B": _XML_ResumeParser, "d": _XML_SetCharacterDataHandler, "a": _XML_SetElementHandler, "n": _XML_SetUserData, "i": _XML_StopParser, "La": ___dlsym, "Ga": ___syscall__newselect, "Ka": ___syscall_bind, "Ja": ___syscall_connect, "Ca": ___syscall_faccessat, "c": ___syscall_fcntl64, "Ba": ___syscall_fstat64, "O": ___syscall_ftruncate64, "wa": ___syscall_getdents64, "Ea": ___syscall_getpeername, "Fa": ___syscall_getsockopt, "L": ___syscall_ioctl, "ya": ___syscall_lstat64, "xa": ___syscall_mkdirat, "za": ___syscall_newfstatat, "M": ___syscall_openat, "Ha": ___syscall_recvfrom, "ua": ___syscall_renameat, "G": ___syscall_rmdir, "Ia": ___syscall_sendto, "I": ___syscall_socket, "Aa": ___syscall_stat64, "H": ___syscall_unlinkat, "S": __emscripten_get_now_is_monotonic, "ea": __localtime_js, "fa": __tzset_js, "j": _abort, "Ma": _dlopen, "ma": _duckdb_web_fs_directory_create, "na": _duckdb_web_fs_directory_exists, "ja": _duckdb_web_fs_directory_list_files, "ka": _duckdb_web_fs_directory_remove, "E": _duckdb_web_fs_file_close, "ha": _duckdb_web_fs_file_exists, "N": _duckdb_web_fs_file_get_last_modified_time, "ia": _duckdb_web_fs_file_move, "pa": _duckdb_web_fs_file_open, "p": _duckdb_web_fs_file_read, "oa": _duckdb_web_fs_file_truncate, "F": _duckdb_web_fs_file_write, "qa": _duckdb_web_fs_get_default_data_protocol, "ga": _duckdb_web_fs_glob, "D": _duckdb_web_test_platform_feature, "ra": _duckdb_web_udf_scalar_call, "A": _emscripten_date_now, "X": _emscripten_get_heap_max, "g": _emscripten_get_now, "Oa": _emscripten_memcpy_big, "Pa": _emscripten_resize_heap, "la": _environ_get, "ta": _environ_sizes_get, "k": _fd_close, "Na": _fd_fdstat_get, "Q": _fd_pread, "P": _fd_pwrite, "K": _fd_read, "R": _fd_seek, "va": _fd_sync, "v": _fd_write, "J": _getaddrinfo, "sa": _getentropy, "Da": _getnameinfo, "ba": _strftime_l, "e": _ucnv_close_64, "Y": _ucnv_convertEx_64, "u": _ucnv_open_64, "Z": _ucnv_toAlgorithmic_64, "C": _ucsdet_close_64, "aa": _ucsdet_detect_64, "$": _ucsdet_getConfidence_64, "_": _ucsdet_getName_64, "da": _ucsdet_open_64, "ca": _ucsdet_setText_64, "h": _unzClose, "t": _unzCloseCurrentFile, "y": _unzGetCurrentFileInfo, "q": _unzGetCurrentFileInfo64, "U": _unzGetGlobalInfo, "z": _unzGoToFirstFile, "x": _unzGoToNextFile, "s": _unzLocateFile, "w": _unzOpen, "T": _unzOpen2, "r": _unzOpenCurrentFile, "l": _unzReadCurrentFile };
          var asm = createWasm();
          var ___wasm_call_ctors = function() {
            return (___wasm_call_ctors = Module["asm"]["Ra"]).apply(null, arguments);
          };
          var _main = Module["_main"] = function() {
            return (_main = Module["_main"] = Module["asm"]["Sa"]).apply(null, arguments);
          };
          var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = function() {
            return (_duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = Module["asm"]["Ua"]).apply(null, arguments);
          };
          var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = function() {
            return (_duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = Module["asm"]["Va"]).apply(null, arguments);
          };
          var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = function() {
            return (_duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = Module["asm"]["Wa"]).apply(null, arguments);
          };
          var _duckdb_web_reset = Module["_duckdb_web_reset"] = function() {
            return (_duckdb_web_reset = Module["_duckdb_web_reset"] = Module["asm"]["Xa"]).apply(null, arguments);
          };
          var _duckdb_web_connect = Module["_duckdb_web_connect"] = function() {
            return (_duckdb_web_connect = Module["_duckdb_web_connect"] = Module["asm"]["Ya"]).apply(null, arguments);
          };
          var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = function() {
            return (_duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = Module["asm"]["Za"]).apply(null, arguments);
          };
          var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = function() {
            return (_duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = Module["asm"]["_a"]).apply(null, arguments);
          };
          var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = function() {
            return (_duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = Module["asm"]["$a"]).apply(null, arguments);
          };
          var _duckdb_web_open = Module["_duckdb_web_open"] = function() {
            return (_duckdb_web_open = Module["_duckdb_web_open"] = Module["asm"]["ab"]).apply(null, arguments);
          };
          var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = function() {
            return (_duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = Module["asm"]["bb"]).apply(null, arguments);
          };
          var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = function() {
            return (_duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = Module["asm"]["cb"]).apply(null, arguments);
          };
          var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = function() {
            return (_duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = Module["asm"]["db"]).apply(null, arguments);
          };
          var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = function() {
            return (_duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = Module["asm"]["eb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = function() {
            return (_duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = Module["asm"]["fb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = function() {
            return (_duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = Module["asm"]["gb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = function() {
            return (_duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = Module["asm"]["hb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = function() {
            return (_duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = Module["asm"]["ib"]).apply(null, arguments);
          };
          var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = function() {
            return (_duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = Module["asm"]["jb"]).apply(null, arguments);
          };
          var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = function() {
            return (_duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = Module["asm"]["kb"]).apply(null, arguments);
          };
          var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = function() {
            return (_duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = Module["asm"]["lb"]).apply(null, arguments);
          };
          var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = function() {
            return (_duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = Module["asm"]["mb"]).apply(null, arguments);
          };
          var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = function() {
            return (_duckdb_web_get_version = Module["_duckdb_web_get_version"] = Module["asm"]["nb"]).apply(null, arguments);
          };
          var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = function() {
            return (_duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = Module["asm"]["ob"]).apply(null, arguments);
          };
          var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = function() {
            return (_duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = Module["asm"]["pb"]).apply(null, arguments);
          };
          var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = function() {
            return (_duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = Module["asm"]["qb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = function() {
            return (_duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = Module["asm"]["rb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = function() {
            return (_duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = Module["asm"]["sb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = function() {
            return (_duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = Module["asm"]["tb"]).apply(null, arguments);
          };
          var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = function() {
            return (_duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = Module["asm"]["ub"]).apply(null, arguments);
          };
          var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = function() {
            return (_duckdb_web_query_run = Module["_duckdb_web_query_run"] = Module["asm"]["vb"]).apply(null, arguments);
          };
          var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = function() {
            return (_duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = Module["asm"]["wb"]).apply(null, arguments);
          };
          var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = function() {
            return (_duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = Module["asm"]["xb"]).apply(null, arguments);
          };
          var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = function() {
            return (_duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = Module["asm"]["yb"]).apply(null, arguments);
          };
          var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = function() {
            return (_duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = Module["asm"]["zb"]).apply(null, arguments);
          };
          var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = function() {
            return (_duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = Module["asm"]["Ab"]).apply(null, arguments);
          };
          var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = function() {
            return (_duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = Module["asm"]["Bb"]).apply(null, arguments);
          };
          var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = function() {
            return (_duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = Module["asm"]["Cb"]).apply(null, arguments);
          };
          var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = function() {
            return (_duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = Module["asm"]["Db"]).apply(null, arguments);
          };
          var ___errno_location = function() {
            return (___errno_location = Module["asm"]["__errno_location"]).apply(null, arguments);
          };
          var _htonl = function() {
            return (_htonl = Module["asm"]["Eb"]).apply(null, arguments);
          };
          var _htons = function() {
            return (_htons = Module["asm"]["Fb"]).apply(null, arguments);
          };
          var _ntohs = function() {
            return (_ntohs = Module["asm"]["Gb"]).apply(null, arguments);
          };
          var _malloc = Module["_malloc"] = function() {
            return (_malloc = Module["_malloc"] = Module["asm"]["Hb"]).apply(null, arguments);
          };
          var _free = Module["_free"] = function() {
            return (_free = Module["_free"] = Module["asm"]["Ib"]).apply(null, arguments);
          };
          var ___trap = function() {
            return (___trap = Module["asm"]["Jb"]).apply(null, arguments);
          };
          var stackSave = function() {
            return (stackSave = Module["asm"]["Kb"]).apply(null, arguments);
          };
          var stackRestore = function() {
            return (stackRestore = Module["asm"]["Lb"]).apply(null, arguments);
          };
          var stackAlloc = function() {
            return (stackAlloc = Module["asm"]["Mb"]).apply(null, arguments);
          };
          Module["stackAlloc"] = stackAlloc;
          Module["stackSave"] = stackSave;
          Module["stackRestore"] = stackRestore;
          Module["ccall"] = ccall;
          var calledRun;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun)
              run();
            if (!calledRun)
              dependenciesFulfilled = runCaller;
          };
          function callMain() {
            var entryFunction = _main;
            var argc = 0;
            var argv = 0;
            try {
              var ret = entryFunction(argc, argv);
              exitJS(ret, true);
              return ret;
            } catch (e) {
              return handleException(e);
            }
          }
          function run() {
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }
            function doRun() {
              if (calledRun)
                return;
              calledRun = true;
              Module["calledRun"] = true;
              if (ABORT)
                return;
              initRuntime();
              preMain();
              readyPromiseResolve(Module);
              if (Module["onRuntimeInitialized"])
                Module["onRuntimeInitialized"]();
              if (shouldRunNow)
                callMain();
              postRun();
            }
            if (Module["setStatus"]) {
              Module["setStatus"]("Running...");
              setTimeout(function() {
                setTimeout(function() {
                  Module["setStatus"]("");
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module["noInitialRun"])
            shouldRunNow = false;
          run();
          return DuckDB4.ready;
        };
      })();
      if (typeof exports2 === "object" && typeof module2 === "object")
        module2.exports = DuckDB3;
      else if (typeof define === "function" && define["amd"])
        define([], function() {
          return DuckDB3;
        });
      else if (typeof exports2 === "object")
        exports2["DuckDB"] = DuckDB3;
    }
  });

  // ../../node_modules/web-worker/cjs/browser.js
  var require_browser = __commonJS({
    "../../node_modules/web-worker/cjs/browser.js"(exports2, module2) {
      module2.exports = Worker;
    }
  });

  // node_modules/tslib/tslib.es6.mjs
  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
      }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function(v) {
        return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }

  // node_modules/apache-arrow/util/buffer.mjs
  var buffer_exports = {};
  __export(buffer_exports, {
    compareArrayLike: () => compareArrayLike,
    joinUint8Arrays: () => joinUint8Arrays,
    memcpy: () => memcpy,
    rebaseValueOffsets: () => rebaseValueOffsets,
    toArrayBufferView: () => toArrayBufferView,
    toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
    toArrayBufferViewIterator: () => toArrayBufferViewIterator,
    toBigInt64Array: () => toBigInt64Array,
    toBigUint64Array: () => toBigUint64Array,
    toFloat32Array: () => toFloat32Array,
    toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
    toFloat32ArrayIterator: () => toFloat32ArrayIterator,
    toFloat64Array: () => toFloat64Array,
    toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
    toFloat64ArrayIterator: () => toFloat64ArrayIterator,
    toInt16Array: () => toInt16Array,
    toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
    toInt16ArrayIterator: () => toInt16ArrayIterator,
    toInt32Array: () => toInt32Array,
    toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
    toInt32ArrayIterator: () => toInt32ArrayIterator,
    toInt8Array: () => toInt8Array,
    toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
    toInt8ArrayIterator: () => toInt8ArrayIterator,
    toUint16Array: () => toUint16Array,
    toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
    toUint16ArrayIterator: () => toUint16ArrayIterator,
    toUint32Array: () => toUint32Array,
    toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
    toUint32ArrayIterator: () => toUint32ArrayIterator,
    toUint8Array: () => toUint8Array,
    toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
    toUint8ArrayIterator: () => toUint8ArrayIterator,
    toUint8ClampedArray: () => toUint8ClampedArray,
    toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
    toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
  });

  // node_modules/apache-arrow/util/utf8.mjs
  var decoder = new TextDecoder("utf-8");
  var decodeUtf8 = (buffer) => decoder.decode(buffer);
  var encoder = new TextEncoder();
  var encodeUtf8 = (value) => encoder.encode(value);

  // node_modules/apache-arrow/util/compat.mjs
  var [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {
    const BigInt64ArrayUnavailableError = () => {
      throw new Error("BigInt64Array is not available in this environment");
    };
    class BigInt64ArrayUnavailable {
      static get BYTES_PER_ELEMENT() {
        return 8;
      }
      static of() {
        throw BigInt64ArrayUnavailableError();
      }
      static from() {
        throw BigInt64ArrayUnavailableError();
      }
      constructor() {
        throw BigInt64ArrayUnavailableError();
      }
    }
    return typeof BigInt64Array !== "undefined" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];
  })();
  var [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {
    const BigUint64ArrayUnavailableError = () => {
      throw new Error("BigUint64Array is not available in this environment");
    };
    class BigUint64ArrayUnavailable {
      static get BYTES_PER_ELEMENT() {
        return 8;
      }
      static of() {
        throw BigUint64ArrayUnavailableError();
      }
      static from() {
        throw BigUint64ArrayUnavailableError();
      }
      constructor() {
        throw BigUint64ArrayUnavailableError();
      }
    }
    return typeof BigUint64Array !== "undefined" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
  })();
  var isNumber = (x) => typeof x === "number";
  var isBoolean = (x) => typeof x === "boolean";
  var isFunction = (x) => typeof x === "function";
  var isObject = (x) => x != null && Object(x) === x;
  var isPromise = (x) => {
    return isObject(x) && isFunction(x.then);
  };
  var isIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.iterator]);
  };
  var isAsyncIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.asyncIterator]);
  };
  var isArrowJSON = (x) => {
    return isObject(x) && isObject(x["schema"]);
  };
  var isIteratorResult = (x) => {
    return isObject(x) && "done" in x && "value" in x;
  };
  var isFileHandle = (x) => {
    return isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
  };
  var isFetchResponse = (x) => {
    return isObject(x) && isReadableDOMStream(x["body"]);
  };
  var isReadableInterop = (x) => "_getDOMStream" in x && "_getNodeStream" in x;
  var isWritableDOMStream = (x) => {
    return isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !isReadableInterop(x);
  };
  var isReadableDOMStream = (x) => {
    return isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !isReadableInterop(x);
  };
  var isWritableNodeStream = (x) => {
    return isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !isReadableInterop(x);
  };
  var isReadableNodeStream = (x) => {
    return isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !isReadableInterop(x);
  };
  var isFlatbuffersByteBuffer = (x) => {
    return isObject(x) && isFunction(x["clear"]) && isFunction(x["bytes"]) && isFunction(x["position"]) && isFunction(x["setPosition"]) && isFunction(x["capacity"]) && isFunction(x["getBufferIdentifier"]) && isFunction(x["createLong"]);
  };

  // node_modules/apache-arrow/util/buffer.mjs
  var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
  function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n; ) {
      x = result[j];
      y = chunks[i];
      if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
        y && (result[++j] = y);
        continue;
      }
      ({ byteOffset: xOffset, byteLength: xLen } = x);
      ({ byteOffset: yOffset, byteLength: yLen } = y);
      if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
        y && (result[++j] = y);
        continue;
      }
      result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
  }
  function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
  }
  function joinUint8Arrays(chunks, size) {
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n; ) {
      source = result[index];
      sliced = source.subarray(0, Math.min(source.length, length - offset));
      if (length <= offset + sliced.length) {
        if (sliced.length < source.length) {
          result[index] = source.subarray(sliced.length);
        } else if (sliced.length === source.length) {
          index++;
        }
        buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
        break;
      }
      memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
      offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
  }
  function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
      if (ArrayBufferViewCtor === Uint8Array) {
        return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
      }
      return value;
    }
    if (!value) {
      return new ArrayBufferViewCtor(0);
    }
    if (typeof value === "string") {
      value = encodeUtf8(value);
    }
    if (value instanceof ArrayBuffer) {
      return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
      return new ArrayBufferViewCtor(value);
    }
    if (isFlatbuffersByteBuffer(value)) {
      return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
  }
  var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
  var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
  var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
  var toBigInt64Array = (input) => toArrayBufferView(BigInt64ArrayCtor, input);
  var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
  var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
  var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
  var toBigUint64Array = (input) => toArrayBufferView(BigUint64ArrayCtor, input);
  var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
  var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
  var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
  var pump = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) {
      yield x;
    };
    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable(source) ? wrap(source) : source;
    yield* pump(function* (it2) {
      let r = null;
      do {
        r = it2.next(yield toArrayBufferView(ArrayCtor, r));
      } while (!r.done);
    }(buffers[Symbol.iterator]()));
    return new ArrayCtor();
  }
  var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
  var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
  var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
  var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
  var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
  var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
  var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
  var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
  var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
  function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
      if (isPromise(source)) {
        return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
      }
      const wrap = function(x) {
        return __asyncGenerator(this, arguments, function* () {
          yield yield __await(yield __await(x));
        });
      };
      const emit = function(source2) {
        return __asyncGenerator(this, arguments, function* () {
          yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it2) {
            let r = null;
            do {
              r = it2.next(yield r === null || r === void 0 ? void 0 : r.value);
            } while (!r.done);
          }(source2[Symbol.iterator]())))));
        });
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;
      yield __await(
        // otherwise if AsyncIterable, use it
        yield* __asyncDelegator(__asyncValues(pump(function(it2) {
          return __asyncGenerator(this, arguments, function* () {
            let r = null;
            do {
              r = yield __await(it2.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
            } while (!r.done);
          });
        }(buffers[Symbol.asyncIterator]()))))
      );
      return yield __await(new ArrayCtor());
    });
  }
  var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
  var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
  var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
  var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
  var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
  var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
  var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
  var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
  var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
  function rebaseValueOffsets(offset, length, valueOffsets) {
    if (offset !== 0) {
      valueOffsets = valueOffsets.slice(0, length + 1);
      for (let i = -1; ++i <= length; ) {
        valueOffsets[i] += offset;
      }
    }
    return valueOffsets;
  }
  function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
      return false;
    }
    if (n > 0) {
      do {
        if (a[i] !== b[i]) {
          return false;
        }
      } while (++i < n);
    }
    return true;
  }

  // node_modules/apache-arrow/io/adapters.mjs
  var adapters_default = {
    fromIterable(source) {
      return pump2(fromIterable(source));
    },
    fromAsyncIterable(source) {
      return pump2(fromAsyncIterable(source));
    },
    fromDOMStream(source) {
      return pump2(fromDOMStream(source));
    },
    fromNodeStream(stream) {
      return pump2(fromNodeStream(stream));
    },
    // @ts-ignore
    toDOMStream(source, options) {
      throw new Error(`"toDOMStream" not available in this environment`);
    },
    // @ts-ignore
    toNodeStream(source, options) {
      throw new Error(`"toNodeStream" not available in this environment`);
    }
  };
  var pump2 = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield null);
    const it2 = toUint8ArrayIterator(source)[Symbol.iterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it2.next() : it2.next(size - bufferLength));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield byteRange());
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it2.throw === "function" && it2.throw(e);
    } finally {
      threw === false && typeof it2.return === "function" && it2.return(null);
    }
    return null;
  }
  function fromAsyncIterable(source) {
    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2.next()) : yield __await(it2.next(size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it2.throw === "function" && (yield __await(it2.throw(e)));
      } finally {
        threw === false && typeof it2.return === "function" && (yield __await(it2.return(new Uint8Array(0))));
      }
      return yield __await(null);
    });
  }
  function fromDOMStream(source) {
    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
      let done = false, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = new AdaptiveByteReader(source);
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2["read"]()) : yield __await(it2["read"](size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(toUint8Array(buffer));
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && (yield __await(it2["cancel"](e)));
      } finally {
        threw === false ? yield __await(it2["cancel"]()) : source["locked"] && it2.releaseLock();
      }
      return yield __await(null);
    });
  }
  var AdaptiveByteReader = class {
    constructor(source) {
      this.source = source;
      this.reader = null;
      this.reader = this.source["getReader"]();
      this.reader["closed"].catch(() => {
      });
    }
    get closed() {
      return this.reader ? this.reader["closed"].catch(() => {
      }) : Promise.resolve();
    }
    releaseLock() {
      if (this.reader) {
        this.reader.releaseLock();
      }
      this.reader = null;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        const { reader, source } = this;
        reader && (yield reader["cancel"](reason).catch(() => {
        }));
        source && (source["locked"] && this.releaseLock());
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        if (size === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = yield this.reader.read();
        !result.done && (result.value = toUint8Array(result));
        return result;
      });
    }
  };
  var onEvent = (stream, event) => {
    const handler = (_) => resolve([event, _]);
    let resolve;
    return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
  };
  function fromNodeStream(stream) {
    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
      const events = [];
      let event = "error";
      let done = false, err = null;
      let cmd, size, bufferLength = 0;
      let buffers = [], buffer;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      if (stream["isTTY"]) {
        yield yield __await(new Uint8Array(0));
        return yield __await(null);
      }
      try {
        events[0] = onEvent(stream, "end");
        events[1] = onEvent(stream, "error");
        do {
          events[2] = onEvent(stream, "readable");
          [event, err] = yield __await(Promise.race(events.map((x) => x[2])));
          if (event === "error") {
            break;
          }
          if (!(done = event === "end")) {
            if (!Number.isFinite(size - bufferLength)) {
              buffer = toUint8Array(stream["read"]());
            } else {
              buffer = toUint8Array(stream["read"](size - bufferLength));
              if (buffer.byteLength < size - bufferLength) {
                buffer = toUint8Array(stream["read"]());
              }
            }
            if (buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } finally {
        yield __await(cleanup(events, event === "error" ? err : null));
      }
      return yield __await(null);
      function cleanup(events2, err2) {
        buffer = buffers = null;
        return new Promise((resolve, reject) => {
          for (const [evt, fn] of events2) {
            stream["off"](evt, fn);
          }
          try {
            const destroy = stream["destroy"];
            destroy && destroy.call(stream, err2);
            err2 = void 0;
          } catch (e) {
            err2 = e || err2;
          } finally {
            err2 != null ? reject(err2) : resolve();
          }
        });
      }
    });
  }

  // node_modules/apache-arrow/enum.mjs
  var MetadataVersion;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion || (MetadataVersion = {}));
  var UnionMode;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode || (UnionMode = {}));
  var Precision;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision || (Precision = {}));
  var DateUnit;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit || (DateUnit = {}));
  var TimeUnit;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit || (TimeUnit = {}));
  var IntervalUnit;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit || (IntervalUnit = {}));
  var MessageHeader;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader || (MessageHeader = {}));
  var Type;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["Float"] = 3] = "Float";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct"] = 13] = "Struct";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Dictionary"] = -1] = "Dictionary";
    Type3[Type3["Int8"] = -2] = "Int8";
    Type3[Type3["Int16"] = -3] = "Int16";
    Type3[Type3["Int32"] = -4] = "Int32";
    Type3[Type3["Int64"] = -5] = "Int64";
    Type3[Type3["Uint8"] = -6] = "Uint8";
    Type3[Type3["Uint16"] = -7] = "Uint16";
    Type3[Type3["Uint32"] = -8] = "Uint32";
    Type3[Type3["Uint64"] = -9] = "Uint64";
    Type3[Type3["Float16"] = -10] = "Float16";
    Type3[Type3["Float32"] = -11] = "Float32";
    Type3[Type3["Float64"] = -12] = "Float64";
    Type3[Type3["DateDay"] = -13] = "DateDay";
    Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
    Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
    Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
    Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
    Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
    Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  })(Type || (Type = {}));
  var BufferType;
  (function(BufferType2) {
    BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
    BufferType2[BufferType2["DATA"] = 1] = "DATA";
    BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
    BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
  })(BufferType || (BufferType = {}));

  // node_modules/apache-arrow/util/vector.mjs
  var vector_exports = {};
  __export(vector_exports, {
    clampIndex: () => clampIndex,
    clampRange: () => clampRange,
    createElementComparator: () => createElementComparator
  });

  // node_modules/apache-arrow/util/pretty.mjs
  var undf = void 0;
  function valueToString(x) {
    if (x === null) {
      return "null";
    }
    if (x === undf) {
      return "undefined";
    }
    switch (typeof x) {
      case "number":
        return `${x}`;
      case "bigint":
        return `${x}`;
      case "string":
        return `"${x}"`;
    }
    if (typeof x[Symbol.toPrimitive] === "function") {
      return x[Symbol.toPrimitive]("string");
    }
    if (ArrayBuffer.isView(x)) {
      if (x instanceof BigInt64ArrayCtor || x instanceof BigUint64ArrayCtor) {
        return `[${[...x].map((x2) => valueToString(x2))}]`;
      }
      return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
  }

  // node_modules/apache-arrow/util/bn.mjs
  var bn_exports = {};
  __export(bn_exports, {
    BN: () => BN,
    bignumToBigInt: () => bignumToBigInt,
    bignumToString: () => bignumToString,
    isArrowBigNumSymbol: () => isArrowBigNumSymbol
  });
  var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
  function BigNum(x, ...xs) {
    if (xs.length === 0) {
      return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
  }
  BigNum.prototype[isArrowBigNumSymbol] = true;
  BigNum.prototype.toJSON = function() {
    return `"${bignumToString(this)}"`;
  };
  BigNum.prototype.valueOf = function() {
    return bignumToNumber(this);
  };
  BigNum.prototype.toString = function() {
    return bignumToString(this);
  };
  BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
    switch (hint) {
      case "number":
        return bignumToNumber(this);
      case "string":
        return bignumToString(this);
      case "default":
        return bignumToBigInt(this);
    }
    return bignumToString(this);
  };
  function SignedBigNum(...args) {
    return BigNum.apply(this, args);
  }
  function UnsignedBigNum(...args) {
    return BigNum.apply(this, args);
  }
  function DecimalBigNum(...args) {
    return BigNum.apply(this, args);
  }
  Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
  Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64ArrayCtor });
  Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64ArrayCtor });
  Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64ArrayCtor });
  function bignumToNumber(bn) {
    const { buffer, byteOffset, length, "signed": signed } = bn;
    const words = new BigUint64ArrayCtor(buffer, byteOffset, length);
    const negative = signed && words[words.length - 1] & BigInt(1) << BigInt(63);
    let number = negative ? BigInt(1) : BigInt(0);
    let i = BigInt(0);
    if (!negative) {
      for (const word of words) {
        number += word * (BigInt(1) << BigInt(32) * i++);
      }
    } else {
      for (const word of words) {
        number += ~word * (BigInt(1) << BigInt(32) * i++);
      }
      number *= BigInt(-1);
    }
    return number;
  }
  var bignumToString = (a) => a.byteLength === 8 ? `${new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a);
  var bignumToBigInt = (a) => a.byteLength === 8 ? new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0] : decimalToString(a);
  function decimalToString(a) {
    let digits = "";
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
      for (base64[0] = base32[i = 0]; i < n; ) {
        base32[i++] = base64[1] = base64[0] / 10;
        base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
      }
      base32[i] = base64[1] = base64[0] / 10;
      base64[0] = base64[0] - base64[1] * 10;
      digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
  }
  var BN = class _BN {
    /** @nocollapse */
    static new(num, isSigned) {
      switch (isSigned) {
        case true:
          return new SignedBigNum(num);
        case false:
          return new UnsignedBigNum(num);
      }
      switch (num.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case BigInt64ArrayCtor:
          return new SignedBigNum(num);
      }
      if (num.byteLength === 16) {
        return new DecimalBigNum(num);
      }
      return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static signed(num) {
      return new SignedBigNum(num);
    }
    /** @nocollapse */
    static unsigned(num) {
      return new UnsignedBigNum(num);
    }
    /** @nocollapse */
    static decimal(num) {
      return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
      return _BN.new(num, isSigned);
    }
  };

  // node_modules/apache-arrow/util/bigint.mjs
  function bigIntToNumber(number) {
    if (typeof number === "bigint" && (number < Number.MIN_SAFE_INTEGER || number > Number.MAX_SAFE_INTEGER)) {
      throw new TypeError(`${number} is not safe to convert to a number.`);
    }
    return Number(number);
  }

  // node_modules/apache-arrow/type.mjs
  var _a;
  var _b;
  var _c;
  var _d;
  var _e;
  var _f;
  var _g;
  var _h;
  var _j;
  var _k;
  var _l;
  var _m;
  var _o;
  var _p;
  var _q;
  var _r;
  var _s;
  var _t;
  var _u;
  var DataType = class _DataType {
    /** @nocollapse */
    static isNull(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Null;
    }
    /** @nocollapse */
    static isInt(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Int;
    }
    /** @nocollapse */
    static isFloat(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Float;
    }
    /** @nocollapse */
    static isBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Binary;
    }
    /** @nocollapse */
    static isUtf8(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Utf8;
    }
    /** @nocollapse */
    static isBool(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Bool;
    }
    /** @nocollapse */
    static isDecimal(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Decimal;
    }
    /** @nocollapse */
    static isDate(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Date;
    }
    /** @nocollapse */
    static isTime(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Time;
    }
    /** @nocollapse */
    static isTimestamp(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Timestamp;
    }
    /** @nocollapse */
    static isInterval(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Interval;
    }
    /** @nocollapse */
    static isList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.List;
    }
    /** @nocollapse */
    static isStruct(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Struct;
    }
    /** @nocollapse */
    static isUnion(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Union;
    }
    /** @nocollapse */
    static isFixedSizeBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeBinary;
    }
    /** @nocollapse */
    static isFixedSizeList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeList;
    }
    /** @nocollapse */
    static isMap(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Map;
    }
    /** @nocollapse */
    static isDictionary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Dictionary;
    }
    /** @nocollapse */
    static isDenseUnion(x) {
      return _DataType.isUnion(x) && x.mode === UnionMode.Dense;
    }
    /** @nocollapse */
    static isSparseUnion(x) {
      return _DataType.isUnion(x) && x.mode === UnionMode.Sparse;
    }
    get typeId() {
      return Type.NONE;
    }
  };
  _a = Symbol.toStringTag;
  DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    return proto[Symbol.toStringTag] = "DataType";
  })(DataType.prototype);
  var Null = class extends DataType {
    toString() {
      return `Null`;
    }
    get typeId() {
      return Type.Null;
    }
  };
  _b = Symbol.toStringTag;
  Null[_b] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null.prototype);
  var Int_ = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 8:
          return this.isSigned ? Int8Array : Uint8Array;
        case 16:
          return this.isSigned ? Int16Array : Uint16Array;
        case 32:
          return this.isSigned ? Int32Array : Uint32Array;
        case 64:
          return this.isSigned ? BigInt64ArrayCtor : BigUint64ArrayCtor;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
    }
  };
  _c = Symbol.toStringTag;
  Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Int";
  })(Int_.prototype);
  var Int8 = class extends Int_ {
    constructor() {
      super(true, 8);
    }
    get ArrayType() {
      return Int8Array;
    }
  };
  var Int16 = class extends Int_ {
    constructor() {
      super(true, 16);
    }
    get ArrayType() {
      return Int16Array;
    }
  };
  var Int32 = class extends Int_ {
    constructor() {
      super(true, 32);
    }
    get ArrayType() {
      return Int32Array;
    }
  };
  var Int64 = class extends Int_ {
    constructor() {
      super(true, 64);
    }
    get ArrayType() {
      return BigInt64ArrayCtor;
    }
  };
  var Uint8 = class extends Int_ {
    constructor() {
      super(false, 8);
    }
    get ArrayType() {
      return Uint8Array;
    }
  };
  var Uint16 = class extends Int_ {
    constructor() {
      super(false, 16);
    }
    get ArrayType() {
      return Uint16Array;
    }
  };
  var Uint32 = class extends Int_ {
    constructor() {
      super(false, 32);
    }
    get ArrayType() {
      return Uint32Array;
    }
  };
  var Uint64 = class extends Int_ {
    constructor() {
      super(false, 64);
    }
    get ArrayType() {
      return BigUint64ArrayCtor;
    }
  };
  Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
  Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
  Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
  Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64ArrayCtor });
  Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
  Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
  Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64ArrayCtor });
  var Float = class extends DataType {
    constructor(precision) {
      super();
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get ArrayType() {
      switch (this.precision) {
        case Precision.HALF:
          return Uint16Array;
        case Precision.SINGLE:
          return Float32Array;
        case Precision.DOUBLE:
          return Float64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `Float${this.precision << 5 || 16}`;
    }
  };
  _d = Symbol.toStringTag;
  Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = "Float";
  })(Float.prototype);
  var Float16 = class extends Float {
    constructor() {
      super(Precision.HALF);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
  Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return `Binary`;
    }
  };
  _e = Symbol.toStringTag;
  Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Binary";
  })(Binary.prototype);
  var Utf8 = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Utf8;
    }
    toString() {
      return `Utf8`;
    }
  };
  _f = Symbol.toStringTag;
  Utf8[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Utf8";
  })(Utf8.prototype);
  var Bool = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Bool;
    }
    toString() {
      return `Bool`;
    }
  };
  _g = Symbol.toStringTag;
  Bool[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Bool";
  })(Bool.prototype);
  var Decimal = class extends DataType {
    constructor(scale, precision, bitWidth = 128) {
      super();
      this.scale = scale;
      this.precision = precision;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Decimal;
    }
    toString() {
      return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
    }
  };
  _h = Symbol.toStringTag;
  Decimal[_h] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = "Decimal";
  })(Decimal.prototype);
  var Date_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    toString() {
      return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
  };
  _j = Symbol.toStringTag;
  Date_[_j] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Date";
  })(Date_.prototype);
  var DateDay = class extends Date_ {
    constructor() {
      super(DateUnit.DAY);
    }
  };
  var DateMillisecond = class extends Date_ {
    constructor() {
      super(DateUnit.MILLISECOND);
    }
  };
  var Time_ = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 32:
          return Int32Array;
        case 64:
          return BigInt64ArrayCtor;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  };
  _k = Symbol.toStringTag;
  Time_[_k] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Time";
  })(Time_.prototype);
  var Timestamp_ = class extends DataType {
    constructor(unit, timezone) {
      super();
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    toString() {
      return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
    }
  };
  _l = Symbol.toStringTag;
  Timestamp_[_l] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Timestamp";
  })(Timestamp_.prototype);
  var TimestampSecond = class extends Timestamp_ {
    constructor(timezone) {
      super(TimeUnit.SECOND, timezone);
    }
  };
  var Interval_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    toString() {
      return `Interval<${IntervalUnit[this.unit]}>`;
    }
  };
  _m = Symbol.toStringTag;
  Interval_[_m] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Interval";
  })(Interval_.prototype);
  var List = class extends DataType {
    constructor(child) {
      super();
      this.children = [child];
    }
    get typeId() {
      return Type.List;
    }
    toString() {
      return `List<${this.valueType}>`;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
  };
  _o = Symbol.toStringTag;
  List[_o] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "List";
  })(List.prototype);
  var Struct = class extends DataType {
    constructor(children) {
      super();
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _p = Symbol.toStringTag;
  Struct[_p] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "Struct";
  })(Struct.prototype);
  var Union_ = class extends DataType {
    constructor(mode, typeIds, children) {
      super();
      this.mode = mode;
      this.children = children;
      this.typeIds = typeIds = Int32Array.from(typeIds);
      this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
    }
    get typeId() {
      return Type.Union;
    }
    toString() {
      return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
  };
  _q = Symbol.toStringTag;
  Union_[_q] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = "Union";
  })(Union_.prototype);
  var FixedSizeBinary = class extends DataType {
    constructor(byteWidth) {
      super();
      this.byteWidth = byteWidth;
    }
    get typeId() {
      return Type.FixedSizeBinary;
    }
    toString() {
      return `FixedSizeBinary[${this.byteWidth}]`;
    }
  };
  _r = Symbol.toStringTag;
  FixedSizeBinary[_r] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "FixedSizeBinary";
  })(FixedSizeBinary.prototype);
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
    toString() {
      return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
  };
  _s = Symbol.toStringTag;
  FixedSizeList[_s] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = "FixedSizeList";
  })(FixedSizeList.prototype);
  var Map_ = class extends DataType {
    constructor(child, keysSorted = false) {
      super();
      this.children = [child];
      this.keysSorted = keysSorted;
    }
    get typeId() {
      return Type.Map;
    }
    get keyType() {
      return this.children[0].type.children[0].type;
    }
    get valueType() {
      return this.children[0].type.children[1].type;
    }
    get childType() {
      return this.children[0].type;
    }
    toString() {
      return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _t = Symbol.toStringTag;
  Map_[_t] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = "Map_";
  })(Map_.prototype);
  var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
  var Dictionary = class extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
      super();
      this.indices = indices;
      this.dictionary = dictionary;
      this.isOrdered = isOrdered || false;
      this.id = id == null ? getId() : bigIntToNumber(id);
    }
    get typeId() {
      return Type.Dictionary;
    }
    get children() {
      return this.dictionary.children;
    }
    get valueType() {
      return this.dictionary;
    }
    get ArrayType() {
      return this.dictionary.ArrayType;
    }
    toString() {
      return `Dictionary<${this.indices}, ${this.dictionary}>`;
    }
  };
  _u = Symbol.toStringTag;
  Dictionary[_u] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = "Dictionary";
  })(Dictionary.prototype);
  function strideForType(type) {
    const t = type;
    switch (type.typeId) {
      case Type.Decimal:
        return type.bitWidth / 32;
      case Type.Timestamp:
        return 2;
      case Type.Date:
        return 1 + t.unit;
      case Type.Interval:
        return 1 + t.unit;
      case Type.FixedSizeList:
        return t.listSize;
      case Type.FixedSizeBinary:
        return t.byteWidth;
      default:
        return 1;
    }
  }

  // node_modules/apache-arrow/visitor.mjs
  var Visitor = class {
    visitMany(nodes, ...args) {
      return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
    }
    visit(...args) {
      return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
      return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
      return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) {
      return null;
    }
    visitBool(_node, ..._args) {
      return null;
    }
    visitInt(_node, ..._args) {
      return null;
    }
    visitFloat(_node, ..._args) {
      return null;
    }
    visitUtf8(_node, ..._args) {
      return null;
    }
    visitBinary(_node, ..._args) {
      return null;
    }
    visitFixedSizeBinary(_node, ..._args) {
      return null;
    }
    visitDate(_node, ..._args) {
      return null;
    }
    visitTimestamp(_node, ..._args) {
      return null;
    }
    visitTime(_node, ..._args) {
      return null;
    }
    visitDecimal(_node, ..._args) {
      return null;
    }
    visitList(_node, ..._args) {
      return null;
    }
    visitStruct(_node, ..._args) {
      return null;
    }
    visitUnion(_node, ..._args) {
      return null;
    }
    visitDictionary(_node, ..._args) {
      return null;
    }
    visitInterval(_node, ..._args) {
      return null;
    }
    visitFixedSizeList(_node, ..._args) {
      return null;
    }
    visitMap(_node, ..._args) {
      return null;
    }
  };
  function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === "number") {
      return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === "string" && node in Type) {
      return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);
    }
    if (node && node instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);
  }
  function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
      case Type.Null:
        fn = visitor.visitNull;
        break;
      case Type.Bool:
        fn = visitor.visitBool;
        break;
      case Type.Int:
        fn = visitor.visitInt;
        break;
      case Type.Int8:
        fn = visitor.visitInt8 || visitor.visitInt;
        break;
      case Type.Int16:
        fn = visitor.visitInt16 || visitor.visitInt;
        break;
      case Type.Int32:
        fn = visitor.visitInt32 || visitor.visitInt;
        break;
      case Type.Int64:
        fn = visitor.visitInt64 || visitor.visitInt;
        break;
      case Type.Uint8:
        fn = visitor.visitUint8 || visitor.visitInt;
        break;
      case Type.Uint16:
        fn = visitor.visitUint16 || visitor.visitInt;
        break;
      case Type.Uint32:
        fn = visitor.visitUint32 || visitor.visitInt;
        break;
      case Type.Uint64:
        fn = visitor.visitUint64 || visitor.visitInt;
        break;
      case Type.Float:
        fn = visitor.visitFloat;
        break;
      case Type.Float16:
        fn = visitor.visitFloat16 || visitor.visitFloat;
        break;
      case Type.Float32:
        fn = visitor.visitFloat32 || visitor.visitFloat;
        break;
      case Type.Float64:
        fn = visitor.visitFloat64 || visitor.visitFloat;
        break;
      case Type.Utf8:
        fn = visitor.visitUtf8;
        break;
      case Type.Binary:
        fn = visitor.visitBinary;
        break;
      case Type.FixedSizeBinary:
        fn = visitor.visitFixedSizeBinary;
        break;
      case Type.Date:
        fn = visitor.visitDate;
        break;
      case Type.DateDay:
        fn = visitor.visitDateDay || visitor.visitDate;
        break;
      case Type.DateMillisecond:
        fn = visitor.visitDateMillisecond || visitor.visitDate;
        break;
      case Type.Timestamp:
        fn = visitor.visitTimestamp;
        break;
      case Type.TimestampSecond:
        fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMillisecond:
        fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMicrosecond:
        fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
        break;
      case Type.TimestampNanosecond:
        fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
        break;
      case Type.Time:
        fn = visitor.visitTime;
        break;
      case Type.TimeSecond:
        fn = visitor.visitTimeSecond || visitor.visitTime;
        break;
      case Type.TimeMillisecond:
        fn = visitor.visitTimeMillisecond || visitor.visitTime;
        break;
      case Type.TimeMicrosecond:
        fn = visitor.visitTimeMicrosecond || visitor.visitTime;
        break;
      case Type.TimeNanosecond:
        fn = visitor.visitTimeNanosecond || visitor.visitTime;
        break;
      case Type.Decimal:
        fn = visitor.visitDecimal;
        break;
      case Type.List:
        fn = visitor.visitList;
        break;
      case Type.Struct:
        fn = visitor.visitStruct;
        break;
      case Type.Union:
        fn = visitor.visitUnion;
        break;
      case Type.DenseUnion:
        fn = visitor.visitDenseUnion || visitor.visitUnion;
        break;
      case Type.SparseUnion:
        fn = visitor.visitSparseUnion || visitor.visitUnion;
        break;
      case Type.Dictionary:
        fn = visitor.visitDictionary;
        break;
      case Type.Interval:
        fn = visitor.visitInterval;
        break;
      case Type.IntervalDayTime:
        fn = visitor.visitIntervalDayTime || visitor.visitInterval;
        break;
      case Type.IntervalYearMonth:
        fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
        break;
      case Type.FixedSizeList:
        fn = visitor.visitFixedSizeList;
        break;
      case Type.Map:
        fn = visitor.visitMap;
        break;
    }
    if (typeof fn === "function")
      return fn;
    if (!throwIfNotFound)
      return () => null;
    throw new Error(`Unrecognized type '${Type[dtype]}'`);
  }
  function inferDType(type) {
    switch (type.typeId) {
      case Type.Null:
        return Type.Null;
      case Type.Int: {
        const { bitWidth, isSigned } = type;
        switch (bitWidth) {
          case 8:
            return isSigned ? Type.Int8 : Type.Uint8;
          case 16:
            return isSigned ? Type.Int16 : Type.Uint16;
          case 32:
            return isSigned ? Type.Int32 : Type.Uint32;
          case 64:
            return isSigned ? Type.Int64 : Type.Uint64;
        }
        return Type.Int;
      }
      case Type.Float:
        switch (type.precision) {
          case Precision.HALF:
            return Type.Float16;
          case Precision.SINGLE:
            return Type.Float32;
          case Precision.DOUBLE:
            return Type.Float64;
        }
        return Type.Float;
      case Type.Binary:
        return Type.Binary;
      case Type.Utf8:
        return Type.Utf8;
      case Type.Bool:
        return Type.Bool;
      case Type.Decimal:
        return Type.Decimal;
      case Type.Time:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimeSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimeMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimeMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimeNanosecond;
        }
        return Type.Time;
      case Type.Timestamp:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimestampSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimestampMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimestampMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimestampNanosecond;
        }
        return Type.Timestamp;
      case Type.Date:
        switch (type.unit) {
          case DateUnit.DAY:
            return Type.DateDay;
          case DateUnit.MILLISECOND:
            return Type.DateMillisecond;
        }
        return Type.Date;
      case Type.Interval:
        switch (type.unit) {
          case IntervalUnit.DAY_TIME:
            return Type.IntervalDayTime;
          case IntervalUnit.YEAR_MONTH:
            return Type.IntervalYearMonth;
        }
        return Type.Interval;
      case Type.Map:
        return Type.Map;
      case Type.List:
        return Type.List;
      case Type.Struct:
        return Type.Struct;
      case Type.Union:
        switch (type.mode) {
          case UnionMode.Dense:
            return Type.DenseUnion;
          case UnionMode.Sparse:
            return Type.SparseUnion;
        }
        return Type.Union;
      case Type.FixedSizeBinary:
        return Type.FixedSizeBinary;
      case Type.FixedSizeList:
        return Type.FixedSizeList;
      case Type.Dictionary:
        return Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${Type[type.typeId]}'`);
  }
  Visitor.prototype.visitInt8 = null;
  Visitor.prototype.visitInt16 = null;
  Visitor.prototype.visitInt32 = null;
  Visitor.prototype.visitInt64 = null;
  Visitor.prototype.visitUint8 = null;
  Visitor.prototype.visitUint16 = null;
  Visitor.prototype.visitUint32 = null;
  Visitor.prototype.visitUint64 = null;
  Visitor.prototype.visitFloat16 = null;
  Visitor.prototype.visitFloat32 = null;
  Visitor.prototype.visitFloat64 = null;
  Visitor.prototype.visitDateDay = null;
  Visitor.prototype.visitDateMillisecond = null;
  Visitor.prototype.visitTimestampSecond = null;
  Visitor.prototype.visitTimestampMillisecond = null;
  Visitor.prototype.visitTimestampMicrosecond = null;
  Visitor.prototype.visitTimestampNanosecond = null;
  Visitor.prototype.visitTimeSecond = null;
  Visitor.prototype.visitTimeMillisecond = null;
  Visitor.prototype.visitTimeMicrosecond = null;
  Visitor.prototype.visitTimeNanosecond = null;
  Visitor.prototype.visitDenseUnion = null;
  Visitor.prototype.visitSparseUnion = null;
  Visitor.prototype.visitIntervalDayTime = null;
  Visitor.prototype.visitIntervalYearMonth = null;

  // node_modules/apache-arrow/util/math.mjs
  var math_exports = {};
  __export(math_exports, {
    float64ToUint16: () => float64ToUint16,
    uint16ToFloat64: () => uint16ToFloat64
  });
  var f64 = new Float64Array(1);
  var u32 = new Uint32Array(f64.buffer);
  function uint16ToFloat64(h) {
    const expo = (h & 31744) >> 10;
    const sigf = (h & 1023) / 1024;
    const sign = Math.pow(-1, (h & 32768) >> 15);
    switch (expo) {
      case 31:
        return sign * (sigf ? Number.NaN : 1 / 0);
      case 0:
        return sign * (sigf ? 6103515625e-14 * sigf : 0);
    }
    return sign * Math.pow(2, expo - 15) * (1 + sigf);
  }
  function float64ToUint16(d) {
    if (d !== d) {
      return 32256;
    }
    f64[0] = d;
    const sign = (u32[1] & 2147483648) >> 16 & 65535;
    let expo = u32[1] & 2146435072, sigf = 0;
    if (expo >= 1089470464) {
      if (u32[0] > 0) {
        expo = 31744;
      } else {
        expo = (expo & 2080374784) >> 16;
        sigf = (u32[1] & 1048575) >> 10;
      }
    } else if (expo <= 1056964608) {
      sigf = 1048576 + (u32[1] & 1048575);
      sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
      expo = 0;
    } else {
      expo = expo - 1056964608 >> 10;
      sigf = (u32[1] & 1048575) + 512 >> 10;
    }
    return sign | expo | sigf & 65535;
  }

  // node_modules/apache-arrow/visitor/set.mjs
  var SetVisitor = class extends Visitor {
  };
  function wrapSet(fn) {
    return (data, _1, _2) => {
      if (data.setValid(_1, _2 != null)) {
        return fn(data, _1, _2);
      }
    };
  }
  var setEpochMsToDays = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs / 864e5);
  };
  var setEpochMsToMillisecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs % 4294967296);
    data[index + 1] = Math.trunc(epochMs / 4294967296);
  };
  var setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs * 1e3 % 4294967296);
    data[index + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
  };
  var setEpochMsToNanosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs * 1e6 % 4294967296);
    data[index + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
  };
  var setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      values.set(value.subarray(0, y - x), x);
    }
  };
  var setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
  };
  var setInt = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat16 = ({ values }, index, value) => {
    values[index] = float64ToUint16(value);
  };
  var setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
      case Precision.HALF:
        return setFloat16(data, index, value);
      case Precision.SINGLE:
      case Precision.DOUBLE:
        return setFloat(data, index, value);
    }
  };
  var setDateDay = ({ values }, index, value) => {
    setEpochMsToDays(values, index, value.valueOf());
  };
  var setDateMillisecond = ({ values }, index, value) => {
    setEpochMsToMillisecondsLong(values, index * 2, value.valueOf());
  };
  var setFixedSizeBinary = ({ stride, values }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);
  var setUtf8 = ({ values, valueOffsets }, index, value) => {
    setVariableWidthBytes(values, valueOffsets, index, encodeUtf8(value));
  };
  var setDate = (data, index, value) => {
    data.type.unit === DateUnit.DAY ? setDateDay(data, index, value) : setDateMillisecond(data, index, value);
  };
  var setTimestampSecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value / 1e3);
  var setTimestampMillisecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value);
  var setTimestampMicrosecond = ({ values }, index, value) => setEpochMsToMicrosecondsLong(values, index * 2, value);
  var setTimestampNanosecond = ({ values }, index, value) => setEpochMsToNanosecondsLong(values, index * 2, value);
  var setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimestampSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimestampMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimestampMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimestampNanosecond(data, index, value);
    }
  };
  var setTimeSecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMillisecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMicrosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeNanosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTime = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimeSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimeMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimeMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimeNanosecond(data, index, value);
    }
  };
  var setDecimal = ({ values, stride }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setList = (data, index, value) => {
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = instance.getVisitFn(values);
    if (Array.isArray(value)) {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value[++idx]);
      }
    } else {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value.get(++idx));
      }
    }
  };
  var setMap = (data, index, value) => {
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
      set(values, idx, val);
      if (++idx >= end)
        break;
    }
  };
  var _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
  var _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
  var _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
  var _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
  var setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
  };
  var setUnion = (data, index, value) => {
    data.type.mode === UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
  };
  var setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, data.valueOffsets[index], value);
  };
  var setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, index, value);
  };
  var setDictionary = (data, index, value) => {
    var _a5;
    (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index], value);
  };
  var setIntervalValue = (data, index, value) => {
    data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index, value) : setIntervalYearMonth(data, index, value);
  };
  var setIntervalDayTime = ({ values }, index, value) => {
    values.set(value.subarray(0, 2), 2 * index);
  };
  var setIntervalYearMonth = ({ values }, index, value) => {
    values[index] = value[0] * 12 + value[1] % 12;
  };
  var setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set = instance.getVisitFn(child);
    if (Array.isArray(value)) {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value[idx]);
      }
    } else {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value.get(idx));
      }
    }
  };
  SetVisitor.prototype.visitBool = wrapSet(setBool);
  SetVisitor.prototype.visitInt = wrapSet(setInt);
  SetVisitor.prototype.visitInt8 = wrapSet(setInt);
  SetVisitor.prototype.visitInt16 = wrapSet(setInt);
  SetVisitor.prototype.visitInt32 = wrapSet(setInt);
  SetVisitor.prototype.visitInt64 = wrapSet(setInt);
  SetVisitor.prototype.visitUint8 = wrapSet(setInt);
  SetVisitor.prototype.visitUint16 = wrapSet(setInt);
  SetVisitor.prototype.visitUint32 = wrapSet(setInt);
  SetVisitor.prototype.visitUint64 = wrapSet(setInt);
  SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
  SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
  SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
  SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
  SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
  SetVisitor.prototype.visitBinary = wrapSet(setBinary);
  SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
  SetVisitor.prototype.visitDate = wrapSet(setDate);
  SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
  SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
  SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
  SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
  SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
  SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
  SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
  SetVisitor.prototype.visitTime = wrapSet(setTime);
  SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
  SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
  SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
  SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
  SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
  SetVisitor.prototype.visitList = wrapSet(setList);
  SetVisitor.prototype.visitStruct = wrapSet(setStruct);
  SetVisitor.prototype.visitUnion = wrapSet(setUnion);
  SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
  SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
  SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
  SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
  SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
  SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
  SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
  SetVisitor.prototype.visitMap = wrapSet(setMap);
  var instance = new SetVisitor();

  // node_modules/apache-arrow/row/struct.mjs
  var kParent = Symbol.for("parent");
  var kRowIndex = Symbol.for("rowIndex");
  var StructRow = class {
    constructor(parent, rowIndex) {
      this[kParent] = parent;
      this[kRowIndex] = rowIndex;
      return new Proxy(this, new StructRowProxyHandler());
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const i = this[kRowIndex];
      const parent = this[kParent];
      const keys = parent.type.children;
      const json = {};
      for (let j = -1, n = keys.length; ++j < n; ) {
        json[keys[j].name] = instance2.visit(parent.children[j], i);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
    [Symbol.iterator]() {
      return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
  };
  var StructRowIterator = class {
    constructor(data, rowIndex) {
      this.childIndex = 0;
      this.children = data.children;
      this.rowIndex = rowIndex;
      this.childFields = data.type.children;
      this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i = this.childIndex;
      if (i < this.numChildren) {
        this.childIndex = i + 1;
        return {
          done: false,
          value: [
            this.childFields[i].name,
            instance2.visit(this.children[i], this.rowIndex)
          ]
        };
      }
      return { done: true, value: null };
    }
  };
  Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
  });
  var StructRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
      return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;
    }
    getOwnPropertyDescriptor(row, key) {
      if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        instance.visit(row[kParent].children[idx], row[kRowIndex], val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key) || typeof key === "symbol") {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };

  // node_modules/apache-arrow/visitor/get.mjs
  var GetVisitor = class extends Visitor {
  };
  function wrapGet(fn) {
    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
  }
  var epochDaysToMs = (data, index) => 864e5 * data[index];
  var epochMillisecondsLongToMs = (data, index) => 4294967296 * data[index + 1] + (data[index] >>> 0);
  var epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e3) + (data[index] >>> 0) / 1e3;
  var epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e6) + (data[index] >>> 0) / 1e6;
  var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
  var epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
  var epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
  var getNull = (_data, _index) => null;
  var getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
      return null;
    }
    const x = valueOffsets[index];
    const y = valueOffsets[index + 1];
    return values.subarray(x, y);
  };
  var getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << idx % 8) !== 0;
  };
  var getDateDay = ({ values }, index) => epochDaysToDate(values, index);
  var getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
  var getNumeric = ({ stride, values }, index) => values[stride * index];
  var getFloat16 = ({ stride, values }, index) => uint16ToFloat64(values[stride * index]);
  var getBigInts = ({ values }, index) => values[index];
  var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
  var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
  var getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? decodeUtf8(bytes) : null;
  };
  var getInt = ({ values }, index) => values[index];
  var getFloat = ({ type, values }, index) => type.precision !== Precision.HALF ? values[index] : uint16ToFloat64(values[index]);
  var getDate = (data, index) => data.type.unit === DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
  var getTimestampSecond = ({ values }, index) => 1e3 * epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
  var getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
  var getTimestamp = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimestampSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimestampMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimestampMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimestampNanosecond(data, index);
    }
  };
  var getTimeSecond = ({ values }, index) => values[index];
  var getTimeMillisecond = ({ values }, index) => values[index];
  var getTimeMicrosecond = ({ values }, index) => values[index];
  var getTimeNanosecond = ({ values }, index) => values[index];
  var getTime = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimeSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimeMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimeMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimeNanosecond(data, index);
    }
  };
  var getDecimal = ({ values, stride }, index) => BN.decimal(values.subarray(stride * index, stride * (index + 1)));
  var getList = (data, index) => {
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new Vector([slice]);
  };
  var getMap = (data, index) => {
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new MapRow(child.slice(begin, end - begin));
  };
  var getStruct = (data, index) => {
    return new StructRow(data, index);
  };
  var getUnion = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
  };
  var getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, data.valueOffsets[index]);
  };
  var getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, index);
  };
  var getDictionary = (data, index) => {
    var _a5;
    return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index]);
  };
  var getInterval = (data, index) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
  var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
  var getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12);
    int32s[1] = Math.trunc(interval % 12);
    return int32s;
  };
  var getFixedSizeList = (data, index) => {
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new Vector([slice]);
  };
  GetVisitor.prototype.visitNull = wrapGet(getNull);
  GetVisitor.prototype.visitBool = wrapGet(getBool);
  GetVisitor.prototype.visitInt = wrapGet(getInt);
  GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitFloat = wrapGet(getFloat);
  GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
  GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
  GetVisitor.prototype.visitBinary = wrapGet(getBinary);
  GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
  GetVisitor.prototype.visitDate = wrapGet(getDate);
  GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
  GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
  GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
  GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
  GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
  GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
  GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
  GetVisitor.prototype.visitTime = wrapGet(getTime);
  GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
  GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
  GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
  GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
  GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
  GetVisitor.prototype.visitList = wrapGet(getList);
  GetVisitor.prototype.visitStruct = wrapGet(getStruct);
  GetVisitor.prototype.visitUnion = wrapGet(getUnion);
  GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
  GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
  GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
  GetVisitor.prototype.visitInterval = wrapGet(getInterval);
  GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
  GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
  GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
  GetVisitor.prototype.visitMap = wrapGet(getMap);
  var instance2 = new GetVisitor();

  // node_modules/apache-arrow/row/map.mjs
  var kKeys = Symbol.for("keys");
  var kVals = Symbol.for("vals");
  var MapRow = class {
    constructor(slice) {
      this[kKeys] = new Vector([slice.children[0]]).memoize();
      this[kVals] = slice.children[1];
      return new Proxy(this, new MapRowProxyHandler());
    }
    [Symbol.iterator]() {
      return new MapRowIterator(this[kKeys], this[kVals]);
    }
    get size() {
      return this[kKeys].length;
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const keys = this[kKeys];
      const vals = this[kVals];
      const json = {};
      for (let i = -1, n = keys.length; ++i < n; ) {
        json[keys.get(i)] = instance2.visit(vals, i);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  };
  var MapRowIterator = class {
    constructor(keys, vals) {
      this.keys = keys;
      this.vals = vals;
      this.keyIndex = 0;
      this.numKeys = keys.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i = this.keyIndex;
      if (i === this.numKeys) {
        return { done: true, value: null };
      }
      this.keyIndex++;
      return {
        done: false,
        value: [
          this.keys.get(i),
          instance2.visit(this.vals, i)
        ]
      };
    }
  };
  var MapRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kKeys].toArray().map(String);
    }
    has(row, key) {
      return row[kKeys].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        const val = instance2.visit(Reflect.get(row, kVals), idx);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        instance.visit(Reflect.get(row, kVals), idx, val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key)) {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };
  Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [kVals]: { writable: true, enumerable: false, configurable: false, value: null }
  });

  // node_modules/apache-arrow/util/vector.mjs
  function clampIndex(source, index, then) {
    const length = source.length;
    const adjust = index > -1 ? index : length + index % length;
    return then ? then(source, adjust) : adjust;
  }
  var tmp;
  function clampRange(source, begin, end, then) {
    const { length: len = 0 } = source;
    let lhs = typeof begin !== "number" ? 0 : begin;
    let rhs = typeof end !== "number" ? len : end;
    lhs < 0 && (lhs = (lhs % len + len) % len);
    rhs < 0 && (rhs = (rhs % len + len) % len);
    rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
    rhs > len && (rhs = len);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
  }
  var isNaNFast = (value) => value !== value;
  function createElementComparator(search) {
    const typeofSearch = typeof search;
    if (typeofSearch !== "object" || search === null) {
      if (isNaNFast(search)) {
        return isNaNFast;
      }
      return (value) => value === search;
    }
    if (search instanceof Date) {
      const valueOfSearch = search.valueOf();
      return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
    }
    if (ArrayBuffer.isView(search)) {
      return (value) => value ? compareArrayLike(search, value) : false;
    }
    if (search instanceof Map) {
      return createMapComparator(search);
    }
    if (Array.isArray(search)) {
      return createArrayLikeComparator(search);
    }
    if (search instanceof Vector) {
      return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
  }
  function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs[i]);
    }
    return createSubElementsComparator(comparators);
  }
  function createMapComparator(lhs) {
    let i = -1;
    const comparators = [];
    for (const v of lhs.values())
      comparators[++i] = createElementComparator(v);
    return createSubElementsComparator(comparators);
  }
  function createVectorComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs.get(i));
    }
    return createSubElementsComparator(comparators);
  }
  function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    if (!allowEmpty && keys.length === 0) {
      return () => false;
    }
    const comparators = [];
    for (let i = -1, n = keys.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs[keys[i]]);
    }
    return createSubElementsComparator(comparators, keys);
  }
  function createSubElementsComparator(comparators, keys) {
    return (rhs) => {
      if (!rhs || typeof rhs !== "object") {
        return false;
      }
      switch (rhs.constructor) {
        case Array:
          return compareArray(comparators, rhs);
        case Map:
          return compareObject(comparators, rhs, rhs.keys());
        case MapRow:
        case StructRow:
        case Object:
        case void 0:
          return compareObject(comparators, rhs, keys || Object.keys(rhs));
      }
      return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
    };
  }
  function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
      return false;
    }
    for (let i = -1; ++i < n; ) {
      if (!comparators[i](arr[i])) {
        return false;
      }
    }
    return true;
  }
  function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
      return false;
    }
    for (let i = -1; ++i < n; ) {
      if (!comparators[i](vec.get(i))) {
        return false;
      }
    }
    return true;
  }
  function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
      if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
        break;
      }
    }
    if (i === n && lKey.done && rKey.done && rVal.done) {
      return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
  }

  // node_modules/apache-arrow/util/bit.mjs
  var bit_exports = {};
  __export(bit_exports, {
    BitIterator: () => BitIterator,
    getBit: () => getBit,
    getBool: () => getBool2,
    packBools: () => packBools,
    popcnt_array: () => popcnt_array,
    popcnt_bit_range: () => popcnt_bit_range,
    popcnt_uint32: () => popcnt_uint32,
    setBool: () => setBool2,
    truncateBitmap: () => truncateBitmap
  });
  function getBool2(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
  }
  function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
  }
  function setBool2(bytes, index, value) {
    return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
  }
  function truncateBitmap(offset, length, bitmap) {
    const alignedSize = bitmap.byteLength + 7 & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
      const bytes = new Uint8Array(alignedSize);
      bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : (
        // Otherwise iterate each bit from the offset and return a new one
        packBools(new BitIterator(bitmap, offset, length, null, getBool2)).subarray(0, alignedSize)
      ));
      return bytes;
    }
    return bitmap;
  }
  function packBools(values) {
    const xs = [];
    let i = 0, bit = 0, byte = 0;
    for (const value of values) {
      value && (byte |= 1 << bit);
      if (++bit === 8) {
        xs[i++] = byte;
        byte = bit = 0;
      }
    }
    if (i === 0 || bit > 0) {
      xs[i++] = byte;
    }
    const b = new Uint8Array(xs.length + 7 & ~7);
    b.set(xs);
    return b;
  }
  var BitIterator = class {
    constructor(bytes, begin, length, context, get) {
      this.bytes = bytes;
      this.length = length;
      this.context = context;
      this.get = get;
      this.bit = begin % 8;
      this.byteIndex = begin >> 3;
      this.byte = bytes[this.byteIndex++];
      this.index = 0;
    }
    next() {
      if (this.index < this.length) {
        if (this.bit === 8) {
          this.bit = 0;
          this.byte = this.bytes[this.byteIndex++];
        }
        return {
          value: this.get(this.context, this.index++, this.byte, this.bit++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
      return 0;
    }
    if (rhs - lhs < 8) {
      let sum2 = 0;
      for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
        sum2 += bit;
      }
      return sum2;
    }
    const rhsInside = rhs >> 3 << 3;
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return (
      // Get the popcnt of bits between the left hand side, and the next highest multiple of 8
      popcnt_bit_range(data, lhs, lhsInside) + // Get the popcnt of bits between the right hand side, and the next lowest multiple of 8
      popcnt_bit_range(data, rhsInside, rhs) + // Get the popcnt of all bits between the left and right hand sides' multiples of 8
      popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3)
    );
  }
  function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len - pos >= 4) {
      cnt += popcnt_uint32(view.getUint32(pos));
      pos += 4;
    }
    while (len - pos >= 2) {
      cnt += popcnt_uint32(view.getUint16(pos));
      pos += 2;
    }
    while (len - pos >= 1) {
      cnt += popcnt_uint32(view.getUint8(pos));
      pos += 1;
    }
    return cnt;
  }
  function popcnt_uint32(uint32) {
    let i = Math.trunc(uint32);
    i = i - (i >>> 1 & 1431655765);
    i = (i & 858993459) + (i >>> 2 & 858993459);
    return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
  }

  // node_modules/apache-arrow/data.mjs
  var kUnknownNullCount = -1;
  var Data = class _Data {
    get typeId() {
      return this.type.typeId;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get buffers() {
      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get byteLength() {
      let byteLength = 0;
      const { valueOffsets, values, nullBitmap, typeIds } = this;
      valueOffsets && (byteLength += valueOffsets.byteLength);
      values && (byteLength += values.byteLength);
      nullBitmap && (byteLength += nullBitmap.byteLength);
      typeIds && (byteLength += typeIds.byteLength);
      return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
    }
    get nullCount() {
      let nullCount = this._nullCount;
      let nullBitmap;
      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
        this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
      }
      return nullCount;
    }
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
      this.type = type;
      this.children = children;
      this.dictionary = dictionary;
      this.offset = Math.floor(Math.max(offset || 0, 0));
      this.length = Math.floor(Math.max(length || 0, 0));
      this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
      let buffer;
      if (buffers instanceof _Data) {
        this.stride = buffers.stride;
        this.values = buffers.values;
        this.typeIds = buffers.typeIds;
        this.nullBitmap = buffers.nullBitmap;
        this.valueOffsets = buffers.valueOffsets;
      } else {
        this.stride = strideForType(type);
        if (buffers) {
          (buffer = buffers[0]) && (this.valueOffsets = buffer);
          (buffer = buffers[1]) && (this.values = buffer);
          (buffer = buffers[2]) && (this.nullBitmap = buffer);
          (buffer = buffers[3]) && (this.typeIds = buffer);
        }
      }
      this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    getValid(index) {
      if (this.nullable && this.nullCount > 0) {
        const pos = this.offset + index;
        const val = this.nullBitmap[pos >> 3];
        return (val & 1 << pos % 8) !== 0;
      }
      return true;
    }
    setValid(index, value) {
      if (!this.nullable) {
        return value;
      }
      if (!this.nullBitmap || this.nullBitmap.byteLength <= index >> 3) {
        const { nullBitmap: nullBitmap2 } = this._changeLengthAndBackfillNullBitmap(this.length);
        Object.assign(this, { nullBitmap: nullBitmap2, _nullCount: 0 });
      }
      const { nullBitmap, offset } = this;
      const pos = offset + index >> 3;
      const bit = (offset + index) % 8;
      const val = nullBitmap[pos] >> bit & 1;
      value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);
      return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
      return new _Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
      const { stride, typeId, children } = this;
      const nullCount = +(this._nullCount === 0) - 1;
      const childStride = typeId === 16 ? stride : 1;
      const buffers = this._sliceBuffers(offset, length, stride, typeId);
      return this.clone(
        this.type,
        this.offset + offset,
        length,
        nullCount,
        buffers,
        // Don't slice children if we have value offsets (the variable-width types)
        children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset, childStride * length)
      );
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
      if (this.typeId === Type.Null) {
        return this.clone(this.type, 0, newLength, 0);
      }
      const { length, nullCount } = this;
      const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
      bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
      if (nullCount > 0) {
        bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);
      }
      const buffers = this.buffers;
      buffers[BufferType.VALIDITY] = bitmap;
      return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
      let arr;
      const { buffers } = this;
      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));
      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || // Otherwise if no offsets, slice the data buffer. Don't slice the data vector for Booleans, since the offset goes by bits not bytes
      (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
      return buffers;
    }
    _sliceChildren(children, offset, length) {
      return children.map((child) => child.slice(offset, length));
    }
  };
  Data.prototype.children = Object.freeze([]);
  var MakeDataVisitor = class _MakeDataVisitor extends Visitor {
    visit(props) {
      return this.getVisitFn(props["type"]).call(this, props);
    }
    visitNull(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length = 0 } = props;
      return new Data(type, offset, length, 0);
    }
    visitBool(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitInt(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitFloat(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitUtf8(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitDate(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitTimestamp(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitTime(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitDecimal(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
    visitStruct(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { length = children.reduce((len, { length: length2 }) => Math.max(len, length2), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], children);
    }
    visitUnion(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
      const { ["length"]: length = typeIds.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      if (DataType.isSparseUnion(type)) {
        return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap, typeIds], children);
      }
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children);
    }
    visitDictionary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.indices.ArrayType, props["data"]);
      const { ["dictionary"]: dictionary = new Vector([new _MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.valueType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { ["length"]: length = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], [child]);
    }
    visitMap(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new _MakeDataVisitor().visit({ type: type.childType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
  };
  function makeData(props) {
    return new MakeDataVisitor().visit(props);
  }

  // node_modules/apache-arrow/util/chunk.mjs
  var ChunkedIterator = class {
    constructor(numChunks = 0, getChunkIterator) {
      this.numChunks = numChunks;
      this.getChunkIterator = getChunkIterator;
      this.chunkIndex = 0;
      this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
      while (this.chunkIndex < this.numChunks) {
        const next = this.chunkIterator.next();
        if (!next.done) {
          return next;
        }
        if (++this.chunkIndex < this.numChunks) {
          this.chunkIterator = this.getChunkIterator(this.chunkIndex);
        }
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
  }
  function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index) => {
      offsets[index + 1] = offsets[index] + chunk.length;
      return offsets;
    }, new Uint32Array(chunks.length + 1));
  }
  function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for (let i = -1, n = chunks.length; ++i < n; ) {
      const chunk = chunks[i];
      const offset = offsets[i];
      const { length } = chunk;
      if (offset >= end) {
        break;
      }
      if (begin >= offset + length) {
        continue;
      }
      if (offset >= begin && offset + length <= end) {
        slices.push(chunk);
        continue;
      }
      const from = Math.max(0, begin - offset);
      const to = Math.min(end - offset, length);
      slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
      slices.push(chunks[0].slice(0, 0));
    }
    return slices;
  }
  function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
      if (lhs >= rhs - 1) {
        return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
      }
      mid = lhs + Math.trunc((rhs - lhs) * 0.5);
      idx < offsets[mid] ? rhs = mid : lhs = mid;
    } while (lhs < rhs);
  }
  function isChunkedValid(data, index) {
    return data.getValid(index);
  }
  function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i, j) {
      return fn(chunks[i], j);
    }
    return function(index) {
      const data = this.data;
      return binarySearch(data, this._offsets, index, chunkedFn);
    };
  }
  function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i, j) {
      return fn(chunks[i], j, _2);
    }
    return function(index, value) {
      const data = this.data;
      _2 = value;
      const result = binarySearch(data, this._offsets, index, chunkedFn);
      _2 = void 0;
      return result;
    };
  }
  function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
      let begin = fromIndex, index = 0, total = 0;
      for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {
        const chunk = data[i];
        if (~(index = indexOf(chunk, _1, begin))) {
          return total + index;
        }
        begin = 0;
        total += chunk.length;
      }
      return -1;
    }
    return function(element, offset) {
      _1 = element;
      const data = this.data;
      const result = typeof offset !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
      _1 = void 0;
      return result;
    };
  }

  // node_modules/apache-arrow/visitor/indexof.mjs
  var IndexOfVisitor = class extends Visitor {
  };
  function nullIndexOf(data, searchElement) {
    return searchElement === null && data.length > 0 ? 0 : -1;
  }
  function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
      return -1;
    }
    let i = 0;
    for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {
      if (!isValid) {
        return i;
      }
      ++i;
    }
    return -1;
  }
  function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === void 0) {
      return -1;
    }
    if (searchElement === null) {
      return indexOfNull(data, fromIndex);
    }
    const get = instance2.getVisitFn(data);
    const compare = createElementComparator(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
      if (compare(get(data, i))) {
        return i;
      }
    }
    return -1;
  }
  function indexOfUnion(data, searchElement, fromIndex) {
    const get = instance2.getVisitFn(data);
    const compare = createElementComparator(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
      if (compare(get(data, i))) {
        return i;
      }
    }
    return -1;
  }
  IndexOfVisitor.prototype.visitNull = nullIndexOf;
  IndexOfVisitor.prototype.visitBool = indexOfValue;
  IndexOfVisitor.prototype.visitInt = indexOfValue;
  IndexOfVisitor.prototype.visitInt8 = indexOfValue;
  IndexOfVisitor.prototype.visitInt16 = indexOfValue;
  IndexOfVisitor.prototype.visitInt32 = indexOfValue;
  IndexOfVisitor.prototype.visitInt64 = indexOfValue;
  IndexOfVisitor.prototype.visitUint8 = indexOfValue;
  IndexOfVisitor.prototype.visitUint16 = indexOfValue;
  IndexOfVisitor.prototype.visitUint32 = indexOfValue;
  IndexOfVisitor.prototype.visitUint64 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat = indexOfValue;
  IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
  IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
  IndexOfVisitor.prototype.visitBinary = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
  IndexOfVisitor.prototype.visitDate = indexOfValue;
  IndexOfVisitor.prototype.visitDateDay = indexOfValue;
  IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTime = indexOfValue;
  IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDecimal = indexOfValue;
  IndexOfVisitor.prototype.visitList = indexOfValue;
  IndexOfVisitor.prototype.visitStruct = indexOfValue;
  IndexOfVisitor.prototype.visitUnion = indexOfValue;
  IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitDictionary = indexOfValue;
  IndexOfVisitor.prototype.visitInterval = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
  IndexOfVisitor.prototype.visitMap = indexOfValue;
  var instance3 = new IndexOfVisitor();

  // node_modules/apache-arrow/visitor/iterator.mjs
  var IteratorVisitor = class extends Visitor {
  };
  function vectorIterator(vector) {
    const { type } = vector;
    if (vector.nullCount === 0 && vector.stride === 1 && (type.typeId === Type.Timestamp || type instanceof Int_ && type.bitWidth !== 64 || type instanceof Time_ && type.bitWidth !== 64 || type instanceof Float && type.precision !== Precision.HALF)) {
      return new ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        return data.values.subarray(0, data.length)[Symbol.iterator]();
      });
    }
    let offset = 0;
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data = vector.data[chunkIndex];
      const length = data.length;
      const inner = vector.slice(offset, offset + length);
      offset += length;
      return new VectorIterator(inner);
    });
  }
  var VectorIterator = class {
    constructor(vector) {
      this.vector = vector;
      this.index = 0;
    }
    next() {
      if (this.index < this.vector.length) {
        return {
          value: this.vector.get(this.index++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  IteratorVisitor.prototype.visitNull = vectorIterator;
  IteratorVisitor.prototype.visitBool = vectorIterator;
  IteratorVisitor.prototype.visitInt = vectorIterator;
  IteratorVisitor.prototype.visitInt8 = vectorIterator;
  IteratorVisitor.prototype.visitInt16 = vectorIterator;
  IteratorVisitor.prototype.visitInt32 = vectorIterator;
  IteratorVisitor.prototype.visitInt64 = vectorIterator;
  IteratorVisitor.prototype.visitUint8 = vectorIterator;
  IteratorVisitor.prototype.visitUint16 = vectorIterator;
  IteratorVisitor.prototype.visitUint32 = vectorIterator;
  IteratorVisitor.prototype.visitUint64 = vectorIterator;
  IteratorVisitor.prototype.visitFloat = vectorIterator;
  IteratorVisitor.prototype.visitFloat16 = vectorIterator;
  IteratorVisitor.prototype.visitFloat32 = vectorIterator;
  IteratorVisitor.prototype.visitFloat64 = vectorIterator;
  IteratorVisitor.prototype.visitUtf8 = vectorIterator;
  IteratorVisitor.prototype.visitBinary = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
  IteratorVisitor.prototype.visitDate = vectorIterator;
  IteratorVisitor.prototype.visitDateDay = vectorIterator;
  IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestamp = vectorIterator;
  IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitTime = vectorIterator;
  IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitDecimal = vectorIterator;
  IteratorVisitor.prototype.visitList = vectorIterator;
  IteratorVisitor.prototype.visitStruct = vectorIterator;
  IteratorVisitor.prototype.visitUnion = vectorIterator;
  IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
  IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
  IteratorVisitor.prototype.visitDictionary = vectorIterator;
  IteratorVisitor.prototype.visitInterval = vectorIterator;
  IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
  IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
  IteratorVisitor.prototype.visitMap = vectorIterator;
  var instance4 = new IteratorVisitor();

  // node_modules/apache-arrow/visitor/bytelength.mjs
  var sum = (x, y) => x + y;
  var GetByteLengthVisitor = class extends Visitor {
    visitNull(____, _) {
      return 0;
    }
    visitInt(data, _) {
      return data.type.bitWidth / 8;
    }
    visitFloat(data, _) {
      return data.type.ArrayType.BYTES_PER_ELEMENT;
    }
    visitBool(____, _) {
      return 1 / 8;
    }
    visitDecimal(data, _) {
      return data.type.bitWidth / 8;
    }
    visitDate(data, _) {
      return (data.type.unit + 1) * 4;
    }
    visitTime(data, _) {
      return data.type.bitWidth / 8;
    }
    visitTimestamp(data, _) {
      return data.type.unit === TimeUnit.SECOND ? 4 : 8;
    }
    visitInterval(data, _) {
      return (data.type.unit + 1) * 4;
    }
    visitStruct(data, i) {
      return data.children.reduce((total, child) => total + instance5.visit(child, i), 0);
    }
    visitFixedSizeBinary(data, _) {
      return data.type.byteWidth;
    }
    visitMap(data, i) {
      return 8 + data.children.reduce((total, child) => total + instance5.visit(child, i), 0);
    }
    visitDictionary(data, i) {
      var _a5;
      return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);
    }
  };
  var getUtf8ByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getBinaryByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getListByteLength = ({ valueOffsets, stride, children }, index) => {
    const child = children[0];
    const { [index * stride]: start } = valueOffsets;
    const { [index * stride + 1]: end } = valueOffsets;
    const visit = instance5.getVisitFn(child.type);
    const slice = child.slice(start, end - start);
    let size = 8;
    for (let idx = -1, len = end - start; ++idx < len; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getFixedSizeListByteLength = ({ stride, children }, index) => {
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    const visit = instance5.getVisitFn(child.type);
    let size = 0;
    for (let idx = -1, len = slice.length; ++idx < len; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getUnionByteLength = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index) : getSparseUnionByteLength(data, index);
  };
  var getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
    const childIndex = type.typeIdToChildIndex[typeIds[index]];
    return 8 + instance5.visit(children[childIndex], valueOffsets[index]);
  };
  var getSparseUnionByteLength = ({ children }, index) => {
    return 4 + instance5.visitMany(children, children.map(() => index)).reduce(sum, 0);
  };
  GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
  GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
  GetByteLengthVisitor.prototype.visitList = getListByteLength;
  GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
  GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
  GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
  GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
  var instance5 = new GetByteLengthVisitor();

  // node_modules/apache-arrow/vector.mjs
  var _a2;
  var visitorsByTypeId = {};
  var vectorPrototypesByTypeId = {};
  var Vector = class _Vector {
    constructor(input) {
      var _b2, _c2, _d2;
      const data = input[0] instanceof _Vector ? input.flatMap((x) => x.data) : input;
      if (data.length === 0 || data.some((x) => !(x instanceof Data))) {
        throw new TypeError("Vector constructor expects an Array of Data instances.");
      }
      const type = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
      switch (data.length) {
        case 0:
          this._offsets = [0];
          break;
        case 1: {
          const { get, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
          const unchunkedData = data[0];
          this.isValid = (index) => isChunkedValid(unchunkedData, index);
          this.get = (index) => get(unchunkedData, index);
          this.set = (index, value) => set(unchunkedData, index, value);
          this.indexOf = (index) => indexOf(unchunkedData, index);
          this.getByteLength = (index) => byteLength(unchunkedData, index);
          this._offsets = [0, unchunkedData.length];
          break;
        }
        default:
          Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
          this._offsets = computeChunkOffsets(data);
          break;
      }
      this.data = data;
      this.type = type;
      this.stride = strideForType(type);
      this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
      this.length = this._offsets[this._offsets.length - 1];
    }
    /**
     * The aggregate size (in bytes) of this Vector's buffers and/or child Vectors.
     */
    get byteLength() {
      if (this._byteLength === -1) {
        this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
      }
      return this._byteLength;
    }
    /**
     * The number of null elements in this Vector.
     */
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    /**
     * The Array or TypedAray constructor used for the JS representation
     *  of the element's values in {@link Vector.prototype.toArray `toArray()`}.
     */
    get ArrayType() {
      return this.type.ArrayType;
    }
    /**
     * The name that should be printed when the Vector is logged in a message.
     */
    get [Symbol.toStringTag]() {
      return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    /**
     * The name of this Vector.
     */
    get VectorName() {
      return `${Type[this.type.typeId]}Vector`;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) {
      return false;
    }
    /**
     * Get an element value by position.
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) {
      return null;
    }
    /**
     * Set an element value by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) {
      return;
    }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) {
      return -1;
    }
    includes(element, offset) {
      return this.indexOf(element, offset) > 0;
    }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) {
      return 0;
    }
    /**
     * Iterator for the Vector's elements.
     */
    [Symbol.iterator]() {
      return instance4.visit(this);
    }
    /**
     * Combines two or more Vectors of the same type.
     * @param others Additional Vectors to add to the end of this Vector.
     */
    concat(...others) {
      return new _Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    /**
     * Return a zero-copy sub-section of this Vector.
     * @param start The beginning of the specified portion of the Vector.
     * @param end The end of the specified portion of the Vector. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
      return new _Vector(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));
    }
    toJSON() {
      return [...this];
    }
    /**
     * Return a JavaScript Array or TypedArray of the Vector's elements.
     *
     * @note If this Vector contains a single Data chunk and the Vector's type is a
     *  primitive numeric type corresponding to one of the JavaScript TypedArrays, this
     *  method returns a zero-copy slice of the underlying TypedArray values. If there's
     *  more than one chunk, the resulting TypedArray will be a copy of the data from each
     *  chunk's underlying TypedArray values.
     *
     * @returns An Array or TypedArray of the Vector's elements, based on the Vector's DataType.
     */
    toArray() {
      const { type, data, length, stride, ArrayType } = this;
      switch (type.typeId) {
        case Type.Int:
        case Type.Float:
        case Type.Decimal:
        case Type.Time:
        case Type.Timestamp:
          switch (data.length) {
            case 0:
              return new ArrayType();
            case 1:
              return data[0].values.subarray(0, length * stride);
            default:
              return data.reduce((memo, { values, length: chunk_length }) => {
                memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                memo.offset += chunk_length * stride;
                return memo;
              }, { array: new ArrayType(length * stride), offset: 0 }).array;
          }
      }
      return [...this];
    }
    /**
     * Returns a string representation of the Vector.
     *
     * @returns A string representation of the Vector.
     */
    toString() {
      return `[${[...this].join(",")}]`;
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
      if (index > -1 && index < this.numChildren) {
        return new _Vector(this.data.map(({ children }) => children[index]));
      }
      return null;
    }
    get isMemoized() {
      if (DataType.isDictionary(this.type)) {
        return this.data[0].dictionary.isMemoized;
      }
      return false;
    }
    /**
     * Adds memoization to the Vector's {@link get} method. For dictionary
     * vectors, this method return a vector that memoizes only the dictionary
     * values.
     *
     * Memoization is very useful when decoding a value is expensive such as
     * Uft8. The memoization creates a cache of the size of the Vector and
     * therfore increases memory usage.
     *
     * @returns A new vector that memoizes calls to {@link get}.
     */
    memoize() {
      if (DataType.isDictionary(this.type)) {
        const dictionary = new MemoizedVector(this.data[0].dictionary);
        const newData = this.data.map((data) => {
          const cloned = data.clone();
          cloned.dictionary = dictionary;
          return cloned;
        });
        return new _Vector(newData);
      }
      return new MemoizedVector(this);
    }
    /**
     * Returns a vector without memoization of the {@link get} method. If this
     * vector is not memoized, this method returns this vector.
     *
     * @returns A a vector without memoization.
     */
    unmemoize() {
      if (DataType.isDictionary(this.type) && this.isMemoized) {
        const dictionary = this.data[0].dictionary.unmemoize();
        const newData = this.data.map((data) => {
          const newData2 = data.clone();
          newData2.dictionary = dictionary;
          return newData2;
        });
        return new _Vector(newData);
      }
      return this;
    }
  };
  _a2 = Symbol.toStringTag;
  Vector[_a2] = ((proto) => {
    proto.type = DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._nullCount = -1;
    proto._byteLength = -1;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === "number" && T !== Type.NONE);
    for (const typeId of typeIds) {
      const get = instance2.getVisitFnByTypeId(typeId);
      const set = instance.getVisitFnByTypeId(typeId);
      const indexOf = instance3.getVisitFnByTypeId(typeId);
      const byteLength = instance5.getVisitFnByTypeId(typeId);
      visitorsByTypeId[typeId] = { get, set, indexOf, byteLength };
      vectorPrototypesByTypeId[typeId] = Object.create(proto, {
        ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
        ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
        ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
        ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },
        ["getByteLength"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }
      });
    }
    return "Vector";
  })(Vector.prototype);
  var MemoizedVector = class _MemoizedVector extends Vector {
    constructor(vector) {
      super(vector.data);
      const get = this.get;
      const set = this.set;
      const slice = this.slice;
      const cache = new Array(this.length);
      Object.defineProperty(this, "get", {
        value(index) {
          const cachedValue = cache[index];
          if (cachedValue !== void 0) {
            return cachedValue;
          }
          const value = get.call(this, index);
          cache[index] = value;
          return value;
        }
      });
      Object.defineProperty(this, "set", {
        value(index, value) {
          set.call(this, index, value);
          cache[index] = value;
        }
      });
      Object.defineProperty(this, "slice", {
        value: (begin, end) => new _MemoizedVector(slice.call(this, begin, end))
      });
      Object.defineProperty(this, "isMemoized", { value: true });
      Object.defineProperty(this, "unmemoize", {
        value: () => new Vector(this.data)
      });
      Object.defineProperty(this, "memoize", {
        value: () => this
      });
    }
  };
  function makeVector(init) {
    if (init) {
      if (init instanceof Data) {
        return new Vector([init]);
      }
      if (init instanceof Vector) {
        return new Vector(init.data);
      }
      if (init.type instanceof DataType) {
        return new Vector([makeData(init)]);
      }
      if (Array.isArray(init)) {
        return new Vector(init.flatMap((v) => unwrapInputs(v)));
      }
      if (ArrayBuffer.isView(init)) {
        if (init instanceof DataView) {
          init = new Uint8Array(init.buffer);
        }
        const props = { offset: 0, length: init.length, nullCount: 0, data: init };
        if (init instanceof Int8Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int8() }))]);
        }
        if (init instanceof Int16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int16() }))]);
        }
        if (init instanceof Int32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int32() }))]);
        }
        if (init instanceof BigInt64ArrayCtor) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int64() }))]);
        }
        if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint8() }))]);
        }
        if (init instanceof Uint16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint16() }))]);
        }
        if (init instanceof Uint32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint32() }))]);
        }
        if (init instanceof BigUint64ArrayCtor) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint64() }))]);
        }
        if (init instanceof Float32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float32() }))]);
        }
        if (init instanceof Float64Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float64() }))]);
        }
        throw new Error("Unrecognized input");
      }
    }
    throw new Error("Unrecognized input");
  }
  function unwrapInputs(x) {
    return x instanceof Data ? [x] : x instanceof Vector ? x.data : makeVector(x).data;
  }

  // node_modules/apache-arrow/builder/valid.mjs
  function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
      return function isValid(value) {
        return true;
      };
    }
    let fnBody = "";
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
      fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
    }
    if (nullValues.length !== noNaNs.length) {
      fnBody = `if (x !== x) return false;
${fnBody}`;
    }
    return new Function(`x`, `${fnBody}
return true;`);
  }
  function valueToCase(x) {
    if (typeof x !== "bigint") {
      return valueToString(x);
    }
    return `${valueToString(x)}n`;
  }

  // node_modules/apache-arrow/builder/buffer.mjs
  var roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;
  var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
  var BufferBuilder = class {
    constructor(buffer, stride = 1) {
      this.buffer = buffer;
      this.stride = stride;
      this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
      this.ArrayType = buffer.constructor;
      this._resize(this.length = Math.ceil(buffer.length / stride));
    }
    get byteLength() {
      return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() {
      return this.buffer.length / this.stride;
    }
    get reservedByteLength() {
      return this.buffer.byteLength;
    }
    // @ts-ignore
    set(index, value) {
      return this;
    }
    append(value) {
      return this.set(this.length, value);
    }
    reserve(extra) {
      if (extra > 0) {
        this.length += extra;
        const stride = this.stride;
        const length = this.length * stride;
        const reserved = this.buffer.length;
        if (length >= reserved) {
          this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
        }
      }
      return this;
    }
    flush(length = this.length) {
      length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
      const array = sliceOrExtendArray(this.buffer, length);
      this.clear();
      return array;
    }
    clear() {
      this.length = 0;
      this._resize(0);
      return this;
    }
    _resize(newLength) {
      return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);
    }
  };
  BufferBuilder.prototype.offset = 0;
  var DataBufferBuilder = class extends BufferBuilder {
    last() {
      return this.get(this.length - 1);
    }
    get(index) {
      return this.buffer[index];
    }
    set(index, value) {
      this.reserve(index - this.length + 1);
      this.buffer[index * this.stride] = value;
      return this;
    }
  };
  var BitmapBufferBuilder = class extends DataBufferBuilder {
    constructor(data = new Uint8Array(0)) {
      super(data, 1 / 8);
      this.numValid = 0;
    }
    get numInvalid() {
      return this.length - this.numValid;
    }
    get(idx) {
      return this.buffer[idx >> 3] >> idx % 8 & 1;
    }
    set(idx, val) {
      const { buffer } = this.reserve(idx - this.length + 1);
      const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
      val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
      return this;
    }
    clear() {
      this.numValid = 0;
      return super.clear();
    }
  };
  var OffsetsBufferBuilder = class extends DataBufferBuilder {
    constructor(data = new Int32Array(1)) {
      super(data, 1);
    }
    append(value) {
      return this.set(this.length - 1, value);
    }
    set(index, value) {
      const offset = this.length - 1;
      const buffer = this.reserve(index - offset + 1).buffer;
      if (offset < index++) {
        buffer.fill(buffer[offset], offset, index);
      }
      buffer[index] = buffer[index - 1] + value;
      return this;
    }
    flush(length = this.length - 1) {
      if (length > this.length) {
        this.set(length - 1, 0);
      }
      return super.flush(length + 1);
    }
  };

  // node_modules/apache-arrow/builder.mjs
  var Builder = class {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    // @ts-ignore
    static throughDOM(options) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    /**
     * Construct a builder with the given Arrow DataType with optional null values,
     * which will be interpreted as "null" when set or appended to the `Builder`.
     * @param {{ type: T, nullValues?: any[] }} options A `BuilderOptions` object used to create this `Builder`.
     */
    constructor({ "type": type, "nullValues": nulls }) {
      this.length = 0;
      this.finished = false;
      this.type = type;
      this.children = [];
      this.nullValues = nulls;
      this.stride = strideForType(type);
      this._nulls = new BitmapBufferBuilder();
      if (nulls && nulls.length > 0) {
        this._isValid = createIsValidFunction(nulls);
      }
    }
    /**
     * Flush the `Builder` and return a `Vector<T>`.
     * @returns {Vector<T>} A `Vector<T>` of the flushed values.
     */
    toVector() {
      return new Vector([this.flush()]);
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get nullCount() {
      return this._nulls.numInvalid;
    }
    get numChildren() {
      return this.children.length;
    }
    /**
     * @returns The aggregate length (in bytes) of the values that have been written.
     */
    get byteLength() {
      let size = 0;
      const { _offsets, _values, _nulls, _typeIds, children } = this;
      _offsets && (size += _offsets.byteLength);
      _values && (size += _values.byteLength);
      _nulls && (size += _nulls.byteLength);
      _typeIds && (size += _typeIds.byteLength);
      return children.reduce((size2, child) => size2 + child.byteLength, size);
    }
    /**
     * @returns The aggregate number of rows that have been reserved to write new values.
     */
    get reservedLength() {
      return this._nulls.reservedLength;
    }
    /**
     * @returns The aggregate length (in bytes) that has been reserved to write new values.
     */
    get reservedByteLength() {
      let size = 0;
      this._offsets && (size += this._offsets.reservedByteLength);
      this._values && (size += this._values.reservedByteLength);
      this._nulls && (size += this._nulls.reservedByteLength);
      this._typeIds && (size += this._typeIds.reservedByteLength);
      return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
    }
    get valueOffsets() {
      return this._offsets ? this._offsets.buffer : null;
    }
    get values() {
      return this._values ? this._values.buffer : null;
    }
    get nullBitmap() {
      return this._nulls ? this._nulls.buffer : null;
    }
    get typeIds() {
      return this._typeIds ? this._typeIds.buffer : null;
    }
    /**
     * Appends a value (or null) to this `Builder`.
     * This is equivalent to `builder.set(builder.length, value)`.
     * @param {T['TValue'] | TNull } value The value to append.
     */
    append(value) {
      return this.set(this.length, value);
    }
    /**
     * Validates whether a value is valid (true), or null (false)
     * @param {T['TValue'] | TNull } value The value to compare against null the value representations
     */
    isValid(value) {
      return this._isValid(value);
    }
    /**
     * Write a value (or null-value sentinel) at the supplied index.
     * If the value matches one of the null-value representations, a 1-bit is
     * written to the null `BitmapBufferBuilder`. Otherwise, a 0 is written to
     * the null `BitmapBufferBuilder`, and the value is passed to
     * `Builder.prototype.setValue()`.
     * @param {number} index The index of the value to write.
     * @param {T['TValue'] | TNull } value The value to write at the supplied index.
     * @returns {this} The updated `Builder` instance.
     */
    set(index, value) {
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value);
      }
      return this;
    }
    /**
     * Write a value to the underlying buffers at the supplied index, bypassing
     * the null-value check. This is a low-level method that
     * @param {number} index
     * @param {T['TValue'] | TNull } value
     */
    setValue(index, value) {
      this._setValue(this, index, value);
    }
    setValid(index, valid) {
      this.length = this._nulls.set(index, +valid).length;
      return valid;
    }
    // @ts-ignore
    addChild(child, name = `${this.numChildren}`) {
      throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    /**
     * Retrieve the child `Builder` at the supplied `index`, or null if no child
     * exists at that index.
     * @param {number} index The index of the child `Builder` to retrieve.
     * @returns {Builder | null} The child Builder at the supplied index or null.
     */
    getChildAt(index) {
      return this.children[index] || null;
    }
    /**
     * Commit all the values that have been written to their underlying
     * ArrayBuffers, including any child Builders if applicable, and reset
     * the internal `Builder` state.
     * @returns A `Data<T>` of the buffers and children representing the values written.
     */
    flush() {
      let data;
      let typeIds;
      let nullBitmap;
      let valueOffsets;
      const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
      if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
        valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
      } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
        data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
      } else {
        data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
      }
      if (nullCount > 0) {
        nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
      }
      const children = this.children.map((child) => child.flush());
      this.clear();
      return makeData({
        type,
        length,
        nullCount,
        children,
        "child": children[0],
        data,
        typeIds,
        nullBitmap,
        valueOffsets
      });
    }
    /**
     * Finalize this `Builder`, and child builders if applicable.
     * @returns {this} The finalized `Builder` instance.
     */
    finish() {
      this.finished = true;
      for (const child of this.children)
        child.finish();
      return this;
    }
    /**
     * Clear this Builder's internal state, including child Builders if applicable, and reset the length to 0.
     * @returns {this} The cleared `Builder` instance.
     */
    clear() {
      var _a5, _b2, _c2, _d2;
      this.length = 0;
      (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();
      (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();
      (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();
      (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();
      for (const child of this.children)
        child.clear();
      return this;
    }
  };
  Builder.prototype.length = 1;
  Builder.prototype.stride = 1;
  Builder.prototype.children = null;
  Builder.prototype.finished = false;
  Builder.prototype.nullValues = null;
  Builder.prototype._isValid = () => true;
  var FixedWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);
    }
    setValue(index, value) {
      const values = this._values;
      values.reserve(index - values.length + 1);
      return super.setValue(index, value);
    }
  };
  var VariableWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._pendingLength = 0;
      this._offsets = new OffsetsBufferBuilder();
    }
    setValue(index, value) {
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.length);
      this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
      pending.set(index, value);
    }
    setValid(index, isValid) {
      if (!super.setValid(index, isValid)) {
        (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
        return false;
      }
      return true;
    }
    clear() {
      this._pendingLength = 0;
      this._pending = void 0;
      return super.clear();
    }
    flush() {
      this._flush();
      return super.flush();
    }
    finish() {
      this._flush();
      return super.finish();
    }
    _flush() {
      const pending = this._pending;
      const pendingLength = this._pendingLength;
      this._pendingLength = 0;
      this._pending = void 0;
      if (pending && pending.size > 0) {
        this._flushPending(pending, pendingLength);
      }
      return this;
    }
  };

  // node_modules/apache-arrow/fb/block.mjs
  var Block = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    /**
     * Index to the start of the RecordBlock (note this is past the Message header)
     */
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    /**
     * Length of the metadata
     */
    metaDataLength() {
      return this.bb.readInt32(this.bb_pos + 8);
    }
    /**
     * Length of the data (this is aligned so there can be a gap between this and
     * the metadata).
     */
    bodyLength() {
      return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
      return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
      builder.prep(8, 24);
      builder.writeInt64(BigInt(bodyLength !== null && bodyLength !== void 0 ? bodyLength : 0));
      builder.pad(4);
      builder.writeInt32(metaDataLength);
      builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
      return builder.offset();
    }
  };

  // node_modules/flatbuffers/mjs/constants.js
  var SIZEOF_SHORT = 2;
  var SIZEOF_INT = 4;
  var FILE_IDENTIFIER_LENGTH = 4;
  var SIZE_PREFIX_LENGTH = 4;

  // node_modules/flatbuffers/mjs/utils.js
  var int32 = new Int32Array(2);
  var float32 = new Float32Array(int32.buffer);
  var float64 = new Float64Array(int32.buffer);
  var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

  // node_modules/flatbuffers/mjs/encoding.js
  var Encoding;
  (function(Encoding2) {
    Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
  })(Encoding || (Encoding = {}));

  // node_modules/flatbuffers/mjs/byte-buffer.js
  var ByteBuffer = class _ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
      this.bytes_ = bytes_;
      this.position_ = 0;
      this.text_decoder_ = new TextDecoder();
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
      return new _ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
      this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
      return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
      return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
      this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
      return this.bytes_.length;
    }
    readInt8(offset) {
      return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
      return this.bytes_[offset];
    }
    readInt16(offset) {
      return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
      return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
      return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
      return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
      int32[0] = this.readInt32(offset);
      return float32[0];
    }
    readFloat64(offset) {
      int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
      int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return float64[0];
    }
    writeInt8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
      this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
      this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
      this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
      this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
      float32[0] = value;
      this.writeInt32(offset, int32[0]);
    }
    writeFloat64(offset, value) {
      float64[0] = value;
      this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
      if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
      }
      let result = "";
      for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
      }
      return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
      const vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
     * "optionalEncoding" argument. This is useful for avoiding conversion when
     * the data will just be packaged back up in another FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
      offset += this.readInt32(offset);
      const length = this.readInt32(offset);
      offset += SIZEOF_INT;
      const utf8bytes = this.bytes_.subarray(offset, offset + length);
      if (opt_encoding === Encoding.UTF8_BYTES)
        return utf8bytes;
      else
        return this.text_decoder_.decode(utf8bytes);
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
      if (typeof o === "string") {
        return this.__string(offset);
      }
      return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
      return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
      return offset + this.readInt32(offset) + SIZEOF_INT;
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
      if (ident.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
      const ret = [];
      for (let i = 0; i < listLength; ++i) {
        const val = listAccessor(i);
        if (val !== null) {
          ret.push(val);
        }
      }
      return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
      const ret = [];
      for (let i = 0; i < listLength; ++i) {
        const val = listAccessor(i);
        if (val !== null) {
          ret.push(val.unpack());
        }
      }
      return ret;
    }
  };

  // node_modules/flatbuffers/mjs/builder.js
  var Builder2 = class _Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
      this.text_encoder = new TextEncoder();
      let initial_size;
      if (!opt_initial_size) {
        initial_size = 1024;
      } else {
        initial_size = opt_initial_size;
      }
      this.bb = ByteBuffer.allocate(initial_size);
      this.space = initial_size;
    }
    clear() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
      this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
      return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        const old_buf_size = this.bb.capacity();
        this.bb = _Builder.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    }
    pad(byte_size) {
      for (let i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    }
    writeInt8(value) {
      this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
      this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
      this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
      this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the buffer.
     */
    addInt8(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the buffer.
     */
    addInt16(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the buffer.
     */
    addInt32(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the buffer.
     */
    addInt64(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the buffer.
     */
    addFloat32(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the buffer.
     */
    addFloat64(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    }
    addFieldInt16(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    }
    addFieldInt32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    }
    addFieldInt64(voffset, value, defaultValue) {
      if (this.force_defaults || value !== defaultValue) {
        this.addInt64(value);
        this.slot(voffset);
      }
    }
    addFieldFloat32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    }
    addFieldFloat64(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    }
    addFieldOffset(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
      if (this.vtable !== null)
        this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
      return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
      const old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      const new_buf_size = old_buf_size << 1;
      const nbb = ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
      this.prep(SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (let i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      const vtableloc = this.offset();
      let i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      const trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      const standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
      this.addInt16(len);
      let existing_vtable = 0;
      const vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          const vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
      const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        const file_identifier = opt_file_identifier;
        this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
        }
        for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
      const table_start = this.bb.capacity() - table;
      const vtable_start = table_start - this.bb.readInt32(table_start);
      const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s) {
      if (!s) {
        return 0;
      }
      if (!this.string_maps) {
        this.string_maps = /* @__PURE__ */ new Map();
      }
      if (this.string_maps.has(s)) {
        return this.string_maps.get(s);
      }
      const offset = this.createString(s);
      this.string_maps.set(s, offset);
      return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s) {
      if (s === null || s === void 0) {
        return 0;
      }
      let utf8;
      if (s instanceof Uint8Array) {
        utf8 = s;
      } else {
        utf8 = this.text_encoder.encode(s);
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
      if (obj === null) {
        return 0;
      }
      if (typeof obj === "string") {
        return this.createString(obj);
      } else {
        return obj.pack(this);
      }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
      const ret = [];
      for (let i = 0; i < list.length; ++i) {
        const val = list[i];
        if (val !== null) {
          ret.push(this.createObjectOffset(val));
        } else {
          throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
        }
      }
      return ret;
    }
    createStructOffsetList(list, startFunc) {
      startFunc(this, list.length);
      this.createObjectOffsetList(list.slice().reverse());
      return this.endVector();
    }
  };

  // node_modules/apache-arrow/fb/key-value.mjs
  var KeyValue = class _KeyValue {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsKeyValue(bb, obj) {
      return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
      builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
      builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
      builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
      _KeyValue.startKeyValue(builder);
      _KeyValue.addKey(builder, keyOffset);
      _KeyValue.addValue(builder, valueOffset);
      return _KeyValue.endKeyValue(builder);
    }
  };

  // node_modules/apache-arrow/fb/metadata-version.mjs
  var MetadataVersion2;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion2 || (MetadataVersion2 = {}));

  // node_modules/apache-arrow/fb/endianness.mjs
  var Endianness;
  (function(Endianness2) {
    Endianness2[Endianness2["Little"] = 0] = "Little";
    Endianness2[Endianness2["Big"] = 1] = "Big";
  })(Endianness || (Endianness = {}));

  // node_modules/apache-arrow/fb/dictionary-kind.mjs
  var DictionaryKind;
  (function(DictionaryKind2) {
    DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
  })(DictionaryKind || (DictionaryKind = {}));

  // node_modules/apache-arrow/fb/int.mjs
  var Int = class _Int {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsInt(bb, obj) {
      return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
      builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
      builder.addFieldInt8(1, +isSigned, 0);
    }
    static endInt(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
      _Int.startInt(builder);
      _Int.addBitWidth(builder, bitWidth);
      _Int.addIsSigned(builder, isSigned);
      return _Int.endInt(builder);
    }
  };

  // node_modules/apache-arrow/fb/dictionary-encoding.mjs
  var DictionaryEncoding = class _DictionaryEncoding {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
      return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     */
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     */
    indexType(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     */
    isOrdered() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
      builder.startObject(4);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, BigInt("0"));
    }
    static addIndexType(builder, indexTypeOffset) {
      builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
      builder.addFieldInt8(2, +isOrdered, 0);
    }
    static addDictionaryKind(builder, dictionaryKind) {
      builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // node_modules/apache-arrow/fb/binary.mjs
  var Binary2 = class _Binary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBinary(bb, obj) {
      return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
      builder.startObject(0);
    }
    static endBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBinary(builder) {
      _Binary.startBinary(builder);
      return _Binary.endBinary(builder);
    }
  };

  // node_modules/apache-arrow/fb/bool.mjs
  var Bool2 = class _Bool {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBool(bb, obj) {
      return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
      builder.startObject(0);
    }
    static endBool(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBool(builder) {
      _Bool.startBool(builder);
      return _Bool.endBool(builder);
    }
  };

  // node_modules/apache-arrow/fb/date-unit.mjs
  var DateUnit2;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit2 || (DateUnit2 = {}));

  // node_modules/apache-arrow/fb/date.mjs
  var Date2 = class _Date {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDate(bb, obj) {
      return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit2.MILLISECOND;
    }
    static startDate(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, DateUnit2.MILLISECOND);
    }
    static endDate(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDate(builder, unit) {
      _Date.startDate(builder);
      _Date.addUnit(builder, unit);
      return _Date.endDate(builder);
    }
  };

  // node_modules/apache-arrow/fb/decimal.mjs
  var Decimal2 = class _Decimal {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDecimal(bb, obj) {
      return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Total number of decimal digits
     */
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of digits after the decimal point "."
     */
    scale() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     */
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
      builder.startObject(3);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
      builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
      _Decimal.startDecimal(builder);
      _Decimal.addPrecision(builder, precision);
      _Decimal.addScale(builder, scale);
      _Decimal.addBitWidth(builder, bitWidth);
      return _Decimal.endDecimal(builder);
    }
  };

  // node_modules/apache-arrow/fb/time-unit.mjs
  var TimeUnit2;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit2 || (TimeUnit2 = {}));

  // node_modules/apache-arrow/fb/fixed-size-binary.mjs
  var FixedSizeBinary2 = class _FixedSizeBinary {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
      return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of bytes per value
     */
    byteWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
      builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
      builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
      _FixedSizeBinary.startFixedSizeBinary(builder);
      _FixedSizeBinary.addByteWidth(builder, byteWidth);
      return _FixedSizeBinary.endFixedSizeBinary(builder);
    }
  };

  // node_modules/apache-arrow/fb/fixed-size-list.mjs
  var FixedSizeList2 = class _FixedSizeList {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
      return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Number of list items per value
     */
    listSize() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
      builder.startObject(1);
    }
    static addListSize(builder, listSize) {
      builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeList(builder, listSize) {
      _FixedSizeList.startFixedSizeList(builder);
      _FixedSizeList.addListSize(builder, listSize);
      return _FixedSizeList.endFixedSizeList(builder);
    }
  };

  // node_modules/apache-arrow/fb/precision.mjs
  var Precision2;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision2 || (Precision2 = {}));

  // node_modules/apache-arrow/fb/floating-point.mjs
  var FloatingPoint = class _FloatingPoint {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
      return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision2.HALF;
    }
    static startFloatingPoint(builder) {
      builder.startObject(1);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt16(0, precision, Precision2.HALF);
    }
    static endFloatingPoint(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFloatingPoint(builder, precision) {
      _FloatingPoint.startFloatingPoint(builder);
      _FloatingPoint.addPrecision(builder, precision);
      return _FloatingPoint.endFloatingPoint(builder);
    }
  };

  // node_modules/apache-arrow/fb/interval-unit.mjs
  var IntervalUnit2;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit2 || (IntervalUnit2 = {}));

  // node_modules/apache-arrow/fb/interval.mjs
  var Interval = class _Interval {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsInterval(bb, obj) {
      return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit2.YEAR_MONTH;
    }
    static startInterval(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, IntervalUnit2.YEAR_MONTH);
    }
    static endInterval(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInterval(builder, unit) {
      _Interval.startInterval(builder);
      _Interval.addUnit(builder, unit);
      return _Interval.endInterval(builder);
    }
  };

  // node_modules/apache-arrow/fb/list.mjs
  var List2 = class _List {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsList(bb, obj) {
      return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
      builder.startObject(0);
    }
    static endList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createList(builder) {
      _List.startList(builder);
      return _List.endList(builder);
    }
  };

  // node_modules/apache-arrow/fb/map.mjs
  var Map2 = class _Map {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsMap(bb, obj) {
      return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Set to true if the keys within each value are sorted
     */
    keysSorted() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
      builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
      builder.addFieldInt8(0, +keysSorted, 0);
    }
    static endMap(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createMap(builder, keysSorted) {
      _Map.startMap(builder);
      _Map.addKeysSorted(builder, keysSorted);
      return _Map.endMap(builder);
    }
  };

  // node_modules/apache-arrow/fb/null.mjs
  var Null2 = class _Null {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsNull(bb, obj) {
      return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
      builder.startObject(0);
    }
    static endNull(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createNull(builder) {
      _Null.startNull(builder);
      return _Null.endNull(builder);
    }
  };

  // node_modules/apache-arrow/fb/struct-.mjs
  var Struct_ = class _Struct_ {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsStruct_(bb, obj) {
      return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
      builder.startObject(0);
    }
    static endStruct_(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createStruct_(builder) {
      _Struct_.startStruct_(builder);
      return _Struct_.endStruct_(builder);
    }
  };

  // node_modules/apache-arrow/fb/time.mjs
  var Time = class _Time {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsTime(bb, obj) {
      return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.MILLISECOND;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTime(builder, unit, bitWidth) {
      _Time.startTime(builder);
      _Time.addUnit(builder, unit);
      _Time.addBitWidth(builder, bitWidth);
      return _Time.endTime(builder);
    }
  };

  // node_modules/apache-arrow/fb/timestamp.mjs
  var Timestamp = class _Timestamp {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsTimestamp(bb, obj) {
      return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.SECOND;
    }
    timezone(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
      builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
      _Timestamp.startTimestamp(builder);
      _Timestamp.addUnit(builder, unit);
      _Timestamp.addTimezone(builder, timezoneOffset);
      return _Timestamp.endTimestamp(builder);
    }
  };

  // node_modules/apache-arrow/fb/union-mode.mjs
  var UnionMode2;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode2 || (UnionMode2 = {}));

  // node_modules/apache-arrow/fb/union.mjs
  var Union = class _Union {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsUnion(bb, obj) {
      return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode2.Sparse;
    }
    typeIds(index) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
      builder.startObject(2);
    }
    static addMode(builder, mode) {
      builder.addFieldInt16(0, mode, UnionMode2.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
      builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt32(data[i]);
      }
      return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
      _Union.startUnion(builder);
      _Union.addMode(builder, mode);
      _Union.addTypeIds(builder, typeIdsOffset);
      return _Union.endUnion(builder);
    }
  };

  // node_modules/apache-arrow/fb/utf8.mjs
  var Utf82 = class _Utf8 {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsUtf8(bb, obj) {
      return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
      builder.startObject(0);
    }
    static endUtf8(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUtf8(builder) {
      _Utf8.startUtf8(builder);
      return _Utf8.endUtf8(builder);
    }
  };

  // node_modules/apache-arrow/fb/type.mjs
  var Type2;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct_"] = 13] = "Struct_";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Duration"] = 18] = "Duration";
    Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
    Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
    Type3[Type3["LargeList"] = 21] = "LargeList";
    Type3[Type3["RunEndEncoded"] = 22] = "RunEndEncoded";
  })(Type2 || (Type2 = {}));

  // node_modules/apache-arrow/fb/field.mjs
  var Field = class _Field {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsField(bb, obj) {
      return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     */
    nullable() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : Type2.NONE;
    }
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     */
    type(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    /**
     * Present only if the field is dictionary encoded.
     */
    dictionary(obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     */
    children(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? (obj || new _Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
      builder.startObject(7);
    }
    static addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
      builder.addFieldInt8(1, +nullable, 0);
    }
    static addTypeType(builder, typeType) {
      builder.addFieldInt8(2, typeType, Type2.NONE);
    }
    static addType(builder, typeOffset) {
      builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
      builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
      builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // node_modules/apache-arrow/fb/schema.mjs
  var Schema = class _Schema {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsSchema(bb, obj) {
      return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     */
    endianness() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;
    }
    fields(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Features used in the stream/file.
     */
    features(index) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
    featuresLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
      builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
      builder.addFieldInt16(0, endianness, Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
      builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
      builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt64(data[i]);
      }
      return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishSchemaBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
      _Schema.startSchema(builder);
      _Schema.addEndianness(builder, endianness);
      _Schema.addFields(builder, fieldsOffset);
      _Schema.addCustomMetadata(builder, customMetadataOffset);
      _Schema.addFeatures(builder, featuresOffset);
      return _Schema.endSchema(builder);
    }
  };

  // node_modules/apache-arrow/fb/footer.mjs
  var Footer = class _Footer {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFooter(bb, obj) {
      return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    schema(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * User-defined metadata
     */
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addSchema(builder, schemaOffset) {
      builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
      builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
      builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishFooterBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
  };

  // node_modules/apache-arrow/schema.mjs
  var Schema2 = class _Schema {
    constructor(fields = [], metadata, dictionaries) {
      this.fields = fields || [];
      this.metadata = metadata || /* @__PURE__ */ new Map();
      if (!dictionaries) {
        dictionaries = generateDictionaryMap(fields);
      }
      this.dictionaries = dictionaries;
    }
    get [Symbol.toStringTag]() {
      return "Schema";
    }
    get names() {
      return this.fields.map((f) => f.name);
    }
    toString() {
      return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
    }
    /**
     * Construct a new Schema containing only specified fields.
     *
     * @param fieldNames Names of fields to keep.
     * @returns A new Schema of fields matching the specified names.
     */
    select(fieldNames) {
      const names = new Set(fieldNames);
      const fields = this.fields.filter((f) => names.has(f.name));
      return new _Schema(fields, this.metadata);
    }
    /**
     * Construct a new Schema containing only fields at the specified indices.
     *
     * @param fieldIndices Indices of fields to keep.
     * @returns A new Schema of fields at the specified indices.
     */
    selectAt(fieldIndices) {
      const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
      return new _Schema(fields, this.metadata);
    }
    assign(...args) {
      const other = args[0] instanceof _Schema ? args[0] : Array.isArray(args[0]) ? new _Schema(args[0]) : new _Schema(args);
      const curFields = [...this.fields];
      const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
      const newFields = other.fields.filter((f2) => {
        const i = curFields.findIndex((f) => f.name === f2.name);
        return ~i ? (curFields[i] = f2.clone({
          metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
        })) && false : true;
      });
      const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
      return new _Schema([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
  };
  Schema2.prototype.fields = null;
  Schema2.prototype.metadata = null;
  Schema2.prototype.dictionaries = null;
  var Field2 = class _Field {
    /** @nocollapse */
    static new(...args) {
      let [name, type, nullable, metadata] = args;
      if (args[0] && typeof args[0] === "object") {
        ({ name } = args[0]);
        type === void 0 && (type = args[0].type);
        nullable === void 0 && (nullable = args[0].nullable);
        metadata === void 0 && (metadata = args[0].metadata);
      }
      return new _Field(`${name}`, type, nullable, metadata);
    }
    constructor(name, type, nullable = false, metadata) {
      this.name = name;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata || /* @__PURE__ */ new Map();
    }
    get typeId() {
      return this.type.typeId;
    }
    get [Symbol.toStringTag]() {
      return "Field";
    }
    toString() {
      return `${this.name}: ${this.type}`;
    }
    clone(...args) {
      let [name, type, nullable, metadata] = args;
      !args[0] || typeof args[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
      return _Field.new(name, type, nullable, metadata);
    }
  };
  Field2.prototype.type = null;
  Field2.prototype.name = null;
  Field2.prototype.nullable = null;
  Field2.prototype.metadata = null;
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }
  function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const field = fields[i];
      const type = field.type;
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          dictionaries.set(type.id, type.dictionary);
        } else if (dictionaries.get(type.id) !== type.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        generateDictionaryMap(type.children, dictionaries);
      }
    }
    return dictionaries;
  }

  // node_modules/apache-arrow/ipc/metadata/file.mjs
  var Builder3 = Builder2;
  var ByteBuffer2 = ByteBuffer;
  var Footer_ = class {
    /** @nocollapse */
    static decode(buf) {
      buf = new ByteBuffer2(toUint8Array(buf));
      const footer = Footer.getRootAsFooter(buf);
      const schema = Schema2.decode(footer.schema());
      return new OffHeapFooter(schema, footer);
    }
    /** @nocollapse */
    static encode(footer) {
      const b = new Builder3();
      const schemaOffset = Schema2.encode(b, footer.schema);
      Footer.startRecordBatchesVector(b, footer.numRecordBatches);
      for (const rb of [...footer.recordBatches()].slice().reverse()) {
        FileBlock.encode(b, rb);
      }
      const recordBatchesOffset = b.endVector();
      Footer.startDictionariesVector(b, footer.numDictionaries);
      for (const db2 of [...footer.dictionaryBatches()].slice().reverse()) {
        FileBlock.encode(b, db2);
      }
      const dictionaryBatchesOffset = b.endVector();
      Footer.startFooter(b);
      Footer.addSchema(b, schemaOffset);
      Footer.addVersion(b, MetadataVersion.V4);
      Footer.addRecordBatches(b, recordBatchesOffset);
      Footer.addDictionaries(b, dictionaryBatchesOffset);
      Footer.finishFooterBuffer(b, Footer.endFooter(b));
      return b.asUint8Array();
    }
    get numRecordBatches() {
      return this._recordBatches.length;
    }
    get numDictionaries() {
      return this._dictionaryBatches.length;
    }
    constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {
      this.schema = schema;
      this.version = version;
      recordBatches && (this._recordBatches = recordBatches);
      dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    *recordBatches() {
      for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
        if (block = this.getRecordBatch(i)) {
          yield block;
        }
      }
    }
    *dictionaryBatches() {
      for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
        if (block = this.getDictionaryBatch(i)) {
          yield block;
        }
      }
    }
    getRecordBatch(index) {
      return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
      return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
    }
  };
  var OffHeapFooter = class extends Footer_ {
    get numRecordBatches() {
      return this._footer.recordBatchesLength();
    }
    get numDictionaries() {
      return this._footer.dictionariesLength();
    }
    constructor(schema, _footer) {
      super(schema, _footer.version());
      this._footer = _footer;
    }
    getRecordBatch(index) {
      if (index >= 0 && index < this.numRecordBatches) {
        const fileBlock = this._footer.recordBatches(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
    getDictionaryBatch(index) {
      if (index >= 0 && index < this.numDictionaries) {
        const fileBlock = this._footer.dictionaries(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
  };
  var FileBlock = class _FileBlock {
    /** @nocollapse */
    static decode(block) {
      return new _FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    /** @nocollapse */
    static encode(b, fileBlock) {
      const { metaDataLength } = fileBlock;
      const offset = BigInt(fileBlock.offset);
      const bodyLength = BigInt(fileBlock.bodyLength);
      return Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
    constructor(metaDataLength, bodyLength, offset) {
      this.metaDataLength = metaDataLength;
      this.offset = bigIntToNumber(offset);
      this.bodyLength = bigIntToNumber(bodyLength);
    }
  };

  // node_modules/apache-arrow/io/interfaces.mjs
  var ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
  var ArrowJSON = class {
    constructor(_json) {
      this._json = _json;
    }
    get schema() {
      return this._json["schema"];
    }
    get batches() {
      return this._json["batches"] || [];
    }
    get dictionaries() {
      return this._json["dictionaries"] || [];
    }
  };
  var ReadableInterop = class {
    tee() {
      return this._getDOMStream().tee();
    }
    pipe(writable, options) {
      return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) {
      return this._getDOMStream().pipeTo(writable, options);
    }
    pipeThrough(duplex, options) {
      return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
      return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
      return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
  };
  var AsyncQueue = class extends ReadableInterop {
    constructor() {
      super();
      this._values = [];
      this.resolvers = [];
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() {
      return this._closedPromise;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    write(value) {
      if (this._ensureOpen()) {
        this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
      }
    }
    abort(value) {
      if (this._closedPromiseResolve) {
        this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
      }
    }
    close() {
      if (this._closedPromiseResolve) {
        const { resolvers } = this;
        while (resolvers.length > 0) {
          resolvers.shift().resolve(ITERATOR_DONE);
        }
        this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    toDOMStream(options) {
      return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    toNodeStream(options) {
      return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    throw(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.abort(_);
        return ITERATOR_DONE;
      });
    }
    return(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return ITERATOR_DONE;
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(..._args) {
      if (this._values.length > 0) {
        return Promise.resolve({ done: false, value: this._values.shift() });
      } else if (this._error) {
        return Promise.reject({ done: true, value: this._error.error });
      } else if (!this._closedPromiseResolve) {
        return Promise.resolve(ITERATOR_DONE);
      } else {
        return new Promise((resolve, reject) => {
          this.resolvers.push({ resolve, reject });
        });
      }
    }
    _ensureOpen() {
      if (this._closedPromiseResolve) {
        return true;
      }
      throw new Error(`AsyncQueue is closed`);
    }
  };

  // node_modules/apache-arrow/io/stream.mjs
  var AsyncByteQueue = class extends AsyncQueue {
    write(value) {
      if ((value = toUint8Array(value)).byteLength > 0) {
        return super.write(value);
      }
    }
    toString(sync = false) {
      return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
    }
    toUint8Array(sync = false) {
      return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
        var _a5, e_1, _b2, _c2;
        const buffers = [];
        let byteLength = 0;
        try {
          for (var _d2 = true, _e2 = __asyncValues(this), _f2; _f2 = yield _e2.next(), _a5 = _f2.done, !_a5; ) {
            _c2 = _f2.value;
            _d2 = false;
            try {
              const chunk = _c2;
              buffers.push(chunk);
              byteLength += chunk.byteLength;
            } finally {
              _d2 = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a5 && (_b2 = _e2.return))
              yield _b2.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return joinUint8Arrays(buffers, byteLength)[0];
      }))();
    }
  };
  var ByteStream = class {
    constructor(source) {
      if (source) {
        this.source = new ByteStreamSource(adapters_default.fromIterable(source));
      }
    }
    [Symbol.iterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var AsyncByteStream = class _AsyncByteStream {
    constructor(source) {
      if (source instanceof _AsyncByteStream) {
        this.source = source.source;
      } else if (source instanceof AsyncByteQueue) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isReadableNodeStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
      } else if (isReadableDOMStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
      } else if (isFetchResponse(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
      } else if (isIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
      } else if (isPromise(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isAsyncIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    get closed() {
      return this.source.closed;
    }
    cancel(reason) {
      return this.source.cancel(reason);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var ByteStreamSource = class {
    constructor(source) {
      this.source = source;
    }
    cancel(reason) {
      this.return(reason);
    }
    peek(size) {
      return this.next(size, "peek").value;
    }
    read(size) {
      return this.next(size, "read").value;
    }
    next(size, cmd = "read") {
      return this.source.next({ cmd, size });
    }
    throw(value) {
      return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
    }
    return(value) {
      return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
    }
  };
  var AsyncByteStreamSource = class {
    constructor(source) {
      this.source = source;
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    get closed() {
      return this._closedPromise;
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(size, cmd = "read") {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.next({ cmd, size });
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
  };

  // node_modules/apache-arrow/io/file.mjs
  var RandomAccessFile = class extends ByteStream {
    constructor(buffer, byteLength) {
      super();
      this.position = 0;
      this.buffer = toUint8Array(buffer);
      this.size = byteLength === void 0 ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
      const { buffer, byteOffset } = this.readAt(position, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
      this.position = Math.min(position, this.size);
      return position < this.size;
    }
    read(nBytes) {
      const { buffer, size, position } = this;
      if (buffer && position < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        this.position = Math.min(size, position + Math.min(size - position, nBytes));
        return buffer.subarray(position, this.position);
      }
      return null;
    }
    readAt(position, nBytes) {
      const buf = this.buffer;
      const end = Math.min(this.size, position + nBytes);
      return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() {
      this.buffer && (this.buffer = null);
    }
    throw(value) {
      this.close();
      return { done: true, value };
    }
    return(value) {
      this.close();
      return { done: true, value };
    }
  };
  var AsyncRandomAccessFile = class extends AsyncByteStream {
    constructor(file, byteLength) {
      super();
      this.position = 0;
      this._handle = file;
      if (typeof byteLength === "number") {
        this.size = byteLength;
      } else {
        this._pending = (() => __awaiter(this, void 0, void 0, function* () {
          this.size = (yield file.stat()).size;
          delete this._pending;
        }))();
      }
    }
    readInt32(position) {
      return __awaiter(this, void 0, void 0, function* () {
        const { buffer, byteOffset } = yield this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      });
    }
    seek(position) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        this.position = Math.min(position, this.size);
        return position < this.size;
      });
    }
    read(nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size, position } = this;
        if (file && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Number.POSITIVE_INFINITY;
          }
          let pos = position, offset = 0, bytesRead = 0;
          const end = Math.min(size, pos + Math.min(size - pos, nBytes));
          const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
          while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
            ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
          }
          return buffer;
        }
        return null;
      });
    }
    readAt(position, nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size } = this;
        if (file && position + nBytes < size) {
          const end = Math.min(size, position + nBytes);
          const buffer = new Uint8Array(end - position);
          return (yield file.read(buffer, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const f = this._handle;
        this._handle = null;
        f && (yield f.close());
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
  };

  // node_modules/apache-arrow/util/int.mjs
  var int_exports = {};
  __export(int_exports, {
    BaseInt64: () => BaseInt64,
    Int128: () => Int128,
    Int64: () => Int642,
    Uint64: () => Uint642
  });
  var carryBit16 = 1 << 16;
  function intAsHex(value) {
    if (value < 0) {
      value = 4294967295 + value + 1;
    }
    return `0x${value.toString(16)}`;
  }
  var kInt32DecimalDigits = 8;
  var kPowersOfTen = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8
  ];
  var BaseInt64 = class {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return this.buffer[1];
    }
    low() {
      return this.buffer[0];
    }
    _times(other) {
      const L = new Uint32Array([
        this.buffer[1] >>> 16,
        this.buffer[1] & 65535,
        this.buffer[0] >>> 16,
        this.buffer[0] & 65535
      ]);
      const R = new Uint32Array([
        other.buffer[1] >>> 16,
        other.buffer[1] & 65535,
        other.buffer[0] >>> 16,
        other.buffer[0] & 65535
      ]);
      let product = L[3] * R[3];
      this.buffer[0] = product & 65535;
      let sum2 = product >>> 16;
      product = L[2] * R[3];
      sum2 += product;
      product = L[3] * R[2] >>> 0;
      sum2 += product;
      this.buffer[0] += sum2 << 16;
      this.buffer[1] = sum2 >>> 0 < product ? carryBit16 : 0;
      this.buffer[1] += sum2 >>> 16;
      this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
      this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
      return this;
    }
    _plus(other) {
      const sum2 = this.buffer[0] + other.buffer[0] >>> 0;
      this.buffer[1] += other.buffer[1];
      if (sum2 < this.buffer[0] >>> 0) {
        ++this.buffer[1];
      }
      this.buffer[0] = sum2;
    }
    lessThan(other) {
      return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
    }
    equals(other) {
      return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
      return other.lessThan(this);
    }
    hex() {
      return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
  };
  var Uint642 = class _Uint64 extends BaseInt64 {
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
      return _Uint64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return _Uint64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const length = str.length;
      const out = new _Uint64(out_buffer);
      for (let posn = 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new _Uint64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new _Uint64(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return out;
    }
    /** @nocollapse */
    static convertArray(values) {
      const data = new Uint32Array(values.length * 2);
      for (let i = -1, n = values.length; ++i < n; ) {
        _Uint64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
      }
      return data;
    }
    /** @nocollapse */
    static multiply(left, right) {
      const rtrn = new _Uint64(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
      const rtrn = new _Uint64(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int642 = class _Int64 extends BaseInt64 {
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      return this;
    }
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    lessThan(other) {
      const this_high = this.buffer[1] << 0;
      const other_high = other.buffer[1] << 0;
      return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(2)) {
      return _Int64.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return _Int64.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out = new _Int64(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new _Int64(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new _Int64(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return negate ? out.negate() : out;
    }
    /** @nocollapse */
    static convertArray(values) {
      const data = new Uint32Array(values.length * 2);
      for (let i = -1, n = values.length; ++i < n; ) {
        _Int64.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
      }
      return data;
    }
    /** @nocollapse */
    static multiply(left, right) {
      const rtrn = new _Int64(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
      const rtrn = new _Int64(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int128 = class _Int128 {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      this.buffer[2] = ~this.buffer[2];
      this.buffer[3] = ~this.buffer[3];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      if (this.buffer[1] == 0) {
        ++this.buffer[2];
      }
      if (this.buffer[2] == 0) {
        ++this.buffer[3];
      }
      return this;
    }
    times(other) {
      const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
      const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
      const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
      const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
      const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
      const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
      const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
      const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
      let product = Uint642.multiply(L3, R3);
      this.buffer[0] = product.low();
      const sum2 = new Uint642(new Uint32Array([product.high(), 0]));
      product = Uint642.multiply(L2, R3);
      sum2.plus(product);
      product = Uint642.multiply(L3, R2);
      sum2.plus(product);
      this.buffer[1] = sum2.low();
      this.buffer[3] = sum2.lessThan(product) ? 1 : 0;
      this.buffer[2] = sum2.high();
      const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
      this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
      return this;
    }
    plus(other) {
      const sums = new Uint32Array(4);
      sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
      sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
      sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
      sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
      if (sums[0] < this.buffer[0] >>> 0) {
        ++sums[1];
      }
      if (sums[1] < this.buffer[1] >>> 0) {
        ++sums[2];
      }
      if (sums[2] < this.buffer[2] >>> 0) {
        ++sums[3];
      }
      this.buffer[3] = sums[3];
      this.buffer[2] = sums[2];
      this.buffer[1] = sums[1];
      this.buffer[0] = sums[0];
      return this;
    }
    hex() {
      return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    /** @nocollapse */
    static multiply(left, right) {
      const rtrn = new _Int128(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    /** @nocollapse */
    static add(left, right) {
      const rtrn = new _Int128(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
    /** @nocollapse */
    static from(val, out_buffer = new Uint32Array(4)) {
      return _Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
      return _Int128.fromString(num.toString(), out_buffer);
    }
    /** @nocollapse */
    static fromString(str, out_buffer = new Uint32Array(4)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out = new _Int128(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new _Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
        const multiple = new _Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return negate ? out.negate() : out;
    }
    /** @nocollapse */
    static convertArray(values) {
      const data = new Uint32Array(values.length * 4);
      for (let i = -1, n = values.length; ++i < n; ) {
        _Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
      }
      return data;
    }
  };

  // node_modules/apache-arrow/visitor/vectorloader.mjs
  var VectorLoader = class extends Visitor {
    constructor(bytes, nodes, buffers, dictionaries) {
      super();
      this.nodesIndex = -1;
      this.buffersIndex = -1;
      this.bytes = bytes;
      this.nodes = nodes;
      this.buffers = buffers;
      this.dictionaries = dictionaries;
    }
    visit(node) {
      return super.visit(node instanceof Field2 ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
      return makeData({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type) {
      return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type) : this.visitDenseUnion(type);
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), "child": this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    nextFieldNode() {
      return this.nodes[++this.nodesIndex];
    }
    nextBufferRange() {
      return this.buffers[++this.buffersIndex];
    }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
      return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) {
      return this.readData(type, buffer);
    }
    readTypeIds(type, buffer) {
      return this.readData(type, buffer);
    }
    readData(_type, { length, offset } = this.nextBufferRange()) {
      return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
      return this.dictionaries.get(type.id);
    }
  };
  var JSONVectorLoader = class extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries) {
      super(new Uint8Array(0), nodes, buffers, dictionaries);
      this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
      return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
      const { sources } = this;
      if (DataType.isTimestamp(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDecimal(type)) {
        return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));
      } else if (DataType.isBinary(type) || DataType.isFixedSizeBinary(type)) {
        return binaryDataFromJSON(sources[offset]);
      } else if (DataType.isBool(type)) {
        return packBools(sources[offset]);
      } else if (DataType.isUtf8(type)) {
        return encodeUtf8(sources[offset].join(""));
      }
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
    }
  };
  function binaryDataFromJSON(values) {
    const joined = values.join("");
    const data = new Uint8Array(joined.length / 2);
    for (let i = 0; i < joined.length; i += 2) {
      data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
  }

  // node_modules/apache-arrow/builder/binary.mjs
  var BinaryBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, toUint8Array(value));
    }
    _flushPending(pending, pendingLength) {
      const offsets = this._offsets;
      const data = this._values.reserve(pendingLength).buffer;
      let offset = 0;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          const length = value.length;
          data.set(value, offset);
          offsets.set(index, length);
          offset += length;
        }
      }
    }
  };

  // node_modules/apache-arrow/builder/bool.mjs
  var BoolBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._values = new BitmapBufferBuilder();
    }
    setValue(index, value) {
      this._values.set(index, +value);
    }
  };

  // node_modules/apache-arrow/builder/date.mjs
  var DateBuilder = class extends FixedWidthBuilder {
  };
  DateBuilder.prototype._setValue = setDate;
  var DateDayBuilder = class extends DateBuilder {
  };
  DateDayBuilder.prototype._setValue = setDateDay;
  var DateMillisecondBuilder = class extends DateBuilder {
  };
  DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

  // node_modules/apache-arrow/builder/decimal.mjs
  var DecimalBuilder = class extends FixedWidthBuilder {
  };
  DecimalBuilder.prototype._setValue = setDecimal;

  // node_modules/apache-arrow/builder/dictionary.mjs
  var DictionaryBuilder = class extends Builder {
    constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
      super({ type: new Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
      this._nulls = null;
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      this.indices = makeBuilder({ "type": this.type.indices, "nullValues": nulls });
      this.dictionary = makeBuilder({ "type": this.type.dictionary, "nullValues": null });
      if (typeof hashFn === "function") {
        this.valueToKey = hashFn;
      }
    }
    get values() {
      return this.indices.values;
    }
    get nullCount() {
      return this.indices.nullCount;
    }
    get nullBitmap() {
      return this.indices.nullBitmap;
    }
    get byteLength() {
      return this.indices.byteLength + this.dictionary.byteLength;
    }
    get reservedLength() {
      return this.indices.reservedLength + this.dictionary.reservedLength;
    }
    get reservedByteLength() {
      return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
    }
    isValid(value) {
      return this.indices.isValid(value);
    }
    setValid(index, valid) {
      const indices = this.indices;
      valid = indices.setValid(index, valid);
      this.length = indices.length;
      return valid;
    }
    setValue(index, value) {
      const keysToIndices = this._keysToIndices;
      const key = this.valueToKey(value);
      let idx = keysToIndices[key];
      if (idx === void 0) {
        keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
      }
      return this.indices.setValue(index, idx);
    }
    flush() {
      const type = this.type;
      const prev = this._dictionary;
      const curr = this.dictionary.toVector();
      const data = this.indices.flush().clone(type);
      data.dictionary = prev ? prev.concat(curr) : curr;
      this.finished || (this._dictionaryOffset += curr.length);
      this._dictionary = data.dictionary;
      this.clear();
      return data;
    }
    finish() {
      this.indices.finish();
      this.dictionary.finish();
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      return super.finish();
    }
    clear() {
      this.indices.clear();
      this.dictionary.clear();
      return super.clear();
    }
    valueToKey(val) {
      return typeof val === "string" ? val : `${val}`;
    }
  };

  // node_modules/apache-arrow/builder/fixedsizebinary.mjs
  var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {
  };
  FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

  // node_modules/apache-arrow/builder/fixedsizelist.mjs
  var FixedSizeListBuilder = class extends Builder {
    setValue(index, value) {
      const [child] = this.children;
      const start = index * this.stride;
      for (let i = -1, n = value.length; ++i < n; ) {
        child.set(start + i, value[i]);
      }
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("FixedSizeListBuilder can only have one child.");
      }
      const childIndex = this.children.push(child);
      this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));
      return childIndex;
    }
  };

  // node_modules/apache-arrow/builder/float.mjs
  var FloatBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Float16Builder = class extends FloatBuilder {
    setValue(index, value) {
      super.setValue(index, float64ToUint16(value));
    }
  };
  var Float32Builder = class extends FloatBuilder {
  };
  var Float64Builder = class extends FloatBuilder {
  };

  // node_modules/apache-arrow/builder/interval.mjs
  var IntervalBuilder = class extends FixedWidthBuilder {
  };
  IntervalBuilder.prototype._setValue = setIntervalValue;
  var IntervalDayTimeBuilder = class extends IntervalBuilder {
  };
  IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
  var IntervalYearMonthBuilder = class extends IntervalBuilder {
  };
  IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

  // node_modules/apache-arrow/builder/int.mjs
  var IntBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Int8Builder = class extends IntBuilder {
  };
  var Int16Builder = class extends IntBuilder {
  };
  var Int32Builder = class extends IntBuilder {
  };
  var Int64Builder = class extends IntBuilder {
  };
  var Uint8Builder = class extends IntBuilder {
  };
  var Uint16Builder = class extends IntBuilder {
  };
  var Uint32Builder = class extends IntBuilder {
  };
  var Uint64Builder = class extends IntBuilder {
  };

  // node_modules/apache-arrow/builder/list.mjs
  var ListBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._offsets = new OffsetsBufferBuilder();
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new List(new Field2(name, child.type, true));
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (typeof value === "undefined") {
          offsets.set(index, 0);
        } else {
          const n = value.length;
          const start = offsets.set(index, n).buffer[index];
          for (let i = -1; ++i < n; ) {
            child.set(start + i, value[i]);
          }
        }
      }
    }
  };

  // node_modules/apache-arrow/builder/map.mjs
  var MapBuilder = class extends VariableWidthBuilder {
    set(index, value) {
      return super.set(index, value);
    }
    setValue(index, value) {
      const row = value instanceof Map ? value : new Map(Object.entries(value));
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.size);
      this._pendingLength += row.size;
      pending.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
          for (const val of value.entries()) {
            child.set(idx, val);
            if (++idx >= end)
              break;
          }
        }
      }
    }
  };

  // node_modules/apache-arrow/builder/null.mjs
  var NullBuilder = class extends Builder {
    // @ts-ignore
    setValue(index, value) {
    }
    setValid(index, valid) {
      this.length = Math.max(index + 1, this.length);
      return valid;
    }
  };

  // node_modules/apache-arrow/builder/struct.mjs
  var StructBuilder = class extends Builder {
    setValue(index, value) {
      const { children, type } = this;
      switch (Array.isArray(value) || value.constructor) {
        case true:
          return type.children.forEach((_, i) => children[i].set(index, value[i]));
        case Map:
          return type.children.forEach((f, i) => children[i].set(index, value.get(f.name)));
        default:
          return type.children.forEach((f, i) => children[i].set(index, value[f.name]));
      }
    }
    /** @inheritdoc */
    setValid(index, valid) {
      if (!super.setValid(index, valid)) {
        this.children.forEach((child) => child.setValid(index, valid));
      }
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      const childIndex = this.children.push(child);
      this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);
      return childIndex;
    }
  };

  // node_modules/apache-arrow/builder/timestamp.mjs
  var TimestampBuilder = class extends FixedWidthBuilder {
  };
  TimestampBuilder.prototype._setValue = setTimestamp;
  var TimestampSecondBuilder = class extends TimestampBuilder {
  };
  TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
  var TimestampMillisecondBuilder = class extends TimestampBuilder {
  };
  TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
  var TimestampMicrosecondBuilder = class extends TimestampBuilder {
  };
  TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
  var TimestampNanosecondBuilder = class extends TimestampBuilder {
  };
  TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

  // node_modules/apache-arrow/builder/time.mjs
  var TimeBuilder = class extends FixedWidthBuilder {
  };
  TimeBuilder.prototype._setValue = setTime;
  var TimeSecondBuilder = class extends TimeBuilder {
  };
  TimeSecondBuilder.prototype._setValue = setTimeSecond;
  var TimeMillisecondBuilder = class extends TimeBuilder {
  };
  TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
  var TimeMicrosecondBuilder = class extends TimeBuilder {
  };
  TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
  var TimeNanosecondBuilder = class extends TimeBuilder {
  };
  TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

  // node_modules/apache-arrow/builder/union.mjs
  var UnionBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);
      if (typeof options["valueToChildTypeId"] === "function") {
        this._valueToChildTypeId = options["valueToChildTypeId"];
      }
    }
    get typeIdToChildIndex() {
      return this.type.typeIdToChildIndex;
    }
    append(value, childTypeId) {
      return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
      if (childTypeId === void 0) {
        childTypeId = this._valueToChildTypeId(this, value, index);
      }
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value, childTypeId);
      }
      return this;
    }
    setValue(index, value, childTypeId) {
      this._typeIds.set(index, childTypeId);
      const childIndex = this.type.typeIdToChildIndex[childTypeId];
      const child = this.children[childIndex];
      child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
      const childTypeId = this.children.push(child);
      const { type: { children, mode, typeIds } } = this;
      const fields = [...children, new Field2(name, child.type)];
      this.type = new Union_(mode, [...typeIds, childTypeId], fields);
      return childTypeId;
    }
    /** @ignore */
    // @ts-ignore
    _valueToChildTypeId(builder, value, offset) {
      throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
  };
  var SparseUnionBuilder = class extends UnionBuilder {
  };
  var DenseUnionBuilder = class extends UnionBuilder {
    constructor(options) {
      super(options);
      this._offsets = new DataBufferBuilder(new Int32Array(0));
    }
    /** @ignore */
    setValue(index, value, childTypeId) {
      const id = this._typeIds.set(index, childTypeId).buffer[index];
      const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
      const denseIndex = this._offsets.set(index, child.length).buffer[index];
      child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
  };

  // node_modules/apache-arrow/builder/utf8.mjs
  var Utf8Builder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, encodeUtf8(value));
    }
    // @ts-ignore
    _flushPending(pending, pendingLength) {
    }
  };
  Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

  // node_modules/apache-arrow/visitor/builderctor.mjs
  var GetBuilderCtor = class extends Visitor {
    visitNull() {
      return NullBuilder;
    }
    visitBool() {
      return BoolBuilder;
    }
    visitInt() {
      return IntBuilder;
    }
    visitInt8() {
      return Int8Builder;
    }
    visitInt16() {
      return Int16Builder;
    }
    visitInt32() {
      return Int32Builder;
    }
    visitInt64() {
      return Int64Builder;
    }
    visitUint8() {
      return Uint8Builder;
    }
    visitUint16() {
      return Uint16Builder;
    }
    visitUint32() {
      return Uint32Builder;
    }
    visitUint64() {
      return Uint64Builder;
    }
    visitFloat() {
      return FloatBuilder;
    }
    visitFloat16() {
      return Float16Builder;
    }
    visitFloat32() {
      return Float32Builder;
    }
    visitFloat64() {
      return Float64Builder;
    }
    visitUtf8() {
      return Utf8Builder;
    }
    visitBinary() {
      return BinaryBuilder;
    }
    visitFixedSizeBinary() {
      return FixedSizeBinaryBuilder;
    }
    visitDate() {
      return DateBuilder;
    }
    visitDateDay() {
      return DateDayBuilder;
    }
    visitDateMillisecond() {
      return DateMillisecondBuilder;
    }
    visitTimestamp() {
      return TimestampBuilder;
    }
    visitTimestampSecond() {
      return TimestampSecondBuilder;
    }
    visitTimestampMillisecond() {
      return TimestampMillisecondBuilder;
    }
    visitTimestampMicrosecond() {
      return TimestampMicrosecondBuilder;
    }
    visitTimestampNanosecond() {
      return TimestampNanosecondBuilder;
    }
    visitTime() {
      return TimeBuilder;
    }
    visitTimeSecond() {
      return TimeSecondBuilder;
    }
    visitTimeMillisecond() {
      return TimeMillisecondBuilder;
    }
    visitTimeMicrosecond() {
      return TimeMicrosecondBuilder;
    }
    visitTimeNanosecond() {
      return TimeNanosecondBuilder;
    }
    visitDecimal() {
      return DecimalBuilder;
    }
    visitList() {
      return ListBuilder;
    }
    visitStruct() {
      return StructBuilder;
    }
    visitUnion() {
      return UnionBuilder;
    }
    visitDenseUnion() {
      return DenseUnionBuilder;
    }
    visitSparseUnion() {
      return SparseUnionBuilder;
    }
    visitDictionary() {
      return DictionaryBuilder;
    }
    visitInterval() {
      return IntervalBuilder;
    }
    visitIntervalDayTime() {
      return IntervalDayTimeBuilder;
    }
    visitIntervalYearMonth() {
      return IntervalYearMonthBuilder;
    }
    visitFixedSizeList() {
      return FixedSizeListBuilder;
    }
    visitMap() {
      return MapBuilder;
    }
  };
  var instance6 = new GetBuilderCtor();

  // node_modules/apache-arrow/visitor/typecomparator.mjs
  var TypeComparator = class extends Visitor {
    compareSchemas(schema, other) {
      return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
    }
    compareManyFields(fields, others) {
      return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));
    }
    compareFields(field, other) {
      return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
    }
  };
  function compareConstructor(type, other) {
    return other instanceof type.constructor;
  }
  function compareAny(type, other) {
    return type === other || compareConstructor(type, other);
  }
  function compareInt(type, other) {
    return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
  }
  function compareFloat(type, other) {
    return type === other || compareConstructor(type, other) && type.precision === other.precision;
  }
  function compareFixedSizeBinary(type, other) {
    return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
  }
  function compareDate(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareTimestamp(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
  }
  function compareTime(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
  }
  function compareList(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareStruct(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareUnion(type, other) {
    return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && instance7.compareManyFields(type.children, other.children);
  }
  function compareDictionary(type, other) {
    return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance7.visit(type.indices, other.indices) && instance7.visit(type.dictionary, other.dictionary);
  }
  function compareInterval(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareFixedSizeList(type, other) {
    return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareMap(type, other) {
    return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  TypeComparator.prototype.visitNull = compareAny;
  TypeComparator.prototype.visitBool = compareAny;
  TypeComparator.prototype.visitInt = compareInt;
  TypeComparator.prototype.visitInt8 = compareInt;
  TypeComparator.prototype.visitInt16 = compareInt;
  TypeComparator.prototype.visitInt32 = compareInt;
  TypeComparator.prototype.visitInt64 = compareInt;
  TypeComparator.prototype.visitUint8 = compareInt;
  TypeComparator.prototype.visitUint16 = compareInt;
  TypeComparator.prototype.visitUint32 = compareInt;
  TypeComparator.prototype.visitUint64 = compareInt;
  TypeComparator.prototype.visitFloat = compareFloat;
  TypeComparator.prototype.visitFloat16 = compareFloat;
  TypeComparator.prototype.visitFloat32 = compareFloat;
  TypeComparator.prototype.visitFloat64 = compareFloat;
  TypeComparator.prototype.visitUtf8 = compareAny;
  TypeComparator.prototype.visitBinary = compareAny;
  TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
  TypeComparator.prototype.visitDate = compareDate;
  TypeComparator.prototype.visitDateDay = compareDate;
  TypeComparator.prototype.visitDateMillisecond = compareDate;
  TypeComparator.prototype.visitTimestamp = compareTimestamp;
  TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
  TypeComparator.prototype.visitTime = compareTime;
  TypeComparator.prototype.visitTimeSecond = compareTime;
  TypeComparator.prototype.visitTimeMillisecond = compareTime;
  TypeComparator.prototype.visitTimeMicrosecond = compareTime;
  TypeComparator.prototype.visitTimeNanosecond = compareTime;
  TypeComparator.prototype.visitDecimal = compareAny;
  TypeComparator.prototype.visitList = compareList;
  TypeComparator.prototype.visitStruct = compareStruct;
  TypeComparator.prototype.visitUnion = compareUnion;
  TypeComparator.prototype.visitDenseUnion = compareUnion;
  TypeComparator.prototype.visitSparseUnion = compareUnion;
  TypeComparator.prototype.visitDictionary = compareDictionary;
  TypeComparator.prototype.visitInterval = compareInterval;
  TypeComparator.prototype.visitIntervalDayTime = compareInterval;
  TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
  TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
  TypeComparator.prototype.visitMap = compareMap;
  var instance7 = new TypeComparator();
  function compareSchemas(schema, other) {
    return instance7.compareSchemas(schema, other);
  }
  function compareFields(field, other) {
    return instance7.compareFields(field, other);
  }
  function compareTypes(type, other) {
    return instance7.visit(type, other);
  }

  // node_modules/apache-arrow/factories.mjs
  function makeBuilder(options) {
    const type = options.type;
    const builder = new (instance6.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
      const children = options["children"] || [];
      const defaultOptions = { "nullValues": options["nullValues"] };
      const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : ({ name }) => children[name] || defaultOptions;
      for (const [index, field] of type.children.entries()) {
        const { type: type2 } = field;
        const opts = getChildOptions(field, index);
        builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type2 })));
      }
    }
    return builder;
  }
  function vectorFromArray(init, type) {
    if (init instanceof Data || init instanceof Vector || init.type instanceof DataType || ArrayBuffer.isView(init)) {
      return makeVector(init);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (DataType.isDictionary(vector.type)) {
      return vector.memoize();
    }
    return vector;
  }
  function inferType(value) {
    if (value.length === 0) {
      return new Null();
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
      if (val == null) {
        ++nullsCount;
        continue;
      }
      switch (typeof val) {
        case "bigint":
          ++bigintsCount;
          continue;
        case "boolean":
          ++booleansCount;
          continue;
        case "number":
          ++numbersCount;
          continue;
        case "string":
          ++stringsCount;
          continue;
        case "object":
          if (Array.isArray(val)) {
            ++arraysCount;
          } else if (Object.prototype.toString.call(val) === "[object Date]") {
            ++datesCount;
          } else {
            ++objectsCount;
          }
          continue;
      }
      throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected.");
    }
    if (numbersCount + nullsCount === value.length) {
      return new Float64();
    } else if (stringsCount + nullsCount === value.length) {
      return new Dictionary(new Utf8(), new Int32());
    } else if (bigintsCount + nullsCount === value.length) {
      return new Int64();
    } else if (booleansCount + nullsCount === value.length) {
      return new Bool();
    } else if (datesCount + nullsCount === value.length) {
      return new DateMillisecond();
    } else if (arraysCount + nullsCount === value.length) {
      const array = value;
      const childType = inferType(array[array.findIndex((ary) => ary != null)]);
      if (array.every((ary) => ary == null || compareTypes(childType, inferType(ary)))) {
        return new List(new Field2("", childType, true));
      }
    } else if (objectsCount + nullsCount === value.length) {
      const fields = /* @__PURE__ */ new Map();
      for (const row of value) {
        for (const key of Object.keys(row)) {
          if (!fields.has(key) && row[key] != null) {
            fields.set(key, new Field2(key, inferType([row[key]]), true));
          }
        }
      }
      return new Struct([...fields.values()]);
    }
    throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected.");
  }
  function builderThroughIterable(options) {
    const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
    const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
    return function* (source) {
      let numChunks = 0;
      const builder = makeBuilder(options);
      for (const value of source) {
        if (builder.append(value)[sizeProperty] >= highWaterMark) {
          ++numChunks && (yield builder.toVector());
        }
      }
      if (builder.finish().length > 0 || numChunks === 0) {
        yield builder.toVector();
      }
    };
  }

  // node_modules/apache-arrow/util/recordbatch.mjs
  function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
  }
  function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i = -1;
    const numColumns = cols.length;
    let child, children = [];
    while (memo.numBatches-- > 0) {
      for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
        children[i] = child = cols[i].shift();
        batchLength = Math.min(batchLength, child ? child.length : batchLength);
      }
      if (Number.isFinite(batchLength)) {
        children = distributeChildren(fields, batchLength, children, cols, memo);
        if (batchLength > 0) {
          batches[numBatches++] = makeData({
            type: new Struct(fields),
            length: batchLength,
            nullCount: 0,
            children: children.slice()
          });
        }
      }
    }
    return [
      schema = schema.assign(fields),
      batches.map((data) => new RecordBatch(schema, data))
    ];
  }
  function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a5;
    const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
    for (let i = -1, n = columns.length; ++i < n; ) {
      const child = children[i];
      const length = child === null || child === void 0 ? void 0 : child.length;
      if (length >= batchLength) {
        if (length === batchLength) {
          children[i] = child;
        } else {
          children[i] = child.slice(0, batchLength);
          memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
        }
      } else {
        const field = fields[i];
        fields[i] = field.clone({ nullable: true });
        children[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
          type: field.type,
          length: batchLength,
          nullCount: batchLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return children;
  }

  // node_modules/apache-arrow/table.mjs
  var _a3;
  var Table = class _Table {
    constructor(...args) {
      var _b2, _c2;
      if (args.length === 0) {
        this.batches = [];
        this.schema = new Schema2([]);
        this._offsets = [0];
        return this;
      }
      let schema;
      let offsets;
      if (args[0] instanceof Schema2) {
        schema = args.shift();
      }
      if (args[args.length - 1] instanceof Uint32Array) {
        offsets = args.pop();
      }
      const unwrap = (x) => {
        if (x) {
          if (x instanceof RecordBatch) {
            return [x];
          } else if (x instanceof _Table) {
            return x.batches;
          } else if (x instanceof Data) {
            if (x.type instanceof Struct) {
              return [new RecordBatch(new Schema2(x.type.children), x)];
            }
          } else if (Array.isArray(x)) {
            return x.flatMap((v) => unwrap(v));
          } else if (typeof x[Symbol.iterator] === "function") {
            return [...x].flatMap((v) => unwrap(v));
          } else if (typeof x === "object") {
            const keys = Object.keys(x);
            const vecs = keys.map((k) => new Vector([x[k]]));
            const schema2 = new Schema2(keys.map((k, i) => new Field2(String(k), vecs[i].type)));
            const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);
            return batches2.length === 0 ? [new RecordBatch(x)] : batches2;
          }
        }
        return [];
      };
      const batches = args.flatMap((v) => unwrap(v));
      schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);
      if (!(schema instanceof Schema2)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      for (const batch of batches) {
        if (!(batch instanceof RecordBatch)) {
          throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
        }
        if (!compareSchemas(schema, batch.schema)) {
          throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
        }
      }
      this.schema = schema;
      this.batches = batches;
      this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);
    }
    /**
     * The contiguous {@link RecordBatch `RecordBatch`} chunks of the Table rows.
     */
    get data() {
      return this.batches.map(({ data }) => data);
    }
    /**
     * The number of columns in this Table.
     */
    get numCols() {
      return this.schema.fields.length;
    }
    /**
     * The number of rows in this Table.
     */
    get numRows() {
      return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    /**
     * The number of null rows in this Table.
     */
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    /**
     * Check whether an element is null.
     *
     * @param index The index at which to read the validity bitmap.
     */
    // @ts-ignore
    isValid(index) {
      return false;
    }
    /**
     * Get an element value by position.
     *
     * @param index The index of the element to read.
     */
    // @ts-ignore
    get(index) {
      return null;
    }
    /**
     * Set an element value by position.
     *
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    // @ts-ignore
    set(index, value) {
      return;
    }
    /**
     * Retrieve the index of the first occurrence of a value in an Vector.
     *
     * @param element The value to locate in the Vector.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    // @ts-ignore
    indexOf(element, offset) {
      return -1;
    }
    /**
     * Get the size in bytes of an element by index.
     * @param index The index at which to get the byteLength.
     */
    // @ts-ignore
    getByteLength(index) {
      return 0;
    }
    /**
     * Iterator for rows in this Table.
     */
    [Symbol.iterator]() {
      if (this.batches.length > 0) {
        return instance4.visit(new Vector(this.data));
      }
      return new Array(0)[Symbol.iterator]();
    }
    /**
     * Return a JavaScript Array of the Table rows.
     *
     * @returns An Array of Table rows.
     */
    toArray() {
      return [...this];
    }
    /**
     * Returns a string representation of the Table rows.
     *
     * @returns A string representation of the Table rows.
     */
    toString() {
      return `[
  ${this.toArray().join(",\n  ")}
]`;
    }
    /**
     * Combines two or more Tables of the same schema.
     *
     * @param others Additional Tables to add to the end of this Tables.
     */
    concat(...others) {
      const schema = this.schema;
      const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
      return new _Table(schema, data.map((data2) => new RecordBatch(schema, data2)));
    }
    /**
     * Return a zero-copy sub-section of this Table.
     *
     * @param begin The beginning of the specified portion of the Table.
     * @param end The end of the specified portion of the Table. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
      const schema = this.schema;
      [begin, end] = clampRange({ length: this.numRows }, begin, end);
      const data = sliceChunks(this.data, this._offsets, begin, end);
      return new _Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     *
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
      return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     *
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        const data = this.data.map((data2) => data2.children[index]);
        if (data.length === 0) {
          const { type } = this.schema.fields[index];
          const empty = makeData({ type, length: 0, nullCount: 0 });
          data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
        }
        return new Vector(data);
      }
      return null;
    }
    /**
     * Sets a child Vector by name.
     *
     * @param name The name of the child to overwrite.
     * @returns A new Table with the supplied child for the specified name.
     */
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let batches = [...this.batches];
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const field = fields[index].clone({ type: child.type });
        const children = this.schema.fields.map((_, i) => this.getChildAt(i));
        [fields[index], children[index]] = [field, child];
        [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);
      }
      return new _Table(schema, batches);
    }
    /**
     * Construct a new Table containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new Table of columns matching the specified names.
     */
    select(columnNames) {
      const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
      return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    /**
     * Construct a new Table containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new Table of columns at the specified indices.
     */
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const data = this.batches.map((batch) => batch.selectAt(columnIndices));
      return new _Table(schema, data);
    }
    assign(other) {
      const fields = this.schema.fields;
      const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
        const [indices2, oldToNew2] = memo;
        const i = fields.findIndex((f) => f.name === f2.name);
        ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
        return memo;
      }, [[], []]);
      const schema = this.schema.assign(other.schema);
      const columns = [
        ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),
        ...indices.map((i) => other.getChildAt(i))
      ].filter(Boolean);
      return new _Table(...distributeVectorsIntoRecordBatches(schema, columns));
    }
  };
  _a3 = Symbol.toStringTag;
  Table[_a3] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto["isValid"] = wrapChunkedCall1(isChunkedValid);
    proto["get"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));
    proto["set"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));
    proto["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));
    proto["getByteLength"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));
    return "Table";
  })(Table.prototype);

  // node_modules/apache-arrow/recordbatch.mjs
  var _a4;
  var RecordBatch = class _RecordBatch {
    constructor(...args) {
      switch (args.length) {
        case 2: {
          [this.schema] = args;
          if (!(this.schema instanceof Schema2)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [
            ,
            this.data = makeData({
              nullCount: 0,
              type: new Struct(this.schema.fields),
              children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
            })
          ] = args;
          if (!(this.data instanceof Data)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
          break;
        }
        case 1: {
          const [obj] = args;
          const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
            memo.children[i] = obj[name];
            memo.length = Math.max(memo.length, obj[name].length);
            memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });
            return memo;
          }, {
            length: 0,
            fields: new Array(),
            children: new Array()
          });
          const schema = new Schema2(fields);
          const data = makeData({ type: new Struct(fields), length, children, nullCount: 0 });
          [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
          break;
        }
        default:
          throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
      }
    }
    get dictionaries() {
      return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    /**
     * The number of columns in this RecordBatch.
     */
    get numCols() {
      return this.schema.fields.length;
    }
    /**
     * The number of rows in this RecordBatch.
     */
    get numRows() {
      return this.data.length;
    }
    /**
     * The number of null rows in this RecordBatch.
     */
    get nullCount() {
      return this.data.nullCount;
    }
    /**
     * Check whether an element is null.
     * @param index The index at which to read the validity bitmap.
     */
    isValid(index) {
      return this.data.getValid(index);
    }
    /**
     * Get a row by position.
     * @param index The index of the element to read.
     */
    get(index) {
      return instance2.visit(this.data, index);
    }
    /**
     * Set a row by position.
     * @param index The index of the element to write.
     * @param value The value to set.
     */
    set(index, value) {
      return instance.visit(this.data, index, value);
    }
    /**
     * Retrieve the index of the first occurrence of a row in an RecordBatch.
     * @param element The row to locate in the RecordBatch.
     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.
     */
    indexOf(element, offset) {
      return instance3.visit(this.data, element, offset);
    }
    /**
     * Get the size (in bytes) of a row by index.
     * @param index The row index for which to compute the byteLength.
     */
    getByteLength(index) {
      return instance5.visit(this.data, index);
    }
    /**
     * Iterator for rows in this RecordBatch.
     */
    [Symbol.iterator]() {
      return instance4.visit(new Vector([this.data]));
    }
    /**
     * Return a JavaScript Array of the RecordBatch rows.
     * @returns An Array of RecordBatch rows.
     */
    toArray() {
      return [...this];
    }
    /**
     * Combines two or more RecordBatch of the same schema.
     * @param others Additional RecordBatch to add to the end of this RecordBatch.
     */
    concat(...others) {
      return new Table(this.schema, [this, ...others]);
    }
    /**
     * Return a zero-copy sub-section of this RecordBatch.
     * @param start The beginning of the specified portion of the RecordBatch.
     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.
     */
    slice(begin, end) {
      const [slice] = new Vector([this.data]).slice(begin, end).data;
      return new _RecordBatch(this.schema, slice);
    }
    /**
     * Returns a child Vector by name, or null if this Vector has no child with the given name.
     * @param name The name of the child to retrieve.
     */
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
    }
    /**
     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.
     * @param index The index of the child to retrieve.
     */
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        return new Vector([this.data.children[index]]);
      }
      return null;
    }
    /**
     * Sets a child Vector by name.
     * @param name The name of the child to overwrite.
     * @returns A new RecordBatch with the new child for the specified name.
     */
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let data = this.data;
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const children = data.children.slice();
        const field = fields[index].clone({ type: child.type });
        [fields[index], children[index]] = [field, child.data[0]];
        schema = new Schema2(fields, new Map(this.schema.metadata));
        data = makeData({ type: new Struct(fields), children });
      }
      return new _RecordBatch(schema, data);
    }
    /**
     * Construct a new RecordBatch containing only specified columns.
     *
     * @param columnNames Names of columns to keep.
     * @returns A new RecordBatch of columns matching the specified names.
     */
    select(columnNames) {
      const schema = this.schema.select(columnNames);
      const type = new Struct(schema.fields);
      const children = [];
      for (const name of columnNames) {
        const index = this.schema.fields.findIndex((f) => f.name === name);
        if (~index) {
          children[index] = this.data.children[index];
        }
      }
      return new _RecordBatch(schema, makeData({ type, length: this.numRows, children }));
    }
    /**
     * Construct a new RecordBatch containing only columns at the specified indices.
     *
     * @param columnIndices Indices of columns to keep.
     * @returns A new RecordBatch of columns matching at the specified indices.
     */
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
      const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });
      return new _RecordBatch(schema, subset);
    }
  };
  _a4 = Symbol.toStringTag;
  RecordBatch[_a4] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return "RecordBatch";
  })(RecordBatch.prototype);
  function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b2;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
      const chunk = chunks[idx];
      if (!chunk || chunk.length !== maxLength) {
        fields[idx] = field.clone({ nullable: true });
        children[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
          type: field.type,
          length: maxLength,
          nullCount: maxLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return [
      schema.assign(fields),
      makeData({ type: new Struct(fields), length: maxLength, children })
    ];
  }
  function collectDictionaries(fields, children, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const field = fields[i];
      const type = field.type;
      const data = children[i];
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          if (data.dictionary) {
            dictionaries.set(type.id, data.dictionary);
          }
        } else if (dictionaries.get(type.id) !== data.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        collectDictionaries(type.children, data.children, dictionaries);
      }
    }
    return dictionaries;
  }
  var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
    constructor(schema) {
      const children = schema.fields.map((f) => makeData({ type: f.type }));
      const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children });
      super(schema, data);
    }
  };

  // node_modules/apache-arrow/fb/body-compression-method.mjs
  var BodyCompressionMethod;
  (function(BodyCompressionMethod2) {
    BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
  })(BodyCompressionMethod || (BodyCompressionMethod = {}));

  // node_modules/apache-arrow/fb/compression-type.mjs
  var CompressionType;
  (function(CompressionType2) {
    CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
  })(CompressionType || (CompressionType = {}));

  // node_modules/apache-arrow/fb/body-compression.mjs
  var BodyCompression = class _BodyCompression {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBodyCompression(bb, obj) {
      return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * Compressor library.
     * For LZ4_FRAME, each compressed buffer must consist of a single frame.
     */
    codec() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;
    }
    /**
     * Indicates the way the record batch body was compressed
     */
    method() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
      builder.startObject(2);
    }
    static addCodec(builder, codec) {
      builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method2) {
      builder.addFieldInt8(1, method2, BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBodyCompression(builder, codec, method2) {
      _BodyCompression.startBodyCompression(builder);
      _BodyCompression.addCodec(builder, codec);
      _BodyCompression.addMethod(builder, method2);
      return _BodyCompression.endBodyCompression(builder);
    }
  };

  // node_modules/apache-arrow/fb/buffer.mjs
  var Buffer2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     */
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     */
    length() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createBuffer(builder, offset, length) {
      builder.prep(8, 16);
      builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
      builder.writeInt64(BigInt(offset !== null && offset !== void 0 ? offset : 0));
      return builder.offset();
    }
  };

  // node_modules/apache-arrow/fb/field-node.mjs
  var FieldNode = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     */
    length() {
      return this.bb.readInt64(this.bb_pos);
    }
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     */
    nullCount() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createFieldNode(builder, length, null_count) {
      builder.prep(8, 16);
      builder.writeInt64(BigInt(null_count !== null && null_count !== void 0 ? null_count : 0));
      builder.writeInt64(BigInt(length !== null && length !== void 0 ? length : 0));
      return builder.offset();
    }
  };

  // node_modules/apache-arrow/fb/record-batch.mjs
  var RecordBatch2 = class _RecordBatch {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsRecordBatch(bb, obj) {
      return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     */
    length() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     */
    nodes(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     */
    buffers(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    /**
     * Optional compression of the message body
     */
    compression(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
      builder.startObject(4);
    }
    static addLength(builder, length) {
      builder.addFieldInt64(0, length, BigInt("0"));
    }
    static addNodes(builder, nodesOffset) {
      builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
      builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
      builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // node_modules/apache-arrow/fb/dictionary-batch.mjs
  var DictionaryBatch = class _DictionaryBatch {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
      return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    data(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     */
    isDelta() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
      builder.startObject(3);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, BigInt("0"));
    }
    static addData(builder, dataOffset) {
      builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
      builder.addFieldInt8(2, +isDelta, 0);
    }
    static endDictionaryBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // node_modules/apache-arrow/fb/message-header.mjs
  var MessageHeader2;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader2 || (MessageHeader2 = {}));

  // node_modules/apache-arrow/fb/message.mjs
  var Message = class _Message {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsMessage(bb, obj) {
      return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new _Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    headerType() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader2.NONE;
    }
    header(obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : BigInt("0");
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addHeaderType(builder, headerType) {
      builder.addFieldInt8(1, headerType, MessageHeader2.NONE);
    }
    static addHeader(builder, headerOffset) {
      builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
      builder.addFieldInt64(3, bodyLength, BigInt("0"));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishMessageBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
      _Message.startMessage(builder);
      _Message.addVersion(builder, version);
      _Message.addHeaderType(builder, headerType);
      _Message.addHeader(builder, headerOffset);
      _Message.addBodyLength(builder, bodyLength);
      _Message.addCustomMetadata(builder, customMetadataOffset);
      return _Message.endMessage(builder);
    }
  };

  // node_modules/apache-arrow/visitor/typeassembler.mjs
  var TypeAssembler = class extends Visitor {
    visit(node, builder) {
      return node == null || builder == null ? void 0 : super.visit(node, builder);
    }
    visitNull(_node, b) {
      Null2.startNull(b);
      return Null2.endNull(b);
    }
    visitInt(node, b) {
      Int.startInt(b);
      Int.addBitWidth(b, node.bitWidth);
      Int.addIsSigned(b, node.isSigned);
      return Int.endInt(b);
    }
    visitFloat(node, b) {
      FloatingPoint.startFloatingPoint(b);
      FloatingPoint.addPrecision(b, node.precision);
      return FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
      Binary2.startBinary(b);
      return Binary2.endBinary(b);
    }
    visitBool(_node, b) {
      Bool2.startBool(b);
      return Bool2.endBool(b);
    }
    visitUtf8(_node, b) {
      Utf82.startUtf8(b);
      return Utf82.endUtf8(b);
    }
    visitDecimal(node, b) {
      Decimal2.startDecimal(b);
      Decimal2.addScale(b, node.scale);
      Decimal2.addPrecision(b, node.precision);
      Decimal2.addBitWidth(b, node.bitWidth);
      return Decimal2.endDecimal(b);
    }
    visitDate(node, b) {
      Date2.startDate(b);
      Date2.addUnit(b, node.unit);
      return Date2.endDate(b);
    }
    visitTime(node, b) {
      Time.startTime(b);
      Time.addUnit(b, node.unit);
      Time.addBitWidth(b, node.bitWidth);
      return Time.endTime(b);
    }
    visitTimestamp(node, b) {
      const timezone = node.timezone && b.createString(node.timezone) || void 0;
      Timestamp.startTimestamp(b);
      Timestamp.addUnit(b, node.unit);
      if (timezone !== void 0) {
        Timestamp.addTimezone(b, timezone);
      }
      return Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
      Interval.startInterval(b);
      Interval.addUnit(b, node.unit);
      return Interval.endInterval(b);
    }
    visitList(_node, b) {
      List2.startList(b);
      return List2.endList(b);
    }
    visitStruct(_node, b) {
      Struct_.startStruct_(b);
      return Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
      Union.startTypeIdsVector(b, node.typeIds.length);
      const typeIds = Union.createTypeIdsVector(b, node.typeIds);
      Union.startUnion(b);
      Union.addMode(b, node.mode);
      Union.addTypeIds(b, typeIds);
      return Union.endUnion(b);
    }
    visitDictionary(node, b) {
      const indexType = this.visit(node.indices, b);
      DictionaryEncoding.startDictionaryEncoding(b);
      DictionaryEncoding.addId(b, BigInt(node.id));
      DictionaryEncoding.addIsOrdered(b, node.isOrdered);
      if (indexType !== void 0) {
        DictionaryEncoding.addIndexType(b, indexType);
      }
      return DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
      FixedSizeBinary2.startFixedSizeBinary(b);
      FixedSizeBinary2.addByteWidth(b, node.byteWidth);
      return FixedSizeBinary2.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
      FixedSizeList2.startFixedSizeList(b);
      FixedSizeList2.addListSize(b, node.listSize);
      return FixedSizeList2.endFixedSizeList(b);
    }
    visitMap(node, b) {
      Map2.startMap(b);
      Map2.addKeysSorted(b, node.keysSorted);
      return Map2.endMap(b);
    }
  };
  var instance8 = new TypeAssembler();

  // node_modules/apache-arrow/ipc/metadata/json.mjs
  function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["customMetadata"]), dictionaries);
  }
  function recordBatchFromJSON(b) {
    return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
  }
  function dictionaryBatchFromJSON(b) {
    return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
  }
  function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
      ...fieldNodes,
      new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
      ...fieldNodesFromJSON(column["children"])
    ], []);
  }
  function buffersFromJSON(xs, buffers = []) {
    for (let i = -1, n = (xs || []).length; ++i < n; ) {
      const column = xs[i];
      column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
      column["TYPE"] && buffers.push(new BufferRegion(buffers.length, column["TYPE"].length));
      column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
      column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
      buffers = buffersFromJSON(column["children"], buffers);
    }
    return buffers;
  }
  function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum2, val) => sum2 + +(val === 0), 0);
  }
  function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    if (!dictionaries || !(dictMeta = _field["dictionary"])) {
      type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
      field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    } else if (!dictionaries.has(id = dictMeta["id"])) {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    } else {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    }
    return field || null;
  }
  function customMetadataFromJSON(_metadata) {
    return new Map(Object.entries(_metadata || {}));
  }
  function indexTypeFromJSON(_type) {
    return new Int_(_type["isSigned"], _type["bitWidth"]);
  }
  function typeFromJSON(f, children) {
    const typeId = f["type"]["name"];
    switch (typeId) {
      case "NONE":
        return new Null();
      case "null":
        return new Null();
      case "binary":
        return new Binary();
      case "utf8":
        return new Utf8();
      case "bool":
        return new Bool();
      case "list":
        return new List((children || [])[0]);
      case "struct":
        return new Struct(children || []);
      case "struct_":
        return new Struct(children || []);
    }
    switch (typeId) {
      case "int": {
        const t = f["type"];
        return new Int_(t["isSigned"], t["bitWidth"]);
      }
      case "floatingpoint": {
        const t = f["type"];
        return new Float(Precision[t["precision"]]);
      }
      case "decimal": {
        const t = f["type"];
        return new Decimal(t["scale"], t["precision"], t["bitWidth"]);
      }
      case "date": {
        const t = f["type"];
        return new Date_(DateUnit[t["unit"]]);
      }
      case "time": {
        const t = f["type"];
        return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
      }
      case "timestamp": {
        const t = f["type"];
        return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
      }
      case "interval": {
        const t = f["type"];
        return new Interval_(IntervalUnit[t["unit"]]);
      }
      case "union": {
        const t = f["type"];
        return new Union_(UnionMode[t["mode"]], t["typeIds"] || [], children || []);
      }
      case "fixedsizebinary": {
        const t = f["type"];
        return new FixedSizeBinary(t["byteWidth"]);
      }
      case "fixedsizelist": {
        const t = f["type"];
        return new FixedSizeList(t["listSize"], (children || [])[0]);
      }
      case "map": {
        const t = f["type"];
        return new Map_((children || [])[0], t["keysSorted"]);
      }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
  }

  // node_modules/apache-arrow/ipc/metadata/message.mjs
  var Builder4 = Builder2;
  var ByteBuffer3 = ByteBuffer;
  var Message2 = class _Message {
    /** @nocollapse */
    static fromJSON(msg, headerType) {
      const message = new _Message(0, MetadataVersion.V4, headerType);
      message._createHeader = messageHeaderFromJSON(msg, headerType);
      return message;
    }
    /** @nocollapse */
    static decode(buf) {
      buf = new ByteBuffer3(toUint8Array(buf));
      const _message = Message.getRootAsMessage(buf);
      const bodyLength = _message.bodyLength();
      const version = _message.version();
      const headerType = _message.headerType();
      const message = new _Message(bodyLength, version, headerType);
      message._createHeader = decodeMessageHeader(_message, headerType);
      return message;
    }
    /** @nocollapse */
    static encode(message) {
      const b = new Builder4();
      let headerOffset = -1;
      if (message.isSchema()) {
        headerOffset = Schema2.encode(b, message.header());
      } else if (message.isRecordBatch()) {
        headerOffset = RecordBatch3.encode(b, message.header());
      } else if (message.isDictionaryBatch()) {
        headerOffset = DictionaryBatch2.encode(b, message.header());
      }
      Message.startMessage(b);
      Message.addVersion(b, MetadataVersion.V4);
      Message.addHeader(b, headerOffset);
      Message.addHeaderType(b, message.headerType);
      Message.addBodyLength(b, BigInt(message.bodyLength));
      Message.finishMessageBuffer(b, Message.endMessage(b));
      return b.asUint8Array();
    }
    /** @nocollapse */
    static from(header, bodyLength = 0) {
      if (header instanceof Schema2) {
        return new _Message(0, MetadataVersion.V4, MessageHeader.Schema, header);
      }
      if (header instanceof RecordBatch3) {
        return new _Message(bodyLength, MetadataVersion.V4, MessageHeader.RecordBatch, header);
      }
      if (header instanceof DictionaryBatch2) {
        return new _Message(bodyLength, MetadataVersion.V4, MessageHeader.DictionaryBatch, header);
      }
      throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() {
      return this.headerType;
    }
    get version() {
      return this._version;
    }
    get headerType() {
      return this._headerType;
    }
    get bodyLength() {
      return this._bodyLength;
    }
    header() {
      return this._createHeader();
    }
    isSchema() {
      return this.headerType === MessageHeader.Schema;
    }
    isRecordBatch() {
      return this.headerType === MessageHeader.RecordBatch;
    }
    isDictionaryBatch() {
      return this.headerType === MessageHeader.DictionaryBatch;
    }
    constructor(bodyLength, version, headerType, header) {
      this._version = version;
      this._headerType = headerType;
      this.body = new Uint8Array(0);
      header && (this._createHeader = () => header);
      this._bodyLength = bigIntToNumber(bodyLength);
    }
  };
  var RecordBatch3 = class {
    get nodes() {
      return this._nodes;
    }
    get length() {
      return this._length;
    }
    get buffers() {
      return this._buffers;
    }
    constructor(length, nodes, buffers) {
      this._nodes = nodes;
      this._buffers = buffers;
      this._length = bigIntToNumber(length);
    }
  };
  var DictionaryBatch2 = class {
    get id() {
      return this._id;
    }
    get data() {
      return this._data;
    }
    get isDelta() {
      return this._isDelta;
    }
    get length() {
      return this.data.length;
    }
    get nodes() {
      return this.data.nodes;
    }
    get buffers() {
      return this.data.buffers;
    }
    constructor(data, id, isDelta = false) {
      this._data = data;
      this._isDelta = isDelta;
      this._id = bigIntToNumber(id);
    }
  };
  var BufferRegion = class {
    constructor(offset, length) {
      this.offset = bigIntToNumber(offset);
      this.length = bigIntToNumber(length);
    }
  };
  var FieldNode2 = class {
    constructor(length, nullCount) {
      this.length = bigIntToNumber(length);
      this.nullCount = bigIntToNumber(nullCount);
    }
  };
  function messageHeaderFromJSON(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.fromJSON(message);
        case MessageHeader.RecordBatch:
          return RecordBatch3.fromJSON(message);
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.fromJSON(message);
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  function decodeMessageHeader(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.decode(message.header(new Schema()));
        case MessageHeader.RecordBatch:
          return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  Field2["encode"] = encodeField;
  Field2["decode"] = decodeField;
  Field2["fromJSON"] = fieldFromJSON;
  Schema2["encode"] = encodeSchema;
  Schema2["decode"] = decodeSchema;
  Schema2["fromJSON"] = schemaFromJSON;
  RecordBatch3["encode"] = encodeRecordBatch;
  RecordBatch3["decode"] = decodeRecordBatch;
  RecordBatch3["fromJSON"] = recordBatchFromJSON;
  DictionaryBatch2["encode"] = encodeDictionaryBatch;
  DictionaryBatch2["decode"] = decodeDictionaryBatch;
  DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
  FieldNode2["encode"] = encodeFieldNode;
  FieldNode2["decode"] = decodeFieldNode;
  BufferRegion["encode"] = encodeBufferRegion;
  BufferRegion["decode"] = decodeBufferRegion;
  function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries);
  }
  function decodeRecordBatch(batch, version = MetadataVersion.V4) {
    if (batch.compression() !== null) {
      throw new Error("Record batch compression not implemented");
    }
    return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
  }
  function decodeDictionaryBatch(batch, version = MetadataVersion.V4) {
    return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
  }
  function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
  }
  function decodeFieldNode(f) {
    return new FieldNode2(f.length(), f.nullCount());
  }
  function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {
      if (f = batch.nodes(i)) {
        nodes[++j] = FieldNode2.decode(f);
      }
    }
    return nodes;
  }
  function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {
      if (b = batch.buffers(i)) {
        if (version < MetadataVersion.V4) {
          b.bb_pos += 8 * (i + 1);
        }
        bufferRegions[++j] = BufferRegion.decode(b);
      }
    }
    return bufferRegions;
  }
  function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {
      if (f = schema.fields(i)) {
        fields[++j] = Field2.decode(f, dictionaries);
      }
    }
    return fields;
  }
  function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n; ) {
      if (f = field.children(i)) {
        children[++j] = Field2.decode(f, dictionaries);
      }
    }
    return children;
  }
  function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    if (!dictionaries || !(dictMeta = f.dictionary())) {
      type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
      field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    } else if (!dictionaries.has(id = bigIntToNumber(dictMeta.id()))) {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    } else {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
  }
  function decodeCustomMetadata(parent) {
    const data = /* @__PURE__ */ new Map();
    if (parent) {
      for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {
        if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
          data.set(key, entry.value());
        }
      }
    }
    return data;
  }
  function decodeIndexType(_type) {
    return new Int_(_type.isSigned(), _type.bitWidth());
  }
  function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
      case Type2["NONE"]:
        return new Null();
      case Type2["Null"]:
        return new Null();
      case Type2["Binary"]:
        return new Binary();
      case Type2["Utf8"]:
        return new Utf8();
      case Type2["Bool"]:
        return new Bool();
      case Type2["List"]:
        return new List((children || [])[0]);
      case Type2["Struct_"]:
        return new Struct(children || []);
    }
    switch (typeId) {
      case Type2["Int"]: {
        const t = f.type(new Int());
        return new Int_(t.isSigned(), t.bitWidth());
      }
      case Type2["FloatingPoint"]: {
        const t = f.type(new FloatingPoint());
        return new Float(t.precision());
      }
      case Type2["Decimal"]: {
        const t = f.type(new Decimal2());
        return new Decimal(t.scale(), t.precision(), t.bitWidth());
      }
      case Type2["Date"]: {
        const t = f.type(new Date2());
        return new Date_(t.unit());
      }
      case Type2["Time"]: {
        const t = f.type(new Time());
        return new Time_(t.unit(), t.bitWidth());
      }
      case Type2["Timestamp"]: {
        const t = f.type(new Timestamp());
        return new Timestamp_(t.unit(), t.timezone());
      }
      case Type2["Interval"]: {
        const t = f.type(new Interval());
        return new Interval_(t.unit());
      }
      case Type2["Union"]: {
        const t = f.type(new Union());
        return new Union_(t.mode(), t.typeIdsArray() || [], children || []);
      }
      case Type2["FixedSizeBinary"]: {
        const t = f.type(new FixedSizeBinary2());
        return new FixedSizeBinary(t.byteWidth());
      }
      case Type2["FixedSizeList"]: {
        const t = f.type(new FixedSizeList2());
        return new FixedSizeList(t.listSize(), (children || [])[0]);
      }
      case Type2["Map"]: {
        const t = f.type(new Map2());
        return new Map_((children || [])[0], t.keysSorted());
      }
    }
    throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
  }
  function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
    Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    Schema.startSchema(b);
    Schema.addFields(b, fieldsVectorOffset);
    Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
    if (metadataOffset !== -1) {
      Schema.addCustomMetadata(b, metadataOffset);
    }
    return Schema.endSchema(b);
  }
  function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!DataType.isDictionary(type)) {
      typeOffset = instance8.visit(type, b);
    } else {
      typeId = type.dictionary.typeId;
      dictionaryOffset = instance8.visit(type, b);
      typeOffset = instance8.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
    const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    if (field.name) {
      nameOffset = b.createString(field.name);
    }
    Field.startField(b);
    Field.addType(b, typeOffset);
    Field.addTypeType(b, typeId);
    Field.addChildren(b, childrenVectorOffset);
    Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
      Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
      Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
      Field.addCustomMetadata(b, metadataOffset);
    }
    return Field.endField(b);
  }
  function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    RecordBatch2.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
      FieldNode2.encode(b, n);
    const nodesVectorOffset = b.endVector();
    RecordBatch2.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
      BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    RecordBatch2.startRecordBatch(b);
    RecordBatch2.addLength(b, BigInt(recordBatch.length));
    RecordBatch2.addNodes(b, nodesVectorOffset);
    RecordBatch2.addBuffers(b, buffersVectorOffset);
    return RecordBatch2.endRecordBatch(b);
  }
  function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
    DictionaryBatch.startDictionaryBatch(b);
    DictionaryBatch.addId(b, BigInt(dictionaryBatch.id));
    DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    DictionaryBatch.addData(b, dataOffset);
    return DictionaryBatch.endDictionaryBatch(b);
  }
  function encodeFieldNode(b, node) {
    return FieldNode.createFieldNode(b, BigInt(node.length), BigInt(node.nullCount));
  }
  function encodeBufferRegion(b, node) {
    return Buffer2.createBuffer(b, BigInt(node.offset), BigInt(node.length));
  }
  var platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(
      0,
      256,
      true
      /* littleEndian */
    );
    return new Int16Array(buffer)[0] === 256;
  })();

  // node_modules/apache-arrow/ipc/message.mjs
  var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
  var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
  var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
  var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
  var MessageReader = class {
    constructor(source) {
      this.source = source instanceof ByteStream ? source : new ByteStream(source);
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let r;
      if ((r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readMessageBody(bodyLength) {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return (
        /* 1. */
        buf.byteOffset % 8 === 0 && /* 2. */
        buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
      );
    }
    readSchema(throwIfNull = false) {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
    readMetadataLength() {
      const buf = this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    }
    readMetadata(metadataLength) {
      const buf = this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    }
  };
  var AsyncMessageReader = class {
    constructor(source, byteLength) {
      this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if ((r = yield this.readMetadata(r.value)).done) {
          return ITERATOR_DONE;
        }
        return r;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.throw(value);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.return(value);
      });
    }
    readMessage(type) {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      });
    }
    readMessageBody(bodyLength) {
      return __awaiter(this, void 0, void 0, function* () {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = toUint8Array(yield this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return (
          /* 1. */
          buf.byteOffset % 8 === 0 && /* 2. */
          buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice()
        );
      });
    }
    readSchema(throwIfNull = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const type = MessageHeader.Schema;
        const message = yield this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      });
    }
    readMetadataLength() {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
      });
    }
    readMetadata(metadataLength) {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(metadataLength);
        if (!buf) {
          return ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: Message2.decode(buf) };
      });
    }
  };
  var JSONMessageReader = class extends MessageReader {
    constructor(source) {
      super(new Uint8Array(0));
      this._schema = false;
      this._body = [];
      this._batchIndex = 0;
      this._dictionaryIndex = 0;
      this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
    }
    next() {
      const { _json } = this;
      if (!this._schema) {
        this._schema = true;
        const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
        return { done: false, value: message };
      }
      if (this._dictionaryIndex < _json.dictionaries.length) {
        const batch = _json.dictionaries[this._dictionaryIndex++];
        this._body = batch["data"]["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
        return { done: false, value: message };
      }
      if (this._batchIndex < _json.batches.length) {
        const batch = _json.batches[this._batchIndex++];
        this._body = batch["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
        return { done: false, value: message };
      }
      this._body = [];
      return ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
      return flattenDataSources(this._body);
      function flattenDataSources(xs) {
        return (xs || []).reduce((buffers, column) => [
          ...buffers,
          ...column["VALIDITY"] && [column["VALIDITY"]] || [],
          ...column["TYPE"] && [column["TYPE"]] || [],
          ...column["OFFSET"] && [column["OFFSET"]] || [],
          ...column["DATA"] && [column["DATA"]] || [],
          ...flattenDataSources(column["children"])
        ], []);
      }
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readSchema() {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (!message || !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
  };
  var PADDING = 4;
  var MAGIC_STR = "ARROW1";
  var MAGIC = new Uint8Array(MAGIC_STR.length);
  for (let i = 0; i < MAGIC_STR.length; i += 1) {
    MAGIC[i] = MAGIC_STR.codePointAt(i);
  }
  function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = MAGIC.length; ++i < n; ) {
      if (MAGIC[i] !== buffer[index + i]) {
        return false;
      }
    }
    return true;
  }
  var magicLength = MAGIC.length;
  var magicAndPadding = magicLength + PADDING;
  var magicX2AndPadding = magicLength * 2 + PADDING;

  // node_modules/apache-arrow/ipc/reader.mjs
  var RecordBatchReader = class _RecordBatchReader extends ReadableInterop {
    constructor(impl) {
      super();
      this._impl = impl;
    }
    get closed() {
      return this._impl.closed;
    }
    get schema() {
      return this._impl.schema;
    }
    get autoDestroy() {
      return this._impl.autoDestroy;
    }
    get dictionaries() {
      return this._impl.dictionaries;
    }
    get numDictionaries() {
      return this._impl.numDictionaries;
    }
    get numRecordBatches() {
      return this._impl.numRecordBatches;
    }
    get footer() {
      return this._impl.isFile() ? this._impl.footer : null;
    }
    isSync() {
      return this._impl.isSync();
    }
    isAsync() {
      return this._impl.isAsync();
    }
    isFile() {
      return this._impl.isFile();
    }
    isStream() {
      return this._impl.isStream();
    }
    next() {
      return this._impl.next();
    }
    throw(value) {
      return this._impl.throw(value);
    }
    return(value) {
      return this._impl.return(value);
    }
    cancel() {
      return this._impl.cancel();
    }
    reset(schema) {
      this._impl.reset(schema);
      this._DOMStream = void 0;
      this._nodeStream = void 0;
      return this;
    }
    open(options) {
      const opening = this._impl.open(options);
      return isPromise(opening) ? opening.then(() => this) : this;
    }
    readRecordBatch(index) {
      return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
      return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
    }
    toNodeStream() {
      return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
    }
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    /** @nocollapse */
    static from(source) {
      if (source instanceof _RecordBatchReader) {
        return source;
      } else if (isArrowJSON(source)) {
        return fromArrowJSON(source);
      } else if (isFileHandle(source)) {
        return fromFileHandle(source);
      } else if (isPromise(source)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
          return yield _RecordBatchReader.from(yield source);
        }))();
      } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
        return fromAsyncByteStream(new AsyncByteStream(source));
      }
      return fromByteStream(new ByteStream(source));
    }
    /** @nocollapse */
    static readAll(source) {
      if (source instanceof _RecordBatchReader) {
        return source.isSync() ? readAllSync(source) : readAllAsync(source);
      } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {
        return readAllSync(source);
      }
      return readAllAsync(source);
    }
  };
  var RecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      return [...this];
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return __asyncGenerator(this, arguments, function* _a5() {
        yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
      });
    }
  };
  var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      var _a5, e_1, _b2, _c2;
      return __awaiter(this, void 0, void 0, function* () {
        const batches = new Array();
        try {
          for (var _d2 = true, _e2 = __asyncValues(this), _f2; _f2 = yield _e2.next(), _a5 = _f2.done, !_a5; ) {
            _c2 = _f2.value;
            _d2 = false;
            try {
              const batch = _c2;
              batches.push(batch);
            } finally {
              _d2 = true;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d2 && !_a5 && (_b2 = _e2.return))
              yield _b2.call(_e2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return batches;
      });
    }
    [Symbol.iterator]() {
      throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
  };
  var RecordBatchFileReader = class extends RecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var RecordBatchReaderImpl = class {
    get numDictionaries() {
      return this._dictionaryIndex;
    }
    get numRecordBatches() {
      return this._recordBatchIndex;
    }
    constructor(dictionaries = /* @__PURE__ */ new Map()) {
      this.closed = false;
      this.autoDestroy = true;
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.dictionaries = dictionaries;
    }
    isSync() {
      return false;
    }
    isAsync() {
      return false;
    }
    isFile() {
      return false;
    }
    isStream() {
      return false;
    }
    reset(schema) {
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.schema = schema;
      this.dictionaries = /* @__PURE__ */ new Map();
      return this;
    }
    _loadRecordBatch(header, body) {
      const children = this._loadVectors(header, body, this.schema.fields);
      const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children });
      return new RecordBatch(this.schema, data);
    }
    _loadDictionaryBatch(header, body) {
      const { id, isDelta } = header;
      const { dictionaries, schema } = this;
      const dictionary = dictionaries.get(id);
      if (isDelta || !dictionary) {
        const type = schema.dictionaries.get(id);
        const data = this._loadVectors(header.data, body, [type]);
        return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();
      }
      return dictionary.memoize();
    }
    _loadVectors(header, body, types) {
      return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
    }
  };
  var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
    }
    isSync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.iterator]() {
      return this;
    }
    cancel() {
      if (!this.closed && (this.closed = true)) {
        this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    }
    open(options) {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = this._reader.readSchema()))) {
          this.cancel();
        }
      }
      return this;
    }
    throw(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    }
    return(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    }
    next() {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return this.return();
    }
    _readNextMessageAndValidate(type) {
      return this._reader.readMessage(type);
    }
  };
  var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = new AsyncMessageReader(this._handle = source);
    }
    isAsync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && (this.closed = true)) {
          yield this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      });
    }
    open(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
            yield this.cancel();
          }
        }
        return this;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.throw(value);
        }
        return ITERATOR_DONE;
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.return(value);
        }
        return ITERATOR_DONE;
      });
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = yield this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            yield this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return yield this.return();
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this._reader.readMessage(type);
      });
    }
  };
  var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, dictionaries) {
      super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
    }
    isSync() {
      return true;
    }
    isFile() {
      return true;
    }
    open(options) {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && this._readDictionaryBatch(this._dictionaryIndex++);
        }
      }
      return super.open(options);
    }
    readRecordBatch(index) {
      var _a5;
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    }
    _readDictionaryBatch(index) {
      var _a5;
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    }
    _readFooter() {
      const { _handle } = this;
      const offset = _handle.size - magicAndPadding;
      const length = _handle.readInt32(offset);
      const buffer = _handle.readAt(offset - length, length);
      return Footer_.decode(buffer);
    }
    _readNextMessageAndValidate(type) {
      var _a5;
      if (!this._footer) {
        this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);
        if (block && this._handle.seek(block.offset)) {
          return this._reader.readMessage(type);
        }
      }
      return null;
    }
  };
  var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    constructor(source, ...rest) {
      const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
      const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
      super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);
    }
    isFile() {
      return true;
    }
    isAsync() {
      return true;
    }
    open(options) {
      const _super = Object.create(null, {
        open: { get: () => super.open }
      });
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = yield this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
          }
        }
        return yield _super.open.call(this, options);
      });
    }
    readRecordBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          yield this.open();
        }
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
          if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      });
    }
    _readDictionaryBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
          if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      });
    }
    _readFooter() {
      return __awaiter(this, void 0, void 0, function* () {
        const { _handle } = this;
        _handle._pending && (yield _handle._pending);
        const offset = _handle.size - magicAndPadding;
        const length = yield _handle.readInt32(offset);
        const buffer = yield _handle.readAt(offset - length, length);
        return Footer_.decode(buffer);
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this._footer) {
          yield this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && (yield this._handle.seek(block.offset))) {
            return yield this._reader.readMessage(type);
          }
        }
        return null;
      });
    }
  };
  var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source, dictionaries);
    }
    _loadVectors(header, body, types) {
      return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
    }
  };
  function shouldAutoDestroy(self2, options) {
    return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
  }
  function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
      if (!reader.open({ autoDestroy: false }).closed) {
        do {
          yield reader;
        } while (!reader.reset().open().closed);
      }
    } finally {
      reader.cancel();
    }
  }
  function readAllAsync(source) {
    return __asyncGenerator(this, arguments, function* readAllAsync_1() {
      const reader = yield __await(RecordBatchReader.from(source));
      try {
        if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
          do {
            yield yield __await(reader);
          } while (!(yield __await(reader.reset().open())).closed);
        }
      } finally {
        yield __await(reader.cancel());
      }
    });
  }
  function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
  }
  function fromByteStream(source) {
    const bytes = source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(/* @__PURE__ */ function* () {
    }()));
  }
  function fromAsyncByteStream(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const bytes = yield source.peek(magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
        return __asyncGenerator(this, arguments, function* () {
        });
      }()));
    });
  }
  function fromFileHandle(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const { size } = yield source.stat();
      const file = new AsyncRandomAccessFile(source, size);
      if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
        return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
      }
      return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
  }

  // node_modules/apache-arrow/visitor/vectorassembler.mjs
  var VectorAssembler = class _VectorAssembler extends Visitor {
    /** @nocollapse */
    static assemble(...args) {
      const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);
      const assembler = new _VectorAssembler();
      assembler.visitMany(unwrap(args));
      return assembler;
    }
    constructor() {
      super();
      this._byteLength = 0;
      this._nodes = [];
      this._buffers = [];
      this._bufferRegions = [];
    }
    visit(data) {
      if (data instanceof Vector) {
        this.visitMany(data.data);
        return this;
      }
      const { type } = data;
      if (!DataType.isDictionary(type)) {
        const { length, nullCount } = data;
        if (length > 2147483647) {
          throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
        }
        if (!DataType.isNull(type)) {
          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length, data.nullBitmap));
        }
        this.nodes.push(new FieldNode2(length, nullCount));
      }
      return super.visit(data);
    }
    visitNull(_null) {
      return this;
    }
    visitDictionary(data) {
      return this.visit(data.clone(data.type.indices));
    }
    get nodes() {
      return this._nodes;
    }
    get buffers() {
      return this._buffers;
    }
    get byteLength() {
      return this._byteLength;
    }
    get bufferRegions() {
      return this._bufferRegions;
    }
  };
  function addBuffer(values) {
    const byteLength = values.byteLength + 7 & ~7;
    this.buffers.push(values);
    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
  }
  function assembleUnion(data) {
    const { type, length, typeIds, valueOffsets } = data;
    addBuffer.call(this, typeIds);
    if (type.mode === UnionMode.Sparse) {
      return assembleNestedVector.call(this, data);
    } else if (type.mode === UnionMode.Dense) {
      if (data.offset <= 0) {
        addBuffer.call(this, valueOffsets);
        return assembleNestedVector.call(this, data);
      } else {
        const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
        const childLengths = new Int32Array(maxChildTypeId + 1);
        const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
        const shiftedOffsets = new Int32Array(length);
        const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
        for (let typeId, shift, index = -1; ++index < length; ) {
          if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
            shift = childOffsets[typeId] = unshiftedOffsets[typeId];
          }
          shiftedOffsets[index] = unshiftedOffsets[index] - shift;
          ++childLengths[typeId];
        }
        addBuffer.call(this, shiftedOffsets);
        for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren; ) {
          if (child = data.children[childIndex]) {
            const typeId = type.typeIds[childIndex];
            const childLength = Math.min(length, childLengths[typeId]);
            this.visit(child.slice(childOffsets[typeId], childLength));
          }
        }
      }
    }
    return this;
  }
  function assembleBoolVector(data) {
    let values;
    if (data.nullCount >= data.length) {
      return addBuffer.call(this, new Uint8Array(0));
    } else if ((values = data.values) instanceof Uint8Array) {
      return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));
    }
    return addBuffer.call(this, packBools(data.values));
  }
  function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
  }
  function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets));
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength));
    return this;
  }
  function assembleListVector(data) {
    const { length, valueOffsets } = data;
    if (valueOffsets) {
      addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
    }
    return this.visit(data.children[0]);
  }
  function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
  }
  VectorAssembler.prototype.visitBool = assembleBoolVector;
  VectorAssembler.prototype.visitInt = assembleFlatVector;
  VectorAssembler.prototype.visitFloat = assembleFlatVector;
  VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
  VectorAssembler.prototype.visitBinary = assembleFlatListVector;
  VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
  VectorAssembler.prototype.visitDate = assembleFlatVector;
  VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
  VectorAssembler.prototype.visitTime = assembleFlatVector;
  VectorAssembler.prototype.visitDecimal = assembleFlatVector;
  VectorAssembler.prototype.visitList = assembleListVector;
  VectorAssembler.prototype.visitStruct = assembleNestedVector;
  VectorAssembler.prototype.visitUnion = assembleUnion;
  VectorAssembler.prototype.visitInterval = assembleFlatVector;
  VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
  VectorAssembler.prototype.visitMap = assembleListVector;

  // node_modules/apache-arrow/ipc/writer.mjs
  var RecordBatchWriter = class extends ReadableInterop {
    /** @nocollapse */
    // @ts-ignore
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    /** @nocollapse */
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    constructor(options) {
      super();
      this._position = 0;
      this._started = false;
      this._sink = new AsyncByteQueue();
      this._schema = null;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
      this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
      this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
    }
    toString(sync = false) {
      return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
      return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
      if (isPromise(input)) {
        return input.then((x) => this.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(this, input);
      }
      return writeAll(this, input);
    }
    get closed() {
      return this._sink.closed;
    }
    [Symbol.asyncIterator]() {
      return this._sink[Symbol.asyncIterator]();
    }
    toDOMStream(options) {
      return this._sink.toDOMStream(options);
    }
    toNodeStream(options) {
      return this._sink.toNodeStream(options);
    }
    close() {
      return this.reset()._sink.close();
    }
    abort(reason) {
      return this.reset()._sink.abort(reason);
    }
    finish() {
      this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
      return this;
    }
    reset(sink = this._sink, schema = null) {
      if (sink === this._sink || sink instanceof AsyncByteQueue) {
        this._sink = sink;
      } else {
        this._sink = new AsyncByteQueue();
        if (sink && isWritableDOMStream(sink)) {
          this.toDOMStream({ type: "bytes" }).pipeTo(sink);
        } else if (sink && isWritableNodeStream(sink)) {
          this.toNodeStream({ objectMode: false }).pipe(sink);
        }
      }
      if (this._started && this._schema) {
        this._writeFooter(this._schema);
      }
      this._started = false;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      if (!schema || !compareSchemas(schema, this._schema)) {
        if (schema == null) {
          this._position = 0;
          this._schema = null;
        } else {
          this._started = true;
          this._schema = schema;
          this._writeSchema(schema);
        }
      }
      return this;
    }
    write(payload) {
      let schema = null;
      if (!this._sink) {
        throw new Error(`RecordBatchWriter is closed`);
      } else if (payload == null) {
        return this.finish() && void 0;
      } else if (payload instanceof Table && !(schema = payload.schema)) {
        return this.finish() && void 0;
      } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {
        return this.finish() && void 0;
      }
      if (schema && !compareSchemas(schema, this._schema)) {
        if (this._started && this._autoDestroy) {
          return this.close();
        }
        this.reset(this._sink, schema);
      }
      if (payload instanceof RecordBatch) {
        if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
          this._writeRecordBatch(payload);
        }
      } else if (payload instanceof Table) {
        this.writeAll(payload.batches);
      } else if (isIterable(payload)) {
        this.writeAll(payload);
      }
    }
    _writeMessage(message, alignment = 8) {
      const a = alignment - 1;
      const buffer = Message2.encode(message);
      const flatbufferSize = buffer.byteLength;
      const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
      const alignedSize = flatbufferSize + prefixSize + a & ~a;
      const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
      if (message.headerType === MessageHeader.RecordBatch) {
        this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      } else if (message.headerType === MessageHeader.DictionaryBatch) {
        this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      }
      if (!this._writeLegacyIpcFormat) {
        this._write(Int32Array.of(-1));
      }
      this._write(Int32Array.of(alignedSize - prefixSize));
      if (flatbufferSize > 0) {
        this._write(buffer);
      }
      return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
      if (this._started) {
        const buffer = toUint8Array(chunk);
        if (buffer && buffer.byteLength > 0) {
          this._sink.write(buffer);
          this._position += buffer.byteLength;
        }
      }
      return this;
    }
    _writeSchema(schema) {
      return this._writeMessage(Message2.from(schema));
    }
    // @ts-ignore
    _writeFooter(schema) {
      return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
      return this._write(MAGIC);
    }
    _writePadding(nBytes) {
      return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
      const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
      const message = Message2.from(recordBatch, byteLength);
      return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
      this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector([dictionary]));
      const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);
      const dictionaryBatch = new DictionaryBatch2(recordBatch, id, isDelta);
      const message = Message2.from(dictionaryBatch, byteLength);
      return this._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
      let buffer;
      let size, padding;
      for (let i = -1, n = buffers.length; ++i < n; ) {
        if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
          this._write(buffer);
          if ((padding = (size + 7 & ~7) - size) > 0) {
            this._writePadding(padding);
          }
        }
      }
      return this;
    }
    _writeDictionaries(batch) {
      for (let [id, dictionary] of batch.dictionaries) {
        let offset = this._dictionaryDeltaOffsets.get(id) || 0;
        if (offset === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset)).length > 0) {
          for (const data of dictionary.data) {
            this._writeDictionaryBatch(data, id, offset > 0);
            offset += data.length;
          }
        }
      }
      return this;
    }
  };
  var RecordBatchStreamWriter = class _RecordBatchStreamWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input, options) {
      const writer = new _RecordBatchStreamWriter(options);
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
  };
  var RecordBatchFileWriter = class _RecordBatchFileWriter extends RecordBatchWriter {
    /** @nocollapse */
    static writeAll(input) {
      const writer = new _RecordBatchFileWriter();
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
    constructor() {
      super();
      this._autoDestroy = true;
    }
    // @ts-ignore
    _writeSchema(schema) {
      return this._writeMagic()._writePadding(2);
    }
    _writeFooter(schema) {
      const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));
      return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
    }
  };
  function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof Table) {
      chunks = input.batches;
      writer.reset(void 0, input.schema);
    }
    for (const batch of chunks) {
      writer.write(batch);
    }
    return writer.finish();
  }
  function writeAllAsync(writer, batches) {
    var _a5, batches_1, batches_1_1;
    var _b2, e_1, _c2, _d2;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        for (_a5 = true, batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), _b2 = batches_1_1.done, !_b2; ) {
          _d2 = batches_1_1.value;
          _a5 = false;
          try {
            const batch = _d2;
            writer.write(batch);
          } finally {
            _a5 = true;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_a5 && !_b2 && (_c2 = batches_1.return))
            yield _c2.call(batches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return writer.finish();
    });
  }

  // node_modules/apache-arrow/io/whatwg/iterable.mjs
  function toDOMStream(source, options) {
    if (isAsyncIterable(source)) {
      return asyncIterableAsReadableDOMStream(source, options);
    }
    if (isIterable(source)) {
      return iterableAsReadableDOMStream(source, options);
    }
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
  }
  function iterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        next(controller, it2 || (it2 = source[Symbol.iterator]()));
      },
      pull(controller) {
        it2 ? next(controller, it2) : controller.close();
      },
      cancel() {
        ((it2 === null || it2 === void 0 ? void 0 : it2.return) && it2.return() || true) && (it2 = null);
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = it3.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    }
  }
  function asyncIterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, it2 || (it2 = source[Symbol.asyncIterator]()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          it2 ? yield next(controller, it2) : controller.close();
        });
      },
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          ((it2 === null || it2 === void 0 ? void 0 : it2.return) && (yield it2.return()) || true) && (it2 = null);
        });
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = yield it3.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // node_modules/apache-arrow/io/whatwg/builder.mjs
  function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
  }
  var BuilderTransform = class {
    constructor(options) {
      this._numChunks = 0;
      this._finished = false;
      this._bufferedSize = 0;
      const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
      this._controller = null;
      this._builder = makeBuilder(builderOptions);
      this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
      const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
      const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
      this["readable"] = new ReadableStream({
        ["cancel"]: () => {
          this._builder.clear();
        },
        ["pull"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        },
        ["start"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        }
      }, {
        "highWaterMark": readableHighWaterMark,
        "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
      });
      this["writable"] = new WritableStream({
        ["abort"]: () => {
          this._builder.clear();
        },
        ["write"]: () => {
          this._maybeFlush(this._builder, this._controller);
        },
        ["close"]: () => {
          this._maybeFlush(this._builder.finish(), this._controller);
        }
      }, {
        "highWaterMark": writableHighWaterMark,
        "size": (value) => this._writeValueAndReturnChunkSize(value)
      });
    }
    _writeValueAndReturnChunkSize(value) {
      const bufferedSize = this._bufferedSize;
      this._bufferedSize = this._getSize(this._builder.append(value));
      return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
      if (controller == null) {
        return;
      }
      if (this._bufferedSize >= controller.desiredSize) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (builder.finished) {
        if (builder.length > 0 || this._numChunks === 0) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (!this._finished && (this._finished = true)) {
          this._enqueue(controller, null);
        }
      }
    }
    _enqueue(controller, chunk) {
      this._bufferedSize = 0;
      this._controller = null;
      chunk == null ? controller.close() : controller.enqueue(chunk);
    }
  };
  var chunkLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;
  };
  var chunkByteLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;
  };

  // node_modules/apache-arrow/io/whatwg/reader.mjs
  function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield queue.close();
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, reader || (reader = yield open()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          reader ? yield next(controller, reader) : controller.close();
        });
      }
    });
    return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
    function open() {
      return __awaiter(this, void 0, void 0, function* () {
        return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
      });
    }
    function next(controller, reader2) {
      return __awaiter(this, void 0, void 0, function* () {
        let size = controller.desiredSize;
        let r = null;
        while (!(r = yield reader2.next()).done) {
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // node_modules/apache-arrow/io/whatwg/writer.mjs
  function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new AsyncByteStream(writer);
    const readable = new ReadableStream({
      // type: 'bytes',
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield reader.cancel();
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      }
    }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf = null;
        let size = controller.desiredSize;
        while (buf = yield reader.read(size || null)) {
          controller.enqueue(buf);
          if (size != null && (size -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // node_modules/apache-arrow/ipc/serialization.mjs
  function tableToIPC(table, type = "stream") {
    return (type === "stream" ? RecordBatchStreamWriter : RecordBatchFileWriter).writeAll(table).toUint8Array(true);
  }

  // node_modules/apache-arrow/Arrow.mjs
  var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {
    compareSchemas,
    compareFields,
    compareTypes
  });

  // node_modules/apache-arrow/Arrow.dom.mjs
  adapters_default.toDOMStream = toDOMStream;
  Builder["throughDOM"] = builderThroughDOMStream;
  RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

  // src/bindings/connection.ts
  var DuckDBConnection = class {
    /** Constructor */
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    /** Close a connection */
    close() {
      this._bindings.disconnect(this._conn);
    }
    /** Brave souls may use this function to consume the underlying connection id */
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    /** Run a query */
    query(text) {
      const buffer = this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    /** Send a query */
    async send(text) {
      let header = this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await new Promise((resolve, reject) => {
          try {
            resolve(this._bindings.pollPendingQuery(this._conn));
          } catch (e) {
            console.log(e);
            reject(e);
          }
        });
      }
      const iter = new ResultStreamIterator(this._bindings, this._conn, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
    /** Cancel a query that was sent earlier */
    cancelSent() {
      return this._bindings.cancelPendingQuery(this._conn);
    }
    /** Get table names */
    getTableNames(query) {
      return this._bindings.getTableNames(this._conn, query);
    }
    /** Create a prepared statement */
    prepare(text) {
      const stmt = this._bindings.createPrepared(this._conn, text);
      return new PreparedStatement(this._bindings, this._conn, stmt);
    }
    /** Create a scalar function */
    createScalarFunction(name, returns, func) {
      this._bindings.createScalarFunction(this._conn, name, returns, func);
    }
    /** Insert an arrow table */
    insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      this.insertArrowFromIPCStream(buffer, options);
    }
    /** Insert an arrow table from an ipc stream */
    insertArrowFromIPCStream(buffer, options) {
      this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    /** Inesrt csv file from path */
    insertCSVFromPath(path, options) {
      this._bindings.insertCSVFromPath(this._conn, path, options);
    }
    /** Insert json file from path */
    insertJSONFromPath(path, options) {
      this._bindings.insertJSONFromPath(this._conn, path, options);
    }
  };
  var ResultStreamIterator = class {
    constructor(bindings, conn, header) {
      this.bindings = bindings;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
    }
    next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      const bufferI8 = this.bindings.fetchQueryResults(this.conn);
      this._depleted = bufferI8.length == 0;
      return {
        done: this._depleted,
        value: bufferI8
      };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  var PreparedStatement = class {
    /** Constructor */
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    /** Close a prepared statement */
    close() {
      this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    /** Run a prepared statement */
    query(...params) {
      const buffer = this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    /** Send a prepared statement */
    send(...params) {
      const header = this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new ResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/bindings/udf_runtime.ts
  var TEXT_ENCODER = new TextEncoder();
  var TEXT_DECODER = new TextDecoder("utf-8");
  function storeError(mod, response, message) {
    const msgBuffer = TEXT_ENCODER.encode(message);
    const heapAddr = mod._malloc(msgBuffer.byteLength);
    const heapArray = mod.HEAPU8.subarray(heapAddr, heapAddr + msgBuffer.byteLength);
    heapArray.set(msgBuffer);
    mod.HEAPF64[(response >> 3) + 0] = 1;
    mod.HEAPF64[(response >> 3) + 1] = heapAddr;
    mod.HEAPF64[(response >> 3) + 2] = heapArray.byteLength;
  }
  function getTypeSize(ptype) {
    switch (ptype) {
      case "UINT8":
      case "INT8":
        return 1;
      case "INT32":
      case "FLOAT":
        return 4;
      case "INT64":
      case "UINT64":
      case "DOUBLE":
      case "VARCHAR":
        return 8;
      default:
        return 0;
    }
  }
  function ptrToArray(mod, ptr, ptype, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n * getTypeSize(ptype));
    switch (ptype) {
      case "UINT8":
        return new Uint8Array(heap.buffer, heap.byteOffset, n);
      case "INT8":
        return new Int8Array(heap.buffer, heap.byteOffset, n);
      case "INT32":
        return new Int32Array(heap.buffer, heap.byteOffset, n);
      case "FLOAT":
        return new Float32Array(heap.buffer, heap.byteOffset, n);
      case "DOUBLE":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      case "VARCHAR":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      default:
        return new Array(0);
    }
  }
  function ptrToUint8Array(mod, ptr, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n);
    return new Uint8Array(heap.buffer, heap.byteOffset, n);
  }
  function ptrToFloat64Array(mod, ptr, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n * 8);
    return new Float64Array(heap.buffer, heap.byteOffset, n);
  }
  function callScalarUDF(runtime, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) {
    try {
      const udf = runtime._udfFunctions.get(funcId);
      if (!udf) {
        storeError(mod, response, "Unknown UDF with id: " + funcId);
        return;
      }
      const rawDesc = TEXT_DECODER.decode(mod.HEAPU8.subarray(descPtr, descPtr + descSize));
      const desc = JSON.parse(rawDesc);
      const ptrs = ptrToFloat64Array(mod, ptrsPtr, ptrsSize / 8);
      const buildResolver = (arg) => {
        let validity = null;
        if (arg.validityBuffer !== void 0) {
          validity = ptrToUint8Array(mod, ptrs[arg.validityBuffer], desc.rows);
        }
        switch (arg.physicalType) {
          case "VARCHAR": {
            if (arg.dataBuffer === null || arg.dataBuffer === void 0) {
              throw new Error("malformed data view, expected data buffer for VARCHAR argument");
            }
            if (arg.lengthBuffer === null || arg.lengthBuffer === void 0) {
              throw new Error("malformed data view, expected data length buffer for VARCHAR argument");
            }
            const raw = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            const strings = [];
            const stringLengths = ptrToFloat64Array(mod, ptrs[arg.lengthBuffer], desc.rows);
            for (let j = 0; j < desc.rows; ++j) {
              if (validity != null && !validity[j]) {
                strings.push(null);
                continue;
              }
              const subarray = mod.HEAPU8.subarray(
                raw[j],
                raw[j] + stringLengths[j]
              );
              const str = TEXT_DECODER.decode(subarray);
              strings.push(str);
            }
            return (row) => strings[row];
          }
          case "STRUCT": {
            const tmp2 = {};
            const children = [];
            for (let j = 0; j < (arg.children?.length || 0); ++j) {
              const attr = arg.children[j];
              const child = buildResolver(attr);
              children.push((row) => {
                tmp2[attr.name] = child(row);
              });
            }
            if (validity != null) {
              return (row) => {
                if (!validity[row]) {
                  return null;
                }
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            } else {
              return (row) => {
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            }
          }
          default: {
            if (arg.dataBuffer === void 0) {
              throw new Error(
                "malformed data view, expected data buffer for argument of type: " + arg.physicalType
              );
            }
            const data = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            if (validity != null) {
              return (row) => !validity[row] ? null : data[row];
            } else {
              return (row) => data[row];
            }
          }
        }
      };
      const argResolvers = [];
      for (let i = 0; i < desc.args.length; ++i) {
        argResolvers.push(buildResolver(desc.args[i]));
      }
      const resultDataLen = desc.rows * getTypeSize(desc.ret.physicalType);
      const resultDataPtr = mod._malloc(resultDataLen);
      const resultData = ptrToArray(mod, resultDataPtr, desc.ret.physicalType, desc.rows);
      const resultValidityPtr = mod._malloc(desc.rows);
      const resultValidity = ptrToUint8Array(mod, resultValidityPtr, desc.rows);
      if (resultData.length == 0 || resultValidity.length == 0) {
        storeError(mod, response, "Can't create physical arrays for result");
        return;
      }
      let rawResultData = resultData;
      if (desc.ret.physicalType == "VARCHAR") {
        rawResultData = new Array(desc.rows);
      }
      const args = [];
      for (let i = 0; i < desc.args.length; ++i) {
        args.push(null);
      }
      for (let i = 0; i < desc.rows; ++i) {
        for (let j = 0; j < desc.args.length; ++j) {
          args[j] = argResolvers[j](i);
        }
        const res = udf.func(...args);
        rawResultData[i] = res;
        resultValidity[i] = res === void 0 || res === null ? 0 : 1;
      }
      let resultLengthsPtr = 0;
      switch (desc.ret.physicalType) {
        case "VARCHAR": {
          const resultDataUTF8 = new Array(0);
          resultLengthsPtr = mod._malloc(desc.rows * getTypeSize("DOUBLE"));
          const resultLengths = ptrToFloat64Array(mod, resultLengthsPtr, desc.rows);
          let totalLength = 0;
          for (let row = 0; row < desc.rows; ++row) {
            const utf8 = TEXT_ENCODER.encode(rawResultData[row] || "");
            resultDataUTF8.push(utf8);
            resultLengths[row] = utf8.length;
            totalLength += utf8.length;
          }
          const resultStringPtr = mod._malloc(totalLength);
          const resultStringBuf = mod.HEAPU8.subarray(resultStringPtr, resultStringPtr + totalLength);
          let writerOffset = 0;
          for (let row = 0; row < desc.rows; ++row) {
            resultData[row] = writerOffset;
            const resultUTF8 = resultDataUTF8[row];
            const writer = resultStringBuf.subarray(writerOffset, writerOffset + resultUTF8.length);
            writer.set(resultUTF8);
            writerOffset += resultUTF8.length;
          }
        }
      }
      const retLen = 3 * 8;
      const retPtr = mod._malloc(retLen);
      const retBuffer = ptrToFloat64Array(mod, retPtr, 3);
      retBuffer[0] = resultDataPtr;
      retBuffer[1] = resultValidityPtr;
      retBuffer[2] = resultLengthsPtr;
      mod.HEAPF64[(response >> 3) + 0] = 0;
      mod.HEAPF64[(response >> 3) + 1] = retPtr;
      mod.HEAPF64[(response >> 3) + 2] = 0;
    } catch (e) {
      storeError(mod, response, e.toString());
    }
  }

  // src/bindings/runtime.ts
  function TextDecoderWrapper() {
    const decoder3 = new TextDecoder();
    return (data) => {
      if (typeof SharedArrayBuffer !== "undefined" && data.buffer instanceof SharedArrayBuffer) {
        data = new Uint8Array(data);
      }
      return decoder3.decode(data);
    };
  }
  var decodeText = TextDecoderWrapper();
  function failWith(mod, msg) {
    console.error(`FAIL WITH: ${msg}`);
    mod.ccall("duckdb_web_fail_with", null, ["string"], [msg]);
  }
  function copyBuffer(mod, begin, length) {
    const buffer = mod.HEAPU8.subarray(begin, begin + length);
    const copy = new Uint8Array(new ArrayBuffer(buffer.byteLength));
    copy.set(buffer);
    return copy;
  }
  function readString(mod, begin, length) {
    return decodeText(mod.HEAPU8.subarray(begin, begin + length));
  }
  function callSRet(mod, funcName, argTypes, args) {
    const stackPointer = mod.stackSave();
    const response = mod.stackAlloc(3 * 8);
    argTypes.unshift("number");
    args.unshift(response);
    mod.ccall(funcName, null, argTypes, args);
    const status = mod.HEAPF64[(response >> 3) + 0];
    const data = mod.HEAPF64[(response >> 3) + 1];
    const dataSize = mod.HEAPF64[(response >> 3) + 2];
    mod.stackRestore(stackPointer);
    return [status, data, dataSize];
  }
  function dropResponseBuffers(mod) {
    mod.ccall("duckdb_web_clear_response", null, [], []);
  }

  // src/bindings/file_stats.ts
  var FileStatistics = class {
    constructor(u8array) {
      const f642 = new Float64Array(u8array.buffer, u8array.byteOffset, u8array.byteLength / 8);
      const blocks2 = new Uint8Array(new ArrayBuffer(u8array.byteLength));
      blocks2.set(u8array.subarray(7 * 8));
      this.totalFileReadsCold = f642[0];
      this.totalFileReadsAhead = f642[1];
      this.totalFileReadsCached = f642[2];
      this.totalFileWrites = f642[3];
      this.totalPageAccesses = f642[4];
      this.totalPageLoads = f642[5];
      this.blockSize = f642[6];
      this.blockStats = blocks2;
    }
    /** The block stats */
    getBlockStats(index, out) {
      out = out || {
        file_reads_cold: 0,
        file_reads_ahead: 0,
        file_reads_cached: 0,
        file_writes: 0,
        page_accesses: 0,
        page_loads: 0
      };
      out.file_writes = this.blockStats[index * 3 + 0] & 15;
      out.file_reads_cold = this.blockStats[index * 3 + 0] >> 4;
      out.file_reads_ahead = this.blockStats[index * 3 + 1] & 15;
      out.file_reads_cached = this.blockStats[index * 3 + 1] >> 4;
      out.page_accesses = this.blockStats[index * 3 + 1] & 15;
      out.page_loads = this.blockStats[index * 3 + 1] >> 4;
      return out;
    }
  };

  // src/json_typedef.ts
  function arrowToSQLType(type) {
    switch (type.typeId) {
      case Type.Binary:
        return { sqlType: "binary" };
      case Type.Bool:
        return { sqlType: "bool" };
      case Type.Date:
        return { sqlType: "date" };
      case Type.DateDay:
        return { sqlType: "date32[d]" };
      case Type.DateMillisecond:
        return { sqlType: "date64[ms]" };
      case Type.Decimal: {
        const dec = type;
        return { sqlType: "decimal", precision: dec.precision, scale: dec.scale };
      }
      case Type.Float:
        return { sqlType: "float" };
      case Type.Float16:
        return { sqlType: "float16" };
      case Type.Float32:
        return { sqlType: "float32" };
      case Type.Float64:
        return { sqlType: "float64" };
      case Type.Int:
        return { sqlType: "int32" };
      case Type.Int16:
        return { sqlType: "int16" };
      case Type.Int32:
        return { sqlType: "int32" };
      case Type.Int64:
        return { sqlType: "int64" };
      case Type.Uint16:
        return { sqlType: "uint16" };
      case Type.Uint32:
        return { sqlType: "uint32" };
      case Type.Uint64:
        return { sqlType: "uint64" };
      case Type.Uint8:
        return { sqlType: "uint8" };
      case Type.IntervalDayTime:
        return { sqlType: "interval[dt]" };
      case Type.IntervalYearMonth:
        return { sqlType: "interval[m]" };
      case Type.List: {
        const list = type;
        return {
          sqlType: "list",
          valueType: arrowToSQLType(list.valueType)
        };
      }
      case Type.FixedSizeBinary: {
        const bin = type;
        return { sqlType: "fixedsizebinary", byteWidth: bin.byteWidth };
      }
      case Type.Null:
        return { sqlType: "null" };
      case Type.Utf8:
        return { sqlType: "utf8" };
      case Type.Struct: {
        const struct_ = type;
        return {
          sqlType: "struct",
          fields: struct_.children.map((c) => arrowToSQLField(c.name, c.type))
        };
      }
      case Type.Map: {
        const map_ = type;
        return {
          sqlType: "map",
          keyType: arrowToSQLType(map_.keyType),
          valueType: arrowToSQLType(map_.valueType)
        };
      }
      case Type.Time:
        return { sqlType: "time[s]" };
      case Type.TimeMicrosecond:
        return { sqlType: "time[us]" };
      case Type.TimeMillisecond:
        return { sqlType: "time[ms]" };
      case Type.TimeNanosecond:
        return { sqlType: "time[ns]" };
      case Type.TimeSecond:
        return { sqlType: "time[s]" };
      case Type.Timestamp: {
        const ts = type;
        return { sqlType: "timestamp", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampSecond: {
        const ts = type;
        return { sqlType: "timestamp[s]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMicrosecond: {
        const ts = type;
        return { sqlType: "timestamp[us]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampNanosecond: {
        const ts = type;
        return { sqlType: "timestamp[ns]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMillisecond: {
        const ts = type;
        return { sqlType: "timestamp[ms]", timezone: ts.timezone || void 0 };
      }
    }
    throw new Error(`unsupported arrow type: ${type.toString()}`);
  }
  function arrowToSQLField(name, type) {
    const t = arrowToSQLType(type);
    t.name = name;
    return t;
  }

  // src/bindings/bindings_base.ts
  var TEXT_ENCODER2 = new TextEncoder();
  var DuckDBBindingsBase = class {
    constructor(logger, runtime) {
      /** The instance */
      this._instance = null;
      /** The loading promise */
      this._initPromise = null;
      /** The resolver for the open promise (called by onRuntimeInitialized) */
      this._initPromiseResolver = () => {
      };
      /** Instantiate the module */
      this.onInstantiationProgress = [];
      this._logger = logger;
      this._runtime = runtime;
      this._nextUDFId = 1;
    }
    /** Get the logger */
    get logger() {
      return this._logger;
    }
    /** Get the instance */
    get mod() {
      return this._instance;
    }
    /** Get the instance */
    get pthread() {
      return this.mod.PThread || null;
    }
    /** Instantiate the database */
    async instantiate(onProgress = (_) => {
    }) {
      if (this._instance != null) {
        return this;
      }
      if (this._initPromise != null) {
        this.onInstantiationProgress.push(onProgress);
        await this._initPromise;
      }
      this._initPromise = new Promise((resolve) => {
        this._initPromiseResolver = resolve;
      });
      this.onInstantiationProgress = [onProgress];
      this._instance = await this.instantiateImpl({
        print: console.log.bind(console),
        printErr: console.log.bind(console),
        onRuntimeInitialized: this._initPromiseResolver
      });
      await this._initPromise;
      this._initPromise = null;
      this.onInstantiationProgress = this.onInstantiationProgress.filter((x) => x != onProgress);
      return this;
    }
    /** Open a database with a config */
    open(config) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_open", ["string"], [JSON.stringify(config)]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Reset the database */
    reset() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_reset", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Get the version */
    getVersion() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_get_version", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const version = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return version;
    }
    /** Get the feature flags */
    getFeatureFlags() {
      return this.mod.ccall("duckdb_web_get_feature_flags", "number", [], []);
    }
    /** Tokenize a script */
    tokenize(text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_tokenize", ["string"], [text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    /** Connect to database */
    connect() {
      const conn = this.mod.ccall("duckdb_web_connect", "number", [], []);
      return new DuckDBConnection(this, conn);
    }
    /** Disconnect from database */
    disconnect(conn) {
      this.mod.ccall("duckdb_web_disconnect", null, ["number"], [conn]);
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "dropUDFFunctions",
            connectionId: conn
          });
        }
      }
    }
    /** Send a query and return the full result */
    runQuery(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_query_run", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /**
     *  Start a pending query asynchronously.
     *  This method returns either the arrow ipc schema or null.
     *  On null, the query has to be executed using `pollPendingQuery` until that returns != null.
     *  Results can then be fetched using `fetchQueryResults`
     */
    startPendingQuery(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_pending_query_start", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Poll a pending query */
    pollPendingQuery(conn) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_pending_query_poll", ["number"], [conn]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Cancel a pending query */
    cancelPendingQuery(conn) {
      return this.mod.ccall("duckdb_web_pending_query_cancel", "boolean", ["number"], [conn]);
    }
    /** Fetch query results */
    fetchQueryResults(conn) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_query_fetch_results", ["number"], [conn]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Get table names */
    getTableNames(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_get_tablenames", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    /** Create a scalar function */
    createScalarFunction(conn, name, returns, func) {
      const decl = {
        functionId: this._nextUDFId,
        name,
        returnType: arrowToSQLType(returns)
      };
      const def = {
        functionId: decl.functionId,
        connectionId: conn,
        name,
        returnType: returns,
        func
      };
      this._nextUDFId += 1;
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_udf_scalar_create",
        ["number", "string"],
        [conn, JSON.stringify(decl)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._udfFunctions = (globalThis.DUCKDB_RUNTIME._udfFunctions || /* @__PURE__ */ new Map()).set(
        def.functionId,
        def
      );
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "registerUDFFunction",
            udf: def
          });
        }
      }
    }
    /** Prepare a statement and return its identifier */
    createPrepared(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_prepared_create", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      return d;
    }
    /** Close a prepared statement */
    closePrepared(conn, statement) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_prepared_close", ["number", "number"], [conn, statement]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Execute a prepared statement and return the full result */
    runPrepared(conn, statement, params) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_run",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Execute a prepared statement and stream the result */
    sendPrepared(conn, statement, params) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_send",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    /** Insert record batches from an arrow ipc stream */
    insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const bufferPtr = this.mod._malloc(buffer.length);
      const bufferOfs = this.mod.HEAPU8.subarray(bufferPtr, bufferPtr + buffer.length);
      bufferOfs.set(buffer);
      const optJSON = options ? JSON.stringify(options) : "";
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_arrow_from_ipc_stream",
        ["number", "number", "number", "string"],
        [conn, bufferPtr, buffer.length, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Insert csv from path */
    insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_csv_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Insert json from path */
    insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_json_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Glob file infos */
    globFiles(path) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_glob_file_infos", ["string"], [path]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const infoStr = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      const info = JSON.parse(infoStr);
      if (info == null) {
        return [];
      }
      return info;
    }
    /** Register a file object URL */
    registerFileURL(name, url, proto, directIO = false) {
      if (url === void 0) {
        url = name;
      }
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string"],
        [name, url, proto, directIO]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Register file text */
    registerFileText(name, text) {
      const buffer = TEXT_ENCODER2.encode(text);
      this.registerFileBuffer(name, buffer);
    }
    /** Register a file buffer */
    registerFileBuffer(name, buffer) {
      const ptr = this.mod._malloc(buffer.length);
      const dst = this.mod.HEAPU8.subarray(ptr, ptr + buffer.length);
      dst.set(buffer);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_buffer",
        ["string", "number", "number"],
        [name, ptr, buffer.length]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Register a file object URL */
    registerFileHandle(name, handle, protocol, directIO) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string", "number", "boolean"],
        [name, name, protocol, directIO]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._files = (globalThis.DUCKDB_RUNTIME._files || /* @__PURE__ */ new Map()).set(name, handle);
      if (this.pthread) {
        for (const worker2 of this.pthread.runningWorkers) {
          worker2.postMessage({
            cmd: "registerFileHandle",
            fileName: name,
            fileHandle: handle
          });
        }
        for (const worker2 of this.pthread.unusedWorkers) {
          worker2.postMessage({
            cmd: "dropFileHandle",
            fileName: name
          });
        }
      }
    }
    /** Drop file */
    dropFile(name) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_file", ["string"], [name]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Drop files */
    dropFiles() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_files", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Flush all files */
    flushFiles() {
      this.mod.ccall("duckdb_web_flush_files", null, [], []);
    }
    /** Write a file to a path */
    copyFileToPath(name, path) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_path", ["string", "string"], [name, path]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    /** Write a file to a buffer */
    copyFileToBuffer(name) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_buffer", ["string"], [name]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const buffer = this.mod.HEAPU8.subarray(d, d + n);
      const copy = new Uint8Array(buffer.length);
      copy.set(buffer);
      dropResponseBuffers(this.mod);
      return copy;
    }
    /** Enable tracking of file statistics */
    collectFileStatistics(file, enable) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_collect_file_stats", ["string", "boolean"], [file, enable]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    /** Export file statistics */
    exportFileStatistics(file) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_export_file_stats", ["string"], [file]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      return new FileStatistics(this.mod.HEAPU8.subarray(d, d + n));
    }
  };

  // src/log.ts
  var VoidLogger = class {
    log(_entry) {
    }
  };

  // ../../node_modules/wasm-feature-detect/dist/esm/index.js
  var bulkMemory = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11]));
  var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
  var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
  var threads = () => (async (e) => {
    try {
      return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
    } catch (e2) {
      return false;
    }
  })(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

  // src/platform.ts
  var isNode = () => typeof navigator === "undefined" ? true : false;
  var bigInt64Array = null;
  var wasmExceptions = null;
  var wasmThreads = null;
  var wasmSIMD = null;
  var wasmBulkMemory = null;
  async function getPlatformFeatures() {
    if (bigInt64Array == null) {
      bigInt64Array = typeof BigInt64Array != "undefined";
    }
    if (wasmExceptions == null) {
      wasmExceptions = await exceptions();
    }
    if (wasmThreads == null) {
      wasmThreads = await threads();
    }
    if (wasmSIMD == null) {
      wasmSIMD = await simd();
    }
    if (wasmBulkMemory == null) {
      wasmBulkMemory = await bulkMemory();
    }
    return {
      bigInt64Array,
      crossOriginIsolated: isNode() || globalThis.crossOriginIsolated || false,
      wasmExceptions,
      wasmSIMD,
      wasmThreads,
      wasmBulkMemory
    };
  }
  async function selectBundle(bundles) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (platform.wasmSIMD && platform.wasmThreads && platform.crossOriginIsolated && bundles.coi) {
        return {
          mainModule: bundles.coi.mainModule,
          mainWorker: bundles.coi.mainWorker,
          pthreadWorker: bundles.coi.pthreadWorker
        };
      }
      if (bundles.eh) {
        return {
          mainModule: bundles.eh.mainModule,
          mainWorker: bundles.eh.mainWorker,
          pthreadWorker: null
        };
      }
    }
    return {
      mainModule: bundles.mvp.mainModule,
      mainWorker: bundles.mvp.mainWorker,
      pthreadWorker: null
    };
  }

  // src/utils/s3_helper.ts
  var import_js_sha256 = __toESM(require_sha256());
  var getHTTPHost = function(config, url, bucket) {
    if (config?.endpoint?.startsWith("http")) {
      const httpHost = `${config?.endpoint}`;
      const offset = httpHost.indexOf("://") + 3;
      return httpHost.substring(offset);
    } else if (config?.endpoint) {
      return `${bucket}.${config?.endpoint}`;
    } else {
      return `${bucket}.s3.amazonaws.com`;
    }
  };
  function getS3Params(config, url, method2) {
    const parsedS3Url = parseS3Url(url);
    let path = parsedS3Url.path;
    if (isPathStyleAccess(config)) {
      path = `/${parsedS3Url.bucket}${path}`;
    }
    return {
      url: path,
      query: "",
      host: getHTTPHost(config, url, parsedS3Url.bucket),
      region: config?.region ?? "",
      service: "s3",
      method: method2,
      accessKeyId: config?.accessKeyId ?? "",
      secretAccessKey: config?.secretAccessKey ?? "",
      sessionToken: config?.sessionToken ?? "",
      dateNow: (/* @__PURE__ */ new Date()).toISOString().replace(/-/g, "").split("T")[0],
      datetimeNow: (/* @__PURE__ */ new Date()).toISOString().replace(/-/g, "").replace(/:/g, "").split(".")[0] + "Z"
    };
  }
  function uriEncode(input, encode_slash = false) {
    const hexDigit = "0123456789ABCDEF";
    let result = "";
    for (let i = 0; i < input.length; i++) {
      const ch = input[i];
      if (ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z" || ch >= "0" && ch <= "9" || ch == "_" || ch == "-" || ch == "~" || ch == ".") {
        result += ch;
      } else if (ch == "/") {
        if (encode_slash) {
          result += "%2F";
        } else {
          result += ch;
        }
      } else {
        result += "%";
        result += hexDigit[ch.charCodeAt(0) >> 4];
        result += hexDigit[ch.charCodeAt(0) & 15];
      }
    }
    return result;
  }
  function createS3Headers(params, payloadParams = null) {
    const payloadHash = payloadParams?.contentHash ?? "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    const res = /* @__PURE__ */ new Map();
    res.set("x-amz-date", params.datetimeNow);
    res.set("x-amz-content-sha256", payloadHash);
    if (params.sessionToken) {
      res.set("x-amz-security-token", params.sessionToken);
    }
    let signedHeaders = "";
    if (payloadParams?.contentType) {
      signedHeaders += "content-type;";
    }
    signedHeaders += "host;x-amz-content-sha256;x-amz-date";
    if (params.sessionToken) {
      signedHeaders += ";x-amz-security-token";
    }
    let canonicalRequest = params.method + "\n" + uriEncode(params.url) + "\n" + params.query;
    if (payloadParams?.contentType) {
      canonicalRequest += "\ncontent-type:" + payloadParams?.contentType;
    }
    canonicalRequest += "\nhost:" + params.host + "\nx-amz-content-sha256:" + payloadHash + "\nx-amz-date:" + params.datetimeNow;
    if (params.sessionToken && params.sessionToken.length > 0) {
      canonicalRequest += "\nx-amz-security-token:" + params.sessionToken;
    }
    canonicalRequest += "\n\n" + signedHeaders + "\n" + payloadHash;
    const canonicalRequestHashStr = (0, import_js_sha256.sha256)(canonicalRequest);
    const stringToSign = "AWS4-HMAC-SHA256\n" + params.datetimeNow + "\n" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request\n" + canonicalRequestHashStr;
    const signKey = "AWS4" + params.secretAccessKey;
    const kDate = import_js_sha256.sha256.hmac.arrayBuffer(signKey, params.dateNow);
    const kRegion = import_js_sha256.sha256.hmac.arrayBuffer(kDate, params.region);
    const kService = import_js_sha256.sha256.hmac.arrayBuffer(kRegion, params.service);
    const signingKey = import_js_sha256.sha256.hmac.arrayBuffer(kService, "aws4_request");
    const signature = import_js_sha256.sha256.hmac(signingKey, stringToSign);
    res.set("Authorization", "AWS4-HMAC-SHA256 Credential=" + params.accessKeyId + "/" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request, SignedHeaders=" + signedHeaders + ", Signature=" + signature);
    return res;
  }
  var createS3HeadersFromS3Config = function(config, url, method2, contentType = null, payload = null) {
    const params = getS3Params(config, url, method2);
    const payloadParams = {
      contentType,
      contentHash: payload ? import_js_sha256.sha256.hex(payload) : null
    };
    return createS3Headers(params, payloadParams);
  };
  function addS3Headers(xhr, config, url, method2, contentType = null, payload = null) {
    if (config?.accessKeyId || config?.sessionToken) {
      const headers = createS3HeadersFromS3Config(config, url, method2, contentType, payload);
      headers.forEach((value, header) => {
        xhr.setRequestHeader(header, value);
      });
      if (contentType) {
        xhr.setRequestHeader("content-type", contentType);
      }
    }
  }
  function parseS3Url(url) {
    if (url.indexOf("s3://") != 0) {
      throw new Error("URL needs to start with s3://");
    }
    const slashPos = url.indexOf("/", 5);
    if (slashPos == -1) {
      throw new Error("URL needs to contain a '/' after the host");
    }
    const bucket = url.substring(5, slashPos);
    if (!bucket) {
      throw new Error("URL needs to contain a bucket name");
    }
    const path = url.substring(slashPos);
    if (!path) {
      throw new Error("URL needs to contain key");
    }
    return { bucket, path };
  }
  function isPathStyleAccess(config) {
    if (config?.endpoint?.startsWith("http")) {
      return true;
    }
    return false;
  }
  function getHTTPUrl(config, url) {
    const parsedUrl = parseS3Url(url);
    if (isPathStyleAccess(config)) {
      return `${config?.endpoint}/${parsedUrl.bucket}` + parsedUrl.path;
    }
    return "https://" + getHTTPHost(config, url, parsedUrl.bucket) + parsedUrl.path;
  }

  // src/bindings/runtime_browser.ts
  var BROWSER_RUNTIME = {
    _files: /* @__PURE__ */ new Map(),
    _fileInfoCache: /* @__PURE__ */ new Map(),
    _udfFunctions: /* @__PURE__ */ new Map(),
    _globalFileInfo: null,
    getFileInfo(mod, fileId) {
      try {
        const cached = BROWSER_RUNTIME._fileInfoCache.get(fileId);
        const [s, d, n] = callSRet(
          mod,
          "duckdb_web_fs_get_file_info_by_id",
          ["number", "number"],
          [fileId, cached?.cacheEpoch || 0]
        );
        if (s !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return cached;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info = JSON.parse(infoStr);
        if (info == null) {
          return null;
        }
        const file = { ...info, blob: null };
        BROWSER_RUNTIME._fileInfoCache.set(fileId, file);
        return file;
      } catch (e) {
        console.log(e);
        return null;
      }
    },
    getGlobalFileInfo(mod) {
      try {
        const [s, d, n] = callSRet(
          mod,
          "duckdb_web_get_global_file_info",
          ["number"],
          [BROWSER_RUNTIME._globalFileInfo?.cacheEpoch || 0]
        );
        if (s !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return BROWSER_RUNTIME._globalFileInfo;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info = JSON.parse(infoStr);
        if (info == null) {
          return null;
        }
        BROWSER_RUNTIME._globalFileInfo = { ...info, blob: null };
        return BROWSER_RUNTIME._globalFileInfo;
      } catch (e) {
        console.log(e);
        return null;
      }
    },
    testPlatformFeature: (_mod, feature) => {
      switch (feature) {
        case 1:
          return typeof BigInt64Array !== "undefined";
        default:
          console.warn(`test for unknown feature: ${feature}`);
          return false;
      }
    },
    getDefaultDataProtocol(mod) {
      return 2 /* BROWSER_FILEREADER */;
    },
    openFile: (mod, fileId, flags) => {
      try {
        BROWSER_RUNTIME._fileInfoCache.delete(fileId);
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (flags & 1 /* FILE_FLAGS_READ */ && flags & 2 /* FILE_FLAGS_WRITE */) {
              throw new Error(
                `Opening file ${file.fileName} failed: cannot open file with both read and write flags set`
              );
            } else if (flags & 32 /* FILE_FLAGS_APPEND */) {
              throw new Error(
                `Opening file ${file.fileName} failed: appending to HTTP/S3 files is not supported`
              );
            } else if (flags & 2 /* FILE_FLAGS_WRITE */) {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.send(null);
              if (xhr.status != 200 && xhr.status != 404) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Unexpected return status from server (${xhr.status})`
                );
              } else if (xhr.status == 404 && !(flags & 8 /* FILE_FLAGS_FILE_CREATE */ || flags & 16 /* FILE_FLAGS_FILE_CREATE_NEW */)) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Cannot write to non-existent file without FILE_FLAGS_FILE_CREATE or FILE_FLAGS_FILE_CREATE_NEW flag.`
                );
              }
              const data = mod._malloc(1);
              const src = new Uint8Array();
              mod.HEAPU8.set(src, data);
              const result = mod._malloc(2 * 8);
              mod.HEAPF64[(result >> 3) + 0] = 1;
              mod.HEAPF64[(result >> 3) + 1] = data;
              return result;
            } else if (flags != 1 /* FILE_FLAGS_READ */) {
              throw new Error(`Opening file ${file.fileName} failed: unsupported file flags: ${flags}`);
            }
            let contentLength = null;
            let error = null;
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.setRequestHeader("Range", `bytes=0-`);
              xhr.send(null);
              contentLength = xhr.getResponseHeader("Content-Length");
              if (contentLength !== null && xhr.status == 206) {
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                mod.HEAPF64[(result >> 3) + 1] = 0;
                return result;
              }
            } catch (e) {
              error = e;
              console.warn(`HEAD request with range header failed: ${e}`);
            }
            if (file.allowFullHttpReads) {
              if (contentLength !== null && +contentLength > 1) {
                const xhr2 = new XMLHttpRequest();
                if (file.dataProtocol == 5 /* S3 */) {
                  xhr2.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                  addS3Headers(xhr2, file.s3Config, file.dataUrl, "GET");
                } else {
                  xhr2.open("GET", file.dataUrl, false);
                }
                xhr2.setRequestHeader("Range", `bytes=0-0`);
                xhr2.send(null);
                const contentLength2 = xhr2.getResponseHeader("Content-Length");
                if (xhr2.status == 206 && contentLength2 !== null && +contentLength2 == 1) {
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                  mod.HEAPF64[(result >> 3) + 1] = 0;
                  return result;
                }
                if (xhr2.status == 200 && contentLength2 !== null && +contentLength2 == +contentLength) {
                  console.warn(`fall back to full HTTP read for: ${file.dataUrl}`);
                  const data = mod._malloc(xhr2.response.byteLength);
                  const src = new Uint8Array(xhr2.response, 0, xhr2.response.byteLength);
                  mod.HEAPU8.set(src, data);
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = xhr2.response.byteLength;
                  mod.HEAPF64[(result >> 3) + 1] = data;
                  return result;
                }
              }
              console.warn(`falling back to full HTTP read for: ${file.dataUrl}`);
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              if (xhr.status == 200) {
                const data = mod._malloc(xhr.response.byteLength);
                const src = new Uint8Array(xhr.response, 0, xhr.response.byteLength);
                mod.HEAPU8.set(src, data);
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = xhr.response.byteLength;
                mod.HEAPF64[(result >> 3) + 1] = data;
                return result;
              }
            }
            if (error != null) {
              throw new Error(`Reading file ${file.fileName} failed with error: ${error}`);
            }
            return 0;
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (handle) {
              const result2 = mod._malloc(2 * 8);
              mod.HEAPF64[(result2 >> 3) + 0] = handle.size;
              mod.HEAPF64[(result2 >> 3) + 1] = 0;
              return result2;
            }
            console.warn(`Buffering missing file: ${file.fileName}`);
            const result = mod._malloc(2 * 8);
            const buffer = mod._malloc(1);
            mod.HEAPF64[(result >> 3) + 0] = 1;
            mod.HEAPF64[(result >> 3) + 1] = buffer;
            return result;
          }
        }
      } catch (e) {
        console.error(e.toString());
        failWith(mod, e.toString());
      }
      return 0;
    },
    glob: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          if (xhr.status != 200 && xhr.status !== 206) {
            if (!BROWSER_RUNTIME.getGlobalFileInfo(mod)?.allowFullHttpReads) {
              failWith(mod, `HEAD request failed: ${path}, with full http reads are disabled`);
              return;
            }
            const xhr2 = new XMLHttpRequest();
            if (path.startsWith("s3://")) {
              const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
              xhr2.open("GET", getHTTPUrl(globalInfo?.s3Config, path), false);
              addS3Headers(xhr2, globalInfo?.s3Config, path, "HEAD");
            } else {
              xhr2.open("GET", path, false);
            }
            xhr2.setRequestHeader("Range", `bytes=0-0`);
            xhr2.send(null);
            if (xhr2.status != 200 && xhr2.status !== 206) {
              failWith(mod, `HEAD and GET requests failed: ${path}`);
              return;
            }
            const contentLength = xhr2.getResponseHeader("Content-Length");
            if (contentLength && +contentLength > 1) {
              console.warn(`Range request for ${path} did not return a partial response: ${xhr2.status} "${xhr2.statusText}"`);
            }
          }
          mod.ccall("duckdb_web_fs_glob_add_path", null, ["string"], [path]);
        }
      } catch (e) {
        console.log(e);
        failWith(mod, e.toString());
        return 0;
      }
    },
    checkFile: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          return xhr.status == 206 || xhr.status == 200;
        }
      } catch (e) {
        console.log(e);
        return false;
      }
      return false;
    },
    syncFile: (_mod, _fileId) => {
    },
    closeFile: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      BROWSER_RUNTIME._fileInfoCache.delete(fileId);
      switch (file?.dataProtocol) {
        case 0 /* BUFFER */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          break;
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle.flush();
        }
      }
    },
    truncateFile: (mod, fileId, newSize) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, `Cannot truncate a http file`);
          return;
        case 5 /* S3 */:
          failWith(mod, `Cannot truncate an s3 file`);
          return;
        case 0 /* BUFFER */:
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, `truncateFile not implemented`);
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle.truncate(newSize);
        }
      }
      return 0;
    },
    readFile(mod, fileId, buf, bytes, location) {
      if (bytes == 0) {
        return 0;
      }
      try {
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (!file.dataUrl) {
              throw new Error(`Missing data URL for file ${fileId}`);
            }
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file?.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file?.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.setRequestHeader("Range", `bytes=${location}-${location + bytes - 1}`);
              xhr.send(null);
              if (xhr.status == 206 || xhr.status == 200 && bytes == xhr.response.byteLength && location == 0) {
                const src = new Uint8Array(xhr.response, 0, Math.min(xhr.response.byteLength, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else if (xhr.status == 200) {
                console.warn(`Range request for ${file.dataUrl} did not return a partial response: ${xhr.status} "${xhr.statusText}"`);
                const src = new Uint8Array(xhr.response, location, Math.min(xhr.response.byteLength - location, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else {
                throw new Error(
                  `Range request for ${file.dataUrl} did returned non-success status: ${xhr.status} "${xhr.statusText}"`
                );
              }
            } catch (e) {
              console.log(e);
              throw new Error(`Range request for ${file.dataUrl} failed with error: ${e}"`);
            }
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle) {
              throw new Error(`No HTML5 file registered with name: ${file.fileName}`);
            }
            const sliced = handle.slice(location, location + bytes);
            const data = new Uint8Array(new FileReaderSync().readAsArrayBuffer(sliced));
            mod.HEAPU8.set(data, buf);
            return data.byteLength;
          }
          case 3 /* BROWSER_FSACCESS */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle) {
              throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
            }
            const out = mod.HEAPU8.subarray(buf, buf + bytes);
            return handle.read(out, { at: location });
          }
        }
        return 0;
      } catch (e) {
        console.log(e);
        failWith(mod, e.toString());
        return 0;
      }
    },
    writeFile: (mod, fileId, buf, bytes, location) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, "Cannot write to HTTP file");
          return 0;
        case 5 /* S3 */: {
          const buffer = mod.HEAPU8.subarray(buf, buf + bytes);
          const xhr = new XMLHttpRequest();
          xhr.open("PUT", getHTTPUrl(file?.s3Config, file.dataUrl), false);
          addS3Headers(xhr, file?.s3Config, file.dataUrl, "PUT", "", buffer);
          xhr.send(buffer);
          if (xhr.status !== 200) {
            failWith(mod, "Failed writing file: HTTP " + xhr.status);
            return 0;
          }
          return bytes;
        }
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, "cannot write using the html5 file reader api");
          return 0;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          const input = mod.HEAPU8.subarray(buf, buf + bytes);
          return handle.write(input, { at: location });
        }
      }
      return 0;
    },
    getLastFileModificationTime: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 2 /* BROWSER_FILEREADER */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw Error(`No handle available for file: ${file.fileName}`);
          }
          return 0;
        }
        case 4 /* HTTP */:
        case 5 /* S3 */:
          return (/* @__PURE__ */ new Date()).getTime();
      }
      return 0;
    },
    checkDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`checkDirectory: ${path}`);
      return false;
    },
    createDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`createDirectory: ${path}`);
    },
    removeDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`removeDirectory: ${path}`);
    },
    listDirectoryEntries: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`listDirectoryEntries: ${path}`);
      return false;
    },
    moveFile: (mod, fromPtr, fromLen, toPtr, toLen) => {
      const from = readString(mod, fromPtr, fromLen);
      const to = readString(mod, toPtr, toLen);
      const handle = BROWSER_RUNTIME._files?.get(from);
      if (handle !== void 0) {
        BROWSER_RUNTIME._files.delete(handle);
        BROWSER_RUNTIME._files.set(to, handle);
      }
      for (const [key, value] of BROWSER_RUNTIME._fileInfoCache?.entries() || []) {
        if (value.dataUrl == from) {
          BROWSER_RUNTIME._fileInfoCache.delete(key);
          break;
        }
      }
      return true;
    },
    removeFile: (_mod, _pathPtr, _pathLen) => {
    },
    callScalarUDF: (mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) => {
      callScalarUDF(BROWSER_RUNTIME, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize);
    }
  };
  var runtime_browser_default = BROWSER_RUNTIME;

  // src/bindings/bindings_browser_mvp.ts
  var import_duckdb_mvp = __toESM(require_duckdb_mvp());

  // src/bindings/bindings_browser_base.ts
  var DuckDBBrowserBindings = class extends DuckDBBindingsBase {
    /** Constructor */
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL) {
      super(logger, runtime);
      this.mainModuleURL = mainModuleURL;
      this.pthreadWorkerURL = pthreadWorkerURL;
    }
    /** Locate a file */
    locateFile(path, prefix) {
      if (path.endsWith(".wasm")) {
        return this.mainModuleURL;
      }
      if (path.endsWith(".worker.js")) {
        if (!this.pthreadWorkerURL) {
          throw new Error("Missing DuckDB worker URL!");
        }
        return this.pthreadWorkerURL;
      }
      throw new Error(`WASM instantiation requested unexpected file: prefix=${prefix} path=${path}`);
    }
    /** Instantiate the wasm module */
    instantiateWasm(imports, success) {
      globalThis.DUCKDB_RUNTIME = this._runtime;
      const handlers = this.onInstantiationProgress;
      if (WebAssembly.instantiateStreaming) {
        if (typeof TransformStream === "function") {
          const fetchWithProgress = async () => {
            const request = new Request(this.mainModuleURL);
            const response2 = await fetch(request);
            const contentLengthHdr = response2.headers.get("content-length");
            const contentLength = contentLengthHdr ? parseInt(contentLengthHdr, 10) || 0 : 0;
            const start = /* @__PURE__ */ new Date();
            const progress = {
              startedAt: start,
              updatedAt: start,
              bytesTotal: contentLength || 0,
              bytesLoaded: 0
            };
            const tracker = {
              transform(chunk, ctrl) {
                progress.bytesLoaded += chunk.byteLength;
                const now = /* @__PURE__ */ new Date();
                if (now.getTime() - progress.updatedAt.getTime() < 20) {
                  progress.updatedAt = now;
                  ctrl.enqueue(chunk);
                  return;
                }
                for (const p of handlers) {
                  p(progress);
                }
                ctrl.enqueue(chunk);
              }
            };
            const ts = new TransformStream(tracker);
            return new Response(response2.body?.pipeThrough(ts), response2);
          };
          const response = fetchWithProgress();
          WebAssembly.instantiateStreaming(response, imports).then((output) => {
            success(output.instance, output.module);
          });
        } else {
          console.warn("instantiating without progress handler since transform streams are unavailable");
          const request = new Request(this.mainModuleURL);
          WebAssembly.instantiateStreaming(fetch(request), imports).then((output) => {
            success(output.instance, output.module);
          });
        }
      } else if (typeof XMLHttpRequest == "function") {
        const xhr = new XMLHttpRequest();
        const url = this.mainModuleURL;
        const start = /* @__PURE__ */ new Date();
        const progress = {
          startedAt: start,
          updatedAt: start,
          bytesTotal: 0,
          bytesLoaded: 0
        };
        xhr.open("GET", url);
        xhr.responseType = "arraybuffer";
        xhr.onerror = (error) => {
          this.logger.log({
            timestamp: /* @__PURE__ */ new Date(),
            level: 4 /* ERROR */,
            origin: 3 /* BINDINGS */,
            topic: 5 /* INSTANTIATE */,
            event: 2 /* ERROR */,
            value: "Failed to load WASM: " + error
          });
          throw new Error(error.toString());
        };
        xhr.onprogress = (e) => {
          progress.bytesTotal = e.total;
          progress.bytesLoaded = e.loaded;
          const now = /* @__PURE__ */ new Date();
          if (now.getTime() - progress.updatedAt.getTime() < 20) {
            progress.updatedAt = now;
            return;
          }
          for (const p of handlers) {
            p(progress);
          }
        };
        xhr.onload = () => {
          WebAssembly.instantiate(xhr.response, imports).then((output) => {
            success(output.instance, output.module);
          }).catch((error) => {
            this.logger.log({
              timestamp: /* @__PURE__ */ new Date(),
              level: 4 /* ERROR */,
              origin: 3 /* BINDINGS */,
              topic: 5 /* INSTANTIATE */,
              event: 2 /* ERROR */,
              value: "Failed to instantiate WASM: " + error
            });
            throw new Error(error);
          });
        };
        xhr.send();
      } else {
        console.warn("instantiating with manual fetch since streaming instantiation and xhrs are unavailable");
        const run = async () => {
          const request = new Request(this.mainModuleURL);
          const response = await fetch(request);
          const buffer = await response.arrayBuffer();
          WebAssembly.instantiate(buffer, imports).then((output) => {
            success(output.instance, output.module);
          });
        };
        run();
      }
      return [];
    }
  };

  // src/bindings/bindings_browser_mvp.ts
  var DuckDB = class extends DuckDBBrowserBindings {
    /** Constructor */
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime, mainModuleURL, pthreadWorkerURL);
    }
    /** Instantiate the bindings */
    instantiateImpl(moduleOverrides) {
      return (0, import_duckdb_mvp.default)({
        ...moduleOverrides,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/bindings/bindings_browser_eh.ts
  var import_duckdb_eh = __toESM(require_duckdb_eh());
  var DuckDB2 = class extends DuckDBBrowserBindings {
    /** Constructor */
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime, mainModuleURL, pthreadWorkerURL);
    }
    /** Instantiate the bindings */
    instantiateImpl(moduleOverrides) {
      return (0, import_duckdb_eh.default)({
        ...moduleOverrides,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/targets/duckdb-browser-blocking.ts
  async function createDuckDB(bundles, logger, runtime) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (bundles.eh) {
        return new DuckDB2(logger, runtime, bundles.eh.mainModule);
      }
    }
    return new DuckDB(logger, runtime, bundles.mvp.mainModule);
  }

  // src/parallel/async_connection.ts
  var AsyncDuckDBConnection = class {
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    /** Access the database bindings */
    get bindings() {
      return this._bindings;
    }
    /** Disconnect from the database */
    async close() {
      return this._bindings.disconnect(this._conn);
    }
    /** Brave souls may use this function to consume the underlying connection id */
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    /** Run a query */
    async query(text) {
      this._bindings.logger.log({
        timestamp: /* @__PURE__ */ new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      const buffer = await this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync(), "Reader is not sync");
      console.assert(reader.isFile(), "Reader is not file");
      return new Table(reader);
    }
    /** Send a query */
    async send(text) {
      this._bindings.logger.log({
        timestamp: /* @__PURE__ */ new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      let header = await this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await this._bindings.pollPendingQuery(this._conn);
      }
      const iter = new AsyncResultStreamIterator(this._bindings, this._conn, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
    /** Cancel a query that was sent earlier */
    async cancelSent() {
      return await this._bindings.cancelPendingQuery(this._conn);
    }
    /** Get table names */
    async getTableNames(query) {
      return await this._bindings.getTableNames(this._conn, query);
    }
    /** Create a prepared statement */
    async prepare(text) {
      const stmt = await this._bindings.createPrepared(this._conn, text);
      return new AsyncPreparedStatement(this._bindings, this._conn, stmt);
    }
    /** Insert an arrow table */
    async insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      await this.insertArrowFromIPCStream(buffer, options);
    }
    /** Insert an arrow table from an ipc stream */
    async insertArrowFromIPCStream(buffer, options) {
      await this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    /** Insert csv file from path */
    async insertCSVFromPath(text, options) {
      await this._bindings.insertCSVFromPath(this._conn, text, options);
    }
    /** Insert json file from path */
    async insertJSONFromPath(text, options) {
      await this._bindings.insertJSONFromPath(this._conn, text, options);
    }
  };
  var AsyncResultStreamIterator = class {
    constructor(db2, conn, header) {
      this.db = db2;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
      this._inFlight = null;
    }
    async next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      let buffer;
      if (this._inFlight != null) {
        buffer = await this._inFlight;
        this._inFlight = null;
      } else {
        buffer = await this.db.fetchQueryResults(this.conn);
      }
      this._depleted = buffer.length == 0;
      if (!this._depleted) {
        this._inFlight = this.db.fetchQueryResults(this.conn);
      }
      return {
        done: this._depleted,
        value: buffer
      };
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var AsyncPreparedStatement = class {
    /** Constructor */
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    /** Close a prepared statement */
    async close() {
      await this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    /** Run a prepared statement */
    async query(...params) {
      const buffer = await this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    /** Send a prepared statement */
    async send(...params) {
      const header = await this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new AsyncResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/parallel/worker_request.ts
  var WorkerTask = class {
    constructor(type, data) {
      this.promiseResolver = () => {
      };
      this.promiseRejecter = () => {
      };
      this.type = type;
      this.data = data;
      this.promise = new Promise(
        (resolve, reject) => {
          this.promiseResolver = resolve;
          this.promiseRejecter = reject;
        }
      );
    }
  };

  // src/parallel/async_bindings.ts
  var TEXT_ENCODER3 = new TextEncoder();
  var AsyncDuckDB = class {
    constructor(logger, worker2 = null) {
      /** Instantiate the module */
      this._onInstantiationProgress = [];
      /** The worker */
      this._worker = null;
      /** The promise for the worker shutdown */
      this._workerShutdownPromise = null;
      /** Make the worker as terminated */
      this._workerShutdownResolver = () => {
      };
      /** The next message id */
      this._nextMessageId = 0;
      /** The pending requests */
      this._pendingRequests = /* @__PURE__ */ new Map();
      this._logger = logger;
      this._onMessageHandler = this.onMessage.bind(this);
      this._onErrorHandler = this.onError.bind(this);
      this._onCloseHandler = this.onClose.bind(this);
      if (worker2 != null)
        this.attach(worker2);
    }
    /** Get the logger */
    get logger() {
      return this._logger;
    }
    /** Attach to worker */
    attach(worker2) {
      this._worker = worker2;
      this._worker.addEventListener("message", this._onMessageHandler);
      this._worker.addEventListener("error", this._onErrorHandler);
      this._worker.addEventListener("close", this._onCloseHandler);
      this._workerShutdownPromise = new Promise(
        (resolve, _reject) => {
          this._workerShutdownResolver = resolve;
        }
      );
    }
    /** Detach from worker */
    detach() {
      if (!this._worker)
        return;
      this._worker.removeEventListener("message", this._onMessageHandler);
      this._worker.removeEventListener("error", this._onErrorHandler);
      this._worker.removeEventListener("close", this._onCloseHandler);
      this._worker = null;
      this._workerShutdownResolver(null);
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    /** Kill the worker */
    async terminate() {
      if (!this._worker)
        return;
      this._worker.terminate();
      this._worker = null;
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    /** Post a task */
    async postTask(task, transfer = []) {
      if (!this._worker) {
        console.error("cannot send a message since the worker is not set!");
        return void 0;
      }
      const mid = this._nextMessageId++;
      this._pendingRequests.set(mid, task);
      this._worker.postMessage(
        {
          messageId: mid,
          type: task.type,
          data: task.data
        },
        transfer
      );
      return await task.promise;
    }
    /** Received a message */
    onMessage(event) {
      const response = event.data;
      switch (response.type) {
        case "LOG" /* LOG */: {
          this._logger.log(response.data);
          return;
        }
        case "INSTANTIATE_PROGRESS" /* INSTANTIATE_PROGRESS */: {
          for (const p of this._onInstantiationProgress) {
            p(response.data);
          }
          return;
        }
      }
      const task = this._pendingRequests.get(response.requestId);
      if (!task) {
        console.warn(`unassociated response: [${response.requestId}, ${response.type.toString()}]`);
        return;
      }
      this._pendingRequests.delete(response.requestId);
      if (response.type == "ERROR" /* ERROR */) {
        const e = new Error(response.data.message);
        e.name = response.data.name;
        if (Object.getOwnPropertyDescriptor(e, "stack")?.writable) {
          e.stack = response.data.stack;
        }
        task.promiseRejecter(e);
        return;
      }
      switch (task.type) {
        case "CLOSE_PREPARED" /* CLOSE_PREPARED */:
        case "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */:
        case "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */:
        case "DISCONNECT" /* DISCONNECT */:
        case "DROP_FILE" /* DROP_FILE */:
        case "DROP_FILES" /* DROP_FILES */:
        case "FLUSH_FILES" /* FLUSH_FILES */:
        case "INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */:
        case "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */:
        case "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */:
        case "OPEN" /* OPEN */:
        case "PING" /* PING */:
        case "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */:
        case "REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */:
        case "REGISTER_FILE_URL" /* REGISTER_FILE_URL */:
        case "RESET" /* RESET */:
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "INSTANTIATE" /* INSTANTIATE */:
          this._onInstantiationProgress = [];
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */:
          if (response.type == "FILE_INFOS" /* FILE_INFOS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_VERSION" /* GET_VERSION */:
          if (response.type == "VERSION_STRING" /* VERSION_STRING */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */:
          if (response.type == "FEATURE_FLAGS" /* FEATURE_FLAGS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_TABLE_NAMES" /* GET_TABLE_NAMES */:
          if (response.type == "TABLE_NAMES" /* TABLE_NAMES */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "TOKENIZE" /* TOKENIZE */:
          if (response.type == "SCRIPT_TOKENS" /* SCRIPT_TOKENS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */:
          if (response.type == "FILE_BUFFER" /* FILE_BUFFER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */:
          if (response.type == "FILE_STATISTICS" /* FILE_STATISTICS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CONNECT" /* CONNECT */:
          if (response.type == "CONNECTION_INFO" /* CONNECTION_INFO */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "RUN_PREPARED" /* RUN_PREPARED */:
        case "RUN_QUERY" /* RUN_QUERY */:
          if (response.type == "QUERY_RESULT" /* QUERY_RESULT */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "SEND_PREPARED" /* SEND_PREPARED */:
          if (response.type == "QUERY_RESULT_HEADER" /* QUERY_RESULT_HEADER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "START_PENDING_QUERY" /* START_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */:
          this._onInstantiationProgress = [];
          if (response.type == "SUCCESS" /* SUCCESS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */:
          if (response.type == "QUERY_RESULT_CHUNK" /* QUERY_RESULT_CHUNK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CREATE_PREPARED" /* CREATE_PREPARED */:
          if (response.type == "PREPARED_STATEMENT_ID" /* PREPARED_STATEMENT_ID */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
      }
      task.promiseRejecter(new Error(`unexpected response type: ${response.type.toString()}`));
    }
    /** Received an error */
    onError(event) {
      console.error(event);
      console.error(`error in duckdb worker: ${event.message}`);
      this._pendingRequests.clear();
    }
    /** The worker was closed */
    onClose() {
      this._workerShutdownResolver(null);
      if (this._pendingRequests.size != 0) {
        console.warn(`worker terminated with ${this._pendingRequests.size} pending requests`);
        return;
      }
      this._pendingRequests.clear();
    }
    /** Reset the duckdb */
    async reset() {
      const task = new WorkerTask("RESET" /* RESET */, null);
      return await this.postTask(task);
    }
    /** Ping the worker thread */
    async ping() {
      const task = new WorkerTask("PING" /* PING */, null);
      await this.postTask(task);
    }
    /** Try to drop a file */
    async dropFile(name) {
      const task = new WorkerTask("DROP_FILE" /* DROP_FILE */, name);
      return await this.postTask(task);
    }
    /** Try to drop files */
    async dropFiles() {
      const task = new WorkerTask("DROP_FILES" /* DROP_FILES */, null);
      return await this.postTask(task);
    }
    /** Flush all files */
    async flushFiles() {
      const task = new WorkerTask("FLUSH_FILES" /* FLUSH_FILES */, null);
      return await this.postTask(task);
    }
    /** Open the database */
    async instantiate(mainModuleURL, pthreadWorkerURL = null, progress = (_p2) => {
    }) {
      this._onInstantiationProgress.push(progress);
      const task = new WorkerTask(
        "INSTANTIATE" /* INSTANTIATE */,
        [mainModuleURL, pthreadWorkerURL]
      );
      return await this.postTask(task);
    }
    /** Get the version */
    async getVersion() {
      const task = new WorkerTask("GET_VERSION" /* GET_VERSION */, null);
      const version = await this.postTask(task);
      return version;
    }
    /** Get the feature flags */
    async getFeatureFlags() {
      const task = new WorkerTask(
        "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */,
        null
      );
      const feature = await this.postTask(task);
      return feature;
    }
    /** Open a new database */
    async open(config) {
      const task = new WorkerTask("OPEN" /* OPEN */, config);
      await this.postTask(task);
    }
    /** Tokenize a script text */
    async tokenize(text) {
      const task = new WorkerTask("TOKENIZE" /* TOKENIZE */, text);
      const tokens = await this.postTask(task);
      return tokens;
    }
    /** Connect to the database */
    async connectInternal() {
      const task = new WorkerTask("CONNECT" /* CONNECT */, null);
      return await this.postTask(task);
    }
    /** Connect to the database */
    async connect() {
      const cid = await this.connectInternal();
      return new AsyncDuckDBConnection(this, cid);
    }
    /** Disconnect from the database */
    async disconnect(conn) {
      const task = new WorkerTask(
        "DISCONNECT" /* DISCONNECT */,
        conn
      );
      await this.postTask(task);
    }
    /** Run a query */
    async runQuery(conn, text) {
      const task = new WorkerTask(
        "RUN_QUERY" /* RUN_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Start a pending query */
    async startPendingQuery(conn, text) {
      const task = new WorkerTask(
        "START_PENDING_QUERY" /* START_PENDING_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Poll a pending query */
    async pollPendingQuery(conn) {
      const task = new WorkerTask(
        "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    /** Cancel a pending query */
    async cancelPendingQuery(conn) {
      const task = new WorkerTask(
        "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    /** Fetch query results */
    async fetchQueryResults(conn) {
      const task = new WorkerTask(
        "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */,
        conn
      );
      return await this.postTask(task);
    }
    /** Get table names */
    async getTableNames(conn, text) {
      const task = new WorkerTask(
        "GET_TABLE_NAMES" /* GET_TABLE_NAMES */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Prepare a statement and return its identifier */
    async createPrepared(conn, text) {
      const task = new WorkerTask(
        "CREATE_PREPARED" /* CREATE_PREPARED */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    /** Close a prepared statement */
    async closePrepared(conn, statement) {
      const task = new WorkerTask(
        "CLOSE_PREPARED" /* CLOSE_PREPARED */,
        [conn, statement]
      );
      await this.postTask(task);
    }
    /** Execute a prepared statement and return the full result */
    async runPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "RUN_PREPARED" /* RUN_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    /** Execute a prepared statement and stream the result */
    async sendPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "SEND_PREPARED" /* SEND_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    /** Glob file infos */
    async globFiles(path) {
      const task = new WorkerTask(
        "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */,
        path
      );
      return await this.postTask(task);
    }
    /** Register file text */
    async registerFileText(name, text) {
      const buffer = TEXT_ENCODER3.encode(text);
      await this.registerFileBuffer(name, buffer);
    }
    /** Register a file path. */
    async registerFileURL(name, url, proto, directIO) {
      if (url === void 0) {
        url = name;
      }
      const task = new WorkerTask("REGISTER_FILE_URL" /* REGISTER_FILE_URL */, [name, url, proto, directIO]);
      await this.postTask(task);
    }
    /** Register an empty file buffer. */
    async registerEmptyFileBuffer(name) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name, new Uint8Array()]
      );
      await this.postTask(task);
    }
    /** Register a file buffer. */
    async registerFileBuffer(name, buffer) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name, buffer]
      );
      await this.postTask(task, [buffer.buffer]);
    }
    /** Register a file handle. */
    async registerFileHandle(name, handle, protocol, directIO) {
      const task = new WorkerTask("REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */, [name, handle, protocol, directIO]);
      await this.postTask(task, []);
    }
    /** Enable file statistics */
    async collectFileStatistics(name, enable) {
      const task = new WorkerTask(
        "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */,
        [name, enable]
      );
      await this.postTask(task, []);
    }
    /** Export file statistics */
    async exportFileStatistics(name) {
      const task = new WorkerTask(
        "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */,
        name
      );
      return await this.postTask(task, []);
    }
    /** Copy a file to a buffer. */
    async copyFileToBuffer(name) {
      const task = new WorkerTask(
        "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */,
        name
      );
      return await this.postTask(task);
    }
    /** Copy a file to a path. */
    async copyFileToPath(name, path) {
      const task = new WorkerTask(
        "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */,
        [name, path]
      );
      await this.postTask(task);
    }
    /** Insert arrow from an ipc stream */
    async insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const task = new WorkerTask("INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */, [conn, buffer, options]);
      await this.postTask(task, [buffer.buffer]);
    }
    /** Insert a csv file */
    async insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
    /** Insert a json file */
    async insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
  };

  // src/worker.ts
  var import_web_worker = __toESM(require_browser());
  async function createWorker(url) {
    const request = new Request(url);
    const workerScript = await fetch(request);
    const workerURL = URL.createObjectURL(await workerScript.blob());
    return new import_web_worker.default(workerURL);
  }

  // test/all_types.test.ts
  var MINIMUM_DATE_STR = "-271821-04-20";
  var MINIMUM_DATE = new Date(Date.UTC(-271821, 3, 20));
  var MAXIMUM_DATE_STR = "275760-09-13";
  var MAXIMUM_DATE = new Date(Date.UTC(275760, 8, 13));
  var NOT_IMPLEMENTED_TYPES = [
    "timestamp_s",
    "timestamp_ms",
    "timestamp_ns",
    "timestamp_tz",
    "hugeint",
    "dec_18_6",
    "dec38_10",
    "uuid",
    "map",
    "json",
    "date_array",
    "timestamp_array",
    "timestamptz_array"
  ];
  var PARTIALLY_IMPLEMENTED_TYPES = ["date", "timestamp"];
  var PARTIALLY_IMPLEMENTED_ANSWER_MAP = {
    date: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null],
    timestamp: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null]
  };
  var PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS = [
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Date,'${MAXIMUM_DATE_STR}'::Date,null],i + 1)) as date`,
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Timestamp,'${MAXIMUM_DATE_STR}'::Timestamp,null],i + 1)) as timestamp`
  ];
  var TYPES_REQUIRING_CUSTOM_CONFIG = ["dec_4_1", "dec_9_4"];
  var FULLY_IMPLEMENTED_ANSWER_MAP = {
    bool: [false, true, null],
    tinyint: [-128, 127, null],
    smallint: [-32768, 32767, null],
    int: [-2147483648, 2147483647, null],
    utinyint: [0, 255, null],
    usmallint: [0, 65535, null],
    uint: [0, 4294967295, null],
    ubigint: [BigInt(0), BigInt("18446744073709551615"), null],
    bigint: [BigInt("-9223372036854775808"), BigInt("9223372036854775807"), null],
    // Note that we multiply by thousand (and add 999 for the max) because the value returned by DuckDB is in microseconds,
    // whereas the Date object is in milliseconds.
    time: [BigInt(0), BigInt((/* @__PURE__ */ new Date("1970-01-01T23:59:59.999+00:00")).valueOf()) * BigInt(1e3) + BigInt(999), null],
    time_tz: [
      BigInt(0),
      BigInt((/* @__PURE__ */ new Date("1970-01-01T23:59:59.999+00:00")).valueOf()) * BigInt(1e3) + BigInt(999),
      null
    ],
    interval: [new Int32Array([0, 0]), new Int32Array([0, 0]), null],
    float: [-34028234663852886e22, 34028234663852886e22, null],
    double: [-17976931348623157e292, 17976931348623157e292, null],
    varchar: ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goo\0se", null],
    small_enum: ["DUCK_DUCK_ENUM", "GOOSE", null],
    medium_enum: ["enum_0", "enum_299", null],
    large_enum: ["enum_0", "enum_69999", null],
    int_array: [[], [42, 999, null, null, -42], null],
    double_array: [[], [42, NaN, Infinity, -Infinity, null, -42], null],
    varchar_array: [[], ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goose", null, ""], null],
    nested_int_array: [[], [[], [42, 999, null, null, -42], null, [], [42, 999, null, null, -42]], null],
    struct: ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null],
    struct_of_arrays: [
      '{"a":null,"b":null}',
      '{"a":[42,999,null,null,-42],"b":["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}","goose",null,""]}',
      null
    ],
    array_of_structs: [[], ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null], null],
    // XXX sometimes throws
    // map: ['{}', '{"key1":"🦆🦆🦆🦆🦆🦆","key2":"goose"}', null],
    blob: [
      Uint8Array.from([
        116,
        104,
        105,
        115,
        105,
        115,
        97,
        108,
        111,
        110,
        103,
        98,
        108,
        111,
        98,
        0,
        119,
        105,
        116,
        104,
        110,
        117,
        108,
        108,
        98,
        121,
        116,
        101,
        115
      ]),
      Uint8Array.from([0, 0, 0, 97]),
      null
    ]
  };
  var REPLACE_COLUMNS = PARTIALLY_IMPLEMENTED_TYPES.concat(NOT_IMPLEMENTED_TYPES).concat(TYPES_REQUIRING_CUSTOM_CONFIG);
  function unpack(v) {
    if (v === null)
      return null;
    if (v instanceof Vector) {
      const ret = Array.from(v.toArray());
      for (let i = 0; i < ret.length; i++) {
        if (!v.isValid(i)) {
          ret[i] = null;
        }
      }
      return unpack(ret);
    } else if (v instanceof Array) {
      const ret = [];
      for (let i = 0; i < v.length; i++) {
        ret[i] = unpack(v[i]);
      }
      return ret;
    } else if (v instanceof Uint8Array) {
      return v;
    } else if (v.toJSON instanceof Function) {
      return JSON.stringify(v.toJSON());
    }
    return v;
  }
  function getValue(x) {
    if (typeof x?.valueOf === "function") {
      return x.valueOf();
    } else {
      return x;
    }
  }
  var ALL_TYPES_TEST = [
    {
      name: "fully supported types",
      query: `SELECT * REPLACE('not_implemented' as map) FROM test_all_types()`,
      skip: REPLACE_COLUMNS,
      answerMap: FULLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: REPLACE_COLUMNS.length + Object.keys(FULLY_IMPLEMENTED_ANSWER_MAP).length,
      queryConfig: null
    },
    {
      name: "partially supported types",
      query: `SELECT ${PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS.join(", ")}
                FROM range(0, 3) tbl(i)`,
      skip: [],
      answerMap: PARTIALLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: PARTIALLY_IMPLEMENTED_TYPES.length,
      queryConfig: null
    },
    {
      name: "types with custom config",
      query: `SELECT ${TYPES_REQUIRING_CUSTOM_CONFIG.join(",")} FROM test_all_types()`,
      skip: [],
      answerMap: {
        dec_4_1: [-999.9000000000001, 999.9000000000001, null],
        dec_9_4: [-99999.99990000001, 99999.99990000001, null]
      },
      answerCount: TYPES_REQUIRING_CUSTOM_CONFIG.length,
      queryConfig: {
        castDecimalToDouble: true
      }
    }
  ];
  function testAllTypes(db2) {
    let conn;
    beforeEach(() => {
      db2().flushFiles();
    });
    afterEach(() => {
      if (conn) {
        conn.close();
        conn = null;
      }
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Test All Types", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = db2().connect();
          const results = conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s of test.skip) {
            skip.set(s, true);
          }
          for (let i = 0; i < results.numCols; i++) {
            const name = results.schema.fields[i].name;
            if (name == "bit")
              continue;
            const col = results.getChildAt(i);
            if (skip.get(name))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(unpack(getValue(col.get(0)))).withContext(name).toEqual(test.answerMap[name][0]);
            expect(unpack(getValue(col.get(1)))).withContext(name).toEqual(test.answerMap[name][1]);
            expect(col.get(2)).withContext(name).toEqual(test.answerMap[name][2]);
          }
        });
      }
    });
  }
  function testAllTypesAsync(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Test All Types Async", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, async () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = await db2().connect();
          const results = await conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s of test.skip) {
            skip.set(s, true);
          }
          for (let i = 0; i < results.numCols; i++) {
            const name = results.schema.fields[i].name;
            if (name == "bit")
              continue;
            const col = results.getChildAt(i);
            if (skip.get(name))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(Object.keys(test.answerMap)).toContain(name);
            expect(unpack(getValue(col.get(0)))).withContext(name + "|" + col?.toString() + "|[0]").toEqual(test.answerMap[name][0]);
            expect(unpack(getValue(col.get(1)))).withContext(name + "|" + col?.toString() + "|[1]").toEqual(test.answerMap[name][1]);
            expect(col.get(2)).withContext(name + "|" + col?.toString() + "|[2]").toEqual(test.answerMap[name][2]);
          }
        });
      }
    });
  }

  // test/httpfs_test.ts
  var BUCKET_NAME = "test-bucket";
  var ACCESS_KEY_ID = "S3RVER";
  var ACCESS_KEY_SECRET = "S3RVER";
  var S3_ENDPOINT = "http://localhost:4923";
  var S3_REGION = "eu-west-1";
  var setAwsConfig = async function(conn, type = 1 /* VALID */) {
    switch (type) {
      case 0 /* EMPTY */:
        await conn.query("SET s3_region='';");
        await conn.query("SET s3_access_key_id='';");
        await conn.query("SET s3_secret_access_key='';");
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 1 /* VALID */:
        await conn.query(`SET s3_region='${S3_REGION}';`);
        await conn.query(`SET s3_access_key_id='${ACCESS_KEY_ID}';`);
        await conn.query(`SET s3_secret_access_key='${ACCESS_KEY_SECRET}';`);
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 2 /* INVALID */:
        await conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        await conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        await conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        await conn.query("SET s3_session_token='INVALIDSESSIONTOKEN';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
    }
  };
  function testHTTPFS(sdb) {
    let conn;
    const getModule = function() {
      let module2 = null;
      conn.useUnsafe((bindings, con_number) => {
        module2 = bindings.mod;
      });
      expect(module2).toBeDefined();
      return module2;
    };
    const reset = async () => {
      sdb().reset();
      conn = sdb().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS", () => {
      it("s3 config is set correctly", async () => {
        const module2 = getModule();
        const globalFileInfo = runtime_browser_default.getGlobalFileInfo(module2);
        const cacheEpoch = globalFileInfo.cacheEpoch;
        expect(globalFileInfo?.s3Config).toBeDefined();
        expect(globalFileInfo?.s3Config?.region).toEqual("");
        expect(globalFileInfo?.s3Config?.accessKeyId).toEqual("");
        expect(globalFileInfo?.s3Config?.secretAccessKey).toEqual("");
        expect(globalFileInfo?.s3Config?.sessionToken).toEqual("");
        expect(globalFileInfo?.s3Config?.endpoint).toEqual("");
        conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        conn.query("SET s3_session_token='ANICESESSIONTOKEN';");
        conn.query("SET s3_endpoint='s3.some.sort.of.cloud';");
        const globalFileInfoUpdated = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoUpdated?.s3Config).toBeDefined();
        expect(globalFileInfoUpdated?.cacheEpoch).toEqual(cacheEpoch + 5);
        const params = getS3Params(globalFileInfoUpdated?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(params.url).toEqual("/testfile.txt");
        expect(params.query).toEqual("");
        expect(params.host).toEqual("test-bucket.s3.some.sort.of.cloud");
        expect(params.region).toEqual("a-very-remote-and-non-existent-s3-region");
        expect(params.service).toEqual("s3");
        expect(params.method).toEqual("GET");
        expect(params.accessKeyId).toEqual("THISACCESSKEYIDISNOTVALID");
        expect(params.secretAccessKey).toEqual("THISSECRETACCESSKEYISNOTVALID");
        expect(params.sessionToken).toEqual("ANICESESSIONTOKEN");
        conn.query("SET s3_endpoint='http://localhost:1337';");
        const globalFileInfoFullHttpEndpoint = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsFullHttpEndpoint = getS3Params(
          globalFileInfoFullHttpEndpoint?.s3Config,
          "s3://test-bucket/testfile.txt",
          "GET"
        );
        expect(paramsFullHttpEndpoint.host).toEqual("localhost:1337");
        await reset();
        const globalFileInfoCleared = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsCleared = getS3Params(globalFileInfoCleared?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(paramsCleared.url).toEqual("/testfile.txt");
        expect(paramsCleared.query).toEqual("");
        expect(paramsCleared.host).toEqual("test-bucket.s3.amazonaws.com");
        expect(paramsCleared.region).toEqual("");
        expect(paramsCleared.service).toEqual("s3");
        expect(paramsCleared.method).toEqual("GET");
        expect(paramsCleared.accessKeyId).toEqual("");
        expect(paramsCleared.secretAccessKey).toEqual("");
        expect(paramsCleared.sessionToken).toEqual("");
      });
      it("url parsing is correct", () => {
        const module2 = getModule();
        conn.query("SET s3_endpoint='';");
        const globalFileInfoDefault = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDefault?.s3Config).toBeDefined();
        const defaultUrl = getHTTPUrl(globalFileInfoDefault?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(defaultUrl).toEqual(`https://${BUCKET_NAME}.s3.amazonaws.com/test-file.csv`);
        conn.query("SET s3_endpoint='https://duckdblabs.com';");
        const globalFileInfoFullUrl = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoFullUrl?.s3Config).toBeDefined();
        const fullUrl = getHTTPUrl(globalFileInfoFullUrl?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(fullUrl).toEqual(`https://duckdblabs.com/${BUCKET_NAME}/test-file.csv`);
        conn.query("SET s3_endpoint='duckdblabs.com';");
        const globalFileInfoDomain = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDomain?.s3Config).toBeDefined();
        const domainOnlyUrl = getHTTPUrl(globalFileInfoDomain?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(domainOnlyUrl).toEqual(`https://${BUCKET_NAME}.duckdblabs.com/test-file.csv`);
      });
      it("s3 helper passes validation", () => {
        const testParams1 = {
          url: "/",
          query: "",
          host: "my-precious-bucket.s3.amazonaws.com",
          region: "us-east-1",
          service: "s3",
          method: "GET",
          accessKeyId: "AKIAIOSFODNN7EXAMPLE",
          secretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
          sessionToken: "",
          dateNow: "20150915",
          datetimeNow: "20150915T124500Z"
        };
        const result = createS3Headers(testParams1).get("Authorization");
        expect(result).toEqual(
          "AWS4-HMAC-SHA256 Credential=AKIAIOSFODNN7EXAMPLE/20150915/us-east-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=182072eb53d85c36b2d791a1fa46a12d23454ec1e921b02075c23aee40166d5a"
        );
        const canonical_query_string = "delimiter=%2F&encoding-type=url&list-type=2&prefix=";
        const testParams2 = {
          url: "/",
          query: canonical_query_string,
          host: "my-precious-bucket.s3.eu-west-1.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "GET",
          accessKeyId: "ASIAYSPIOYDTHTBIITVC",
          secretAccessKey: "vs1BZPxSL2qVARBSg5vCMKJsavCoEPlo/HSHRaVe",
          sessionToken: "IQoJb3JpZ2luX2VjENX//////////wEaCWV1LXdlc3QtMSJHMEUCIQDfjzs9BYHrEXDMU/NR+PHV1uSTr7CSVSQdjKSfiPRLdgIgCCztF0VMbi9+uHHAfBVKhV4t9MlUrQg3VAOIsLxrWyoqlAIIHRAAGgw1ODk0MzQ4OTY2MTQiDOGl2DsYxENcKCbh+irxARe91faI+hwUhT60sMGRFg0GWefKnPclH4uRFzczrDOcJlAAaQRJ7KOsT8BrJlrY1jSgjkO7PkVjPp92vi6lJX77bg99MkUTJActiOKmd84XvAE5bFc/jFbqechtBjXzopAPkKsGuaqAhCenXnFt6cwq+LZikv/NJGVw7TRphLV+Aq9PSL9XwdzIgsW2qXwe1c3rxDNj53yStRZHVggdxJ0OgHx5v040c98gFphzSULHyg0OY6wmCMTYcswpb4kO2IIi6AiD9cY25TlwPKRKPi5CdBsTPnyTeW62u7PvwK0fTSy4ZuJUuGKQnH2cKmCXquEwoOHEiQY6nQH9fzY/EDGHMRxWWhxu0HiqIfsuFqC7GS0p0ToKQE+pzNsvVwMjZc+KILIDDQpdCWRIwu53I5PZy2Cvk+3y4XLvdZKQCsAKqeOc4c94UAS4NmUT7mCDOuRV0cLBVM8F0JYBGrUxyI+YoIvHhQWmnRLuKgTb5PkF7ZWrXBHFWG5/tZDOvBbbaCWTlRCL9b0Vpg5+BM/81xd8jChP4w83",
          dateNow: "20210904",
          datetimeNow: "20210904T121746Z"
        };
        const result2 = createS3Headers(testParams2).get("Authorization");
        expect(result2).toEqual(
          "AWS4-HMAC-SHA256 Credential=ASIAYSPIOYDTHTBIITVC/20210904/eu-west-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date;x-amz-security-token, Signature=4d9d6b59d7836b6485f6ad822de97be40287da30347d83042ea7fbed530dc4c0"
        );
        const testParams3 = {
          url: "/correct_auth_test.csv",
          query: "",
          host: "test-bucket-ceiveran.s3.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "PUT",
          accessKeyId: "S3RVER",
          secretAccessKey: "S3RVER",
          sessionToken: "",
          dateNow: "20220121",
          datetimeNow: "20220121T141452Z"
        };
        const test3PayloadParams = {
          contentHash: "28a0cf6ac5c4cb73793091fe6ecc6a68bf90855ac9186158748158f50241bb0c",
          contentType: "text/data;charset=utf-8"
        };
        const result3 = createS3Headers(testParams3, test3PayloadParams).get("Authorization");
        expect(result3).toEqual(
          "AWS4-HMAC-SHA256 Credential=S3RVER/20220121/eu-west-1/s3/aws4_request, SignedHeaders=content-type;host;x-amz-content-sha256;x-amz-date, Signature=5d9a6cbfaa78a6d0f2ab7df0445e2f1cc9c80cd3655ac7de9e7219c036f23f02"
        );
        expect(uriEncode("/category=Books/")).toEqual("/category%3DBooks/");
        expect(uriEncode("/?category=Books&title=Ducks Retreat/")).toEqual(
          "/%3Fcategory%3DBooks%26title%3DDucks%20Retreat/"
        );
        expect(uriEncode("/?category=Books&title=Ducks Retreat/", true)).toEqual(
          "%2F%3Fcategory%3DBooks%26title%3DDucks%20Retreat%2F"
        );
      });
    });
  }
  function testHTTPFSAsync(adb2, resolveData2, baseDir) {
    let conn;
    const putTestFileToS3 = async function(fileName, format, test_data) {
      await adb2().registerFileBuffer("test_file.parquet", test_data);
      if (!conn) {
        conn = await adb2().connect();
      }
      await setAwsConfig(conn, 1 /* VALID */);
      await conn.query(`CREATE TABLE test_table AS (SELECT * FROM parquet_scan('test_file.parquet'));`);
      await conn.query(`COPY test_table TO 's3://${BUCKET_NAME}/${fileName}.${format}' (FORMAT '${format}');`);
      await adb2().flushFiles();
      await adb2().dropFiles();
    };
    const assertTestFileResultCorrect = async function(result, test_data) {
      await adb2().registerFileBuffer("test_file_baseline.parquet", test_data);
      await conn.query(`SELECT * FROM parquet_scan('test_file_baseline.parquet');`);
    };
    const reset = async () => {
      await adb2().reset();
      conn = await adb2().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS Async", () => {
      it("can fetch https file", async () => {
        const results = await conn.query(
          `select * from "https://raw.githubusercontent.com/duckdb/duckdb-wasm/master/data/test.csv";`
        );
        expect(BigInt(results.getChildAt(2)?.get(2))).toEqual(BigInt(9n));
      });
      it("can read and write csv file from S3 with correct auth credentials", async () => {
        let data = await resolveData2("/uni/studenten.parquet");
        await setAwsConfig(conn);
        await putTestFileToS3("correct_auth_test", "csv", data);
        const results_with_auth = await conn.query(`select * from "s3://${BUCKET_NAME}/correct_auth_test.csv";`);
        data = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data);
      });
      it("can read and write parquet file from S3 with correct auth credentials", async () => {
        let data = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("correct_auth_test", "parquet", data);
        await setAwsConfig(conn);
        const results_with_auth = await conn.query(
          `select * from "s3://${BUCKET_NAME}/correct_auth_test.parquet";`
        );
        data = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data);
      });
      it("can not read a file with incorrect credentials", async () => {
        const data = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("incorrect_auth_test", "parquet", data);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select * from "s3://${BUCKET_NAME}/incorrect_auth_test.csv";`)
        ).toBeRejected();
      });
      it("properly invalidates file caches on settings update.", async () => {
        const data = await resolveData2("/tpch/0_01/parquet/lineitem.parquet");
        await putTestFileToS3("file_cache_invalidation_test", "parquet", data);
        await setAwsConfig(conn);
        const results_correct = await conn.query(
          `select l_partkey from "s3://${BUCKET_NAME}/file_cache_invalidation_test.parquet" limit 1;`
        );
        expect(results_correct.getChildAt(0)?.get(0)).toEqual(1552);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select avg(l_partkey) from "s3://${BUCKET_NAME}/lineitem.parquet";`)
        ).toBeRejected();
      });
      it("write after read throws incorrect flag error without dropping files", async () => {
        await setAwsConfig(conn);
        await conn.query(
          `COPY (SELECT * FROM range(1000,1010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
        );
        const result = await conn.query(`SELECT * FROM "s3://${BUCKET_NAME}/test_written.csv";`);
        expect(Number(result.getChildAt(0)?.get(6))).toEqual(Number(1006));
        await expectAsync(
          conn.query(
            `COPY (SELECT * FROM range(2000,2010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
          )
        ).toBeRejectedWithError("Invalid Error: File is not opened in write mode");
      });
    });
  }

  // test/bindings.test.ts
  function testBindings(db2, baseURL2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("DuckDBBindings", () => {
      describe("error handling", () => {
        it("INVALID SQL", async () => {
          let error = null;
          try {
            await conn.send("INVALID");
          } catch (e) {
            error = e;
          }
          expect(error).not.toBe(null);
        });
      });
      describe("Check version", () => {
        it("Version check", async () => {
          await db2().reset();
          conn = db2().connect();
          const version = conn.query(
            "select * from (select version()) where version() != 'v0.0.1-dev0';"
          );
          const rows = version.toArray();
          expect(rows.length).toEqual(1);
          await db2().reset();
        });
      });
      describe("Check platform", () => {
        it("Platform check", async () => {
          await db2().reset();
          conn = db2().connect();
          const version = conn.query(
            "PRAGMA platform;"
          );
          const rows = version.getChildAt(0)?.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0].toString().substr(0, 5)).toEqual("wasm_");
          await db2().reset();
        });
      });
      describe("Reset", () => {
        it("table must disappear", async () => {
          await db2().reset();
          conn = db2().connect();
          conn.query("CREATE TABLE foo (a int)");
          let table = conn.query("PRAGMA show_tables;");
          let rows = table.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0]?.name).toEqual("foo");
          await db2().reset();
          conn = db2().connect();
          table = conn.query("PRAGMA show_tables;");
          rows = table.toArray();
          expect(rows.length).toEqual(0);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const result = stmt.query(234);
          expect(result.numRows).toBe(10001);
          stmt.close();
        });
        it("Streaming", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = stmt.send(234);
          let size = 0;
          for (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          conn.close();
        });
        it("Typecheck", async () => {
          conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          expect(
            () => stmt.query(true, 100, 1e4, 1e6, 5e9, 0.5, Math.PI, "hello world", "hi")
          ).not.toThrow();
          expect(
            () => stmt.query(
              "test",
              // varchar for bool
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              1e4,
              // smallint for tinyint
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e6,
              // int for smallint
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e4,
              5e9,
              // bigint for int
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          conn.close();
        });
      });
    });
  }
  function testAsyncBindings(adb2, baseURL2, baseDirProto) {
    beforeEach(async () => {
    });
    afterEach(async () => {
      await adb2().flushFiles();
      await adb2().dropFiles();
      await adb2().open({
        path: ":memory:"
      });
    });
    describe("Bindings", () => {
      describe("Open", () => {
        it("Remote TPCH 0_01", async () => {
          await adb2().registerFileURL("tpch_0_01.db", `${baseURL2}/tpch/0_01/duckdb/db`, baseDirProto, false);
          await adb2().open({
            path: "tpch_0_01.db"
          });
        });
      });
      describe("Patching", () => {
        it("Count(*) Default", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: false
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Int);
        });
        it("Count(*) No BigInt", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: true
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Float);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v + ? FROM generate_series(0, 10000) as t(v);");
          const result = await stmt.query(234);
          expect(result.numRows).toBe(10001);
          await stmt.close();
        });
        it("Streaming", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = await stmt.send(234);
          let size = 0;
          for await (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          await conn.close();
        });
        it("Typecheck", async () => {
          const conn = await adb2().connect();
          await conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = await conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          const expectToThrow = async (fn) => {
            let throwed = false;
            try {
              await fn();
            } catch (e) {
              throwed = true;
            }
            expect(throwed).toBe(true);
          };
          expectToThrow(async () => {
            await stmt.query(
              "test",
              // varchar for bool
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              1e4,
              // smallint for tinyint
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e6,
              // int for smallint
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e4,
              5e9,
              // bigint for int
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          await conn.close();
        });
      });
      describe("AccessMode", () => {
        it("READ_ONLY", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 2 /* READ_ONLY */
            })
          ).toBeRejectedWithError(/Cannot launch in-memory database in read-only mode/);
        });
        it("READ_WRITE", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 3 /* READ_WRITE */
            })
          ).toBeResolved();
        });
      });
      describe("Cancellation", () => {
        it("hello cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeTrue();
          let polledHeader = null;
          let polledError = null;
          try {
            polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).toBeNull();
          expect(polledError).not.toBeNull();
          expect(polledError.toString()).toEqual("Error: query was canceled");
          const canceledAgain = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(canceledAgain).toBeFalse();
          const table = await conn.query("select 42::integer;");
          expect(table.schema.fields.length).toEqual(1);
        });
        it("noop cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          let polledHeader = null;
          let polledError = null;
          try {
            while (polledHeader == null) {
              polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
            }
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).not.toBeNull();
          expect(polledError).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeFalse();
          const anotherOne = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(anotherOne).toBeFalse();
        });
      });
    });
  }

  // test/batch_stream.test.ts
  var testRows = 1e4;
  function testBatchStream(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++);
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i++));
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++);
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i++));
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
  }

  // test/batch_stream_async.test.ts
  var testRows2 = 1e4;
  function testAsyncBatchStream(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("AsyncDuckDB", () => {
      it("ping", async () => {
        await db2().ping();
      });
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
      describe("scripts", () => {
        it("test1", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS x, (sin(v) * 100 + 100)::INTEGER AS y FROM generate_series(0, ${testRows2}) as t(v)
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(2);
            for (const row of batch) {
              expect(row.x).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
  }

  // test/filesystem.test.ts
  var decoder2 = new TextDecoder();
  function testFilesystem(db2, resolveData2, baseDir, baseDirProto) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("File buffer registration", () => {
      const test = async () => {
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      };
      it("File buffer used once", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
      });
      it("File buffer registered twice", async () => {
        const students0 = await resolveData2("/uni/studenten.parquet");
        const students1 = await resolveData2("/uni/studenten.parquet");
        expect(students0).not.toBeNull();
        expect(students1).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students0);
        await test();
        await db2().registerFileBuffer("studenten.parquet", students1);
        await test();
      });
      it("File buffer used twice", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
        await test();
      });
    });
    describe("Parquet Scans", () => {
      it("single table from buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("simple join", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        const hoeren = await resolveData2("/uni/hoeren.parquet");
        const vorlesungen = await resolveData2("/uni/vorlesungen.parquet");
        expect(students).not.toBeNull();
        expect(hoeren).not.toBeNull();
        expect(vorlesungen).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerFileBuffer("hoeren.parquet", hoeren);
        await db2().registerFileBuffer("vorlesungen.parquet", vorlesungen);
        const result = await conn.send(`
                    SELECT students.matrnr, vorlesungen.titel
                    FROM parquet_scan('studenten.parquet') students
                    INNER JOIN parquet_scan('hoeren.parquet') hoeren ON (students.matrnr = hoeren.matrnr)
                    INNER JOIN parquet_scan('vorlesungen.parquet') vorlesungen ON (vorlesungen.vorlnr = hoeren.vorlnr);
                `);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.numCols).toBe(2);
        const flat = [];
        for (const row of table) {
          flat.push({
            matrnr: row?.matrnr,
            titel: row?.titel?.toString()
          });
        }
        expect(flat).toEqual([
          { matrnr: 26120, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Logik" },
          { matrnr: 28106, titel: "Ethik" },
          { matrnr: 28106, titel: "Wissenschaftstheorie" },
          { matrnr: 28106, titel: "Bioethik" },
          { matrnr: 28106, titel: "Der Wiener Kreis" },
          { matrnr: 29120, titel: "Grundz\xFCge" },
          { matrnr: 29120, titel: "Ethik" },
          { matrnr: 29120, titel: "M\xE4eutik" },
          { matrnr: 29555, titel: "Glaube und Wissen" },
          { matrnr: 25403, titel: "Glaube und Wissen" }
        ]);
      });
    });
    describe("Writing", () => {
      it("Copy To CSV Buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students.csv");
        await conn.query(`CREATE TABLE students AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students TO 'students.csv' WITH (HEADER 1, DELIMITER ';', FORMAT CSV);`);
        await conn.query(`DROP TABLE IF EXISTS students`);
        const outBuffer = await db2().copyFileToBuffer("students.csv");
        expect(outBuffer).not.toBeNull();
        const text = decoder2.decode(outBuffer);
        expect(text).toBe(`matrnr;name;semester
24002;Xenokrates;18
25403;Jonas;12
26120;Fichte;10
26830;Aristoxenos;8
27550;Schopenhauer;6
28106;Carnap;3
29120;Theophrastos;2
29555;Feuerbach;2
`);
      });
      it("Copy To Parquet", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students2.parquet");
        await conn.query(`CREATE TABLE students2 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students2 TO 'students2.parquet' (FORMAT PARQUET);`);
        const url = await db2().copyFileToBuffer("students2.parquet");
        expect(url).not.toBeNull();
      });
      it("Copy To Parquet And Load Again", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students3.parquet");
        await conn.query(`CREATE TABLE students3 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students3 TO 'students3.parquet' (FORMAT PARQUET);`);
        const url = await db2().copyFileToBuffer("students3.parquet");
        expect(url).not.toBeNull();
        await conn.query(`CREATE TABLE students4 AS SELECT * FROM parquet_scan('students3.parquet');`);
        const result = await conn.send(`SELECT matrnr FROM students4;`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
    });
    describe("File access", () => {
      it("Small Parquet file", async () => {
        await db2().registerFileURL("studenten.parquet", `${baseDir}/uni/studenten.parquet`, baseDirProto, true);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("Large Parquet file", async () => {
        await db2().registerFileURL(
          "lineitem.parquet",
          `${baseDir}/tpch/0_01/parquet/lineitem.parquet`,
          baseDirProto,
          true
        );
        const result = await conn.send(`SELECT count(*)::INTEGER as cnt FROM parquet_scan('lineitem.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.get(0)).toBeGreaterThan(6e4);
      });
    });
    describe("Export", () => {
      it("Generate Series as CSV", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportcsv'`);
        const results = await db2().globFiles("/tmp/duckdbexportcsv/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportcsv/foo.csv",
          "/tmp/duckdbexportcsv/load.sql",
          "/tmp/duckdbexportcsv/schema.sql"
        ]);
        const csv_buffer_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/foo.csv");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(csv_buffer_utf8.length).not.toEqual(0);
        const load_script = decoder2.decode(load_script_utf8);
        const schema_script = decoder2.decode(schema_script_utf8);
        const csv_buffer = decoder2.decode(csv_buffer_utf8);
        expect(load_script.trim()).toEqual(
          `COPY foo FROM '/tmp/duckdbexportcsv/foo.csv' (FORMAT 'csv', quote '"', delimiter ',', header 0);`
        );
        expect(schema_script.trim()).toEqual(`CREATE TABLE foo(v BIGINT);`);
        expect(csv_buffer.trim()).toEqual(`1
2
3
4
5`);
      });
      it("Generate Series as Parquet", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportparquet' (FORMAT PARQUET)`);
        const results = await db2().globFiles("/tmp/duckdbexportparquet/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportparquet/foo.parquet",
          "/tmp/duckdbexportparquet/load.sql",
          "/tmp/duckdbexportparquet/schema.sql"
        ]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/foo.parquet");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(
          `SELECT v::integer FROM parquet_scan('/tmp/duckdbexportparquet/foo.parquet')`
        );
        expect(content.nullCount).toEqual(0);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
    describe("Copy", () => {
      it("Generate Series as Parquet", async () => {
        await conn.query(
          `COPY (SELECT * FROM generate_series(1, 5) t(v)) TO '/tmp/duckdbcopytest.parquet' (FORMAT 'parquet')`
        );
        const results = await db2().globFiles("/tmp/duckdbcopytest*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(1);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual(["/tmp/duckdbcopytest.parquet"]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbcopytest.parquet");
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(`SELECT v::integer FROM parquet_scan('/tmp/duckdbcopytest.parquet')`);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
  }

  // test/table_test.ts
  function compareTable(table, expected) {
    const colCount = expected.length;
    expect(table.numCols).toEqual(colCount);
    if (colCount == 0)
      return;
    const rowCount = expected[0].values.length;
    for (let i = 0; i < colCount; ++i) {
      expect(expected[i].values.length).toEqual(rowCount);
      expect(table.getChildAt(i)?.length).toEqual(rowCount);
      expect(table.schema.fields[i]?.name).toEqual(expected[i].name);
    }
    for (let i = 0; i < colCount; ++i) {
      const col = table.getChildAt(i);
      const have = [];
      for (let j = 0; j < rowCount; ++j) {
        have.push(col.get(j));
      }
      expect(Number(have)).toEqual(Number(expected[i].values));
    }
  }

  // test/insert_arrow.test.ts
  var buildUtf8Array = (values) => {
    const builder = new Utf8Builder({
      type: new Utf8()
    });
    for (const v of values) {
      builder.append(v);
    }
    builder.finish();
    return builder.flush();
  };
  var ARROW_INSERT_TESTS = [
    {
      name: "integers_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int32()),
        new Field2("c", new Int32())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int32(), data: new Int32Array([2, 5, 8]) }),
            makeData({ type: new Int32(), data: new Int32Array([3, 6, 9]) })
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "combined_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "combined_2",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        },
        {
          numRows: 2,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([10, 13]) }),
            makeData({ type: new Int16(), data: new Int16Array([11, 14]) }),
            buildUtf8Array(["12", "15"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7, 10, 13] },
        { name: "b", values: [2, 5, 8, 11, 14] },
        { name: "c", values: ["3", "6", "9", "12", "15"] }
      ]
    }
  ];
  function testArrowInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data);
          });
          const table = new Table(test.schema, batches);
          conn.insertArrowTable(table, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testArrowInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow async insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data);
          });
          const table = new Table(test.schema, batches);
          await conn.insertArrowTable(table, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describe("Arrow async insert from table", () => {
      it("simple integers", async () => {
        await conn.query(`DROP TABLE IF EXISTS insert_from_table`);
        const table = new Table({
          a: makeVector(new Int32Array([1, 4, 7])),
          b: makeVector(new Int32Array([2, 5, 8])),
          c: vectorFromArray(["3", "6", "9"])
        });
        await conn.insertArrowTable(table, {
          name: "insert_from_vectors"
        });
        const results = await conn.query("select * from insert_from_vectors");
        compareTable(results, [
          { name: "a", values: [1, 4, 7] },
          { name: "b", values: [2, 5, 8] },
          { name: "c", values: ["3", "6", "9"] }
        ]);
      });
    });
  }

  // test/insert_json.test.ts
  function describeBrowser(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder2 = new TextEncoder();
  var JSON_INSERT_TESTS = [
    {
      name: "rows_integers",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "cols_integers",
      input: `{
            "a": [1, 4, 7],
            "b": [2, 5, 8],
            "c": [3, 6, 9]
        }`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "options_1",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo",
        shape: "row-array" /* ROW_ARRAY */,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    }
  ];
  var TEST_FILE = "TEST";
  function testJSONInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Sync", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          db2().registerFileBuffer(TEST_FILE, buffer);
          conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testJSONInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Buffer Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE, buffer);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser("JSON Insert Blob Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/insert_csv.test.ts
  function describeBrowser2(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder3 = new TextEncoder();
  var CSV_INSERT_TESTS = [
    {
      name: "integers_auto_1",
      input: `"a","b","c"
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a,b,c
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_3",
      input: `a,b,c`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "column0", values: ["a"] },
        { name: "column1", values: ["b"] },
        { name: "column2", values: ["c"] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a
1
4
7
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [{ name: "a", values: [1, 4, 7] }]
    },
    {
      name: "options_1",
      input: `1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo2",
        header: false,
        detect: false,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo2",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "options_2",
      input: `1|2|01/02/2020
4|5|01/03/2020
7|8|01/04/2020
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        dateFormat: "%m/%d/%Y",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new DateDay()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(2020, 0, 2)),
            new Date(Date.UTC(2020, 0, 3)),
            new Date(Date.UTC(2020, 0, 4))
          ]
        }
      ]
    },
    {
      name: "options_3",
      input: `1|2|20:32:45 1992-03-02
4|5|20:32:50 1992-03-02
7|8|20:32:55 1992-03-02
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        quote: "'",
        timestampFormat: "%H:%M:%S %Y-%m-%d",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new TimestampSecond()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(1992, 2, 2, 20, 32, 45)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 50)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 55)).getTime()
          ]
        }
      ]
    }
  ];
  var TEST_FILE2 = "TEST";
  function testCSVInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Sync", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          db2().registerFileBuffer(TEST_FILE2, buffer);
          conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testCSVInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Buffer Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE2, buffer);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser2("CSV Insert Blob Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE2, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/tokenizer.test.ts
  function testTokenization(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }
  function testTokenizationAsync(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(await db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(await db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }

  // test/tablenames.test.ts
  var TABLENAME_TESTS = [
    {
      name: "standard",
      input: "SELECT * FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "fetch_specific",
      input: "SELECT col_a FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "multiple_tables",
      input: "SELECT * FROM my_table1, my_table2, my_table3",
      tables: ["my_table1", "my_table2", "my_table3"]
    },
    {
      name: "same_table_multiple_times",
      input: "SELECT col_a FROM my_table, my_table m2, my_table m3",
      tables: ["my_table"]
    },
    {
      name: "subqueries",
      input: "SELECT * FROM (SELECT * FROM (SELECT * FROM my_table) bla) bla3",
      tables: ["my_table"]
    },
    {
      name: "join",
      input: "SELECT col_a FROM my_table JOIN my_table2 ON (my_table.col_b=my_table2.col_d)",
      tables: ["my_table", "my_table2"]
    },
    {
      name: "scalar_subquery",
      input: "SELECT (SELECT COUNT(*) FROM my_table)",
      tables: ["my_table"]
    },
    {
      name: "set_operations",
      input: "SELECT * FROM my_table UNION ALL SELECT * FROM my_table2 INTERSECT SELECT * FROM my_table3",
      tables: ["my_table", "my_table2", "my_table3"]
    },
    {
      name: "window_functions",
      input: "SELECT row_number() OVER (ORDER BY (SELECT i+j FROM my_table2)) FROM my_table",
      tables: ["my_table", "my_table2"]
    }
  ];
  function testTableNames(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
    });
    describe("TableNames", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, () => {
          const tables = conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }
  function testTableNamesAsync(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
    });
    describe("TableNames Async", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, async () => {
          const tables = await conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }

  // test/regression/github_332.test.ts
  function test332(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("332", async () => {
        await db2().registerFileText(
          "Products.csv",
          `ProductGroup,Product,Year,Quarter,Revenue,Units,Count,Product Key,Reseller,Product Info,QuarterAsNumber
Electronics,Phone,2018,Q1,103,7,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q1,102,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2019,Q1,98,12,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2018,Q1,104,3,1,2018-Q1,Samsung,Format=XML; <Properties>\u2026,1
Electronics,Computer,2019,Q1,83,7,1,2019-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2018,Q1,17,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2019,Q1,20,7,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2018,Q1,25,12,1,2018-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Movies,2019,Q1,26,13,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2018,Q2,99,4,1,2018-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2019,Q2,84,20,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2018,Q2,17,4,1,2018-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Media,Theater,2019,Q2,22,5,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2018,Q2,25,12,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2019,Q2,26,14,1,2019-Q2,Google,Format=XML; <Properties>\u2026,2
Electronics,Phone,2000,Q1,103,7,1,2000-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2001,Q1,102,4,1,2001-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2002,Q1,98,12,1,2002-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Computer,2003,Q1,104,3,1,2003-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2004,Q1,83,7,1,2004-Q1,Samsung,Format=XML; <Properties>\u2026,1
Media,Theater,2005,Q1,17,4,1,2005-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2006,Q1,20,7,1,2006-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2007,Q1,25,12,1,2007-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2008,Q1,26,13,1,2008-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Phone,2009,Q2,105,5,1,2009-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2010,Q2,82,15,1,2010-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2011,Q2,99,4,1,2011-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2012,Q2,84,20,1,2012-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2013,Q2,17,4,1,2013-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2014,Q2,22,5,1,2014-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2015,Q2,25,12,1,2015-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2016,Q2,26,14,1,2016-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2017,Q1,26,13,1,2017-Q1,Google,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2020,Q2,99,4,1,2020-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q1,103,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2020,Q2,102,4,1,2020-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q3,98,12,1,2020-Q3,LG,Format=XML; <Properties>\u2026,3
Electronics,Computer,2020,Q4,104,3,1,2020-Q4,LG,Format=XML; <Properties>\u2026,4
Electronics,Computer,2020,Q1,83,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,17,4,1,2020-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,20,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
`
        );
        await conn.query("CREATE TABLE products AS SELECT * FROM 'Products.csv'");
        const all = await conn.query("SELECT * FROM products");
        expect(all.schema.fields.length).toBe(11);
        expect(all.schema.fields[0].name).toBe("ProductGroup");
        const insensitive = await conn.query("SELECT productgroup FROM products GROUP BY productgroup");
        expect(insensitive.schema.fields.length).toBe(1);
        expect(insensitive.schema.fields[0].name).toBe("ProductGroup");
        expect(insensitive.toArray().length).toEqual(2);
        await conn.query("DROP TABLE products");
      });
    });
  }

  // test/regression/github_334.test.ts
  function test334(adb2) {
    describe("GitHub issues", () => {
      describe("334", () => {
        it("CSV insert", async () => {
          await adb2().registerFileText(`data.csv`, "1|foo\n2|bar\n");
          const conn = await adb2().connect();
          await conn.insertCSVFromPath("data.csv", {
            schema: "main",
            name: "foo",
            detect: false,
            header: false,
            delimiter: "|",
            columns: {
              col1: new Int32(),
              col2: new Utf8()
            }
          });
          await conn.query("DROP TABLE IF EXISTS foo");
          await conn.close();
          await adb2().dropFile("data.csv");
        });
        it("JSON row insert", async () => {
          await adb2().registerFileText(
            "rows.json",
            `[
                    { "col1": 1, "col2": "foo" },
                    { "col1": 2, "col2": "bar" },
                ]`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("rows.json", { name: "rows" });
          await conn.query("DROP TABLE IF EXISTS rows");
          await conn.close();
          await adb2().dropFile("rows.json");
        });
        it("JSON column insert", async () => {
          await adb2().registerFileText(
            "columns.json",
            `{
                    "col1": [1, 2],
                    "col2": ["foo", "bar"]
                }`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("columns.json", { name: "columns" });
          await conn.query("DROP TABLE IF EXISTS columns");
          await conn.close();
          await adb2().dropFile("columns.json");
        });
        it("Query result materialized", async () => {
          const conn = await adb2().connect();
          await conn.query(`
                SELECT * FROM generate_series(1, 100) t(v)
            `);
          await conn.close();
        });
        it("Query result streamed", async () => {
          const conn = await adb2().connect();
          for await (const batch of await conn.send(`
                SELECT * FROM generate_series(1, 100) t(v)
            `)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await conn.close();
        });
        it("Prepared statement materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          await stmt.query(234);
          await stmt.close();
          await conn.close();
        });
        it("Prepared statement streamed", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          for await (const batch of await stmt.send(234)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await stmt.close();
          await conn.close();
        });
      });
    });
  }

  // test/regression/github_393.test.ts
  function test393(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("393", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: false
          }
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithoutCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)).getTime());
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)));
      });
    });
  }

  // test/regression/github_448.test.ts
  function test448(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("448", async () => {
        conn = await db2().connect();
        await conn.query(`create temp table test448(i integer)`);
        await conn.query(`insert into test448 values (1),(2),(1)`);
        let result = await conn.query(`select * from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(3);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 1]));
        result = await conn.query(`select histogram(i) from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(1);
        const array = result.getChildAt(0).toArray();
        expect(array.length).toEqual(1);
        expect(array[0].toString()).toEqual("{1: 2, 2: 1}");
      });
    });
  }

  // test/regression/github_470.test.ts
  function test470(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("470", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: false
          }
        });
        conn = await db2().connect();
        const result1 = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(result1.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithCast.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithDefault = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithDefault.toArray()[0]?.interval?.toString()).toEqual("0,3");
      });
    });
  }

  // test/regression/github_477.test.ts
  function test477(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("477", async () => {
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithoutCast.schema.fields[0].type.scale).toEqual(1);
        expect(resultWithoutCast.schema.fields[0].type.precision).toEqual(2);
        expect(resultWithoutCast.toArray()[0]?.decimal == -19).toBe(false);
        await db2().open({
          path: ":memory:",
          query: {
            castDecimalToDouble: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithCast.toArray()[0]?.decimal).toEqual(-1.9000000000000001);
      });
    });
  }

  // test/regression/index.ts
  function testRegressionAsync(adb2) {
    test332(adb2);
    test334(adb2);
    test393(adb2);
    test448(adb2);
    test470(adb2);
    test477(adb2);
  }

  // test/udf.test.ts
  function testUDF(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("UDF", () => {
      it("simple", async () => {
        conn.createScalarFunction("jsudf", new Int32(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1e4]));
      });
      it("double", async () => {
        conn.createScalarFunction("jsudf2", new Float64(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf2(v::DOUBLE))::DOUBLE as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Float64Array([1e4]));
      });
      it("2 args", async () => {
        conn.createScalarFunction("jsudf3", new Int32(), (a, b) => a + b);
        const result = conn.query(
          "SELECT max(jsudf3(v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([2e4]));
      });
      it("3 args", async () => {
        conn.createScalarFunction("jsudf3args", new Int32(), (a, b, c) => a + b + c);
        const result = conn.query(
          "SELECT max(jsudf3args(v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([3e4]));
      });
      it("4 args", async () => {
        conn.createScalarFunction("jsudf4args", new Int32(), (a, b, c, d) => a + b + c + d);
        const result = conn.query(
          "SELECT max(jsudf4args(v::INTEGER, v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([4e4]));
      });
      it("noargs", async () => {
        conn.createScalarFunction("jsudf4", new Int32(), () => 42);
        const result = conn.query("SELECT max(jsudf4())::INTEGER as foo FROM generate_series(1, 10000) as t(v)");
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("withnulls", async () => {
        conn.createScalarFunction("jsudf5", new Int32(), (a) => a == null ? -100 : a);
        const result = conn.query(
          "SELECT min(jsudf5((case when v % 2 = 0 then v else null end)::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("stringparam", async () => {
        function jsudf6(s) {
          return s.length;
        }
        conn.createScalarFunction("jsudf6", new Int32(), jsudf6);
        const result = conn.query(
          "SELECT max(jsudf6('str_' || v))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("stringparamnulls", async () => {
        function jsudf7(s) {
          if (s == void 0) {
            return 0;
          } else {
            return s.length;
          }
        }
        conn.createScalarFunction("jsudf7", new Int32(), jsudf7);
        const result = conn.query(
          "SELECT max(jsudf7((case when v % 2 = 0 then 'str_' || v else null end)::VARCHAR))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("nullintreturn", async () => {
        conn.createScalarFunction("jsudf8", new Int32(), (a) => void 0);
        const result = conn.query(
          "SELECT max(COALESCE(jsudf8(v::INTEGER), 42))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("stringreturn", async () => {
        conn.createScalarFunction("jsudf9", new Utf8(), (a) => "Hello " + a);
        const result = conn.query(
          "SELECT max(LENGTH(jsudf9(v::INTEGER)))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([11]));
      });
      it("nullstringreturn", async () => {
        conn.createScalarFunction("jsudf10", new Utf8(), (a) => a % 2 == 0 ? "Hello" : void 0);
        const result = conn.query(
          "SELECT COUNT(jsudf10(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([5e3]));
      });
      it("struct", async () => {
        conn.createScalarFunction("jsudf11", new Int32(), (a) => a.x == null ? -100 : a.x);
        const result = conn.query(
          `SELECT min(jsudf11({'x': (case when v % 2 = 0 then v else null end)::INTEGER, 'y': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnested", async () => {
        conn.createScalarFunction("jsudf12", new Int32(), (a) => a.x.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf12({'x': {'y': (case when v % 2 = 0 then v else null end)::INTEGER }, 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnestednull", async () => {
        conn.createScalarFunction("jsudf13", new Int32(), (a) => a.x?.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf13({'x': (case when v % 2 = 0 then {'y': v::INTEGER } else null end), 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
    });
  }

  // test/index_browser.ts
  var DUCKDB_BUNDLES = {
    mvp: {
      mainModule: new URL("/static/duckdb-mvp.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-mvp.worker.js", window.location.href).href
    },
    eh: {
      mainModule: new URL("/static/duckdb-eh.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-eh.worker.js", window.location.href).href
    },
    coi: {
      mainModule: new URL("/static/duckdb-coi.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-coi.worker.js", window.location.href).href,
      pthreadWorker: new URL("/static/duckdb-browser-coi.pthread.worker.js", window.location.href).href
    }
  };
  var DUCKDB_BUNDLE = null;
  describe("wasm check", () => {
    it("worker and wasm urls", async () => {
      if ((await getPlatformFeatures()).crossOriginIsolated && await exceptions() && await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.coi.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.coi.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(DUCKDB_BUNDLES.coi.pthreadWorker);
      }
      if (await exceptions() && !await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.eh.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.eh.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
      if (!await exceptions()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.mvp.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.mvp.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
    });
  });
  jasmine.DEFAULT_TIMEOUT_INTERVAL = 6e4;
  var resolveBuffer = async (url) => {
    const req = await fetch(`/data${url}`);
    if (!req.ok)
      return null;
    return new Uint8Array(await req.arrayBuffer());
  };
  var resolveData = async (url) => {
    switch (url) {
      case "/uni/all.zip":
        return await resolveBuffer("/uni/all.zip");
      case "/uni/assistenten.parquet":
        return await resolveBuffer("/uni/assistenten.parquet");
      case "/uni/studenten.parquet":
        return await resolveBuffer("/uni/studenten.parquet");
      case "/uni/hoeren.parquet":
        return await resolveBuffer("/uni/hoeren.parquet");
      case "/uni/vorlesungen.parquet":
        return await resolveBuffer("/uni/vorlesungen.parquet");
      case "/tpch/0_01/parquet/lineitem.parquet":
        return await resolveBuffer("/tpch/0_01/parquet/lineitem.parquet");
      default:
        return null;
    }
  };
  var db = null;
  var adb = null;
  var worker = null;
  beforeAll(async () => {
    const logger = new VoidLogger();
    db = await createDuckDB(DUCKDB_BUNDLES, logger, BROWSER_RUNTIME);
    await db.instantiate((_) => {
    });
    DUCKDB_BUNDLE = await selectBundle(DUCKDB_BUNDLES);
    worker = await createWorker(DUCKDB_BUNDLE.mainWorker);
    adb = new AsyncDuckDB(logger, worker);
    await adb.instantiate(DUCKDB_BUNDLE.mainModule, DUCKDB_BUNDLE.pthreadWorker);
  });
  afterAll(async () => {
    if (worker)
      worker.terminate();
  });
  var baseURL = window.location.origin;
  var dataURL = `${baseURL}/data`;
  testHTTPFS(() => db);
  testHTTPFSAsync(() => adb, resolveData, dataURL);
  testUDF(() => db);
  testTableNames(() => db);
  testTableNamesAsync(() => adb);
  testRegressionAsync(() => adb);
  testAllTypes(() => db);
  testAllTypesAsync(() => adb);
  testBindings(() => db, dataURL);
  testAsyncBindings(() => adb, dataURL, 4 /* HTTP */);
  testBatchStream(() => db);
  testAsyncBatchStream(() => adb);
  testFilesystem(() => adb, resolveData, dataURL, 4 /* HTTP */);
  testArrowInsert(() => db);
  testArrowInsertAsync(() => adb);
  testJSONInsert(() => db);
  testJSONInsertAsync(() => adb);
  testCSVInsert(() => db);
  testCSVInsertAsync(() => adb);
  testTokenization(() => db);
  testTokenizationAsync(() => adb);
})();
/*! Bundled license information:

js-sha256/src/sha256.js:
  (**
   * [js-sha256]{@link https://github.com/emn178/js-sha256}
   *
   * @version 0.9.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2pzLXNoYTI1Ni9zcmMvc2hhMjU2LmpzIiwgIi4uL3NyYy9iaW5kaW5ncy9kdWNrZGItbXZwLmpzIiwgIi4uL3NyYy9iaW5kaW5ncy9kdWNrZGItZWguanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3dlYi13b3JrZXIvY2pzL2Jyb3dzZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvYnVmZmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL3V0ZjgudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvY29tcGF0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vaW8vYWRhcHRlcnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9lbnVtLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL3ZlY3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9wcmV0dHkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvYm4udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvYmlnaW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdHlwZS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvbWF0aC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci9zZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9yb3cvcm93L3N0cnVjdC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci9nZXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9yb3cvcm93L21hcC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9iaXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9kYXRhLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL2NodW5rLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2luZGV4b2YudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvaXRlcmF0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvYnl0ZWxlbmd0aC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3ZlY3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci92YWxpZC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9idWZmZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvYmxvY2sudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9jb25zdGFudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy91dGlscy5qcyIsICIuLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2VuY29kaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvYnl0ZS1idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9idWlsZGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIva2V5LXZhbHVlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvbWV0YWRhdGEtdmVyc2lvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2VuZGlhbm5lc3MudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9kaWN0aW9uYXJ5LWtpbmQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9pbnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9kaWN0aW9uYXJ5LWVuY29kaW5nLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvYmluYXJ5LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvYm9vbC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RhdGUtdW5pdC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RhdGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9kZWNpbWFsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvdGltZS11bml0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZml4ZWQtc2l6ZS1iaW5hcnkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9maXhlZC1zaXplLWxpc3QudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9wcmVjaXNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9mbG9hdGluZy1wb2ludC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ludGVydmFsLXVuaXQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9pbnRlcnZhbC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2xpc3QudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9tYXAudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9udWxsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvc3RydWN0LS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3RpbWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi90aW1lc3RhbXAudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi91bmlvbi1tb2RlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvdW5pb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi91dGY4LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvdHlwZS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ZpZWxkLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvc2NoZW1hLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZm9vdGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvc2NoZW1hLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL21ldGFkYXRhL2lwYy9tZXRhZGF0YS9maWxlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vaW8vaW50ZXJmYWNlcy50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lvL2lvL3N0cmVhbS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lvL2lvL2ZpbGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvaW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL3ZlY3RvcmxvYWRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9iaW5hcnkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvYm9vbC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9kYXRlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2RlY2ltYWwudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvZGljdGlvbmFyeS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9maXhlZHNpemViaW5hcnkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvZml4ZWRzaXplbGlzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9mbG9hdC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9pbnRlcnZhbC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9pbnQudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvbGlzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9tYXAudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvbnVsbC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9zdHJ1Y3QudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdGltZXN0YW1wLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL3RpbWUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdW5pb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdXRmOC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci9idWlsZGVyY3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci90eXBlY29tcGFyYXRvci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZhY3Rvcmllcy50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9yZWNvcmRiYXRjaC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3RhYmxlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvcmVjb3JkYmF0Y2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9ib2R5LWNvbXByZXNzaW9uLW1ldGhvZC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2NvbXByZXNzaW9uLXR5cGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9ib2R5LWNvbXByZXNzaW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvYnVmZmVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZmllbGQtbm9kZS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3JlY29yZC1iYXRjaC50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RpY3Rpb25hcnktYmF0Y2gudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9tZXNzYWdlLWhlYWRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL21lc3NhZ2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvdHlwZWFzc2VtYmxlci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9tZXRhZGF0YS9pcGMvbWV0YWRhdGEvanNvbi50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9tZXRhZGF0YS9pcGMvbWV0YWRhdGEvbWVzc2FnZS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9pcGMvbWVzc2FnZS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9pcGMvcmVhZGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL3ZlY3RvcmFzc2VtYmxlci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9pcGMvd3JpdGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vd2hhdHdnL2lvL3doYXR3Zy9pdGVyYWJsZS50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lvL3doYXR3Zy9pby93aGF0d2cvYnVpbGRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lvL3doYXR3Zy9pby93aGF0d2cvcmVhZGVyLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vd2hhdHdnL2lvL3doYXR3Zy93cml0ZXIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pcGMvaXBjL3NlcmlhbGl6YXRpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9BcnJvdy50cyIsICIuLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L0Fycm93LmRvbS50cyIsICIuLi9zcmMvYmluZGluZ3MvY29ubmVjdGlvbi50cyIsICIuLi9zcmMvYmluZGluZ3MvdWRmX3J1bnRpbWUudHMiLCAiLi4vc3JjL2JpbmRpbmdzL3J1bnRpbWUudHMiLCAiLi4vc3JjL2JpbmRpbmdzL2ZpbGVfc3RhdHMudHMiLCAiLi4vc3JjL2pzb25fdHlwZWRlZi50cyIsICIuLi9zcmMvYmluZGluZ3MvYmluZGluZ3NfYmFzZS50cyIsICIuLi9zcmMvbG9nLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy93YXNtLWZlYXR1cmUtZGV0ZWN0L2Rpc3QvZXNtL2luZGV4LmpzIiwgIi4uL3NyYy9wbGF0Zm9ybS50cyIsICIuLi9zcmMvdXRpbHMvczNfaGVscGVyLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9ydW50aW1lX2Jyb3dzZXIudHMiLCAiLi4vc3JjL2JpbmRpbmdzL2JpbmRpbmdzX2Jyb3dzZXJfbXZwLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX2Jhc2UudHMiLCAiLi4vc3JjL2JpbmRpbmdzL2JpbmRpbmdzX2Jyb3dzZXJfZWgudHMiLCAiLi4vc3JjL3RhcmdldHMvZHVja2RiLWJyb3dzZXItYmxvY2tpbmcudHMiLCAiLi4vc3JjL3BhcmFsbGVsL2FzeW5jX2Nvbm5lY3Rpb24udHMiLCAiLi4vc3JjL3BhcmFsbGVsL3dvcmtlcl9yZXF1ZXN0LnRzIiwgIi4uL3NyYy9wYXJhbGxlbC9hc3luY19iaW5kaW5ncy50cyIsICIuLi9zcmMvd29ya2VyLnRzIiwgIi4uL3Rlc3QvYWxsX3R5cGVzLnRlc3QudHMiLCAiLi4vdGVzdC9odHRwZnNfdGVzdC50cyIsICIuLi90ZXN0L2JpbmRpbmdzLnRlc3QudHMiLCAiLi4vdGVzdC9iYXRjaF9zdHJlYW0udGVzdC50cyIsICIuLi90ZXN0L2JhdGNoX3N0cmVhbV9hc3luYy50ZXN0LnRzIiwgIi4uL3Rlc3QvZmlsZXN5c3RlbS50ZXN0LnRzIiwgIi4uL3Rlc3QvdGFibGVfdGVzdC50cyIsICIuLi90ZXN0L2luc2VydF9hcnJvdy50ZXN0LnRzIiwgIi4uL3Rlc3QvaW5zZXJ0X2pzb24udGVzdC50cyIsICIuLi90ZXN0L2luc2VydF9jc3YudGVzdC50cyIsICIuLi90ZXN0L3Rva2VuaXplci50ZXN0LnRzIiwgIi4uL3Rlc3QvdGFibGVuYW1lcy50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9naXRodWJfMzMyLnRlc3QudHMiLCAiLi4vdGVzdC9yZWdyZXNzaW9uL2dpdGh1Yl8zMzQudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vZ2l0aHViXzM5My50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9naXRodWJfNDQ4LnRlc3QudHMiLCAiLi4vdGVzdC9yZWdyZXNzaW9uL2dpdGh1Yl80NzAudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vZ2l0aHViXzQ3Ny50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9pbmRleC50cyIsICIuLi90ZXN0L3VkZi50ZXN0LnRzIiwgIi4uL3Rlc3QvaW5kZXhfYnJvd3Nlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBbanMtc2hhMjU2XXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTI1Nn1cbiAqXG4gKiBAdmVyc2lvbiAwLjkuMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNC0yMDE3XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBFUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTI1Nl9OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTI1Nl9OT19OT0RFX0pTICYmIHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZTtcbiAgaWYgKE5PREVfSlMpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFdFQl9XT1JLRVIpIHtcbiAgICByb290ID0gc2VsZjtcbiAgfVxuICB2YXIgQ09NTU9OX0pTID0gIXJvb3QuSlNfU0hBMjU2X05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBFWFRSQSA9IFstMjE0NzQ4MzY0OCwgODM4ODYwOCwgMzI3NjgsIDEyOF07XG4gIHZhciBTSElGVCA9IFsyNCwgMTYsIDgsIDBdO1xuICB2YXIgSyA9IFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbiAgXTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2FycmF5JywgJ2RpZ2VzdCcsICdhcnJheUJ1ZmZlciddO1xuXG4gIHZhciBibG9ja3MgPSBbXTtcblxuICBpZiAocm9vdC5KU19TSEEyNTZfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBMjU2X05PX0FSUkFZX0JVRkZFUl9JU19WSUVXIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgQXJyYXlCdWZmZXIuaXNWaWV3ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iai5idWZmZXIgJiYgb2JqLmJ1ZmZlci5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgaXMyMjQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMjU2KGlzMjI0LCB0cnVlKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoaXMyMjQpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlT3V0cHV0TWV0aG9kKCdoZXgnLCBpczIyNCk7XG4gICAgaWYgKE5PREVfSlMpIHtcbiAgICAgIG1ldGhvZCA9IG5vZGVXcmFwKG1ldGhvZCwgaXMyMjQpO1xuICAgIH1cbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBTaGEyNTYoaXMyMjQpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZCh0eXBlLCBpczIyNCk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIG5vZGVXcmFwID0gZnVuY3Rpb24gKG1ldGhvZCwgaXMyMjQpIHtcbiAgICB2YXIgY3J5cHRvID0gZXZhbChcInJlcXVpcmUoJ2NyeXB0bycpXCIpO1xuICAgIHZhciBCdWZmZXIgPSBldmFsKFwicmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXCIpO1xuICAgIHZhciBhbGdvcml0aG0gPSBpczIyNCA/ICdzaGEyMjQnIDogJ3NoYTI1Nic7XG4gICAgdmFyIG5vZGVNZXRob2QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKS51cGRhdGUobWVzc2FnZSwgJ3V0ZjgnKS5kaWdlc3QoJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KG1lc3NhZ2UpIHx8XG4gICAgICAgIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKS51cGRhdGUobmV3IEJ1ZmZlcihtZXNzYWdlKSkuZGlnZXN0KCdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtZXRob2QobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbm9kZU1ldGhvZDtcbiAgfTtcblxuICB2YXIgY3JlYXRlSG1hY091dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChvdXRwdXRUeXBlLCBpczIyNCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IEhtYWNTaGEyNTYoa2V5LCBpczIyNCwgdHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlSG1hY01ldGhvZCA9IGZ1bmN0aW9uIChpczIyNCkge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kKCdoZXgnLCBpczIyNCk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBuZXcgSG1hY1NoYTI1NihrZXksIGlzMjI0KTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShrZXkpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgT1VUUFVUX1RZUEVTLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdHlwZSA9IE9VVFBVVF9UWVBFU1tpXTtcbiAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QodHlwZSwgaXMyMjQpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNoYTI1NihpczIyNCwgc2hhcmVkTWVtb3J5KSB7XG4gICAgaWYgKHNoYXJlZE1lbW9yeSkge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzWzE2XSA9IGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9XG4gICAgICAgIGJsb2Nrc1s0XSA9IGJsb2Nrc1s1XSA9IGJsb2Nrc1s2XSA9IGJsb2Nrc1s3XSA9XG4gICAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgICAgYmxvY2tzWzEyXSA9IGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IDA7XG4gICAgICB0aGlzLmJsb2NrcyA9IGJsb2NrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ibG9ja3MgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgfVxuXG4gICAgaWYgKGlzMjI0KSB7XG4gICAgICB0aGlzLmgwID0gMHhjMTA1OWVkODtcbiAgICAgIHRoaXMuaDEgPSAweDM2N2NkNTA3O1xuICAgICAgdGhpcy5oMiA9IDB4MzA3MGRkMTc7XG4gICAgICB0aGlzLmgzID0gMHhmNzBlNTkzOTtcbiAgICAgIHRoaXMuaDQgPSAweGZmYzAwYjMxO1xuICAgICAgdGhpcy5oNSA9IDB4Njg1ODE1MTE7XG4gICAgICB0aGlzLmg2ID0gMHg2NGY5OGZhNztcbiAgICAgIHRoaXMuaDcgPSAweGJlZmE0ZmE0O1xuICAgIH0gZWxzZSB7IC8vIDI1NlxuICAgICAgdGhpcy5oMCA9IDB4NmEwOWU2Njc7XG4gICAgICB0aGlzLmgxID0gMHhiYjY3YWU4NTtcbiAgICAgIHRoaXMuaDIgPSAweDNjNmVmMzcyO1xuICAgICAgdGhpcy5oMyA9IDB4YTU0ZmY1M2E7XG4gICAgICB0aGlzLmg0ID0gMHg1MTBlNTI3ZjtcbiAgICAgIHRoaXMuaDUgPSAweDliMDU2ODhjO1xuICAgICAgdGhpcy5oNiA9IDB4MWY4M2Q5YWI7XG4gICAgICB0aGlzLmg3ID0gMHg1YmUwY2QxOTtcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrID0gdGhpcy5zdGFydCA9IHRoaXMuYnl0ZXMgPSB0aGlzLmhCeXRlcyA9IDA7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuaXMyMjQgPSBpczIyNDtcbiAgfVxuXG4gIFNoYTI1Ni5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vdFN0cmluZywgdHlwZSA9IHR5cGVvZiBtZXNzYWdlO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgIH1cbiAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBjb2RlLCBpbmRleCA9IDAsIGksIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcztcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaGVkID0gZmFsc2U7XG4gICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XG4gICAgICAgIGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICAgIGJsb2Nrc1s0XSA9IGJsb2Nrc1s1XSA9IGJsb2Nrc1s2XSA9IGJsb2Nrc1s3XSA9XG4gICAgICAgICAgYmxvY2tzWzhdID0gYmxvY2tzWzldID0gYmxvY2tzWzEwXSA9IGJsb2Nrc1sxMV0gPVxuICAgICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCA2NDsgKytpbmRleCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBjb2RlID0gbWVzc2FnZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IGNvZGUgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweGQ4MDAgfHwgY29kZSA+PSAweGUwMDApIHtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChtZXNzYWdlLmNoYXJDb2RlQXQoKytpbmRleCkgJiAweDNmZikpO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZjAgfCAoY29kZSA+PiAxOCkpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgdGhpcy5ieXRlcyArPSBpIC0gdGhpcy5zdGFydDtcbiAgICAgIGlmIChpID49IDY0KSB7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaSAtIDY0O1xuICAgICAgICB0aGlzLmhhc2goKTtcbiAgICAgICAgdGhpcy5oYXNoZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmJ5dGVzID4gNDI5NDk2NzI5NSkge1xuICAgICAgdGhpcy5oQnl0ZXMgKz0gdGhpcy5ieXRlcyAvIDQyOTQ5NjcyOTYgPDwgMDtcbiAgICAgIHRoaXMuYnl0ZXMgPSB0aGlzLmJ5dGVzICUgNDI5NDk2NzI5NjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleDtcbiAgICBibG9ja3NbMTZdID0gdGhpcy5ibG9jaztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSBFWFRSQVtpICYgM107XG4gICAgdGhpcy5ibG9jayA9IGJsb2Nrc1sxNl07XG4gICAgaWYgKGkgPj0gNTYpIHtcbiAgICAgIGlmICghdGhpcy5oYXNoZWQpIHtcbiAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICB9XG4gICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgYmxvY2tzWzE2XSA9IGJsb2Nrc1sxXSA9IGJsb2Nrc1syXSA9IGJsb2Nrc1szXSA9XG4gICAgICAgIGJsb2Nrc1s0XSA9IGJsb2Nrc1s1XSA9IGJsb2Nrc1s2XSA9IGJsb2Nrc1s3XSA9XG4gICAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgICAgYmxvY2tzWzEyXSA9IGJsb2Nrc1sxM10gPSBibG9ja3NbMTRdID0gYmxvY2tzWzE1XSA9IDA7XG4gICAgfVxuICAgIGJsb2Nrc1sxNF0gPSB0aGlzLmhCeXRlcyA8PCAzIHwgdGhpcy5ieXRlcyA+Pj4gMjk7XG4gICAgYmxvY2tzWzE1XSA9IHRoaXMuYnl0ZXMgPDwgMztcbiAgICB0aGlzLmhhc2goKTtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmgwLCBiID0gdGhpcy5oMSwgYyA9IHRoaXMuaDIsIGQgPSB0aGlzLmgzLCBlID0gdGhpcy5oNCwgZiA9IHRoaXMuaDUsIGcgPSB0aGlzLmg2LFxuICAgICAgaCA9IHRoaXMuaDcsIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBqLCBzMCwgczEsIG1haiwgdDEsIHQyLCBjaCwgYWIsIGRhLCBjZCwgYmM7XG5cbiAgICBmb3IgKGogPSAxNjsgaiA8IDY0OyArK2opIHtcbiAgICAgIC8vIHJpZ2h0cm90YXRlXG4gICAgICB0MSA9IGJsb2Nrc1tqIC0gMTVdO1xuICAgICAgczAgPSAoKHQxID4+PiA3KSB8ICh0MSA8PCAyNSkpIF4gKCh0MSA+Pj4gMTgpIHwgKHQxIDw8IDE0KSkgXiAodDEgPj4+IDMpO1xuICAgICAgdDEgPSBibG9ja3NbaiAtIDJdO1xuICAgICAgczEgPSAoKHQxID4+PiAxNykgfCAodDEgPDwgMTUpKSBeICgodDEgPj4+IDE5KSB8ICh0MSA8PCAxMykpIF4gKHQxID4+PiAxMCk7XG4gICAgICBibG9ja3Nbal0gPSBibG9ja3NbaiAtIDE2XSArIHMwICsgYmxvY2tzW2ogLSA3XSArIHMxIDw8IDA7XG4gICAgfVxuXG4gICAgYmMgPSBiICYgYztcbiAgICBmb3IgKGogPSAwOyBqIDwgNjQ7IGogKz0gNCkge1xuICAgICAgaWYgKHRoaXMuZmlyc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXMyMjQpIHtcbiAgICAgICAgICBhYiA9IDMwMDAzMjtcbiAgICAgICAgICB0MSA9IGJsb2Nrc1swXSAtIDE0MTMyNTc4MTk7XG4gICAgICAgICAgaCA9IHQxIC0gMTUwMDU0NTk5IDw8IDA7XG4gICAgICAgICAgZCA9IHQxICsgMjQxNzcwNzcgPDwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhYiA9IDcwNDc1MTEwOTtcbiAgICAgICAgICB0MSA9IGJsb2Nrc1swXSAtIDIxMDI0NDI0ODtcbiAgICAgICAgICBoID0gdDEgLSAxNTIxNDg2NTM0IDw8IDA7XG4gICAgICAgICAgZCA9IHQxICsgMTQzNjk0NTY1IDw8IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSAoKGEgPj4+IDIpIHwgKGEgPDwgMzApKSBeICgoYSA+Pj4gMTMpIHwgKGEgPDwgMTkpKSBeICgoYSA+Pj4gMjIpIHwgKGEgPDwgMTApKTtcbiAgICAgICAgczEgPSAoKGUgPj4+IDYpIHwgKGUgPDwgMjYpKSBeICgoZSA+Pj4gMTEpIHwgKGUgPDwgMjEpKSBeICgoZSA+Pj4gMjUpIHwgKGUgPDwgNykpO1xuICAgICAgICBhYiA9IGEgJiBiO1xuICAgICAgICBtYWogPSBhYiBeIChhICYgYykgXiBiYztcbiAgICAgICAgY2ggPSAoZSAmIGYpIF4gKH5lICYgZyk7XG4gICAgICAgIHQxID0gaCArIHMxICsgY2ggKyBLW2pdICsgYmxvY2tzW2pdO1xuICAgICAgICB0MiA9IHMwICsgbWFqO1xuICAgICAgICBoID0gZCArIHQxIDw8IDA7XG4gICAgICAgIGQgPSB0MSArIHQyIDw8IDA7XG4gICAgICB9XG4gICAgICBzMCA9ICgoZCA+Pj4gMikgfCAoZCA8PCAzMCkpIF4gKChkID4+PiAxMykgfCAoZCA8PCAxOSkpIF4gKChkID4+PiAyMikgfCAoZCA8PCAxMCkpO1xuICAgICAgczEgPSAoKGggPj4+IDYpIHwgKGggPDwgMjYpKSBeICgoaCA+Pj4gMTEpIHwgKGggPDwgMjEpKSBeICgoaCA+Pj4gMjUpIHwgKGggPDwgNykpO1xuICAgICAgZGEgPSBkICYgYTtcbiAgICAgIG1haiA9IGRhIF4gKGQgJiBiKSBeIGFiO1xuICAgICAgY2ggPSAoaCAmIGUpIF4gKH5oICYgZik7XG4gICAgICB0MSA9IGcgKyBzMSArIGNoICsgS1tqICsgMV0gKyBibG9ja3NbaiArIDFdO1xuICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgIGcgPSBjICsgdDEgPDwgMDtcbiAgICAgIGMgPSB0MSArIHQyIDw8IDA7XG4gICAgICBzMCA9ICgoYyA+Pj4gMikgfCAoYyA8PCAzMCkpIF4gKChjID4+PiAxMykgfCAoYyA8PCAxOSkpIF4gKChjID4+PiAyMikgfCAoYyA8PCAxMCkpO1xuICAgICAgczEgPSAoKGcgPj4+IDYpIHwgKGcgPDwgMjYpKSBeICgoZyA+Pj4gMTEpIHwgKGcgPDwgMjEpKSBeICgoZyA+Pj4gMjUpIHwgKGcgPDwgNykpO1xuICAgICAgY2QgPSBjICYgZDtcbiAgICAgIG1haiA9IGNkIF4gKGMgJiBhKSBeIGRhO1xuICAgICAgY2ggPSAoZyAmIGgpIF4gKH5nICYgZSk7XG4gICAgICB0MSA9IGYgKyBzMSArIGNoICsgS1tqICsgMl0gKyBibG9ja3NbaiArIDJdO1xuICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgIGYgPSBiICsgdDEgPDwgMDtcbiAgICAgIGIgPSB0MSArIHQyIDw8IDA7XG4gICAgICBzMCA9ICgoYiA+Pj4gMikgfCAoYiA8PCAzMCkpIF4gKChiID4+PiAxMykgfCAoYiA8PCAxOSkpIF4gKChiID4+PiAyMikgfCAoYiA8PCAxMCkpO1xuICAgICAgczEgPSAoKGYgPj4+IDYpIHwgKGYgPDwgMjYpKSBeICgoZiA+Pj4gMTEpIHwgKGYgPDwgMjEpKSBeICgoZiA+Pj4gMjUpIHwgKGYgPDwgNykpO1xuICAgICAgYmMgPSBiICYgYztcbiAgICAgIG1haiA9IGJjIF4gKGIgJiBkKSBeIGNkO1xuICAgICAgY2ggPSAoZiAmIGcpIF4gKH5mICYgaCk7XG4gICAgICB0MSA9IGUgKyBzMSArIGNoICsgS1tqICsgM10gKyBibG9ja3NbaiArIDNdO1xuICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgIGUgPSBhICsgdDEgPDwgMDtcbiAgICAgIGEgPSB0MSArIHQyIDw8IDA7XG4gICAgfVxuXG4gICAgdGhpcy5oMCA9IHRoaXMuaDAgKyBhIDw8IDA7XG4gICAgdGhpcy5oMSA9IHRoaXMuaDEgKyBiIDw8IDA7XG4gICAgdGhpcy5oMiA9IHRoaXMuaDIgKyBjIDw8IDA7XG4gICAgdGhpcy5oMyA9IHRoaXMuaDMgKyBkIDw8IDA7XG4gICAgdGhpcy5oNCA9IHRoaXMuaDQgKyBlIDw8IDA7XG4gICAgdGhpcy5oNSA9IHRoaXMuaDUgKyBmIDw8IDA7XG4gICAgdGhpcy5oNiA9IHRoaXMuaDYgKyBnIDw8IDA7XG4gICAgdGhpcy5oNyA9IHRoaXMuaDcgKyBoIDw8IDA7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5oZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGgwID0gdGhpcy5oMCwgaDEgPSB0aGlzLmgxLCBoMiA9IHRoaXMuaDIsIGgzID0gdGhpcy5oMywgaDQgPSB0aGlzLmg0LCBoNSA9IHRoaXMuaDUsXG4gICAgICBoNiA9IHRoaXMuaDYsIGg3ID0gdGhpcy5oNztcblxuICAgIHZhciBoZXggPSBIRVhfQ0hBUlNbKGgwID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMCA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDAgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMCAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgxID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMSA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gxICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDIgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDIgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDIgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgyID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDIgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMyA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMyA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMyA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDMgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMyAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg0ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDQgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg0ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDQgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg0ID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNCA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g0ICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNSA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDUgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNSA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDUgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNSA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDUgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg1ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDUgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg2ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNiA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg2ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNiA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg2ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNiA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDYgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNiAmIDB4MEZdO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soaDcgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNyA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDcgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICBIRVhfQ0hBUlNbKGg3ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNyA+PiA4KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNyA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g3ICYgMHgwRl07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS50b1N0cmluZyA9IFNoYTI1Ni5wcm90b3R5cGUuaGV4O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNCwgaDUgPSB0aGlzLmg1LFxuICAgICAgaDYgPSB0aGlzLmg2LCBoNyA9IHRoaXMuaDc7XG5cbiAgICB2YXIgYXJyID0gW1xuICAgICAgKGgwID4+IDI0KSAmIDB4RkYsIChoMCA+PiAxNikgJiAweEZGLCAoaDAgPj4gOCkgJiAweEZGLCBoMCAmIDB4RkYsXG4gICAgICAoaDEgPj4gMjQpICYgMHhGRiwgKGgxID4+IDE2KSAmIDB4RkYsIChoMSA+PiA4KSAmIDB4RkYsIGgxICYgMHhGRixcbiAgICAgIChoMiA+PiAyNCkgJiAweEZGLCAoaDIgPj4gMTYpICYgMHhGRiwgKGgyID4+IDgpICYgMHhGRiwgaDIgJiAweEZGLFxuICAgICAgKGgzID4+IDI0KSAmIDB4RkYsIChoMyA+PiAxNikgJiAweEZGLCAoaDMgPj4gOCkgJiAweEZGLCBoMyAmIDB4RkYsXG4gICAgICAoaDQgPj4gMjQpICYgMHhGRiwgKGg0ID4+IDE2KSAmIDB4RkYsIChoNCA+PiA4KSAmIDB4RkYsIGg0ICYgMHhGRixcbiAgICAgIChoNSA+PiAyNCkgJiAweEZGLCAoaDUgPj4gMTYpICYgMHhGRiwgKGg1ID4+IDgpICYgMHhGRiwgaDUgJiAweEZGLFxuICAgICAgKGg2ID4+IDI0KSAmIDB4RkYsIChoNiA+PiAxNikgJiAweEZGLCAoaDYgPj4gOCkgJiAweEZGLCBoNiAmIDB4RkZcbiAgICBdO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgYXJyLnB1c2goKGg3ID4+IDI0KSAmIDB4RkYsIChoNyA+PiAxNikgJiAweEZGLCAoaDcgPj4gOCkgJiAweEZGLCBoNyAmIDB4RkYpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuYXJyYXkgPSBTaGEyNTYucHJvdG90eXBlLmRpZ2VzdDtcblxuICBTaGEyNTYucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5pczIyNCA/IDI4IDogMzIpO1xuICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigwLCB0aGlzLmgwKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoNCwgdGhpcy5oMSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDgsIHRoaXMuaDIpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxMiwgdGhpcy5oMyk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDE2LCB0aGlzLmg0KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjAsIHRoaXMuaDUpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigyNCwgdGhpcy5oNik7XG4gICAgaWYgKCF0aGlzLmlzMjI0KSB7XG4gICAgICBkYXRhVmlldy5zZXRVaW50MzIoMjgsIHRoaXMuaDcpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEhtYWNTaGEyNTYoa2V5LCBpczIyNCwgc2hhcmVkTWVtb3J5KSB7XG4gICAgdmFyIGksIHR5cGUgPSB0eXBlb2Yga2V5O1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGJ5dGVzID0gW10sIGxlbmd0aCA9IGtleS5sZW5ndGgsIGluZGV4ID0gMCwgY29kZTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb2RlID0ga2V5LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweGMwIHwgKGNvZGUgPj4gNikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhlMCB8IChjb2RlID4+IDEyKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweGYwIHwgKGNvZGUgPj4gMTgpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2V5ID0gYnl0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYga2V5LmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIGtleSA9IG5ldyBVaW50OEFycmF5KGtleSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleS5sZW5ndGggPiA2NCkge1xuICAgICAga2V5ID0gKG5ldyBTaGEyNTYoaXMyMjQsIHRydWUpKS51cGRhdGUoa2V5KS5hcnJheSgpO1xuICAgIH1cblxuICAgIHZhciBvS2V5UGFkID0gW10sIGlLZXlQYWQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgdmFyIGIgPSBrZXlbaV0gfHwgMDtcbiAgICAgIG9LZXlQYWRbaV0gPSAweDVjIF4gYjtcbiAgICAgIGlLZXlQYWRbaV0gPSAweDM2IF4gYjtcbiAgICB9XG5cbiAgICBTaGEyNTYuY2FsbCh0aGlzLCBpczIyNCwgc2hhcmVkTWVtb3J5KTtcblxuICAgIHRoaXMudXBkYXRlKGlLZXlQYWQpO1xuICAgIHRoaXMub0tleVBhZCA9IG9LZXlQYWQ7XG4gICAgdGhpcy5pbm5lciA9IHRydWU7XG4gICAgdGhpcy5zaGFyZWRNZW1vcnkgPSBzaGFyZWRNZW1vcnk7XG4gIH1cbiAgSG1hY1NoYTI1Ni5wcm90b3R5cGUgPSBuZXcgU2hhMjU2KCk7XG5cbiAgSG1hY1NoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICB0aGlzLmlubmVyID0gZmFsc2U7XG4gICAgICB2YXIgaW5uZXJIYXNoID0gdGhpcy5hcnJheSgpO1xuICAgICAgU2hhMjU2LmNhbGwodGhpcywgdGhpcy5pczIyNCwgdGhpcy5zaGFyZWRNZW1vcnkpO1xuICAgICAgdGhpcy51cGRhdGUodGhpcy5vS2V5UGFkKTtcbiAgICAgIHRoaXMudXBkYXRlKGlubmVySGFzaCk7XG4gICAgICBTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBleHBvcnRzID0gY3JlYXRlTWV0aG9kKCk7XG4gIGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cztcbiAgZXhwb3J0cy5zaGEyMjQgPSBjcmVhdGVNZXRob2QodHJ1ZSk7XG4gIGV4cG9ydHMuc2hhMjU2LmhtYWMgPSBjcmVhdGVIbWFjTWV0aG9kKCk7XG4gIGV4cG9ydHMuc2hhMjI0LmhtYWMgPSBjcmVhdGVIbWFjTWV0aG9kKHRydWUpO1xuXG4gIGlmIChDT01NT05fSlMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zaGEyNTYgPSBleHBvcnRzLnNoYTI1NjtcbiAgICByb290LnNoYTIyNCA9IGV4cG9ydHMuc2hhMjI0O1xuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIiwgIlxudmFyIER1Y2tEQiA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0RGlyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0ID8gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgOiB1bmRlZmluZWQ7XG4gIGlmICh0eXBlb2YgX19maWxlbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIF9zY3JpcHREaXIgPSBfc2NyaXB0RGlyIHx8IF9fZmlsZW5hbWU7XG4gIHJldHVybiAoXG5mdW5jdGlvbihEdWNrREIgPSB7fSkgIHtcblxudmFyIE1vZHVsZT10eXBlb2YgRHVja0RCIT1cInVuZGVmaW5lZFwiP0R1Y2tEQjp7fTt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlW1wicmVhZHlcIl09bmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e3JlYWR5UHJvbWlzZVJlc29sdmU9cmVzb2x2ZTtyZWFkeVByb21pc2VSZWplY3Q9cmVqZWN0fSk7dmFyIG1vZHVsZU92ZXJyaWRlcz1PYmplY3QuYXNzaWduKHt9LE1vZHVsZSk7dmFyIGFyZ3VtZW50c189W107dmFyIHRoaXNQcm9ncmFtPVwiLi90aGlzLnByb2dyYW1cIjt2YXIgcXVpdF89KHN0YXR1cyx0b1Rocm93KT0+e3Rocm93IHRvVGhyb3d9O3ZhciBFTlZJUk9OTUVOVF9JU19XRUI9dHlwZW9mIHdpbmRvdz09XCJvYmplY3RcIjt2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSPXR5cGVvZiBpbXBvcnRTY3JpcHRzPT1cImZ1bmN0aW9uXCI7dmFyIEVOVklST05NRU5UX0lTX05PREU9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zPT1cIm9iamVjdFwiJiZ0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlPT1cInN0cmluZ1wiO3ZhciBzY3JpcHREaXJlY3Rvcnk9XCJcIjtmdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpe2lmKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pe3JldHVybiBNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKHBhdGgsc2NyaXB0RGlyZWN0b3J5KX1yZXR1cm4gc2NyaXB0RGlyZWN0b3J5K3BhdGh9dmFyIHJlYWRfLHJlYWRBc3luYyxyZWFkQmluYXJ5LHNldFdpbmRvd1RpdGxlO2lmKEVOVklST05NRU5UX0lTX05PREUpe3ZhciBmcz1yZXF1aXJlKFwiZnNcIik7dmFyIG5vZGVQYXRoPXJlcXVpcmUoXCJwYXRoXCIpO2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PW5vZGVQYXRoLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KStcIi9cIn1lbHNle3NjcmlwdERpcmVjdG9yeT1fX2Rpcm5hbWUrXCIvXCJ9cmVhZF89KGZpbGVuYW1lLGJpbmFyeSk9PntmaWxlbmFtZT1pc0ZpbGVVUkkoZmlsZW5hbWUpP25ldyBVUkwoZmlsZW5hbWUpOm5vZGVQYXRoLm5vcm1hbGl6ZShmaWxlbmFtZSk7cmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSxiaW5hcnk/dW5kZWZpbmVkOlwidXRmOFwiKX07cmVhZEJpbmFyeT1maWxlbmFtZT0+e3ZhciByZXQ9cmVhZF8oZmlsZW5hbWUsdHJ1ZSk7aWYoIXJldC5idWZmZXIpe3JldD1uZXcgVWludDhBcnJheShyZXQpfXJldHVybiByZXR9O3JlYWRBc3luYz0oZmlsZW5hbWUsb25sb2FkLG9uZXJyb3IsYmluYXJ5PXRydWUpPT57ZmlsZW5hbWU9aXNGaWxlVVJJKGZpbGVuYW1lKT9uZXcgVVJMKGZpbGVuYW1lKTpub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO2ZzLnJlYWRGaWxlKGZpbGVuYW1lLGJpbmFyeT91bmRlZmluZWQ6XCJ1dGY4XCIsKGVycixkYXRhKT0+e2lmKGVycilvbmVycm9yKGVycik7ZWxzZSBvbmxvYWQoYmluYXJ5P2RhdGEuYnVmZmVyOmRhdGEpfSl9O2lmKCFNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSYmcHJvY2Vzcy5hcmd2Lmxlbmd0aD4xKXt0aGlzUHJvZ3JhbT1wcm9jZXNzLmFyZ3ZbMV0ucmVwbGFjZSgvXFxcXC9nLFwiL1wiKX1hcmd1bWVudHNfPXByb2Nlc3MuYXJndi5zbGljZSgyKTtxdWl0Xz0oc3RhdHVzLHRvVGhyb3cpPT57cHJvY2Vzcy5leGl0Q29kZT1zdGF0dXM7dGhyb3cgdG9UaHJvd307TW9kdWxlW1wiaW5zcGVjdFwiXT0oKT0+XCJbRW1zY3JpcHRlbiBNb2R1bGUgb2JqZWN0XVwifWVsc2UgaWYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZn1lbHNlIGlmKHR5cGVvZiBkb2N1bWVudCE9XCJ1bmRlZmluZWRcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7c2NyaXB0RGlyZWN0b3J5PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjfWlmKF9zY3JpcHREaXIpe3NjcmlwdERpcmVjdG9yeT1fc2NyaXB0RGlyfWlmKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKFwiYmxvYjpcIikhPT0wKXtzY3JpcHREaXJlY3Rvcnk9c2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKX1lbHNle3NjcmlwdERpcmVjdG9yeT1cIlwifXtyZWFkXz11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnNlbmQobnVsbCk7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9O2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7cmVhZEJpbmFyeT11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLnNlbmQobnVsbCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSl9fXJlYWRBc3luYz0odXJsLG9ubG9hZCxvbmVycm9yKT0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLHRydWUpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5vbmxvYWQ9KCk9PntpZih4aHIuc3RhdHVzPT0yMDB8fHhoci5zdGF0dXM9PTAmJnhoci5yZXNwb25zZSl7b25sb2FkKHhoci5yZXNwb25zZSk7cmV0dXJufW9uZXJyb3IoKX07eGhyLm9uZXJyb3I9b25lcnJvcjt4aHIuc2VuZChudWxsKX19c2V0V2luZG93VGl0bGU9dGl0bGU9PmRvY3VtZW50LnRpdGxlPXRpdGxlfWVsc2V7fXZhciBvdXQ9TW9kdWxlW1wicHJpbnRcIl18fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7dmFyIGVycj1Nb2R1bGVbXCJwcmludEVyclwiXXx8Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oTW9kdWxlLG1vZHVsZU92ZXJyaWRlcyk7bW9kdWxlT3ZlcnJpZGVzPW51bGw7aWYoTW9kdWxlW1wiYXJndW1lbnRzXCJdKWFyZ3VtZW50c189TW9kdWxlW1wiYXJndW1lbnRzXCJdO2lmKE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdKXRoaXNQcm9ncmFtPU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdO2lmKE1vZHVsZVtcInF1aXRcIl0pcXVpdF89TW9kdWxlW1wicXVpdFwiXTt2YXIgd2FzbUJpbmFyeTtpZihNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKXdhc21CaW5hcnk9TW9kdWxlW1wid2FzbUJpbmFyeVwiXTt2YXIgbm9FeGl0UnVudGltZT1Nb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdfHx0cnVlO2lmKHR5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIil7YWJvcnQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpfXZhciB3YXNtTWVtb3J5O3ZhciBBQk9SVD1mYWxzZTt2YXIgRVhJVFNUQVRVUztmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLHRleHQpe2lmKCFjb25kaXRpb24pe2Fib3J0KHRleHQpfX12YXIgSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpe3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO01vZHVsZVtcIkhFQVA4XCJdPUhFQVA4PW5ldyBJbnQ4QXJyYXkoYik7TW9kdWxlW1wiSEVBUDE2XCJdPUhFQVAxNj1uZXcgSW50MTZBcnJheShiKTtNb2R1bGVbXCJIRUFQMzJcIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGIpO01vZHVsZVtcIkhFQVBVOFwiXT1IRUFQVTg9bmV3IFVpbnQ4QXJyYXkoYik7TW9kdWxlW1wiSEVBUFUxNlwiXT1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShiKTtNb2R1bGVbXCJIRUFQVTMyXCJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGIpO01vZHVsZVtcIkhFQVBGMzJcIl09SEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGIpO01vZHVsZVtcIkhFQVBGNjRcIl09SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGIpfXZhciB3YXNtVGFibGU7dmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVE1BSU5fXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTt2YXIgcnVudGltZUluaXRpYWxpemVkPWZhbHNlO3ZhciBydW50aW1lS2VlcGFsaXZlQ291bnRlcj0wO2Z1bmN0aW9uIGtlZXBSdW50aW1lQWxpdmUoKXtyZXR1cm4gbm9FeGl0UnVudGltZXx8cnVudGltZUtlZXBhbGl2ZUNvdW50ZXI+MH1mdW5jdGlvbiBwcmVSdW4oKXtpZihNb2R1bGVbXCJwcmVSdW5cIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwcmVSdW5cIl09W01vZHVsZVtcInByZVJ1blwiXV07d2hpbGUoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCl7YWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpfX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pfWZ1bmN0aW9uIGluaXRSdW50aW1lKCl7cnVudGltZUluaXRpYWxpemVkPXRydWU7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyl9ZnVuY3Rpb24gcHJlTWFpbigpe2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pfWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGVbXCJwb3N0UnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInBvc3RSdW5cIl09W01vZHVsZVtcInBvc3RSdW5cIl1dO3doaWxlKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyl9ZnVuY3Rpb24gYWRkT25QcmVSdW4oY2Ipe19fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKX1mdW5jdGlvbiBhZGRPbkluaXQoY2Ipe19fQVRJTklUX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKXtfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpfXZhciBydW5EZXBlbmRlbmNpZXM9MDt2YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbDt2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7ZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzKys7aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfX1mdW5jdGlvbiByZW1vdmVSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMtLTtpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9aWYocnVuRGVwZW5kZW5jaWVzPT0wKXtpZihydW5EZXBlbmRlbmN5V2F0Y2hlciE9PW51bGwpe2NsZWFySW50ZXJ2YWwocnVuRGVwZW5kZW5jeVdhdGNoZXIpO3J1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGx9aWYoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKXt2YXIgY2FsbGJhY2s9ZGVwZW5kZW5jaWVzRnVsZmlsbGVkO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2NhbGxiYWNrKCl9fX1mdW5jdGlvbiBhYm9ydCh3aGF0KXtpZihNb2R1bGVbXCJvbkFib3J0XCJdKXtNb2R1bGVbXCJvbkFib3J0XCJdKHdoYXQpfXdoYXQ9XCJBYm9ydGVkKFwiK3doYXQrXCIpXCI7ZXJyKHdoYXQpO0FCT1JUPXRydWU7RVhJVFNUQVRVUz0xO3doYXQrPVwiLiBCdWlsZCB3aXRoIC1zQVNTRVJUSU9OUyBmb3IgbW9yZSBpbmZvLlwiO3ZhciBlPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpO3Rocm93IGV9dmFyIGRhdGFVUklQcmVmaXg9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKXtyZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KX1mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKX12YXIgd2FzbUJpbmFyeUZpbGU7d2FzbUJpbmFyeUZpbGU9XCIuL2R1Y2tkYi1tdnAud2FzbVwiO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKX1mdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSl7dHJ5e2lmKGZpbGU9PXdhc21CaW5hcnlGaWxlJiZ3YXNtQmluYXJ5KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSl9aWYocmVhZEJpbmFyeSl7cmV0dXJuIHJlYWRCaW5hcnkoZmlsZSl9dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goZXJyKXthYm9ydChlcnIpfX1mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpe2lmKCF3YXNtQmluYXJ5JiYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKGJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4ocmVzcG9uc2U9PntpZighcmVzcG9uc2VbXCJva1wiXSl7dGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2JpbmFyeUZpbGUrXCInXCJ9cmV0dXJuIHJlc3BvbnNlW1wiYXJyYXlCdWZmZXJcIl0oKX0pLmNhdGNoKCgpPT5nZXRCaW5hcnkoYmluYXJ5RmlsZSkpfX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Z2V0QmluYXJ5KGJpbmFyeUZpbGUpKX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxyZWNlaXZlcil7cmV0dXJuIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSkudGhlbihiaW5hcnk9PntyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LGltcG9ydHMpfSkudGhlbihpbnN0YW5jZT0+e3JldHVybiBpbnN0YW5jZX0pLnRoZW4ocmVjZWl2ZXIscmVhc29uPT57ZXJyKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrcmVhc29uKTthYm9ydChyZWFzb24pfSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYyhiaW5hcnksYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKXtpZighYmluYXJ5JiZ0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmc9PVwiZnVuY3Rpb25cIiYmIWlzRGF0YVVSSShiaW5hcnlGaWxlKSYmIUVOVklST05NRU5UX0lTX05PREUmJnR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmV0Y2goYmluYXJ5RmlsZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbihyZXNwb25zZT0+e3ZhciByZXN1bHQ9V2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsaW1wb3J0cyk7cmV0dXJuIHJlc3VsdC50aGVuKGNhbGxiYWNrLGZ1bmN0aW9uKHJlYXNvbil7ZXJyKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiK3JlYXNvbik7ZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKX0pfSl9ZWxzZXtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfX1mdW5jdGlvbiBjcmVhdGVXYXNtKCl7dmFyIGluZm89e1wiYVwiOndhc21JbXBvcnRzfTtmdW5jdGlvbiByZWNlaXZlSW5zdGFuY2UoaW5zdGFuY2UsbW9kdWxlKXt2YXIgZXhwb3J0cz1pbnN0YW5jZS5leHBvcnRzO01vZHVsZVtcImFzbVwiXT1leHBvcnRzO3dhc21NZW1vcnk9TW9kdWxlW1wiYXNtXCJdW1wiUmFcIl07dXBkYXRlTWVtb3J5Vmlld3MoKTt3YXNtVGFibGU9TW9kdWxlW1wiYXNtXCJdW1wiVWFcIl07YWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcIlNhXCJdKTtyZW1vdmVSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtyZXR1cm4gZXhwb3J0c31hZGRSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpe3JlY2VpdmVJbnN0YW5jZShyZXN1bHRbXCJpbnN0YW5jZVwiXSl9aWYoTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKXt0cnl7cmV0dXJuIE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLHJlY2VpdmVJbnN0YW5jZSl9Y2F0Y2goZSl7ZXJyKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrZSk7cmVhZHlQcm9taXNlUmVqZWN0KGUpfX1pbnN0YW50aWF0ZUFzeW5jKHdhc21CaW5hcnksd2FzbUJpbmFyeUZpbGUsaW5mbyxyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm57fX12YXIgdGVtcERvdWJsZTt2YXIgdGVtcEk2NDtmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cyl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiO3RoaXMubWVzc2FnZT1gUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke3N0YXR1c30pYDt0aGlzLnN0YXR1cz1zdGF0dXN9ZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKXt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe2NhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSl9fWZ1bmN0aW9uIF9YTUxfR2V0QnVmZmVyKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX0dldEJ1ZmZlclwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX1hNTF9HZXRFcnJvckNvZGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfR2V0RXJyb3JDb2RlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1BhcnNlKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1BhcnNlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1BhcnNlQnVmZmVyKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1BhcnNlQnVmZmVyXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1BhcnNlckNyZWF0ZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZXJDcmVhdGVcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9YTUxfUGFyc2VyRnJlZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZXJGcmVlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1Jlc3VtZVBhcnNlcigpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9SZXN1bWVQYXJzZXJcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9YTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXIoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXJcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9YTUxfU2V0RWxlbWVudEhhbmRsZXIoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0RWxlbWVudEhhbmRsZXJcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9YTUxfU2V0VXNlckRhdGEoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0VXNlckRhdGFcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9YTUxfU3RvcFBhcnNlcigpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9TdG9wUGFyc2VyXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBFeGNlcHRpb25JbmZvKGV4Y1B0cil7dGhpcy5leGNQdHI9ZXhjUHRyO3RoaXMucHRyPWV4Y1B0ci0yNDt0aGlzLnNldF90eXBlPWZ1bmN0aW9uKHR5cGUpe0hFQVBVMzJbdGhpcy5wdHIrND4+PjJdPXR5cGV9O3RoaXMuZ2V0X3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUFUzMlt0aGlzLnB0cis0Pj4+Ml19O3RoaXMuc2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oZGVzdHJ1Y3Rvcil7SEVBUFUzMlt0aGlzLnB0cis4Pj4+Ml09ZGVzdHJ1Y3Rvcn07dGhpcy5nZXRfZGVzdHJ1Y3Rvcj1mdW5jdGlvbigpe3JldHVybiBIRUFQVTMyW3RoaXMucHRyKzg+Pj4yXX07dGhpcy5zZXRfY2F1Z2h0PWZ1bmN0aW9uKGNhdWdodCl7Y2F1Z2h0PWNhdWdodD8xOjA7SEVBUDhbdGhpcy5wdHIrMTI+Pj4wXT1jYXVnaHR9O3RoaXMuZ2V0X2NhdWdodD1mdW5jdGlvbigpe3JldHVybiBIRUFQOFt0aGlzLnB0cisxMj4+PjBdIT0wfTt0aGlzLnNldF9yZXRocm93bj1mdW5jdGlvbihyZXRocm93bil7cmV0aHJvd249cmV0aHJvd24/MTowO0hFQVA4W3RoaXMucHRyKzEzPj4+MF09cmV0aHJvd259O3RoaXMuZ2V0X3JldGhyb3duPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyKzEzPj4+MF0hPTB9O3RoaXMuaW5pdD1mdW5jdGlvbih0eXBlLGRlc3RydWN0b3Ipe3RoaXMuc2V0X2FkanVzdGVkX3B0cigwKTt0aGlzLnNldF90eXBlKHR5cGUpO3RoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcil9O3RoaXMuc2V0X2FkanVzdGVkX3B0cj1mdW5jdGlvbihhZGp1c3RlZFB0cil7SEVBUFUzMlt0aGlzLnB0cisxNj4+PjJdPWFkanVzdGVkUHRyfTt0aGlzLmdldF9hZGp1c3RlZF9wdHI9ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUFUzMlt0aGlzLnB0cisxNj4+PjJdfTt0aGlzLmdldF9leGNlcHRpb25fcHRyPWZ1bmN0aW9uKCl7dmFyIGlzUG9pbnRlcj1fX19jeGFfaXNfcG9pbnRlcl90eXBlKHRoaXMuZ2V0X3R5cGUoKSk7aWYoaXNQb2ludGVyKXtyZXR1cm4gSEVBUFUzMlt0aGlzLmV4Y1B0cj4+PjJdfXZhciBhZGp1c3RlZD10aGlzLmdldF9hZGp1c3RlZF9wdHIoKTtpZihhZGp1c3RlZCE9PTApcmV0dXJuIGFkanVzdGVkO3JldHVybiB0aGlzLmV4Y1B0cn19dmFyIGV4Y2VwdGlvbkxhc3Q9MDt2YXIgdW5jYXVnaHRFeGNlcHRpb25Db3VudD0wO2Z1bmN0aW9uIF9fX2N4YV90aHJvdyhwdHIsdHlwZSxkZXN0cnVjdG9yKXt2YXIgaW5mbz1uZXcgRXhjZXB0aW9uSW5mbyhwdHIpO2luZm8uaW5pdCh0eXBlLGRlc3RydWN0b3IpO2V4Y2VwdGlvbkxhc3Q9cHRyO3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQrKzt0aHJvdyBleGNlcHRpb25MYXN0fXZhciBkbG9wZW5NaXNzaW5nRXJyb3I9XCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2NvbXBpbGluZy9EeW5hbWljLUxpbmtpbmcuaHRtbFwiO2Z1bmN0aW9uIF9fX2Rsc3ltKGhhbmRsZSxzeW1ib2wscmEpe2Fib3J0KGRsb3Blbk1pc3NpbmdFcnJvcil9dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9XCJ1bmRlZmluZWRcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnVuZGVmaW5lZDtmdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSxpZHgsbWF4Qnl0ZXNUb1JlYWQpe2lkeD4+Pj0wO3ZhciBlbmRJZHg9aWR4K21heEJ5dGVzVG9SZWFkO3ZhciBlbmRQdHI9aWR4O3doaWxlKGhlYXBPckFycmF5W2VuZFB0cl0mJiEoZW5kUHRyPj1lbmRJZHgpKSsrZW5kUHRyO2lmKGVuZFB0ci1pZHg+MTYmJmhlYXBPckFycmF5LmJ1ZmZlciYmVVRGOERlY29kZXIpe3JldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcE9yQXJyYXkuc3ViYXJyYXkoaWR4LGVuZFB0cikpfXZhciBzdHI9XCJcIjt3aGlsZShpZHg8ZW5kUHRyKXt2YXIgdTA9aGVhcE9yQXJyYXlbaWR4KytdO2lmKCEodTAmMTI4KSl7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtjb250aW51ZX12YXIgdTE9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyMjQpPT0xOTIpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgodTAmMzEpPDw2fHUxKTtjb250aW51ZX12YXIgdTI9aGVhcE9yQXJyYXlbaWR4KytdJjYzO2lmKCh1MCYyNDApPT0yMjQpe3UwPSh1MCYxNSk8PDEyfHUxPDw2fHUyfWVsc2V7dTA9KHUwJjcpPDwxOHx1MTw8MTJ8dTI8PDZ8aGVhcE9yQXJyYXlbaWR4KytdJjYzfWlmKHUwPDY1NTM2KXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApfWVsc2V7dmFyIGNoPXUwLTY1NTM2O3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxjaD4+MTAsNTYzMjB8Y2gmMTAyMyl9fXJldHVybiBzdHJ9ZnVuY3Rpb24gVVRGOFRvU3RyaW5nKHB0cixtYXhCeXRlc1RvUmVhZCl7cHRyPj4+PTA7cmV0dXJuIHB0cj9VVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgscHRyLG1heEJ5dGVzVG9SZWFkKTpcIlwifXZhciBTWVNDQUxMUz17dmFyYXJnczp1bmRlZmluZWQsZ2V0OmZ1bmN0aW9uKCl7U1lTQ0FMTFMudmFyYXJncys9NDt2YXIgcmV0PUhFQVAzMltTWVNDQUxMUy52YXJhcmdzLTQ+Pj4yXTtyZXR1cm4gcmV0fSxnZXRTdHI6ZnVuY3Rpb24ocHRyKXt2YXIgcmV0PVVURjhUb1N0cmluZyhwdHIpO3JldHVybiByZXR9fTtmdW5jdGlvbiBfX19zeXNjYWxsX19uZXdzZWxlY3QobmZkcyxyZWFkZmRzLHdyaXRlZmRzLGV4Y2VwdGZkcyx0aW1lb3V0KXt2YXIgdG90YWw9MDt2YXIgc3JjUmVhZExvdz1yZWFkZmRzP0hFQVAzMltyZWFkZmRzPj4+Ml06MCxzcmNSZWFkSGlnaD1yZWFkZmRzP0hFQVAzMltyZWFkZmRzKzQ+Pj4yXTowO3ZhciBzcmNXcml0ZUxvdz13cml0ZWZkcz9IRUFQMzJbd3JpdGVmZHM+Pj4yXTowLHNyY1dyaXRlSGlnaD13cml0ZWZkcz9IRUFQMzJbd3JpdGVmZHMrND4+PjJdOjA7dmFyIHNyY0V4Y2VwdExvdz1leGNlcHRmZHM/SEVBUDMyW2V4Y2VwdGZkcz4+PjJdOjAsc3JjRXhjZXB0SGlnaD1leGNlcHRmZHM/SEVBUDMyW2V4Y2VwdGZkcys0Pj4+Ml06MDt2YXIgZHN0UmVhZExvdz0wLGRzdFJlYWRIaWdoPTA7dmFyIGRzdFdyaXRlTG93PTAsZHN0V3JpdGVIaWdoPTA7dmFyIGRzdEV4Y2VwdExvdz0wLGRzdEV4Y2VwdEhpZ2g9MDt2YXIgYWxsTG93PShyZWFkZmRzP0hFQVAzMltyZWFkZmRzPj4+Ml06MCl8KHdyaXRlZmRzP0hFQVAzMlt3cml0ZWZkcz4+PjJdOjApfChleGNlcHRmZHM/SEVBUDMyW2V4Y2VwdGZkcz4+PjJdOjApO3ZhciBhbGxIaWdoPShyZWFkZmRzP0hFQVAzMltyZWFkZmRzKzQ+Pj4yXTowKXwod3JpdGVmZHM/SEVBUDMyW3dyaXRlZmRzKzQ+Pj4yXTowKXwoZXhjZXB0ZmRzP0hFQVAzMltleGNlcHRmZHMrND4+PjJdOjApO3ZhciBjaGVjaz1mdW5jdGlvbihmZCxsb3csaGlnaCx2YWwpe3JldHVybiBmZDwzMj9sb3cmdmFsOmhpZ2gmdmFsfTtmb3IodmFyIGZkPTA7ZmQ8bmZkcztmZCsrKXt2YXIgbWFzaz0xPDxmZCUzMjtpZighY2hlY2soZmQsYWxsTG93LGFsbEhpZ2gsbWFzaykpe2NvbnRpbnVlfXZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTt2YXIgZmxhZ3M9U1lTQ0FMTFMuREVGQVVMVF9QT0xMTUFTSztpZihzdHJlYW0uc3RyZWFtX29wcy5wb2xsKXtmbGFncz1zdHJlYW0uc3RyZWFtX29wcy5wb2xsKHN0cmVhbSl9aWYoZmxhZ3MmMSYmY2hlY2soZmQsc3JjUmVhZExvdyxzcmNSZWFkSGlnaCxtYXNrKSl7ZmQ8MzI/ZHN0UmVhZExvdz1kc3RSZWFkTG93fG1hc2s6ZHN0UmVhZEhpZ2g9ZHN0UmVhZEhpZ2h8bWFzazt0b3RhbCsrfWlmKGZsYWdzJjQmJmNoZWNrKGZkLHNyY1dyaXRlTG93LHNyY1dyaXRlSGlnaCxtYXNrKSl7ZmQ8MzI/ZHN0V3JpdGVMb3c9ZHN0V3JpdGVMb3d8bWFzazpkc3RXcml0ZUhpZ2g9ZHN0V3JpdGVIaWdofG1hc2s7dG90YWwrK31pZihmbGFncyYyJiZjaGVjayhmZCxzcmNFeGNlcHRMb3csc3JjRXhjZXB0SGlnaCxtYXNrKSl7ZmQ8MzI/ZHN0RXhjZXB0TG93PWRzdEV4Y2VwdExvd3xtYXNrOmRzdEV4Y2VwdEhpZ2g9ZHN0RXhjZXB0SGlnaHxtYXNrO3RvdGFsKyt9fWlmKHJlYWRmZHMpe0hFQVAzMltyZWFkZmRzPj4+Ml09ZHN0UmVhZExvdztIRUFQMzJbcmVhZGZkcys0Pj4+Ml09ZHN0UmVhZEhpZ2h9aWYod3JpdGVmZHMpe0hFQVAzMlt3cml0ZWZkcz4+PjJdPWRzdFdyaXRlTG93O0hFQVAzMlt3cml0ZWZkcys0Pj4+Ml09ZHN0V3JpdGVIaWdofWlmKGV4Y2VwdGZkcyl7SEVBUDMyW2V4Y2VwdGZkcz4+PjJdPWRzdEV4Y2VwdExvdztIRUFQMzJbZXhjZXB0ZmRzKzQ+Pj4yXT1kc3RFeGNlcHRIaWdofXJldHVybiB0b3RhbH1mdW5jdGlvbiBTT0NLRlMoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiAkU09DS0ZTXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBGUygpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246ICRGU1wiKTthYm9ydCgtMSl9ZnVuY3Rpb24gZ2V0U29ja2V0RnJvbUZEKGZkKXt2YXIgc29ja2V0PVNPQ0tGUy5nZXRTb2NrZXQoZmQpO2lmKCFzb2NrZXQpdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7cmV0dXJuIHNvY2tldH1mdW5jdGlvbiBpbmV0TnRvcDQoYWRkcil7cmV0dXJuKGFkZHImMjU1KStcIi5cIisoYWRkcj4+OCYyNTUpK1wiLlwiKyhhZGRyPj4xNiYyNTUpK1wiLlwiKyhhZGRyPj4yNCYyNTUpfWZ1bmN0aW9uIGluZXROdG9wNihpbnRzKXt2YXIgc3RyPVwiXCI7dmFyIHdvcmQ9MDt2YXIgbG9uZ2VzdD0wO3ZhciBsYXN0emVybz0wO3ZhciB6c3RhcnQ9MDt2YXIgbGVuPTA7dmFyIGk9MDt2YXIgcGFydHM9W2ludHNbMF0mNjU1MzUsaW50c1swXT4+MTYsaW50c1sxXSY2NTUzNSxpbnRzWzFdPj4xNixpbnRzWzJdJjY1NTM1LGludHNbMl0+PjE2LGludHNbM10mNjU1MzUsaW50c1szXT4+MTZdO3ZhciBoYXNpcHY0PXRydWU7dmFyIHY0cGFydD1cIlwiO2ZvcihpPTA7aTw1O2krKyl7aWYocGFydHNbaV0hPT0wKXtoYXNpcHY0PWZhbHNlO2JyZWFrfX1pZihoYXNpcHY0KXt2NHBhcnQ9aW5ldE50b3A0KHBhcnRzWzZdfHBhcnRzWzddPDwxNik7aWYocGFydHNbNV09PT0tMSl7c3RyPVwiOjpmZmZmOlwiO3N0cis9djRwYXJ0O3JldHVybiBzdHJ9aWYocGFydHNbNV09PT0wKXtzdHI9XCI6OlwiO2lmKHY0cGFydD09PVwiMC4wLjAuMFwiKXY0cGFydD1cIlwiO2lmKHY0cGFydD09PVwiMC4wLjAuMVwiKXY0cGFydD1cIjFcIjtzdHIrPXY0cGFydDtyZXR1cm4gc3RyfX1mb3Iod29yZD0wO3dvcmQ8ODt3b3JkKyspe2lmKHBhcnRzW3dvcmRdPT09MCl7aWYod29yZC1sYXN0emVybz4xKXtsZW49MH1sYXN0emVybz13b3JkO2xlbisrfWlmKGxlbj5sb25nZXN0KXtsb25nZXN0PWxlbjt6c3RhcnQ9d29yZC1sb25nZXN0KzF9fWZvcih3b3JkPTA7d29yZDw4O3dvcmQrKyl7aWYobG9uZ2VzdD4xKXtpZihwYXJ0c1t3b3JkXT09PTAmJndvcmQ+PXpzdGFydCYmd29yZDx6c3RhcnQrbG9uZ2VzdCl7aWYod29yZD09PXpzdGFydCl7c3RyKz1cIjpcIjtpZih6c3RhcnQ9PT0wKXN0cis9XCI6XCJ9Y29udGludWV9fXN0cis9TnVtYmVyKF9udG9ocyhwYXJ0c1t3b3JkXSY2NTUzNSkpLnRvU3RyaW5nKDE2KTtzdHIrPXdvcmQ8Nz9cIjpcIjpcIlwifXJldHVybiBzdHJ9ZnVuY3Rpb24gcmVhZFNvY2thZGRyKHNhLHNhbGVuKXt2YXIgZmFtaWx5PUhFQVAxNltzYT4+PjFdO3ZhciBwb3J0PV9udG9ocyhIRUFQVTE2W3NhKzI+Pj4xXSk7dmFyIGFkZHI7c3dpdGNoKGZhbWlseSl7Y2FzZSAyOmlmKHNhbGVuIT09MTYpe3JldHVybntlcnJubzoyOH19YWRkcj1IRUFQMzJbc2ErND4+PjJdO2FkZHI9aW5ldE50b3A0KGFkZHIpO2JyZWFrO2Nhc2UgMTA6aWYoc2FsZW4hPT0yOCl7cmV0dXJue2Vycm5vOjI4fX1hZGRyPVtIRUFQMzJbc2ErOD4+PjJdLEhFQVAzMltzYSsxMj4+PjJdLEhFQVAzMltzYSsxNj4+PjJdLEhFQVAzMltzYSsyMD4+PjJdXTthZGRyPWluZXROdG9wNihhZGRyKTticmVhaztkZWZhdWx0OnJldHVybntlcnJubzo1fX1yZXR1cm57ZmFtaWx5OmZhbWlseSxhZGRyOmFkZHIscG9ydDpwb3J0fX1mdW5jdGlvbiBpbmV0UHRvbjQoc3RyKXt2YXIgYj1zdHIuc3BsaXQoXCIuXCIpO2Zvcih2YXIgaT0wO2k8NDtpKyspe3ZhciB0bXA9TnVtYmVyKGJbaV0pO2lmKGlzTmFOKHRtcCkpcmV0dXJuIG51bGw7YltpXT10bXB9cmV0dXJuKGJbMF18YlsxXTw8OHxiWzJdPDwxNnxiWzNdPDwyNCk+Pj4wfWZ1bmN0aW9uIGpzdG9pX3Eoc3RyKXtyZXR1cm4gcGFyc2VJbnQoc3RyKX1mdW5jdGlvbiBpbmV0UHRvbjYoc3RyKXt2YXIgd29yZHM7dmFyIHcsb2Zmc2V0LHo7dmFyIHZhbGlkNnJlZ3g9L14oKD89Lio6OikoPyEuKjo6Lis6OikoOjopPyhbXFxkQS1GXXsxLDR9Oig6fFxcYil8KXs1fXwoW1xcZEEtRl17MSw0fTopezZ9KSgoKFtcXGRBLUZdezEsNH0oKD8hXFwzKTo6fDpcXGJ8JCkpfCg/IVxcMlxcMykpezJ9fCgoKDJbMC00XXwxXFxkfFsxLTldKT9cXGR8MjVbMC01XSlcXC4/XFxiKXs0fSkkL2k7dmFyIHBhcnRzPVtdO2lmKCF2YWxpZDZyZWd4LnRlc3Qoc3RyKSl7cmV0dXJuIG51bGx9aWYoc3RyPT09XCI6OlwiKXtyZXR1cm5bMCwwLDAsMCwwLDAsMCwwXX1pZihzdHIuc3RhcnRzV2l0aChcIjo6XCIpKXtzdHI9c3RyLnJlcGxhY2UoXCI6OlwiLFwiWjpcIil9ZWxzZXtzdHI9c3RyLnJlcGxhY2UoXCI6OlwiLFwiOlo6XCIpfWlmKHN0ci5pbmRleE9mKFwiLlwiKT4wKXtzdHI9c3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlsuXVwiLFwiZ1wiKSxcIjpcIik7d29yZHM9c3RyLnNwbGl0KFwiOlwiKTt3b3Jkc1t3b3Jkcy5sZW5ndGgtNF09anN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGgtNF0pK2pzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTNdKSoyNTY7d29yZHNbd29yZHMubGVuZ3RoLTNdPWpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTJdKStqc3RvaV9xKHdvcmRzW3dvcmRzLmxlbmd0aC0xXSkqMjU2O3dvcmRzPXdvcmRzLnNsaWNlKDAsd29yZHMubGVuZ3RoLTIpfWVsc2V7d29yZHM9c3RyLnNwbGl0KFwiOlwiKX1vZmZzZXQ9MDt6PTA7Zm9yKHc9MDt3PHdvcmRzLmxlbmd0aDt3Kyspe2lmKHR5cGVvZiB3b3Jkc1t3XT09XCJzdHJpbmdcIil7aWYod29yZHNbd109PT1cIlpcIil7Zm9yKHo9MDt6PDgtd29yZHMubGVuZ3RoKzE7eisrKXtwYXJ0c1t3K3pdPTB9b2Zmc2V0PXotMX1lbHNle3BhcnRzW3crb2Zmc2V0XT1faHRvbnMocGFyc2VJbnQod29yZHNbd10sMTYpKX19ZWxzZXtwYXJ0c1t3K29mZnNldF09d29yZHNbd119fXJldHVybltwYXJ0c1sxXTw8MTZ8cGFydHNbMF0scGFydHNbM108PDE2fHBhcnRzWzJdLHBhcnRzWzVdPDwxNnxwYXJ0c1s0XSxwYXJ0c1s3XTw8MTZ8cGFydHNbNl1dfXZhciBETlM9e2FkZHJlc3NfbWFwOntpZDoxLGFkZHJzOnt9LG5hbWVzOnt9fSxsb29rdXBfbmFtZTpmdW5jdGlvbihuYW1lKXt2YXIgcmVzPWluZXRQdG9uNChuYW1lKTtpZihyZXMhPT1udWxsKXtyZXR1cm4gbmFtZX1yZXM9aW5ldFB0b242KG5hbWUpO2lmKHJlcyE9PW51bGwpe3JldHVybiBuYW1lfXZhciBhZGRyO2lmKEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSl7YWRkcj1ETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV19ZWxzZXt2YXIgaWQ9RE5TLmFkZHJlc3NfbWFwLmlkKys7YXNzZXJ0KGlkPDY1NTM1LFwiZXhjZWVkZWQgbWF4IGFkZHJlc3MgbWFwcGluZ3Mgb2YgNjU1MzVcIik7YWRkcj1cIjE3Mi4yOS5cIisoaWQmMjU1KStcIi5cIisoaWQmNjUyODApO0ROUy5hZGRyZXNzX21hcC5uYW1lc1thZGRyXT1uYW1lO0ROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXT1hZGRyfXJldHVybiBhZGRyfSxsb29rdXBfYWRkcjpmdW5jdGlvbihhZGRyKXtpZihETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl0pe3JldHVybiBETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl19cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBnZXRTb2NrZXRBZGRyZXNzKGFkZHJwLGFkZHJsZW4sYWxsb3dOdWxsKXtpZihhbGxvd051bGwmJmFkZHJwPT09MClyZXR1cm4gbnVsbDt2YXIgaW5mbz1yZWFkU29ja2FkZHIoYWRkcnAsYWRkcmxlbik7aWYoaW5mby5lcnJubyl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihpbmZvLmVycm5vKTtpbmZvLmFkZHI9RE5TLmxvb2t1cF9hZGRyKGluZm8uYWRkcil8fGluZm8uYWRkcjtyZXR1cm4gaW5mb31mdW5jdGlvbiBfX19zeXNjYWxsX2JpbmQoZmQsYWRkcixhZGRybGVuLGQxLGQyLGQzKXt2YXIgc29jaz1nZXRTb2NrZXRGcm9tRkQoZmQpO3ZhciBpbmZvPWdldFNvY2tldEFkZHJlc3MoYWRkcixhZGRybGVuKTtzb2NrLnNvY2tfb3BzLmJpbmQoc29jayxpbmZvLmFkZHIsaW5mby5wb3J0KTtyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsX2Nvbm5lY3QoZmQsYWRkcixhZGRybGVuLGQxLGQyLGQzKXt2YXIgc29jaz1nZXRTb2NrZXRGcm9tRkQoZmQpO3ZhciBpbmZvPWdldFNvY2tldEFkZHJlc3MoYWRkcixhZGRybGVuKTtzb2NrLnNvY2tfb3BzLmNvbm5lY3Qoc29jayxpbmZvLmFkZHIsaW5mby5wb3J0KTtyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsX2ZhY2Nlc3NhdChkaXJmZCxwYXRoLGFtb2RlLGZsYWdzKXt9ZnVuY3Rpb24gX19fc3lzY2FsbF9mY250bDY0KGZkLGNtZCx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3M7cmV0dXJuIDB9ZnVuY3Rpb24gX19fc3lzY2FsbF9mc3RhdDY0KGZkLGJ1Zil7fWZ1bmN0aW9uIF9fX3N5c2NhbGxfZnRydW5jYXRlNjQoZmQsbGVuZ3RoX2xvdyxsZW5ndGhfaGlnaCl7fWZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpe291dElkeD4+Pj0wO2lmKCEobWF4Qnl0ZXNUb1dyaXRlPjApKXJldHVybiAwO3ZhciBzdGFydElkeD1vdXRJZHg7dmFyIGVuZElkeD1vdXRJZHgrbWF4Qnl0ZXNUb1dyaXRlLTE7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIHU9c3RyLmNoYXJDb2RlQXQoaSk7aWYodT49NTUyOTYmJnU8PTU3MzQzKXt2YXIgdTE9c3RyLmNoYXJDb2RlQXQoKytpKTt1PTY1NTM2KygodSYxMDIzKTw8MTApfHUxJjEwMjN9aWYodTw9MTI3KXtpZihvdXRJZHg+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrPj4+MF09dX1lbHNlIGlmKHU8PTIwNDcpe2lmKG91dElkeCsxPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrKz4+PjBdPTE5Mnx1Pj42O2hlYXBbb3V0SWR4Kys+Pj4wXT0xMjh8dSY2M31lbHNlIGlmKHU8PTY1NTM1KXtpZihvdXRJZHgrMj49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4Kys+Pj4wXT0yMjR8dT4+MTI7aGVhcFtvdXRJZHgrKz4+PjBdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4Kys+Pj4wXT0xMjh8dSY2M31lbHNle2lmKG91dElkeCszPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrKz4+PjBdPTI0MHx1Pj4xODtoZWFwW291dElkeCsrPj4+MF09MTI4fHU+PjEyJjYzO2hlYXBbb3V0SWR4Kys+Pj4wXT0xMjh8dT4+NiY2MztoZWFwW291dElkeCsrPj4+MF09MTI4fHUmNjN9fWhlYXBbb3V0SWR4Pj4+MF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fWZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSl7cmV0dXJuIHN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSl9ZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRkZW50czY0KGZkLGRpcnAsY291bnQpe31mdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3Msc2l6ZSl7SEVBUFU4LmZpbGwoMCxhZGRyZXNzLGFkZHJlc3Mrc2l6ZSk7cmV0dXJuIGFkZHJlc3N9ZnVuY3Rpb24gd3JpdGVTb2NrYWRkcihzYSxmYW1pbHksYWRkcixwb3J0LGFkZHJsZW4pe3N3aXRjaChmYW1pbHkpe2Nhc2UgMjphZGRyPWluZXRQdG9uNChhZGRyKTt6ZXJvTWVtb3J5KHNhLDE2KTtpZihhZGRybGVuKXtIRUFQMzJbYWRkcmxlbj4+PjJdPTE2fUhFQVAxNltzYT4+PjFdPWZhbWlseTtIRUFQMzJbc2ErND4+PjJdPWFkZHI7SEVBUDE2W3NhKzI+Pj4xXT1faHRvbnMocG9ydCk7YnJlYWs7Y2FzZSAxMDphZGRyPWluZXRQdG9uNihhZGRyKTt6ZXJvTWVtb3J5KHNhLDI4KTtpZihhZGRybGVuKXtIRUFQMzJbYWRkcmxlbj4+PjJdPTI4fUhFQVAzMltzYT4+PjJdPWZhbWlseTtIRUFQMzJbc2ErOD4+PjJdPWFkZHJbMF07SEVBUDMyW3NhKzEyPj4+Ml09YWRkclsxXTtIRUFQMzJbc2ErMTY+Pj4yXT1hZGRyWzJdO0hFQVAzMltzYSsyMD4+PjJdPWFkZHJbM107SEVBUDE2W3NhKzI+Pj4xXT1faHRvbnMocG9ydCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gNX1yZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsX2dldHBlZXJuYW1lKGZkLGFkZHIsYWRkcmxlbixkMSxkMixkMyl7dmFyIHNvY2s9Z2V0U29ja2V0RnJvbUZEKGZkKTtpZighc29jay5kYWRkcil7cmV0dXJuLTUzfXZhciBlcnJubz13cml0ZVNvY2thZGRyKGFkZHIsc29jay5mYW1pbHksRE5TLmxvb2t1cF9uYW1lKHNvY2suZGFkZHIpLHNvY2suZHBvcnQsYWRkcmxlbik7cmV0dXJuIDB9ZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRzb2Nrb3B0KGZkLGxldmVsLG9wdG5hbWUsb3B0dmFsLG9wdGxlbixkMSl7dmFyIHNvY2s9Z2V0U29ja2V0RnJvbUZEKGZkKTtpZihsZXZlbD09PTEpe2lmKG9wdG5hbWU9PT00KXtIRUFQMzJbb3B0dmFsPj4+Ml09c29jay5lcnJvcjtIRUFQMzJbb3B0bGVuPj4+Ml09NDtzb2NrLmVycm9yPW51bGw7cmV0dXJuIDB9fXJldHVybi01MH1mdW5jdGlvbiBfX19zeXNjYWxsX2lvY3RsKGZkLG9wLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJncztyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsX2xzdGF0NjQocGF0aCxidWYpe31mdW5jdGlvbiBfX19zeXNjYWxsX21rZGlyYXQoZGlyZmQscGF0aCxtb2RlKXt9ZnVuY3Rpb24gX19fc3lzY2FsbF9uZXdmc3RhdGF0KGRpcmZkLHBhdGgsYnVmLGZsYWdzKXt9ZnVuY3Rpb24gX19fc3lzY2FsbF9vcGVuYXQoZGlyZmQscGF0aCxmbGFncyx2YXJhcmdzKXtTWVNDQUxMUy52YXJhcmdzPXZhcmFyZ3N9ZnVuY3Rpb24gX19fc3lzY2FsbF9yZWN2ZnJvbShmZCxidWYsbGVuLGZsYWdzLGFkZHIsYWRkcmxlbil7dmFyIHNvY2s9Z2V0U29ja2V0RnJvbUZEKGZkKTt2YXIgbXNnPXNvY2suc29ja19vcHMucmVjdm1zZyhzb2NrLGxlbik7aWYoIW1zZylyZXR1cm4gMDtpZihhZGRyKXt2YXIgZXJybm89d3JpdGVTb2NrYWRkcihhZGRyLHNvY2suZmFtaWx5LEROUy5sb29rdXBfbmFtZShtc2cuYWRkciksbXNnLnBvcnQsYWRkcmxlbil9SEVBUFU4LnNldChtc2cuYnVmZmVyLGJ1Zj4+PjApO3JldHVybiBtc2cuYnVmZmVyLmJ5dGVMZW5ndGh9ZnVuY3Rpb24gX19fc3lzY2FsbF9yZW5hbWVhdChvbGRkaXJmZCxvbGRwYXRoLG5ld2RpcmZkLG5ld3BhdGgpe31mdW5jdGlvbiBfX19zeXNjYWxsX3JtZGlyKHBhdGgpe31mdW5jdGlvbiBfX19zeXNjYWxsX3NlbmR0byhmZCxtZXNzYWdlLGxlbmd0aCxmbGFncyxhZGRyLGFkZHJfbGVuKXt9ZnVuY3Rpb24gX19fc3lzY2FsbF9zb2NrZXQoZG9tYWluLHR5cGUscHJvdG9jb2wpe31mdW5jdGlvbiBfX19zeXNjYWxsX3N0YXQ2NChwYXRoLGJ1Zil7fWZ1bmN0aW9uIF9fX3N5c2NhbGxfdW5saW5rYXQoZGlyZmQscGF0aCxmbGFncyl7fXZhciBub3dJc01vbm90b25pYz10cnVlO2Z1bmN0aW9uIF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYygpe3JldHVybiBub3dJc01vbm90b25pY31mdW5jdGlvbiByZWFkSTUzRnJvbUk2NChwdHIpe3JldHVybiBIRUFQVTMyW3B0cj4+PjJdK0hFQVAzMltwdHIrND4+PjJdKjQyOTQ5NjcyOTZ9ZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKXtyZXR1cm4geWVhciU0PT09MCYmKHllYXIlMTAwIT09MHx8eWVhciU0MDA9PT0wKX12YXIgTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkU9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV07dmFyIE1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO2Z1bmN0aW9uIHlkYXlGcm9tRGF0ZShkYXRlKXt2YXIgbGVhcD1pc0xlYXBZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7dmFyIG1vbnRoRGF5c0N1bXVsYXRpdmU9bGVhcD9NT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRTpNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRTt2YXIgeWRheT1tb250aERheXNDdW11bGF0aXZlW2RhdGUuZ2V0TW9udGgoKV0rZGF0ZS5nZXREYXRlKCktMTtyZXR1cm4geWRheX1mdW5jdGlvbiBfX2xvY2FsdGltZV9qcyh0aW1lLHRtUHRyKXt2YXIgZGF0ZT1uZXcgRGF0ZShyZWFkSTUzRnJvbUk2NCh0aW1lKSoxZTMpO0hFQVAzMlt0bVB0cj4+PjJdPWRhdGUuZ2V0U2Vjb25kcygpO0hFQVAzMlt0bVB0cis0Pj4+Ml09ZGF0ZS5nZXRNaW51dGVzKCk7SEVBUDMyW3RtUHRyKzg+Pj4yXT1kYXRlLmdldEhvdXJzKCk7SEVBUDMyW3RtUHRyKzEyPj4+Ml09ZGF0ZS5nZXREYXRlKCk7SEVBUDMyW3RtUHRyKzE2Pj4+Ml09ZGF0ZS5nZXRNb250aCgpO0hFQVAzMlt0bVB0cisyMD4+PjJdPWRhdGUuZ2V0RnVsbFllYXIoKS0xOTAwO0hFQVAzMlt0bVB0cisyND4+PjJdPWRhdGUuZ2V0RGF5KCk7dmFyIHlkYXk9eWRheUZyb21EYXRlKGRhdGUpfDA7SEVBUDMyW3RtUHRyKzI4Pj4+Ml09eWRheTtIRUFQMzJbdG1QdHIrMzY+Pj4yXT0tKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MCk7dmFyIHN0YXJ0PW5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwwLDEpO3ZhciBzdW1tZXJPZmZzZXQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgd2ludGVyT2Zmc2V0PXN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIGRzdD0oc3VtbWVyT2Zmc2V0IT13aW50ZXJPZmZzZXQmJmRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4od2ludGVyT2Zmc2V0LHN1bW1lck9mZnNldCkpfDA7SEVBUDMyW3RtUHRyKzMyPj4+Ml09ZHN0fWZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpe3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgYz1zdHIuY2hhckNvZGVBdChpKTtpZihjPD0xMjcpe2xlbisrfWVsc2UgaWYoYzw9MjA0Nyl7bGVuKz0yfWVsc2UgaWYoYz49NTUyOTYmJmM8PTU3MzQzKXtsZW4rPTQ7KytpfWVsc2V7bGVuKz0zfX1yZXR1cm4gbGVufWZ1bmN0aW9uIHN0cmluZ1RvTmV3VVRGOChzdHIpe3ZhciBzaXplPWxlbmd0aEJ5dGVzVVRGOChzdHIpKzE7dmFyIHJldD1fbWFsbG9jKHNpemUpO2lmKHJldClzdHJpbmdUb1VURjgoc3RyLHJldCxzaXplKTtyZXR1cm4gcmV0fWZ1bmN0aW9uIF9fdHpzZXRfanModGltZXpvbmUsZGF5bGlnaHQsdHpuYW1lKXt2YXIgY3VycmVudFllYXI9KG5ldyBEYXRlKS5nZXRGdWxsWWVhcigpO3ZhciB3aW50ZXI9bmV3IERhdGUoY3VycmVudFllYXIsMCwxKTt2YXIgc3VtbWVyPW5ldyBEYXRlKGN1cnJlbnRZZWFyLDYsMSk7dmFyIHdpbnRlck9mZnNldD13aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgc3VtbWVyT2Zmc2V0PXN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdGRUaW1lem9uZU9mZnNldD1NYXRoLm1heCh3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KTtIRUFQVTMyW3RpbWV6b25lPj4+Ml09c3RkVGltZXpvbmVPZmZzZXQqNjA7SEVBUDMyW2RheWxpZ2h0Pj4+Ml09TnVtYmVyKHdpbnRlck9mZnNldCE9c3VtbWVyT2Zmc2V0KTtmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKXt2YXIgbWF0Y2g9ZGF0ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pO3JldHVybiBtYXRjaD9tYXRjaFsxXTpcIkdNVFwifXZhciB3aW50ZXJOYW1lPWV4dHJhY3Rab25lKHdpbnRlcik7dmFyIHN1bW1lck5hbWU9ZXh0cmFjdFpvbmUoc3VtbWVyKTt2YXIgd2ludGVyTmFtZVB0cj1zdHJpbmdUb05ld1VURjgod2ludGVyTmFtZSk7dmFyIHN1bW1lck5hbWVQdHI9c3RyaW5nVG9OZXdVVEY4KHN1bW1lck5hbWUpO2lmKHN1bW1lck9mZnNldDx3aW50ZXJPZmZzZXQpe0hFQVBVMzJbdHpuYW1lPj4+Ml09d2ludGVyTmFtZVB0cjtIRUFQVTMyW3R6bmFtZSs0Pj4+Ml09c3VtbWVyTmFtZVB0cn1lbHNle0hFQVBVMzJbdHpuYW1lPj4+Ml09c3VtbWVyTmFtZVB0cjtIRUFQVTMyW3R6bmFtZSs0Pj4+Ml09d2ludGVyTmFtZVB0cn19ZnVuY3Rpb24gX2Fib3J0KCl7YWJvcnQoXCJcIil9ZnVuY3Rpb24gX2Rsb3BlbihmaWxlbmFtZSxmbGFncyl7YWJvcnQoZGxvcGVuTWlzc2luZ0Vycm9yKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfY3JlYXRlKHBhdGgscGF0aExlbil7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY3JlYXRlRGlyZWN0b3J5KE1vZHVsZSxwYXRoLHBhdGhMZW4pfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9leGlzdHMocGF0aCxwYXRoTGVuKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jaGVja0RpcmVjdG9yeShNb2R1bGUscGF0aCxwYXRoTGVuKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlcyhwYXRoLHBhdGhMZW4pe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmxpc3REaXJlY3RvcnlFbnRyaWVzKE1vZHVsZSxwYXRoLHBhdGhMZW4pfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9yZW1vdmUocGF0aCxwYXRoTGVuKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5yZW1vdmVEaXJlY3RvcnkoTW9kdWxlLHBhdGgscGF0aExlbil9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9jbG9zZShmaWxlSWQpe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNsb3NlRmlsZShNb2R1bGUsZmlsZUlkKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2V4aXN0cyhwYXRoLHBhdGhMZW4pe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNoZWNrRmlsZShNb2R1bGUscGF0aCxwYXRoTGVuKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2dldF9sYXN0X21vZGlmaWVkX3RpbWUoZmlsZUlkKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWUoTW9kdWxlLGZpbGVJZCl9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlKGZyb20sZnJvbUxlbix0byx0b0xlbil7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUubW92ZUZpbGUoTW9kdWxlLGZyb20sZnJvbUxlbix0byx0b0xlbil9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9vcGVuKGZpbGVJZCxmbGFncyl7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUub3BlbkZpbGUoTW9kdWxlLGZpbGVJZCxmbGFncyl9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkKGZpbGVJZCxidWYsc2l6ZSxsb2NhdGlvbil7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUucmVhZEZpbGUoTW9kdWxlLGZpbGVJZCxidWYsc2l6ZSxsb2NhdGlvbil9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV90cnVuY2F0ZShmaWxlSWQsbmV3U2l6ZSl7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUudHJ1bmNhdGVGaWxlKE1vZHVsZSxmaWxlSWQsbmV3U2l6ZSl9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZShmaWxlSWQsYnVmLHNpemUsbG9jYXRpb24pe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLndyaXRlRmlsZShNb2R1bGUsZmlsZUlkLGJ1ZixzaXplLGxvY2F0aW9uKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19nZXRfZGVmYXVsdF9kYXRhX3Byb3RvY29sKE1vZHVsZSl7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuZ2V0RGVmYXVsdERhdGFQcm90b2NvbChNb2R1bGUpfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2dsb2IocGF0aCxwYXRoTGVuKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nbG9iKE1vZHVsZSxwYXRoLHBhdGhMZW4pfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX3Rlc3RfcGxhdGZvcm1fZmVhdHVyZShmZWF0dXJlKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS50ZXN0UGxhdGZvcm1GZWF0dXJlKE1vZHVsZSxmZWF0dXJlKX1mdW5jdGlvbiBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGwoZnVuY0lkLGRlc2NQdHIsZGVzY1NpemUscHRyc1B0cixwdHJzU2l6ZSxyZXNwb25zZSl7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2FsbFNjYWxhclVERihNb2R1bGUsZnVuY0lkLGRlc2NQdHIsZGVzY1NpemUscHRyc1B0cixwdHJzU2l6ZSxyZXNwb25zZSl9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZGF0ZV9ub3coKXtyZXR1cm4gRGF0ZS5ub3coKX1mdW5jdGlvbiBnZXRIZWFwTWF4KCl7cmV0dXJuIDQyOTQ5MDE3NjB9ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4KCl7cmV0dXJuIGdldEhlYXBNYXgoKX12YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztpZihFTlZJUk9OTUVOVF9JU19OT0RFKXtnbG9iYWwucGVyZm9ybWFuY2U9cmVxdWlyZShcInBlcmZfaG9va3NcIikucGVyZm9ybWFuY2V9X2Vtc2NyaXB0ZW5fZ2V0X25vdz0oKT0+cGVyZm9ybWFuY2Uubm93KCk7ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyhkZXN0LHNyYyxudW0pe0hFQVBVOC5jb3B5V2l0aGluKGRlc3Q+Pj4wLHNyYz4+PjAsc3JjK251bT4+PjApfWZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSl7dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7dmFyIHBhZ2VzPXNpemUtYi5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTY7dHJ5e3dhc21NZW1vcnkuZ3JvdyhwYWdlcyk7dXBkYXRlTWVtb3J5Vmlld3MoKTtyZXR1cm4gMX1jYXRjaChlKXt9fWZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpe3ZhciBvbGRTaXplPUhFQVBVOC5sZW5ndGg7cmVxdWVzdGVkU2l6ZT1yZXF1ZXN0ZWRTaXplPj4+MDt2YXIgbWF4SGVhcFNpemU9Z2V0SGVhcE1heCgpO2lmKHJlcXVlc3RlZFNpemU+bWF4SGVhcFNpemUpe3JldHVybiBmYWxzZX12YXIgYWxpZ25VcD0oeCxtdWx0aXBsZSk9PngrKG11bHRpcGxlLXglbXVsdGlwbGUpJW11bHRpcGxlO2Zvcih2YXIgY3V0RG93bj0xO2N1dERvd248PTQ7Y3V0RG93bio9Mil7dmFyIG92ZXJHcm93bkhlYXBTaXplPW9sZFNpemUqKDErLjIvY3V0RG93bik7b3Zlckdyb3duSGVhcFNpemU9TWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUscmVxdWVzdGVkU2l6ZSsxMDA2NjMyOTYpO3ZhciBuZXdTaXplPU1hdGgubWluKG1heEhlYXBTaXplLGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSxvdmVyR3Jvd25IZWFwU2l6ZSksNjU1MzYpKTt2YXIgcmVwbGFjZW1lbnQ9ZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtpZihyZXBsYWNlbWVudCl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX12YXIgRU5WPXt9O2Z1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCl7cmV0dXJuIHRoaXNQcm9ncmFtfHxcIi4vdGhpcy5wcm9ncmFtXCJ9ZnVuY3Rpb24gZ2V0RW52U3RyaW5ncygpe2lmKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3Mpe3ZhciBsYW5nPSh0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIjt2YXIgZW52PXtcIlVTRVJcIjpcIndlYl91c2VyXCIsXCJMT0dOQU1FXCI6XCJ3ZWJfdXNlclwiLFwiUEFUSFwiOlwiL1wiLFwiUFdEXCI6XCIvXCIsXCJIT01FXCI6XCIvaG9tZS93ZWJfdXNlclwiLFwiTEFOR1wiOmxhbmcsXCJfXCI6Z2V0RXhlY3V0YWJsZU5hbWUoKX07Zm9yKHZhciB4IGluIEVOVil7aWYoRU5WW3hdPT09dW5kZWZpbmVkKWRlbGV0ZSBlbnZbeF07ZWxzZSBlbnZbeF09RU5WW3hdfXZhciBzdHJpbmdzPVtdO2Zvcih2YXIgeCBpbiBlbnYpe3N0cmluZ3MucHVzaChgJHt4fT0ke2Vudlt4XX1gKX1nZXRFbnZTdHJpbmdzLnN0cmluZ3M9c3RyaW5nc31yZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzfWZ1bmN0aW9uIHN0cmluZ1RvQXNjaWkoc3RyLGJ1ZmZlcil7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7SEVBUDhbYnVmZmVyKys+Pj4wXT1zdHIuY2hhckNvZGVBdChpKX1IRUFQOFtidWZmZXI+Pj4wXT0wfWZ1bmN0aW9uIF9lbnZpcm9uX2dldChfX2Vudmlyb24sZW52aXJvbl9idWYpe3ZhciBidWZTaXplPTA7Z2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLGkpe3ZhciBwdHI9ZW52aXJvbl9idWYrYnVmU2l6ZTtIRUFQVTMyW19fZW52aXJvbitpKjQ+Pj4yXT1wdHI7c3RyaW5nVG9Bc2NpaShzdHJpbmcscHRyKTtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtyZXR1cm4gMH1mdW5jdGlvbiBfZW52aXJvbl9zaXplc19nZXQocGVudmlyb25fY291bnQscGVudmlyb25fYnVmX3NpemUpe3ZhciBzdHJpbmdzPWdldEVudlN0cmluZ3MoKTtIRUFQVTMyW3BlbnZpcm9uX2NvdW50Pj4+Ml09c3RyaW5ncy5sZW5ndGg7dmFyIGJ1ZlNpemU9MDtzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nKXtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtIRUFQVTMyW3BlbnZpcm9uX2J1Zl9zaXplPj4+Ml09YnVmU2l6ZTtyZXR1cm4gMH1mdW5jdGlvbiBfZmRfY2xvc2UoZmQpe3JldHVybiA1Mn1mdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCxwYnVmKXt2YXIgcmlnaHRzQmFzZT0wO3ZhciByaWdodHNJbmhlcml0aW5nPTA7dmFyIGZsYWdzPTA7e3ZhciB0eXBlPTI7aWYoZmQ9PTApe3JpZ2h0c0Jhc2U9Mn1lbHNlIGlmKGZkPT0xfHxmZD09Mil7cmlnaHRzQmFzZT02NH1mbGFncz0xfUhFQVA4W3BidWY+Pj4wXT10eXBlO0hFQVAxNltwYnVmKzI+Pj4xXT1mbGFnczt0ZW1wSTY0PVtyaWdodHNCYXNlPj4+MCwodGVtcERvdWJsZT1yaWdodHNCYXNlLCtNYXRoLmFicyh0ZW1wRG91YmxlKT49MT90ZW1wRG91YmxlPjA/K01hdGguZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlLSsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sSEVBUDMyW3BidWYrOD4+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW3BidWYrMTI+Pj4yXT10ZW1wSTY0WzFdO3RlbXBJNjQ9W3JpZ2h0c0luaGVyaXRpbmc+Pj4wLCh0ZW1wRG91YmxlPXJpZ2h0c0luaGVyaXRpbmcsK01hdGguYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8rTWF0aC5mbG9vcih0ZW1wRG91YmxlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUtKyh+fnRlbXBEb3VibGU+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApXSxIRUFQMzJbcGJ1ZisxNj4+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW3BidWYrMjA+Pj4yXT10ZW1wSTY0WzFdO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9wcmVhZChmZCxpb3YsaW92Y250LG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gscG51bSl7cmV0dXJuIDUyfWZ1bmN0aW9uIF9mZF9wd3JpdGUoZmQsaW92LGlvdmNudCxvZmZzZXRfbG93LG9mZnNldF9oaWdoLHBudW0pe3JldHVybiA1Mn1mdW5jdGlvbiBfZmRfcmVhZChmZCxpb3YsaW92Y250LHBudW0pe3JldHVybiA1Mn1mdW5jdGlvbiBfZmRfc2VlayhmZCxvZmZzZXRfbG93LG9mZnNldF9oaWdoLHdoZW5jZSxuZXdPZmZzZXQpe3JldHVybiA3MH1mdW5jdGlvbiBfZmRfc3luYyhmZCl7cmV0dXJuIDUyfXZhciBwcmludENoYXJCdWZmZXJzPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBwcmludENoYXIoc3RyZWFtLGN1cnIpe3ZhciBidWZmZXI9cHJpbnRDaGFyQnVmZmVyc1tzdHJlYW1dO2lmKGN1cnI9PT0wfHxjdXJyPT09MTApeyhzdHJlYW09PT0xP291dDplcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwwKSk7YnVmZmVyLmxlbmd0aD0wfWVsc2V7YnVmZmVyLnB1c2goY3Vycil9fWZ1bmN0aW9uIF9mZF93cml0ZShmZCxpb3YsaW92Y250LHBudW0pe3ZhciBudW09MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUFUzMltpb3Y+Pj4yXTt2YXIgbGVuPUhFQVBVMzJbaW92KzQ+Pj4yXTtpb3YrPTg7Zm9yKHZhciBqPTA7ajxsZW47aisrKXtwcmludENoYXIoZmQsSEVBUFU4W3B0citqPj4+MF0pfW51bSs9bGVufUhFQVBVMzJbcG51bT4+PjJdPW51bTtyZXR1cm4gMH1mdW5jdGlvbiBfZ2V0YWRkcmluZm8obm9kZSxzZXJ2aWNlLGhpbnQsb3V0KXt2YXIgYWRkcj0wO3ZhciBwb3J0PTA7dmFyIGZsYWdzPTA7dmFyIGZhbWlseT0wO3ZhciB0eXBlPTA7dmFyIHByb3RvPTA7dmFyIGFpO2Z1bmN0aW9uIGFsbG9jYWRkcmluZm8oZmFtaWx5LHR5cGUscHJvdG8sY2Fub24sYWRkcixwb3J0KXt2YXIgc2Esc2FsZW4sYWk7dmFyIGVycm5vO3NhbGVuPWZhbWlseT09PTEwPzI4OjE2O2FkZHI9ZmFtaWx5PT09MTA/aW5ldE50b3A2KGFkZHIpOmluZXROdG9wNChhZGRyKTtzYT1fbWFsbG9jKHNhbGVuKTtlcnJubz13cml0ZVNvY2thZGRyKHNhLGZhbWlseSxhZGRyLHBvcnQpO2Fzc2VydCghZXJybm8pO2FpPV9tYWxsb2MoMzIpO0hFQVAzMlthaSs0Pj4+Ml09ZmFtaWx5O0hFQVAzMlthaSs4Pj4+Ml09dHlwZTtIRUFQMzJbYWkrMTI+Pj4yXT1wcm90bztIRUFQVTMyW2FpKzI0Pj4+Ml09Y2Fub247SEVBUFUzMlthaSsyMD4+PjJdPXNhO2lmKGZhbWlseT09PTEwKXtIRUFQMzJbYWkrMTY+Pj4yXT0yOH1lbHNle0hFQVAzMlthaSsxNj4+PjJdPTE2fUhFQVAzMlthaSsyOD4+PjJdPTA7cmV0dXJuIGFpfWlmKGhpbnQpe2ZsYWdzPUhFQVAzMltoaW50Pj4+Ml07ZmFtaWx5PUhFQVAzMltoaW50KzQ+Pj4yXTt0eXBlPUhFQVAzMltoaW50Kzg+Pj4yXTtwcm90bz1IRUFQMzJbaGludCsxMj4+PjJdfWlmKHR5cGUmJiFwcm90byl7cHJvdG89dHlwZT09PTI/MTc6Nn1pZighdHlwZSYmcHJvdG8pe3R5cGU9cHJvdG89PT0xNz8yOjF9aWYocHJvdG89PT0wKXtwcm90bz02fWlmKHR5cGU9PT0wKXt0eXBlPTF9aWYoIW5vZGUmJiFzZXJ2aWNlKXtyZXR1cm4tMn1pZihmbGFncyZ+KDF8Mnw0fDEwMjR8OHwxNnwzMikpe3JldHVybi0xfWlmKGhpbnQhPT0wJiZIRUFQMzJbaGludD4+PjJdJjImJiFub2RlKXtyZXR1cm4tMX1pZihmbGFncyYzMil7cmV0dXJuLTJ9aWYodHlwZSE9PTAmJnR5cGUhPT0xJiZ0eXBlIT09Mil7cmV0dXJuLTd9aWYoZmFtaWx5IT09MCYmZmFtaWx5IT09MiYmZmFtaWx5IT09MTApe3JldHVybi02fWlmKHNlcnZpY2Upe3NlcnZpY2U9VVRGOFRvU3RyaW5nKHNlcnZpY2UpO3BvcnQ9cGFyc2VJbnQoc2VydmljZSwxMCk7aWYoaXNOYU4ocG9ydCkpe2lmKGZsYWdzJjEwMjQpe3JldHVybi0yfXJldHVybi04fX1pZighbm9kZSl7aWYoZmFtaWx5PT09MCl7ZmFtaWx5PTJ9aWYoKGZsYWdzJjEpPT09MCl7aWYoZmFtaWx5PT09Mil7YWRkcj1faHRvbmwoMjEzMDcwNjQzMyl9ZWxzZXthZGRyPVswLDAsMCwxXX19YWk9YWxsb2NhZGRyaW5mbyhmYW1pbHksdHlwZSxwcm90byxudWxsLGFkZHIscG9ydCk7SEVBUFUzMltvdXQ+Pj4yXT1haTtyZXR1cm4gMH1ub2RlPVVURjhUb1N0cmluZyhub2RlKTthZGRyPWluZXRQdG9uNChub2RlKTtpZihhZGRyIT09bnVsbCl7aWYoZmFtaWx5PT09MHx8ZmFtaWx5PT09Mil7ZmFtaWx5PTJ9ZWxzZSBpZihmYW1pbHk9PT0xMCYmZmxhZ3MmOCl7YWRkcj1bMCwwLF9odG9ubCg2NTUzNSksYWRkcl07ZmFtaWx5PTEwfWVsc2V7cmV0dXJuLTJ9fWVsc2V7YWRkcj1pbmV0UHRvbjYobm9kZSk7aWYoYWRkciE9PW51bGwpe2lmKGZhbWlseT09PTB8fGZhbWlseT09PTEwKXtmYW1pbHk9MTB9ZWxzZXtyZXR1cm4tMn19fWlmKGFkZHIhPW51bGwpe2FpPWFsbG9jYWRkcmluZm8oZmFtaWx5LHR5cGUscHJvdG8sbm9kZSxhZGRyLHBvcnQpO0hFQVBVMzJbb3V0Pj4+Ml09YWk7cmV0dXJuIDB9aWYoZmxhZ3MmNCl7cmV0dXJuLTJ9bm9kZT1ETlMubG9va3VwX25hbWUobm9kZSk7YWRkcj1pbmV0UHRvbjQobm9kZSk7aWYoZmFtaWx5PT09MCl7ZmFtaWx5PTJ9ZWxzZSBpZihmYW1pbHk9PT0xMCl7YWRkcj1bMCwwLF9odG9ubCg2NTUzNSksYWRkcl19YWk9YWxsb2NhZGRyaW5mbyhmYW1pbHksdHlwZSxwcm90byxudWxsLGFkZHIscG9ydCk7SEVBUFUzMltvdXQ+Pj4yXT1haTtyZXR1cm4gMH1mdW5jdGlvbiBpbml0UmFuZG9tRmlsbCgpe2lmKHR5cGVvZiBjcnlwdG89PVwib2JqZWN0XCImJnR5cGVvZiBjcnlwdG9bXCJnZXRSYW5kb21WYWx1ZXNcIl09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHZpZXc9PmNyeXB0by5nZXRSYW5kb21WYWx1ZXModmlldyl9ZWxzZSBpZihFTlZJUk9OTUVOVF9JU19OT0RFKXt0cnl7dmFyIGNyeXB0b19tb2R1bGU9cmVxdWlyZShcImNyeXB0b1wiKTt2YXIgcmFuZG9tRmlsbFN5bmM9Y3J5cHRvX21vZHVsZVtcInJhbmRvbUZpbGxTeW5jXCJdO2lmKHJhbmRvbUZpbGxTeW5jKXtyZXR1cm4gdmlldz0+Y3J5cHRvX21vZHVsZVtcInJhbmRvbUZpbGxTeW5jXCJdKHZpZXcpfXZhciByYW5kb21CeXRlcz1jcnlwdG9fbW9kdWxlW1wicmFuZG9tQnl0ZXNcIl07cmV0dXJuIHZpZXc9Pih2aWV3LnNldChyYW5kb21CeXRlcyh2aWV3LmJ5dGVMZW5ndGgpKSx2aWV3KX1jYXRjaChlKXt9fWFib3J0KFwiaW5pdFJhbmRvbURldmljZVwiKX1mdW5jdGlvbiByYW5kb21GaWxsKHZpZXcpe3JldHVybihyYW5kb21GaWxsPWluaXRSYW5kb21GaWxsKCkpKHZpZXcpfWZ1bmN0aW9uIF9nZXRlbnRyb3B5KGJ1ZmZlcixzaXplKXtyYW5kb21GaWxsKEhFQVBVOC5zdWJhcnJheShidWZmZXI+Pj4wLGJ1ZmZlcitzaXplPj4+MCkpO3JldHVybiAwfWZ1bmN0aW9uIF9nZXRuYW1laW5mbyhzYSxzYWxlbixub2RlLG5vZGVsZW4sc2VydixzZXJ2bGVuLGZsYWdzKXt2YXIgaW5mbz1yZWFkU29ja2FkZHIoc2Esc2FsZW4pO2lmKGluZm8uZXJybm8pe3JldHVybi02fXZhciBwb3J0PWluZm8ucG9ydDt2YXIgYWRkcj1pbmZvLmFkZHI7dmFyIG92ZXJmbG93ZWQ9ZmFsc2U7aWYobm9kZSYmbm9kZWxlbil7dmFyIGxvb2t1cDtpZihmbGFncyYxfHwhKGxvb2t1cD1ETlMubG9va3VwX2FkZHIoYWRkcikpKXtpZihmbGFncyY4KXtyZXR1cm4tMn19ZWxzZXthZGRyPWxvb2t1cH12YXIgbnVtQnl0ZXNXcml0dGVuRXhjbE51bGw9c3RyaW5nVG9VVEY4KGFkZHIsbm9kZSxub2RlbGVuKTtpZihudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCsxPj1ub2RlbGVuKXtvdmVyZmxvd2VkPXRydWV9fWlmKHNlcnYmJnNlcnZsZW4pe3BvcnQ9XCJcIitwb3J0O3ZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbD1zdHJpbmdUb1VURjgocG9ydCxzZXJ2LHNlcnZsZW4pO2lmKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsKzE+PXNlcnZsZW4pe292ZXJmbG93ZWQ9dHJ1ZX19aWYob3ZlcmZsb3dlZCl7cmV0dXJuLTEyfXJldHVybiAwfWZ1bmN0aW9uIGFycmF5U3VtKGFycmF5LGluZGV4KXt2YXIgc3VtPTA7Zm9yKHZhciBpPTA7aTw9aW5kZXg7c3VtKz1hcnJheVtpKytdKXt9cmV0dXJuIHN1bX12YXIgTU9OVEhfREFZU19MRUFQPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07dmFyIE1PTlRIX0RBWVNfUkVHVUxBUj1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO2Z1bmN0aW9uIGFkZERheXMoZGF0ZSxkYXlzKXt2YXIgbmV3RGF0ZT1uZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7d2hpbGUoZGF5cz4wKXt2YXIgbGVhcD1pc0xlYXBZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSk7dmFyIGN1cnJlbnRNb250aD1uZXdEYXRlLmdldE1vbnRoKCk7dmFyIGRheXNJbkN1cnJlbnRNb250aD0obGVhcD9NT05USF9EQVlTX0xFQVA6TU9OVEhfREFZU19SRUdVTEFSKVtjdXJyZW50TW9udGhdO2lmKGRheXM+ZGF5c0luQ3VycmVudE1vbnRoLW5ld0RhdGUuZ2V0RGF0ZSgpKXtkYXlzLT1kYXlzSW5DdXJyZW50TW9udGgtbmV3RGF0ZS5nZXREYXRlKCkrMTtuZXdEYXRlLnNldERhdGUoMSk7aWYoY3VycmVudE1vbnRoPDExKXtuZXdEYXRlLnNldE1vbnRoKGN1cnJlbnRNb250aCsxKX1lbHNle25ld0RhdGUuc2V0TW9udGgoMCk7bmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkrMSl9fWVsc2V7bmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpK2RheXMpO3JldHVybiBuZXdEYXRlfX1yZXR1cm4gbmV3RGF0ZX1mdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSxkb250QWRkTnVsbCxsZW5ndGgpe3ZhciBsZW49bGVuZ3RoPjA/bGVuZ3RoOmxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO3ZhciB1OGFycmF5PW5ldyBBcnJheShsZW4pO3ZhciBudW1CeXRlc1dyaXR0ZW49c3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSx1OGFycmF5LDAsdThhcnJheS5sZW5ndGgpO2lmKGRvbnRBZGROdWxsKXU4YXJyYXkubGVuZ3RoPW51bUJ5dGVzV3JpdHRlbjtyZXR1cm4gdThhcnJheX1mdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksYnVmZmVyKXtIRUFQOC5zZXQoYXJyYXksYnVmZmVyPj4+MCl9ZnVuY3Rpb24gX3N0cmZ0aW1lKHMsbWF4c2l6ZSxmb3JtYXQsdG0pe3ZhciB0bV96b25lPUhFQVAzMlt0bSs0MD4+PjJdO3ZhciBkYXRlPXt0bV9zZWM6SEVBUDMyW3RtPj4+Ml0sdG1fbWluOkhFQVAzMlt0bSs0Pj4+Ml0sdG1faG91cjpIRUFQMzJbdG0rOD4+PjJdLHRtX21kYXk6SEVBUDMyW3RtKzEyPj4+Ml0sdG1fbW9uOkhFQVAzMlt0bSsxNj4+PjJdLHRtX3llYXI6SEVBUDMyW3RtKzIwPj4+Ml0sdG1fd2RheTpIRUFQMzJbdG0rMjQ+Pj4yXSx0bV95ZGF5OkhFQVAzMlt0bSsyOD4+PjJdLHRtX2lzZHN0OkhFQVAzMlt0bSszMj4+PjJdLHRtX2dtdG9mZjpIRUFQMzJbdG0rMzY+Pj4yXSx0bV96b25lOnRtX3pvbmU/VVRGOFRvU3RyaW5nKHRtX3pvbmUpOlwiXCJ9O3ZhciBwYXR0ZXJuPVVURjhUb1N0cmluZyhmb3JtYXQpO3ZhciBFWFBBTlNJT05fUlVMRVNfMT17XCIlY1wiOlwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcIiVEXCI6XCIlbS8lZC8leVwiLFwiJUZcIjpcIiVZLSVtLSVkXCIsXCIlaFwiOlwiJWJcIixcIiVyXCI6XCIlSTolTTolUyAlcFwiLFwiJVJcIjpcIiVIOiVNXCIsXCIlVFwiOlwiJUg6JU06JVNcIixcIiV4XCI6XCIlbS8lZC8leVwiLFwiJVhcIjpcIiVIOiVNOiVTXCIsXCIlRWNcIjpcIiVjXCIsXCIlRUNcIjpcIiVDXCIsXCIlRXhcIjpcIiVtLyVkLyV5XCIsXCIlRVhcIjpcIiVIOiVNOiVTXCIsXCIlRXlcIjpcIiV5XCIsXCIlRVlcIjpcIiVZXCIsXCIlT2RcIjpcIiVkXCIsXCIlT2VcIjpcIiVlXCIsXCIlT0hcIjpcIiVIXCIsXCIlT0lcIjpcIiVJXCIsXCIlT21cIjpcIiVtXCIsXCIlT01cIjpcIiVNXCIsXCIlT1NcIjpcIiVTXCIsXCIlT3VcIjpcIiV1XCIsXCIlT1VcIjpcIiVVXCIsXCIlT1ZcIjpcIiVWXCIsXCIlT3dcIjpcIiV3XCIsXCIlT1dcIjpcIiVXXCIsXCIlT3lcIjpcIiV5XCJ9O2Zvcih2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMSl7cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLFwiZ1wiKSxFWFBBTlNJT05fUlVMRVNfMVtydWxlXSl9dmFyIFdFRUtEQVlTPVtcIlN1bmRheVwiLFwiTW9uZGF5XCIsXCJUdWVzZGF5XCIsXCJXZWRuZXNkYXlcIixcIlRodXJzZGF5XCIsXCJGcmlkYXlcIixcIlNhdHVyZGF5XCJdO3ZhciBNT05USFM9W1wiSmFudWFyeVwiLFwiRmVicnVhcnlcIixcIk1hcmNoXCIsXCJBcHJpbFwiLFwiTWF5XCIsXCJKdW5lXCIsXCJKdWx5XCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2N0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdO2Z1bmN0aW9uIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsZGlnaXRzLGNoYXJhY3Rlcil7dmFyIHN0cj10eXBlb2YgdmFsdWU9PVwibnVtYmVyXCI/dmFsdWUudG9TdHJpbmcoKTp2YWx1ZXx8XCJcIjt3aGlsZShzdHIubGVuZ3RoPGRpZ2l0cyl7c3RyPWNoYXJhY3RlclswXStzdHJ9cmV0dXJuIHN0cn1mdW5jdGlvbiBsZWFkaW5nTnVsbHModmFsdWUsZGlnaXRzKXtyZXR1cm4gbGVhZGluZ1NvbWV0aGluZyh2YWx1ZSxkaWdpdHMsXCIwXCIpfWZ1bmN0aW9uIGNvbXBhcmVCeURheShkYXRlMSxkYXRlMil7ZnVuY3Rpb24gc2duKHZhbHVlKXtyZXR1cm4gdmFsdWU8MD8tMTp2YWx1ZT4wPzE6MH12YXIgY29tcGFyZTtpZigoY29tcGFyZT1zZ24oZGF0ZTEuZ2V0RnVsbFllYXIoKS1kYXRlMi5nZXRGdWxsWWVhcigpKSk9PT0wKXtpZigoY29tcGFyZT1zZ24oZGF0ZTEuZ2V0TW9udGgoKS1kYXRlMi5nZXRNb250aCgpKSk9PT0wKXtjb21wYXJlPXNnbihkYXRlMS5nZXREYXRlKCktZGF0ZTIuZ2V0RGF0ZSgpKX19cmV0dXJuIGNvbXBhcmV9ZnVuY3Rpb24gZ2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aCl7c3dpdGNoKGphbkZvdXJ0aC5nZXREYXkoKSl7Y2FzZSAwOnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIGphbkZvdXJ0aDtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMyk7Y2FzZSAzOnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDIpO2Nhc2UgNDpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwzMCl9fWZ1bmN0aW9uIGdldFdlZWtCYXNlZFllYXIoZGF0ZSl7dmFyIHRoaXNEYXRlPWFkZERheXMobmV3IERhdGUoZGF0ZS50bV95ZWFyKzE5MDAsMCwxKSxkYXRlLnRtX3lkYXkpO3ZhciBqYW5Gb3VydGhUaGlzWWVhcj1uZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLDAsNCk7dmFyIGphbkZvdXJ0aE5leHRZZWFyPW5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkrMSwwLDQpO3ZhciBmaXJzdFdlZWtTdGFydFRoaXNZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhUaGlzWWVhcik7dmFyIGZpcnN0V2Vla1N0YXJ0TmV4dFllYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aE5leHRZZWFyKTtpZihjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnRUaGlzWWVhcix0aGlzRGF0ZSk8PTApe2lmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydE5leHRZZWFyLHRoaXNEYXRlKTw9MCl7cmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkrMX1yZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKX1yZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKS0xfXZhciBFWFBBTlNJT05fUlVMRVNfMj17XCIlYVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldLnN1YnN0cmluZygwLDMpfSxcIiVBXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV19LFwiJWJcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXS5zdWJzdHJpbmcoMCwzKX0sXCIlQlwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBNT05USFNbZGF0ZS50bV9tb25dfSxcIiVDXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIHllYXI9ZGF0ZS50bV95ZWFyKzE5MDA7cmV0dXJuIGxlYWRpbmdOdWxscyh5ZWFyLzEwMHwwLDIpfSxcIiVkXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXksMil9LFwiJWVcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ1NvbWV0aGluZyhkYXRlLnRtX21kYXksMixcIiBcIil9LFwiJWdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlR1wiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpfSxcIiVIXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX2hvdXIsMil9LFwiJUlcIjpmdW5jdGlvbihkYXRlKXt2YXIgdHdlbHZlSG91cj1kYXRlLnRtX2hvdXI7aWYodHdlbHZlSG91cj09MCl0d2VsdmVIb3VyPTEyO2Vsc2UgaWYodHdlbHZlSG91cj4xMil0d2VsdmVIb3VyLT0xMjtyZXR1cm4gbGVhZGluZ051bGxzKHR3ZWx2ZUhvdXIsMil9LFwiJWpcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheSthcnJheVN1bShpc0xlYXBZZWFyKGRhdGUudG1feWVhcisxOTAwKT9NT05USF9EQVlTX0xFQVA6TU9OVEhfREFZU19SRUdVTEFSLGRhdGUudG1fbW9uLTEpLDMpfSxcIiVtXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21vbisxLDIpfSxcIiVNXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21pbiwyKX0sXCIlblwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXG5cIn0sXCIlcFwiOmZ1bmN0aW9uKGRhdGUpe2lmKGRhdGUudG1faG91cj49MCYmZGF0ZS50bV9ob3VyPDEyKXtyZXR1cm5cIkFNXCJ9cmV0dXJuXCJQTVwifSxcIiVTXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX3NlYywyKX0sXCIldFwiOmZ1bmN0aW9uKCl7cmV0dXJuXCJcXHRcIn0sXCIldVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3dkYXl8fDd9LFwiJVVcIjpmdW5jdGlvbihkYXRlKXt2YXIgZGF5cz1kYXRlLnRtX3lkYXkrNy1kYXRlLnRtX3dkYXk7cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMvNyksMil9LFwiJVZcIjpmdW5jdGlvbihkYXRlKXt2YXIgdmFsPU1hdGguZmxvb3IoKGRhdGUudG1feWRheSs3LShkYXRlLnRtX3dkYXkrNiklNykvNyk7aWYoKGRhdGUudG1fd2RheSszNzEtZGF0ZS50bV95ZGF5LTIpJTc8PTIpe3ZhbCsrfWlmKCF2YWwpe3ZhbD01Mjt2YXIgZGVjMzE9KGRhdGUudG1fd2RheSs3LWRhdGUudG1feWRheS0xKSU3O2lmKGRlYzMxPT00fHxkZWMzMT09NSYmaXNMZWFwWWVhcihkYXRlLnRtX3llYXIlNDAwLTEpKXt2YWwrK319ZWxzZSBpZih2YWw9PTUzKXt2YXIgamFuMT0oZGF0ZS50bV93ZGF5KzM3MS1kYXRlLnRtX3lkYXkpJTc7aWYoamFuMSE9NCYmKGphbjEhPTN8fCFpc0xlYXBZZWFyKGRhdGUudG1feWVhcikpKXZhbD0xfXJldHVybiBsZWFkaW5nTnVsbHModmFsLDIpfSxcIiV3XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fd2RheX0sXCIlV1wiOmZ1bmN0aW9uKGRhdGUpe3ZhciBkYXlzPWRhdGUudG1feWRheSs3LShkYXRlLnRtX3dkYXkrNiklNztyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguZmxvb3IoZGF5cy83KSwyKX0sXCIleVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybihkYXRlLnRtX3llYXIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMil9LFwiJVlcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV95ZWFyKzE5MDB9LFwiJXpcIjpmdW5jdGlvbihkYXRlKXt2YXIgb2ZmPWRhdGUudG1fZ210b2ZmO3ZhciBhaGVhZD1vZmY+PTA7b2ZmPU1hdGguYWJzKG9mZikvNjA7b2ZmPW9mZi82MCoxMDArb2ZmJTYwO3JldHVybihhaGVhZD9cIitcIjpcIi1cIikrU3RyaW5nKFwiMDAwMFwiK29mZikuc2xpY2UoLTQpfSxcIiVaXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fem9uZX0sXCIlJVwiOmZ1bmN0aW9uKCl7cmV0dXJuXCIlXCJ9fTtwYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzIpe2lmKHBhdHRlcm4uaW5jbHVkZXMocnVsZSkpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzJbcnVsZV0oZGF0ZSkpfX1wYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpO3ZhciBieXRlcz1pbnRBcnJheUZyb21TdHJpbmcocGF0dGVybixmYWxzZSk7aWYoYnl0ZXMubGVuZ3RoPm1heHNpemUpe3JldHVybiAwfXdyaXRlQXJyYXlUb01lbW9yeShieXRlcyxzKTtyZXR1cm4gYnl0ZXMubGVuZ3RoLTF9ZnVuY3Rpb24gX3N0cmZ0aW1lX2wocyxtYXhzaXplLGZvcm1hdCx0bSxsb2Mpe3JldHVybiBfc3RyZnRpbWUocyxtYXhzaXplLGZvcm1hdCx0bSl9ZnVuY3Rpb24gX3VjbnZfY2xvc2VfNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X2Nsb3NlXzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNudl9jb252ZXJ0RXhfNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X2NvbnZlcnRFeF82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VjbnZfb3Blbl82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfb3Blbl82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VjbnZfdG9BbGdvcml0aG1pY182NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfdG9BbGdvcml0aG1pY182NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vjc2RldF9jbG9zZV82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9jbG9zZV82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vjc2RldF9kZXRlY3RfNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZGV0ZWN0XzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNzZGV0X2dldENvbmZpZGVuY2VfNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vjc2RldF9nZXROYW1lXzY0KCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2dldE5hbWVfNjRcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91Y3NkZXRfb3Blbl82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9vcGVuXzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNzZGV0X3NldFRleHRfNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfc2V0VGV4dF82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuekNsb3NlKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56Q2xvc2VcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpDbG9zZUN1cnJlbnRGaWxlKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56Q2xvc2VDdXJyZW50RmlsZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuekdldEN1cnJlbnRGaWxlSW5mbygpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdldEN1cnJlbnRGaWxlSW5mb1wiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuekdldEN1cnJlbnRGaWxlSW5mbzY0KCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R2V0Q3VycmVudEZpbGVJbmZvNjRcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpHZXRHbG9iYWxJbmZvKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R2V0R2xvYmFsSW5mb1wiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuekdvVG9GaXJzdEZpbGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHb1RvRmlyc3RGaWxlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56R29Ub05leHRGaWxlKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R29Ub05leHRGaWxlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56TG9jYXRlRmlsZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekxvY2F0ZUZpbGVcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpPcGVuKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlblwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vuek9wZW4yKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlbjJcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpPcGVuQ3VycmVudEZpbGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuQ3VycmVudEZpbGVcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpSZWFkQ3VycmVudEZpbGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpSZWFkQ3VycmVudEZpbGVcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9wcm9jX2V4aXQoY29kZSl7RVhJVFNUQVRVUz1jb2RlO2lmKCFrZWVwUnVudGltZUFsaXZlKCkpe2lmKE1vZHVsZVtcIm9uRXhpdFwiXSlNb2R1bGVbXCJvbkV4aXRcIl0oY29kZSk7QUJPUlQ9dHJ1ZX1xdWl0Xyhjb2RlLG5ldyBFeGl0U3RhdHVzKGNvZGUpKX1mdW5jdGlvbiBleGl0SlMoc3RhdHVzLGltcGxpY2l0KXtFWElUU1RBVFVTPXN0YXR1cztfcHJvY19leGl0KHN0YXR1cyl9ZnVuY3Rpb24gaGFuZGxlRXhjZXB0aW9uKGUpe2lmKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzfHxlPT1cInVud2luZFwiKXtyZXR1cm4gRVhJVFNUQVRVU31xdWl0XygxLGUpfWZ1bmN0aW9uIGdldENGdW5jKGlkZW50KXt2YXIgZnVuYz1Nb2R1bGVbXCJfXCIraWRlbnRdO3JldHVybiBmdW5jfWZ1bmN0aW9uIHN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKXt2YXIgc2l6ZT1sZW5ndGhCeXRlc1VURjgoc3RyKSsxO3ZhciByZXQ9c3RhY2tBbGxvYyhzaXplKTtzdHJpbmdUb1VURjgoc3RyLHJldCxzaXplKTtyZXR1cm4gcmV0fWZ1bmN0aW9uIGNjYWxsKGlkZW50LHJldHVyblR5cGUsYXJnVHlwZXMsYXJncyxvcHRzKXt2YXIgdG9DPXtcInN0cmluZ1wiOnN0cj0+e3ZhciByZXQ9MDtpZihzdHIhPT1udWxsJiZzdHIhPT11bmRlZmluZWQmJnN0ciE9PTApe3JldD1zdHJpbmdUb1VURjhPblN0YWNrKHN0cil9cmV0dXJuIHJldH0sXCJhcnJheVwiOmFycj0+e3ZhciByZXQ9c3RhY2tBbGxvYyhhcnIubGVuZ3RoKTt3cml0ZUFycmF5VG9NZW1vcnkoYXJyLHJldCk7cmV0dXJuIHJldH19O2Z1bmN0aW9uIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpe2lmKHJldHVyblR5cGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gVVRGOFRvU3RyaW5nKHJldCl9aWYocmV0dXJuVHlwZT09PVwiYm9vbGVhblwiKXJldHVybiBCb29sZWFuKHJldCk7cmV0dXJuIHJldH12YXIgZnVuYz1nZXRDRnVuYyhpZGVudCk7dmFyIGNBcmdzPVtdO3ZhciBzdGFjaz0wO2lmKGFyZ3Mpe2Zvcih2YXIgaT0wO2k8YXJncy5sZW5ndGg7aSsrKXt2YXIgY29udmVydGVyPXRvQ1thcmdUeXBlc1tpXV07aWYoY29udmVydGVyKXtpZihzdGFjaz09PTApc3RhY2s9c3RhY2tTYXZlKCk7Y0FyZ3NbaV09Y29udmVydGVyKGFyZ3NbaV0pfWVsc2V7Y0FyZ3NbaV09YXJnc1tpXX19fXZhciByZXQ9ZnVuYy5hcHBseShudWxsLGNBcmdzKTtmdW5jdGlvbiBvbkRvbmUocmV0KXtpZihzdGFjayE9PTApc3RhY2tSZXN0b3JlKHN0YWNrKTtyZXR1cm4gY29udmVydFJldHVyblZhbHVlKHJldCl9cmV0PW9uRG9uZShyZXQpO3JldHVybiByZXR9dmFyIHdhc21JbXBvcnRzPXtcImdcIjpfWE1MX0dldEJ1ZmZlcixcIlZcIjpfWE1MX0dldEVycm9yQ29kZSxcImRhXCI6X1hNTF9QYXJzZSxcIm5cIjpfWE1MX1BhcnNlQnVmZmVyLFwicFwiOl9YTUxfUGFyc2VyQ3JlYXRlLFwiZFwiOl9YTUxfUGFyc2VyRnJlZSxcIkJcIjpfWE1MX1Jlc3VtZVBhcnNlcixcImZcIjpfWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyLFwiYlwiOl9YTUxfU2V0RWxlbWVudEhhbmRsZXIsXCJvXCI6X1hNTF9TZXRVc2VyRGF0YSxcImhcIjpfWE1MX1N0b3BQYXJzZXIsXCJhXCI6X19fY3hhX3Rocm93LFwiTGFcIjpfX19kbHN5bSxcIkZhXCI6X19fc3lzY2FsbF9fbmV3c2VsZWN0LFwiSmFcIjpfX19zeXNjYWxsX2JpbmQsXCJJYVwiOl9fX3N5c2NhbGxfY29ubmVjdCxcIkJhXCI6X19fc3lzY2FsbF9mYWNjZXNzYXQsXCJlXCI6X19fc3lzY2FsbF9mY250bDY0LFwiQWFcIjpfX19zeXNjYWxsX2ZzdGF0NjQsXCJPXCI6X19fc3lzY2FsbF9mdHJ1bmNhdGU2NCxcInZhXCI6X19fc3lzY2FsbF9nZXRkZW50czY0LFwiRGFcIjpfX19zeXNjYWxsX2dldHBlZXJuYW1lLFwiRWFcIjpfX19zeXNjYWxsX2dldHNvY2tvcHQsXCJLXCI6X19fc3lzY2FsbF9pb2N0bCxcInhhXCI6X19fc3lzY2FsbF9sc3RhdDY0LFwid2FcIjpfX19zeXNjYWxsX21rZGlyYXQsXCJ5YVwiOl9fX3N5c2NhbGxfbmV3ZnN0YXRhdCxcIkxcIjpfX19zeXNjYWxsX29wZW5hdCxcIkdhXCI6X19fc3lzY2FsbF9yZWN2ZnJvbSxcInRhXCI6X19fc3lzY2FsbF9yZW5hbWVhdCxcIkZcIjpfX19zeXNjYWxsX3JtZGlyLFwiSGFcIjpfX19zeXNjYWxsX3NlbmR0byxcIkhcIjpfX19zeXNjYWxsX3NvY2tldCxcInphXCI6X19fc3lzY2FsbF9zdGF0NjQsXCJHXCI6X19fc3lzY2FsbF91bmxpbmthdCxcIk5hXCI6X19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFwiZmFcIjpfX2xvY2FsdGltZV9qcyxcImdhXCI6X190enNldF9qcyxcImpcIjpfYWJvcnQsXCJNYVwiOl9kbG9wZW4sXCJtYVwiOl9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGUsXCJuYVwiOl9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9leGlzdHMsXCJrYVwiOl9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9saXN0X2ZpbGVzLFwibGFcIjpfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfcmVtb3ZlLFwiRFwiOl9kdWNrZGJfd2ViX2ZzX2ZpbGVfY2xvc2UsXCJpYVwiOl9kdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzLFwiTlwiOl9kdWNrZGJfd2ViX2ZzX2ZpbGVfZ2V0X2xhc3RfbW9kaWZpZWRfdGltZSxcImphXCI6X2R1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlLFwicGFcIjpfZHVja2RiX3dlYl9mc19maWxlX29wZW4sXCJxXCI6X2R1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkLFwib2FcIjpfZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlLFwiRVwiOl9kdWNrZGJfd2ViX2ZzX2ZpbGVfd3JpdGUsXCJxYVwiOl9kdWNrZGJfd2ViX2ZzX2dldF9kZWZhdWx0X2RhdGFfcHJvdG9jb2wsXCJoYVwiOl9kdWNrZGJfd2ViX2ZzX2dsb2IsXCJDXCI6X2R1Y2tkYl93ZWJfdGVzdF9wbGF0Zm9ybV9mZWF0dXJlLFwicmFcIjpfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGwsXCJNXCI6X2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXCJPYVwiOl9lbXNjcmlwdGVuX2dldF9oZWFwX21heCxcImlcIjpfZW1zY3JpcHRlbl9nZXRfbm93LFwiS2FcIjpfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFwiUWFcIjpfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcIlRcIjpfZW52aXJvbl9nZXQsXCJXXCI6X2Vudmlyb25fc2l6ZXNfZ2V0LFwibFwiOl9mZF9jbG9zZSxcImVhXCI6X2ZkX2Zkc3RhdF9nZXQsXCJRXCI6X2ZkX3ByZWFkLFwiUFwiOl9mZF9wd3JpdGUsXCJKXCI6X2ZkX3JlYWQsXCJSXCI6X2ZkX3NlZWssXCJ1YVwiOl9mZF9zeW5jLFwid1wiOl9mZF93cml0ZSxcIklcIjpfZ2V0YWRkcmluZm8sXCJzYVwiOl9nZXRlbnRyb3B5LFwiQ2FcIjpfZ2V0bmFtZWluZm8sXCJQYVwiOl9zdHJmdGltZV9sLFwiY1wiOl91Y252X2Nsb3NlXzY0LFwiWFwiOl91Y252X2NvbnZlcnRFeF82NCxcInZcIjpfdWNudl9vcGVuXzY0LFwiWlwiOl91Y252X3RvQWxnb3JpdGhtaWNfNjQsXCJZXCI6X3Vjc2RldF9jbG9zZV82NCxcImFhXCI6X3Vjc2RldF9kZXRlY3RfNjQsXCIkXCI6X3Vjc2RldF9nZXRDb25maWRlbmNlXzY0LFwiX1wiOl91Y3NkZXRfZ2V0TmFtZV82NCxcImNhXCI6X3Vjc2RldF9vcGVuXzY0LFwiYmFcIjpfdWNzZGV0X3NldFRleHRfNjQsXCJrXCI6X3VuekNsb3NlLFwidVwiOl91bnpDbG9zZUN1cnJlbnRGaWxlLFwielwiOl91bnpHZXRDdXJyZW50RmlsZUluZm8sXCJyXCI6X3VuekdldEN1cnJlbnRGaWxlSW5mbzY0LFwiVVwiOl91bnpHZXRHbG9iYWxJbmZvLFwiQVwiOl91bnpHb1RvRmlyc3RGaWxlLFwieVwiOl91bnpHb1RvTmV4dEZpbGUsXCJ0XCI6X3VuekxvY2F0ZUZpbGUsXCJ4XCI6X3Vuek9wZW4sXCJTXCI6X3Vuek9wZW4yLFwic1wiOl91bnpPcGVuQ3VycmVudEZpbGUsXCJtXCI6X3VuelJlYWRDdXJyZW50RmlsZX07dmFyIGFzbT1jcmVhdGVXYXNtKCk7dmFyIF9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihfX193YXNtX2NhbGxfY3RvcnM9TW9kdWxlW1wiYXNtXCJdW1wiU2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9tYWluPU1vZHVsZVtcIl9tYWluXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9tYWluPU1vZHVsZVtcIl9tYWluXCJdPU1vZHVsZVtcImFzbVwiXVtcIlRhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIlZhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJXYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZmFpbF93aXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZhaWxfd2l0aFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mYWlsX3dpdGg9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmFpbF93aXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIlhhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9yZXNldD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9yZXNldD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJZYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfY29ubmVjdD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jb25uZWN0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2Nvbm5lY3Q9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29ubmVjdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJaYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZGlzY29ubmVjdD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9kaXNjb25uZWN0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3Q9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZGlzY29ubmVjdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJfYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIl09TW9kdWxlW1wiYXNtXCJdW1wiJGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mbHVzaF9maWxlPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVcIl09TW9kdWxlW1wiYXNtXCJdW1wiYWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX29wZW49TW9kdWxlW1wiX2R1Y2tkYl93ZWJfb3BlblwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9vcGVuPU1vZHVsZVtcIl9kdWNrZGJfd2ViX29wZW5cIl09TW9kdWxlW1wiYXNtXCJdW1wiYmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCJdPU1vZHVsZVtcImFzbVwiXVtcImNiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0cz1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHNcIl09TW9kdWxlW1wiYXNtXCJdW1wiZGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCJdPU1vZHVsZVtcImFzbVwiXVtcImViXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVcIl09TW9kdWxlW1wiYXNtXCJdW1wiZmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlc1wiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXNcIl09TW9kdWxlW1wiYXNtXCJdW1wiZ2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvcz1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nbG9iX2ZpbGVfaW5mb3NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJoYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWQ9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJpYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X25hbWU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCJdPU1vZHVsZVtcImFzbVwiXVtcImpiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJrYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXI9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXJcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXI9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXJcIl09TW9kdWxlW1wiYXNtXCJdW1wibGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXI9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlclwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXJcIl09TW9kdWxlW1wiYXNtXCJdW1wibWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIm5iXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9nZXRfdmVyc2lvbj1Nb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9nZXRfdmVyc2lvbj1Nb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJvYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3M9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3M9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIl09TW9kdWxlW1wiYXNtXCJdW1wicGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3Rva2VuaXplPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3Rva2VuaXplXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX3Rva2VuaXplPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3Rva2VuaXplXCJdPU1vZHVsZVtcImFzbVwiXVtcInFiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJyYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX2NyZWF0ZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wcmVwYXJlZF9jcmVhdGU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCJdPU1vZHVsZVtcImFzbVwiXVtcInNiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ0YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3J1blwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wcmVwYXJlZF9ydW49TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCJdPU1vZHVsZVtcImFzbVwiXVtcInViXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCJdPU1vZHVsZVtcImFzbVwiXVtcInZiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9xdWVyeV9ydW49TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfcnVuXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX3F1ZXJ5X3J1bj1Nb2R1bGVbXCJfZHVja2RiX3dlYl9xdWVyeV9ydW5cIl09TW9kdWxlW1wiYXNtXCJdW1wid2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnQ9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0PU1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnRcIl09TW9kdWxlW1wiYXNtXCJdW1wieGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3BvbGxcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ5YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWw9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWw9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIl09TW9kdWxlW1wiYXNtXCJdW1wiemJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0c1wiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHNcIl09TW9kdWxlW1wiYXNtXCJdW1wiQWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCJdPU1vZHVsZVtcImFzbVwiXVtcIkJiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW1cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCJdPU1vZHVsZVtcImFzbVwiXVtcIkNiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJEYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9pbnNlcnRfanNvbl9mcm9tX3BhdGg9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIkViXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX19lcnJub19sb2NhdGlvbj1mdW5jdGlvbigpe3JldHVybihfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbXCJhc21cIl1bXCJfX2Vycm5vX2xvY2F0aW9uXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfaHRvbmw9ZnVuY3Rpb24oKXtyZXR1cm4oX2h0b25sPU1vZHVsZVtcImFzbVwiXVtcIkZiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfaHRvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oX2h0b25zPU1vZHVsZVtcImFzbVwiXVtcIkdiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbnRvaHM9ZnVuY3Rpb24oKXtyZXR1cm4oX250b2hzPU1vZHVsZVtcImFzbVwiXVtcIkhiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbWFsbG9jPU1vZHVsZVtcIl9tYWxsb2NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPU1vZHVsZVtcImFzbVwiXVtcIkliXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZnJlZT1Nb2R1bGVbXCJfZnJlZVwiXT1mdW5jdGlvbigpe3JldHVybihfZnJlZT1Nb2R1bGVbXCJfZnJlZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJKYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrU2F2ZT1Nb2R1bGVbXCJhc21cIl1bXCJLYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrUmVzdG9yZT1Nb2R1bGVbXCJhc21cIl1bXCJMYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihzdGFja0FsbG9jPU1vZHVsZVtcImFzbVwiXVtcIk1iXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX19jeGFfaXNfcG9pbnRlcl90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuKF9fX2N4YV9pc19wb2ludGVyX3R5cGU9TW9kdWxlW1wiYXNtXCJdW1wiTmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1zdGFja0FsbG9jO01vZHVsZVtcInN0YWNrU2F2ZVwiXT1zdGFja1NhdmU7TW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdPXN0YWNrUmVzdG9yZTtNb2R1bGVbXCJjY2FsbFwiXT1jY2FsbDt2YXIgY2FsbGVkUnVuO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1mdW5jdGlvbiBydW5DYWxsZXIoKXtpZighY2FsbGVkUnVuKXJ1bigpO2lmKCFjYWxsZWRSdW4pZGVwZW5kZW5jaWVzRnVsZmlsbGVkPXJ1bkNhbGxlcn07ZnVuY3Rpb24gY2FsbE1haW4oKXt2YXIgZW50cnlGdW5jdGlvbj1fbWFpbjt2YXIgYXJnYz0wO3ZhciBhcmd2PTA7dHJ5e3ZhciByZXQ9ZW50cnlGdW5jdGlvbihhcmdjLGFyZ3YpO2V4aXRKUyhyZXQsdHJ1ZSk7cmV0dXJuIHJldH1jYXRjaChlKXtyZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGUpfX1mdW5jdGlvbiBydW4oKXtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59ZnVuY3Rpb24gZG9SdW4oKXtpZihjYWxsZWRSdW4pcmV0dXJuO2NhbGxlZFJ1bj10cnVlO01vZHVsZVtcImNhbGxlZFJ1blwiXT10cnVlO2lmKEFCT1JUKXJldHVybjtpbml0UnVudGltZSgpO3ByZU1haW4oKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0oKTtpZihzaG91bGRSdW5Ob3cpY2FsbE1haW4oKTtwb3N0UnVuKCl9aWYoTW9kdWxlW1wic2V0U3RhdHVzXCJdKXtNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiXCIpfSwxKTtkb1J1bigpfSwxKX1lbHNle2RvUnVuKCl9fWlmKE1vZHVsZVtcInByZUluaXRcIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlSW5pdFwiXT1bTW9kdWxlW1wicHJlSW5pdFwiXV07d2hpbGUoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGg+MCl7TW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpfX12YXIgc2hvdWxkUnVuTm93PXRydWU7aWYoTW9kdWxlW1wibm9Jbml0aWFsUnVuXCJdKXNob3VsZFJ1bk5vdz1mYWxzZTtydW4oKTtcblxuXG4gIHJldHVybiBEdWNrREIucmVhZHlcbn1cblxuKTtcbn0pKCk7XG5pZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICBtb2R1bGUuZXhwb3J0cyA9IER1Y2tEQjtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIER1Y2tEQjsgfSk7XG5lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gIGV4cG9ydHNbXCJEdWNrREJcIl0gPSBEdWNrREI7XG4iLCAiXG52YXIgRHVja0RCID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IHVuZGVmaW5lZDtcbiAgaWYgKHR5cGVvZiBfX2ZpbGVuYW1lICE9PSAndW5kZWZpbmVkJykgX3NjcmlwdERpciA9IF9zY3JpcHREaXIgfHwgX19maWxlbmFtZTtcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKER1Y2tEQiA9IHt9KSAge1xuXG52YXIgTW9kdWxlPXR5cGVvZiBEdWNrREIhPVwidW5kZWZpbmVkXCI/RHVja0RCOnt9O3ZhciByZWFkeVByb21pc2VSZXNvbHZlLHJlYWR5UHJvbWlzZVJlamVjdDtNb2R1bGVbXCJyZWFkeVwiXT1uZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57cmVhZHlQcm9taXNlUmVzb2x2ZT1yZXNvbHZlO3JlYWR5UHJvbWlzZVJlamVjdD1yZWplY3R9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgYXJndW1lbnRzXz1bXTt2YXIgdGhpc1Byb2dyYW09XCIuL3RoaXMucHJvZ3JhbVwiO3ZhciBxdWl0Xz0oc3RhdHVzLHRvVGhyb3cpPT57dGhyb3cgdG9UaHJvd307dmFyIEVOVklST05NRU5UX0lTX1dFQj10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiO3ZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVI9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIjt2YXIgRU5WSVJPTk1FTlRfSVNfTk9ERT10eXBlb2YgcHJvY2Vzcz09XCJvYmplY3RcIiYmdHlwZW9mIHByb2Nlc3MudmVyc2lvbnM9PVwib2JqZWN0XCImJnR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGU9PVwic3RyaW5nXCI7dmFyIHNjcmlwdERpcmVjdG9yeT1cIlwiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSl7cmV0dXJuIE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0ocGF0aCxzY3JpcHREaXJlY3RvcnkpfXJldHVybiBzY3JpcHREaXJlY3RvcnkrcGF0aH12YXIgcmVhZF8scmVhZEFzeW5jLHJlYWRCaW5hcnksc2V0V2luZG93VGl0bGU7aWYoRU5WSVJPTk1FTlRfSVNfTk9ERSl7dmFyIGZzPXJlcXVpcmUoXCJmc1wiKTt2YXIgbm9kZVBhdGg9cmVxdWlyZShcInBhdGhcIik7aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtzY3JpcHREaXJlY3Rvcnk9bm9kZVBhdGguZGlybmFtZShzY3JpcHREaXJlY3RvcnkpK1wiL1wifWVsc2V7c2NyaXB0RGlyZWN0b3J5PV9fZGlybmFtZStcIi9cIn1yZWFkXz0oZmlsZW5hbWUsYmluYXJ5KT0+e2ZpbGVuYW1lPWlzRmlsZVVSSShmaWxlbmFtZSk/bmV3IFVSTChmaWxlbmFtZSk6bm9kZVBhdGgubm9ybWFsaXplKGZpbGVuYW1lKTtyZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLGJpbmFyeT91bmRlZmluZWQ6XCJ1dGY4XCIpfTtyZWFkQmluYXJ5PWZpbGVuYW1lPT57dmFyIHJldD1yZWFkXyhmaWxlbmFtZSx0cnVlKTtpZighcmV0LmJ1ZmZlcil7cmV0PW5ldyBVaW50OEFycmF5KHJldCl9cmV0dXJuIHJldH07cmVhZEFzeW5jPShmaWxlbmFtZSxvbmxvYWQsb25lcnJvcixiaW5hcnk9dHJ1ZSk9PntmaWxlbmFtZT1pc0ZpbGVVUkkoZmlsZW5hbWUpP25ldyBVUkwoZmlsZW5hbWUpOm5vZGVQYXRoLm5vcm1hbGl6ZShmaWxlbmFtZSk7ZnMucmVhZEZpbGUoZmlsZW5hbWUsYmluYXJ5P3VuZGVmaW5lZDpcInV0ZjhcIiwoZXJyLGRhdGEpPT57aWYoZXJyKW9uZXJyb3IoZXJyKTtlbHNlIG9ubG9hZChiaW5hcnk/ZGF0YS5idWZmZXI6ZGF0YSl9KX07aWYoIU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdJiZwcm9jZXNzLmFyZ3YubGVuZ3RoPjEpe3RoaXNQcm9ncmFtPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csXCIvXCIpfWFyZ3VtZW50c189cHJvY2Vzcy5hcmd2LnNsaWNlKDIpO3F1aXRfPShzdGF0dXMsdG9UaHJvdyk9Pntwcm9jZXNzLmV4aXRDb2RlPXN0YXR1czt0aHJvdyB0b1Rocm93fTtNb2R1bGVbXCJpbnNwZWN0XCJdPSgpPT5cIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCJ9ZWxzZSBpZihFTlZJUk9OTUVOVF9JU19XRUJ8fEVOVklST05NRU5UX0lTX1dPUktFUil7aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtzY3JpcHREaXJlY3Rvcnk9c2VsZi5sb2NhdGlvbi5ocmVmfWVsc2UgaWYodHlwZW9mIGRvY3VtZW50IT1cInVuZGVmaW5lZFwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0KXtzY3JpcHREaXJlY3Rvcnk9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9aWYoX3NjcmlwdERpcil7c2NyaXB0RGlyZWN0b3J5PV9zY3JpcHREaXJ9aWYoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoXCJibG9iOlwiKSE9PTApe3NjcmlwdERpcmVjdG9yeT1zY3JpcHREaXJlY3Rvcnkuc3Vic3RyKDAsc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpfWVsc2V7c2NyaXB0RGlyZWN0b3J5PVwiXCJ9e3JlYWRfPXVybD0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLGZhbHNlKTt4aHIuc2VuZChudWxsKTtyZXR1cm4geGhyLnJlc3BvbnNlVGV4dH07aWYoRU5WSVJPTk1FTlRfSVNfV09SS0VSKXtyZWFkQmluYXJ5PXVybD0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLGZhbHNlKTt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjt4aHIuc2VuZChudWxsKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKX19cmVhZEFzeW5jPSh1cmwsb25sb2FkLG9uZXJyb3IpPT57dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsdHJ1ZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLm9ubG9hZD0oKT0+e2lmKHhoci5zdGF0dXM9PTIwMHx8eGhyLnN0YXR1cz09MCYmeGhyLnJlc3BvbnNlKXtvbmxvYWQoeGhyLnJlc3BvbnNlKTtyZXR1cm59b25lcnJvcigpfTt4aHIub25lcnJvcj1vbmVycm9yO3hoci5zZW5kKG51bGwpfX1zZXRXaW5kb3dUaXRsZT10aXRsZT0+ZG9jdW1lbnQudGl0bGU9dGl0bGV9ZWxzZXt9dmFyIG91dD1Nb2R1bGVbXCJwcmludFwiXXx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKTt2YXIgZXJyPU1vZHVsZVtcInByaW50RXJyXCJdfHxjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7T2JqZWN0LmFzc2lnbihNb2R1bGUsbW9kdWxlT3ZlcnJpZGVzKTttb2R1bGVPdmVycmlkZXM9bnVsbDtpZihNb2R1bGVbXCJhcmd1bWVudHNcIl0pYXJndW1lbnRzXz1Nb2R1bGVbXCJhcmd1bWVudHNcIl07aWYoTW9kdWxlW1widGhpc1Byb2dyYW1cIl0pdGhpc1Byb2dyYW09TW9kdWxlW1widGhpc1Byb2dyYW1cIl07aWYoTW9kdWxlW1wicXVpdFwiXSlxdWl0Xz1Nb2R1bGVbXCJxdWl0XCJdO3ZhciB3YXNtQmluYXJ5O2lmKE1vZHVsZVtcIndhc21CaW5hcnlcIl0pd2FzbUJpbmFyeT1Nb2R1bGVbXCJ3YXNtQmluYXJ5XCJdO3ZhciBub0V4aXRSdW50aW1lPU1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl18fHRydWU7aWYodHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiKXthYm9ydChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIil9dmFyIHdhc21NZW1vcnk7dmFyIEFCT1JUPWZhbHNlO3ZhciBFWElUU1RBVFVTO2Z1bmN0aW9uIGFzc2VydChjb25kaXRpb24sdGV4dCl7aWYoIWNvbmRpdGlvbil7YWJvcnQodGV4dCl9fXZhciBIRUFQOCxIRUFQVTgsSEVBUDE2LEhFQVBVMTYsSEVBUDMyLEhFQVBVMzIsSEVBUEYzMixIRUFQRjY0O2Z1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCl7dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7TW9kdWxlW1wiSEVBUDhcIl09SEVBUDg9bmV3IEludDhBcnJheShiKTtNb2R1bGVbXCJIRUFQMTZcIl09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGIpO01vZHVsZVtcIkhFQVAzMlwiXT1IRUFQMzI9bmV3IEludDMyQXJyYXkoYik7TW9kdWxlW1wiSEVBUFU4XCJdPUhFQVBVOD1uZXcgVWludDhBcnJheShiKTtNb2R1bGVbXCJIRUFQVTE2XCJdPUhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KGIpO01vZHVsZVtcIkhFQVBVMzJcIl09SEVBUFUzMj1uZXcgVWludDMyQXJyYXkoYik7TW9kdWxlW1wiSEVBUEYzMlwiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYik7TW9kdWxlW1wiSEVBUEY2NFwiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYil9dmFyIHdhc21UYWJsZTt2YXIgX19BVFBSRVJVTl9fPVtdO3ZhciBfX0FUSU5JVF9fPVtdO3ZhciBfX0FUTUFJTl9fPVtdO3ZhciBfX0FUUE9TVFJVTl9fPVtdO3ZhciBydW50aW1lSW5pdGlhbGl6ZWQ9ZmFsc2U7dmFyIHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyPTA7ZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpe3JldHVybiBub0V4aXRSdW50aW1lfHxydW50aW1lS2VlcGFsaXZlQ291bnRlcj4wfWZ1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVtcInByZVJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInByZVJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInByZVJ1blwiXT1bTW9kdWxlW1wicHJlUnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwcmVSdW5cIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbXCJwcmVSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyl9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtydW50aW1lSW5pdGlhbGl6ZWQ9dHJ1ZTtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKX1mdW5jdGlvbiBwcmVNYWluKCl7Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyl9ZnVuY3Rpb24gcG9zdFJ1bigpe2lmKE1vZHVsZVtcInBvc3RSdW5cIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwb3N0UnVuXCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicG9zdFJ1blwiXT1bTW9kdWxlW1wicG9zdFJ1blwiXV07d2hpbGUoTW9kdWxlW1wicG9zdFJ1blwiXS5sZW5ndGgpe2FkZE9uUG9zdFJ1bihNb2R1bGVbXCJwb3N0UnVuXCJdLnNoaWZ0KCkpfX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKX1mdW5jdGlvbiBhZGRPblByZVJ1bihjYil7X19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uSW5pdChjYil7X19BVElOSVRfXy51bnNoaWZ0KGNiKX1mdW5jdGlvbiBhZGRPblBvc3RSdW4oY2Ipe19fQVRQT1NUUlVOX18udW5zaGlmdChjYil9dmFyIHJ1bkRlcGVuZGVuY2llcz0wO3ZhciBydW5EZXBlbmRlbmN5V2F0Y2hlcj1udWxsO3ZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtmdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMrKztpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9fWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO2lmKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pe01vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKX1pZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKHJ1bkRlcGVuZGVuY3lXYXRjaGVyIT09bnVsbCl7Y2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7cnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbH1pZihkZXBlbmRlbmNpZXNGdWxmaWxsZWQpe3ZhciBjYWxsYmFjaz1kZXBlbmRlbmNpZXNGdWxmaWxsZWQ7ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7Y2FsbGJhY2soKX19fWZ1bmN0aW9uIGFib3J0KHdoYXQpe2lmKE1vZHVsZVtcIm9uQWJvcnRcIl0pe01vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCl9d2hhdD1cIkFib3J0ZWQoXCIrd2hhdCtcIilcIjtlcnIod2hhdCk7QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPTE7d2hhdCs9XCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCI7aWYocnVudGltZUluaXRpYWxpemVkKXtfX190cmFwKCl9dmFyIGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtyZWFkeVByb21pc2VSZWplY3QoZSk7dGhyb3cgZX12YXIgZGF0YVVSSVByZWZpeD1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIjtmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpfWZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSl7cmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpfXZhciB3YXNtQmluYXJ5RmlsZTt3YXNtQmluYXJ5RmlsZT1cIi4vZHVja2RiLWVoLndhc21cIjtpZighaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSl7d2FzbUJpbmFyeUZpbGU9bG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSl9ZnVuY3Rpb24gZ2V0QmluYXJ5KGZpbGUpe3RyeXtpZihmaWxlPT13YXNtQmluYXJ5RmlsZSYmd2FzbUJpbmFyeSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpfWlmKHJlYWRCaW5hcnkpe3JldHVybiByZWFkQmluYXJ5KGZpbGUpfXRocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKGVycil7YWJvcnQoZXJyKX19ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtpZighd2FzbUJpbmFyeSYmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmZXRjaChiaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHJlc3BvbnNlPT57aWYoIXJlc3BvbnNlW1wib2tcIl0pe3Rocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitiaW5hcnlGaWxlK1wiJ1wifXJldHVybiByZXNwb25zZVtcImFycmF5QnVmZmVyXCJdKCl9KS5jYXRjaCgoKT0+Z2V0QmluYXJ5KGJpbmFyeUZpbGUpKX19cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmdldEJpbmFyeShiaW5hcnlGaWxlKSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMscmVjZWl2ZXIpe3JldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5PT57cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbXBvcnRzKX0pLnRoZW4oaW5zdGFuY2U9PntyZXR1cm4gaW5zdGFuY2V9KS50aGVuKHJlY2VpdmVyLHJlYXNvbj0+e2VycihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK3JlYXNvbik7YWJvcnQocmVhc29uKX0pfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl7aWYoIWJpbmFyeSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT1cImZ1bmN0aW9uXCImJiFpc0RhdGFVUkkoYmluYXJ5RmlsZSkmJiFFTlZJUk9OTUVOVF9JU19OT0RFJiZ0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKGJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4ocmVzcG9uc2U9Pnt2YXIgcmVzdWx0PVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLGltcG9ydHMpO3JldHVybiByZXN1bHQudGhlbihjYWxsYmFjayxmdW5jdGlvbihyZWFzb24pe2VycihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIityZWFzb24pO2VycihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl9KX0pfWVsc2V7cmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKX19ZnVuY3Rpb24gY3JlYXRlV2FzbSgpe3ZhciBpbmZvPXtcImFcIjp3YXNtSW1wb3J0c307ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLG1vZHVsZSl7dmFyIGV4cG9ydHM9aW5zdGFuY2UuZXhwb3J0cztNb2R1bGVbXCJhc21cIl09ZXhwb3J0czt3YXNtTWVtb3J5PU1vZHVsZVtcImFzbVwiXVtcIlFhXCJdO3VwZGF0ZU1lbW9yeVZpZXdzKCk7d2FzbVRhYmxlPU1vZHVsZVtcImFzbVwiXVtcIlRhXCJdO2FkZE9uSW5pdChNb2R1bGVbXCJhc21cIl1bXCJSYVwiXSk7cmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7cmV0dXJuIGV4cG9ydHN9YWRkUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KXtyZWNlaXZlSW5zdGFuY2UocmVzdWx0W1wiaW5zdGFuY2VcIl0pfWlmKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSl7dHJ5e3JldHVybiBNb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0oaW5mbyxyZWNlaXZlSW5zdGFuY2UpfWNhdGNoKGUpe2VycihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK2UpO3JlYWR5UHJvbWlzZVJlamVjdChlKX19aW5zdGFudGlhdGVBc3luYyh3YXNtQmluYXJ5LHdhc21CaW5hcnlGaWxlLGluZm8scmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7cmV0dXJue319dmFyIHRlbXBEb3VibGU7dmFyIHRlbXBJNjQ7ZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIjt0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzdGF0dXN9KWA7dGhpcy5zdGF0dXM9c3RhdHVzfWZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcyl7d2hpbGUoY2FsbGJhY2tzLmxlbmd0aD4wKXtjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpfX1mdW5jdGlvbiBfWE1MX0dldEJ1ZmZlcigpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9HZXRCdWZmZXJcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF9YTUxfR2V0RXJyb3JDb2RlKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX0dldEVycm9yQ29kZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX1hNTF9QYXJzZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX1hNTF9QYXJzZUJ1ZmZlcigpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZUJ1ZmZlclwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX1hNTF9QYXJzZXJDcmVhdGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VyQ3JlYXRlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1BhcnNlckZyZWUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VyRnJlZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX1hNTF9SZXN1bWVQYXJzZXIoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUmVzdW1lUGFyc2VyXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1NldEVsZW1lbnRIYW5kbGVyKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldEVsZW1lbnRIYW5kbGVyXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1NldFVzZXJEYXRhKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldFVzZXJEYXRhXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfWE1MX1N0b3BQYXJzZXIoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU3RvcFBhcnNlclwiKTthYm9ydCgtMSl9dmFyIGRsb3Blbk1pc3NpbmdFcnJvcj1cIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvY29tcGlsaW5nL0R5bmFtaWMtTGlua2luZy5odG1sXCI7ZnVuY3Rpb24gX19fZGxzeW0oaGFuZGxlLHN5bWJvbCxyYSl7YWJvcnQoZGxvcGVuTWlzc2luZ0Vycm9yKX12YXIgVVRGOERlY29kZXI9dHlwZW9mIFRleHREZWNvZGVyIT1cInVuZGVmaW5lZFwiP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dW5kZWZpbmVkO2Z1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXBPckFycmF5LGlkeCxtYXhCeXRlc1RvUmVhZCl7aWR4Pj4+PTA7dmFyIGVuZElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQ7dmFyIGVuZFB0cj1pZHg7d2hpbGUoaGVhcE9yQXJyYXlbZW5kUHRyXSYmIShlbmRQdHI+PWVuZElkeCkpKytlbmRQdHI7aWYoZW5kUHRyLWlkeD4xNiYmaGVhcE9yQXJyYXkuYnVmZmVyJiZVVEY4RGVjb2Rlcil7cmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsZW5kUHRyKSl9dmFyIHN0cj1cIlwiO3doaWxlKGlkeDxlbmRQdHIpe3ZhciB1MD1oZWFwT3JBcnJheVtpZHgrK107aWYoISh1MCYxMjgpKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUodTApO2NvbnRpbnVlfXZhciB1MT1oZWFwT3JBcnJheVtpZHgrK10mNjM7aWYoKHUwJjIyNCk9PTE5Mil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCYzMSk8PDZ8dTEpO2NvbnRpbnVlfXZhciB1Mj1oZWFwT3JBcnJheVtpZHgrK10mNjM7aWYoKHUwJjI0MCk9PTIyNCl7dTA9KHUwJjE1KTw8MTJ8dTE8PDZ8dTJ9ZWxzZXt1MD0odTAmNyk8PDE4fHUxPDwxMnx1Mjw8NnxoZWFwT3JBcnJheVtpZHgrK10mNjN9aWYodTA8NjU1MzYpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCl9ZWxzZXt2YXIgY2g9dTAtNjU1MzY7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGNoPj4xMCw1NjMyMHxjaCYxMDIzKX19cmV0dXJuIHN0cn1mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLG1heEJ5dGVzVG9SZWFkKXtwdHI+Pj49MDtyZXR1cm4gcHRyP1VURjhBcnJheVRvU3RyaW5nKEhFQVBVOCxwdHIsbWF4Qnl0ZXNUb1JlYWQpOlwiXCJ9dmFyIFNZU0NBTExTPXt2YXJhcmdzOnVuZGVmaW5lZCxnZXQ6ZnVuY3Rpb24oKXtTWVNDQUxMUy52YXJhcmdzKz00O3ZhciByZXQ9SEVBUDMyW1NZU0NBTExTLnZhcmFyZ3MtND4+PjJdO3JldHVybiByZXR9LGdldFN0cjpmdW5jdGlvbihwdHIpe3ZhciByZXQ9VVRGOFRvU3RyaW5nKHB0cik7cmV0dXJuIHJldH19O2Z1bmN0aW9uIF9fX3N5c2NhbGxfX25ld3NlbGVjdChuZmRzLHJlYWRmZHMsd3JpdGVmZHMsZXhjZXB0ZmRzLHRpbWVvdXQpe3ZhciB0b3RhbD0wO3ZhciBzcmNSZWFkTG93PXJlYWRmZHM/SEVBUDMyW3JlYWRmZHM+Pj4yXTowLHNyY1JlYWRIaWdoPXJlYWRmZHM/SEVBUDMyW3JlYWRmZHMrND4+PjJdOjA7dmFyIHNyY1dyaXRlTG93PXdyaXRlZmRzP0hFQVAzMlt3cml0ZWZkcz4+PjJdOjAsc3JjV3JpdGVIaWdoPXdyaXRlZmRzP0hFQVAzMlt3cml0ZWZkcys0Pj4+Ml06MDt2YXIgc3JjRXhjZXB0TG93PWV4Y2VwdGZkcz9IRUFQMzJbZXhjZXB0ZmRzPj4+Ml06MCxzcmNFeGNlcHRIaWdoPWV4Y2VwdGZkcz9IRUFQMzJbZXhjZXB0ZmRzKzQ+Pj4yXTowO3ZhciBkc3RSZWFkTG93PTAsZHN0UmVhZEhpZ2g9MDt2YXIgZHN0V3JpdGVMb3c9MCxkc3RXcml0ZUhpZ2g9MDt2YXIgZHN0RXhjZXB0TG93PTAsZHN0RXhjZXB0SGlnaD0wO3ZhciBhbGxMb3c9KHJlYWRmZHM/SEVBUDMyW3JlYWRmZHM+Pj4yXTowKXwod3JpdGVmZHM/SEVBUDMyW3dyaXRlZmRzPj4+Ml06MCl8KGV4Y2VwdGZkcz9IRUFQMzJbZXhjZXB0ZmRzPj4+Ml06MCk7dmFyIGFsbEhpZ2g9KHJlYWRmZHM/SEVBUDMyW3JlYWRmZHMrND4+PjJdOjApfCh3cml0ZWZkcz9IRUFQMzJbd3JpdGVmZHMrND4+PjJdOjApfChleGNlcHRmZHM/SEVBUDMyW2V4Y2VwdGZkcys0Pj4+Ml06MCk7dmFyIGNoZWNrPWZ1bmN0aW9uKGZkLGxvdyxoaWdoLHZhbCl7cmV0dXJuIGZkPDMyP2xvdyZ2YWw6aGlnaCZ2YWx9O2Zvcih2YXIgZmQ9MDtmZDxuZmRzO2ZkKyspe3ZhciBtYXNrPTE8PGZkJTMyO2lmKCFjaGVjayhmZCxhbGxMb3csYWxsSGlnaCxtYXNrKSl7Y29udGludWV9dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO3ZhciBmbGFncz1TWVNDQUxMUy5ERUZBVUxUX1BPTExNQVNLO2lmKHN0cmVhbS5zdHJlYW1fb3BzLnBvbGwpe2ZsYWdzPXN0cmVhbS5zdHJlYW1fb3BzLnBvbGwoc3RyZWFtKX1pZihmbGFncyYxJiZjaGVjayhmZCxzcmNSZWFkTG93LHNyY1JlYWRIaWdoLG1hc2spKXtmZDwzMj9kc3RSZWFkTG93PWRzdFJlYWRMb3d8bWFzazpkc3RSZWFkSGlnaD1kc3RSZWFkSGlnaHxtYXNrO3RvdGFsKyt9aWYoZmxhZ3MmNCYmY2hlY2soZmQsc3JjV3JpdGVMb3csc3JjV3JpdGVIaWdoLG1hc2spKXtmZDwzMj9kc3RXcml0ZUxvdz1kc3RXcml0ZUxvd3xtYXNrOmRzdFdyaXRlSGlnaD1kc3RXcml0ZUhpZ2h8bWFzazt0b3RhbCsrfWlmKGZsYWdzJjImJmNoZWNrKGZkLHNyY0V4Y2VwdExvdyxzcmNFeGNlcHRIaWdoLG1hc2spKXtmZDwzMj9kc3RFeGNlcHRMb3c9ZHN0RXhjZXB0TG93fG1hc2s6ZHN0RXhjZXB0SGlnaD1kc3RFeGNlcHRIaWdofG1hc2s7dG90YWwrK319aWYocmVhZGZkcyl7SEVBUDMyW3JlYWRmZHM+Pj4yXT1kc3RSZWFkTG93O0hFQVAzMltyZWFkZmRzKzQ+Pj4yXT1kc3RSZWFkSGlnaH1pZih3cml0ZWZkcyl7SEVBUDMyW3dyaXRlZmRzPj4+Ml09ZHN0V3JpdGVMb3c7SEVBUDMyW3dyaXRlZmRzKzQ+Pj4yXT1kc3RXcml0ZUhpZ2h9aWYoZXhjZXB0ZmRzKXtIRUFQMzJbZXhjZXB0ZmRzPj4+Ml09ZHN0RXhjZXB0TG93O0hFQVAzMltleGNlcHRmZHMrND4+PjJdPWRzdEV4Y2VwdEhpZ2h9cmV0dXJuIHRvdGFsfWZ1bmN0aW9uIFNPQ0tGUygpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246ICRTT0NLRlNcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIEZTKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogJEZTXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBnZXRTb2NrZXRGcm9tRkQoZmQpe3ZhciBzb2NrZXQ9U09DS0ZTLmdldFNvY2tldChmZCk7aWYoIXNvY2tldCl0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtyZXR1cm4gc29ja2V0fWZ1bmN0aW9uIGluZXROdG9wNChhZGRyKXtyZXR1cm4oYWRkciYyNTUpK1wiLlwiKyhhZGRyPj44JjI1NSkrXCIuXCIrKGFkZHI+PjE2JjI1NSkrXCIuXCIrKGFkZHI+PjI0JjI1NSl9ZnVuY3Rpb24gaW5ldE50b3A2KGludHMpe3ZhciBzdHI9XCJcIjt2YXIgd29yZD0wO3ZhciBsb25nZXN0PTA7dmFyIGxhc3R6ZXJvPTA7dmFyIHpzdGFydD0wO3ZhciBsZW49MDt2YXIgaT0wO3ZhciBwYXJ0cz1baW50c1swXSY2NTUzNSxpbnRzWzBdPj4xNixpbnRzWzFdJjY1NTM1LGludHNbMV0+PjE2LGludHNbMl0mNjU1MzUsaW50c1syXT4+MTYsaW50c1szXSY2NTUzNSxpbnRzWzNdPj4xNl07dmFyIGhhc2lwdjQ9dHJ1ZTt2YXIgdjRwYXJ0PVwiXCI7Zm9yKGk9MDtpPDU7aSsrKXtpZihwYXJ0c1tpXSE9PTApe2hhc2lwdjQ9ZmFsc2U7YnJlYWt9fWlmKGhhc2lwdjQpe3Y0cGFydD1pbmV0TnRvcDQocGFydHNbNl18cGFydHNbN108PDE2KTtpZihwYXJ0c1s1XT09PS0xKXtzdHI9XCI6OmZmZmY6XCI7c3RyKz12NHBhcnQ7cmV0dXJuIHN0cn1pZihwYXJ0c1s1XT09PTApe3N0cj1cIjo6XCI7aWYodjRwYXJ0PT09XCIwLjAuMC4wXCIpdjRwYXJ0PVwiXCI7aWYodjRwYXJ0PT09XCIwLjAuMC4xXCIpdjRwYXJ0PVwiMVwiO3N0cis9djRwYXJ0O3JldHVybiBzdHJ9fWZvcih3b3JkPTA7d29yZDw4O3dvcmQrKyl7aWYocGFydHNbd29yZF09PT0wKXtpZih3b3JkLWxhc3R6ZXJvPjEpe2xlbj0wfWxhc3R6ZXJvPXdvcmQ7bGVuKyt9aWYobGVuPmxvbmdlc3Qpe2xvbmdlc3Q9bGVuO3pzdGFydD13b3JkLWxvbmdlc3QrMX19Zm9yKHdvcmQ9MDt3b3JkPDg7d29yZCsrKXtpZihsb25nZXN0PjEpe2lmKHBhcnRzW3dvcmRdPT09MCYmd29yZD49enN0YXJ0JiZ3b3JkPHpzdGFydCtsb25nZXN0KXtpZih3b3JkPT09enN0YXJ0KXtzdHIrPVwiOlwiO2lmKHpzdGFydD09PTApc3RyKz1cIjpcIn1jb250aW51ZX19c3RyKz1OdW1iZXIoX250b2hzKHBhcnRzW3dvcmRdJjY1NTM1KSkudG9TdHJpbmcoMTYpO3N0cis9d29yZDw3P1wiOlwiOlwiXCJ9cmV0dXJuIHN0cn1mdW5jdGlvbiByZWFkU29ja2FkZHIoc2Esc2FsZW4pe3ZhciBmYW1pbHk9SEVBUDE2W3NhPj4+MV07dmFyIHBvcnQ9X250b2hzKEhFQVBVMTZbc2ErMj4+PjFdKTt2YXIgYWRkcjtzd2l0Y2goZmFtaWx5KXtjYXNlIDI6aWYoc2FsZW4hPT0xNil7cmV0dXJue2Vycm5vOjI4fX1hZGRyPUhFQVAzMltzYSs0Pj4+Ml07YWRkcj1pbmV0TnRvcDQoYWRkcik7YnJlYWs7Y2FzZSAxMDppZihzYWxlbiE9PTI4KXtyZXR1cm57ZXJybm86Mjh9fWFkZHI9W0hFQVAzMltzYSs4Pj4+Ml0sSEVBUDMyW3NhKzEyPj4+Ml0sSEVBUDMyW3NhKzE2Pj4+Ml0sSEVBUDMyW3NhKzIwPj4+Ml1dO2FkZHI9aW5ldE50b3A2KGFkZHIpO2JyZWFrO2RlZmF1bHQ6cmV0dXJue2Vycm5vOjV9fXJldHVybntmYW1pbHk6ZmFtaWx5LGFkZHI6YWRkcixwb3J0OnBvcnR9fWZ1bmN0aW9uIGluZXRQdG9uNChzdHIpe3ZhciBiPXN0ci5zcGxpdChcIi5cIik7Zm9yKHZhciBpPTA7aTw0O2krKyl7dmFyIHRtcD1OdW1iZXIoYltpXSk7aWYoaXNOYU4odG1wKSlyZXR1cm4gbnVsbDtiW2ldPXRtcH1yZXR1cm4oYlswXXxiWzFdPDw4fGJbMl08PDE2fGJbM108PDI0KT4+PjB9ZnVuY3Rpb24ganN0b2lfcShzdHIpe3JldHVybiBwYXJzZUludChzdHIpfWZ1bmN0aW9uIGluZXRQdG9uNihzdHIpe3ZhciB3b3Jkczt2YXIgdyxvZmZzZXQsejt2YXIgdmFsaWQ2cmVneD0vXigoPz0uKjo6KSg/IS4qOjouKzo6KSg6Oik/KFtcXGRBLUZdezEsNH06KDp8XFxiKXwpezV9fChbXFxkQS1GXXsxLDR9Oil7Nn0pKCgoW1xcZEEtRl17MSw0fSgoPyFcXDMpOjp8OlxcYnwkKSl8KD8hXFwyXFwzKSl7Mn18KCgoMlswLTRdfDFcXGR8WzEtOV0pP1xcZHwyNVswLTVdKVxcLj9cXGIpezR9KSQvaTt2YXIgcGFydHM9W107aWYoIXZhbGlkNnJlZ3gudGVzdChzdHIpKXtyZXR1cm4gbnVsbH1pZihzdHI9PT1cIjo6XCIpe3JldHVyblswLDAsMCwwLDAsMCwwLDBdfWlmKHN0ci5zdGFydHNXaXRoKFwiOjpcIikpe3N0cj1zdHIucmVwbGFjZShcIjo6XCIsXCJaOlwiKX1lbHNle3N0cj1zdHIucmVwbGFjZShcIjo6XCIsXCI6WjpcIil9aWYoc3RyLmluZGV4T2YoXCIuXCIpPjApe3N0cj1zdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiWy5dXCIsXCJnXCIpLFwiOlwiKTt3b3Jkcz1zdHIuc3BsaXQoXCI6XCIpO3dvcmRzW3dvcmRzLmxlbmd0aC00XT1qc3RvaV9xKHdvcmRzW3dvcmRzLmxlbmd0aC00XSkranN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGgtM10pKjI1Njt3b3Jkc1t3b3Jkcy5sZW5ndGgtM109anN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGgtMl0pK2pzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoLTFdKSoyNTY7d29yZHM9d29yZHMuc2xpY2UoMCx3b3Jkcy5sZW5ndGgtMil9ZWxzZXt3b3Jkcz1zdHIuc3BsaXQoXCI6XCIpfW9mZnNldD0wO3o9MDtmb3Iodz0wO3c8d29yZHMubGVuZ3RoO3crKyl7aWYodHlwZW9mIHdvcmRzW3ddPT1cInN0cmluZ1wiKXtpZih3b3Jkc1t3XT09PVwiWlwiKXtmb3Ioej0wO3o8OC13b3Jkcy5sZW5ndGgrMTt6Kyspe3BhcnRzW3crel09MH1vZmZzZXQ9ei0xfWVsc2V7cGFydHNbdytvZmZzZXRdPV9odG9ucyhwYXJzZUludCh3b3Jkc1t3XSwxNikpfX1lbHNle3BhcnRzW3crb2Zmc2V0XT13b3Jkc1t3XX19cmV0dXJuW3BhcnRzWzFdPDwxNnxwYXJ0c1swXSxwYXJ0c1szXTw8MTZ8cGFydHNbMl0scGFydHNbNV08PDE2fHBhcnRzWzRdLHBhcnRzWzddPDwxNnxwYXJ0c1s2XV19dmFyIEROUz17YWRkcmVzc19tYXA6e2lkOjEsYWRkcnM6e30sbmFtZXM6e319LGxvb2t1cF9uYW1lOmZ1bmN0aW9uKG5hbWUpe3ZhciByZXM9aW5ldFB0b240KG5hbWUpO2lmKHJlcyE9PW51bGwpe3JldHVybiBuYW1lfXJlcz1pbmV0UHRvbjYobmFtZSk7aWYocmVzIT09bnVsbCl7cmV0dXJuIG5hbWV9dmFyIGFkZHI7aWYoRE5TLmFkZHJlc3NfbWFwLmFkZHJzW25hbWVdKXthZGRyPUROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXX1lbHNle3ZhciBpZD1ETlMuYWRkcmVzc19tYXAuaWQrKzthc3NlcnQoaWQ8NjU1MzUsXCJleGNlZWRlZCBtYXggYWRkcmVzcyBtYXBwaW5ncyBvZiA2NTUzNVwiKTthZGRyPVwiMTcyLjI5LlwiKyhpZCYyNTUpK1wiLlwiKyhpZCY2NTI4MCk7RE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdPW5hbWU7RE5TLmFkZHJlc3NfbWFwLmFkZHJzW25hbWVdPWFkZHJ9cmV0dXJuIGFkZHJ9LGxvb2t1cF9hZGRyOmZ1bmN0aW9uKGFkZHIpe2lmKEROUy5hZGRyZXNzX21hcC5uYW1lc1thZGRyXSl7cmV0dXJuIEROUy5hZGRyZXNzX21hcC5uYW1lc1thZGRyXX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIGdldFNvY2tldEFkZHJlc3MoYWRkcnAsYWRkcmxlbixhbGxvd051bGwpe2lmKGFsbG93TnVsbCYmYWRkcnA9PT0wKXJldHVybiBudWxsO3ZhciBpbmZvPXJlYWRTb2NrYWRkcihhZGRycCxhZGRybGVuKTtpZihpbmZvLmVycm5vKXRocm93IG5ldyBGUy5FcnJub0Vycm9yKGluZm8uZXJybm8pO2luZm8uYWRkcj1ETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKXx8aW5mby5hZGRyO3JldHVybiBpbmZvfWZ1bmN0aW9uIF9fX3N5c2NhbGxfYmluZChmZCxhZGRyLGFkZHJsZW4sZDEsZDIsZDMpe3ZhciBzb2NrPWdldFNvY2tldEZyb21GRChmZCk7dmFyIGluZm89Z2V0U29ja2V0QWRkcmVzcyhhZGRyLGFkZHJsZW4pO3NvY2suc29ja19vcHMuYmluZChzb2NrLGluZm8uYWRkcixpbmZvLnBvcnQpO3JldHVybiAwfWZ1bmN0aW9uIF9fX3N5c2NhbGxfY29ubmVjdChmZCxhZGRyLGFkZHJsZW4sZDEsZDIsZDMpe3ZhciBzb2NrPWdldFNvY2tldEZyb21GRChmZCk7dmFyIGluZm89Z2V0U29ja2V0QWRkcmVzcyhhZGRyLGFkZHJsZW4pO3NvY2suc29ja19vcHMuY29ubmVjdChzb2NrLGluZm8uYWRkcixpbmZvLnBvcnQpO3JldHVybiAwfWZ1bmN0aW9uIF9fX3N5c2NhbGxfZmFjY2Vzc2F0KGRpcmZkLHBhdGgsYW1vZGUsZmxhZ3Mpe31mdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsY21kLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJncztyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsYnVmKXt9ZnVuY3Rpb24gX19fc3lzY2FsbF9mdHJ1bmNhdGU2NChmZCxsZW5ndGhfbG93LGxlbmd0aF9oaWdoKXt9ZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLGhlYXAsb3V0SWR4LG1heEJ5dGVzVG9Xcml0ZSl7b3V0SWR4Pj4+PTA7aWYoIShtYXhCeXRlc1RvV3JpdGU+MCkpcmV0dXJuIDA7dmFyIHN0YXJ0SWR4PW91dElkeDt2YXIgZW5kSWR4PW91dElkeCttYXhCeXRlc1RvV3JpdGUtMTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpe3ZhciB1MT1zdHIuY2hhckNvZGVBdCgrK2kpO3U9NjU1MzYrKCh1JjEwMjMpPDwxMCl8dTEmMTAyM31pZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4Kys+Pj4wXT11fWVsc2UgaWYodTw9MjA0Nyl7aWYob3V0SWR4KzE+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrPj4+MF09MTkyfHU+PjY7aGVhcFtvdXRJZHgrKz4+PjBdPTEyOHx1JjYzfWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrKz4+PjBdPTIyNHx1Pj4xMjtoZWFwW291dElkeCsrPj4+MF09MTI4fHU+PjYmNjM7aGVhcFtvdXRJZHgrKz4+PjBdPTEyOHx1JjYzfWVsc2V7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrPj4+MF09MjQwfHU+PjE4O2hlYXBbb3V0SWR4Kys+Pj4wXT0xMjh8dT4+MTImNjM7aGVhcFtvdXRJZHgrKz4+PjBdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4Kys+Pj4wXT0xMjh8dSY2M319aGVhcFtvdXRJZHg+Pj4wXT0wO3JldHVybiBvdXRJZHgtc3RhcnRJZHh9ZnVuY3Rpb24gc3RyaW5nVG9VVEY4KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKXtyZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLEhFQVBVOCxvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKX1mdW5jdGlvbiBfX19zeXNjYWxsX2dldGRlbnRzNjQoZmQsZGlycCxjb3VudCl7fWZ1bmN0aW9uIHplcm9NZW1vcnkoYWRkcmVzcyxzaXplKXtIRUFQVTguZmlsbCgwLGFkZHJlc3MsYWRkcmVzcytzaXplKTtyZXR1cm4gYWRkcmVzc31mdW5jdGlvbiB3cml0ZVNvY2thZGRyKHNhLGZhbWlseSxhZGRyLHBvcnQsYWRkcmxlbil7c3dpdGNoKGZhbWlseSl7Y2FzZSAyOmFkZHI9aW5ldFB0b240KGFkZHIpO3plcm9NZW1vcnkoc2EsMTYpO2lmKGFkZHJsZW4pe0hFQVAzMlthZGRybGVuPj4+Ml09MTZ9SEVBUDE2W3NhPj4+MV09ZmFtaWx5O0hFQVAzMltzYSs0Pj4+Ml09YWRkcjtIRUFQMTZbc2ErMj4+PjFdPV9odG9ucyhwb3J0KTticmVhaztjYXNlIDEwOmFkZHI9aW5ldFB0b242KGFkZHIpO3plcm9NZW1vcnkoc2EsMjgpO2lmKGFkZHJsZW4pe0hFQVAzMlthZGRybGVuPj4+Ml09Mjh9SEVBUDMyW3NhPj4+Ml09ZmFtaWx5O0hFQVAzMltzYSs4Pj4+Ml09YWRkclswXTtIRUFQMzJbc2ErMTI+Pj4yXT1hZGRyWzFdO0hFQVAzMltzYSsxNj4+PjJdPWFkZHJbMl07SEVBUDMyW3NhKzIwPj4+Ml09YWRkclszXTtIRUFQMTZbc2ErMj4+PjFdPV9odG9ucyhwb3J0KTticmVhaztkZWZhdWx0OnJldHVybiA1fXJldHVybiAwfWZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0cGVlcm5hbWUoZmQsYWRkcixhZGRybGVuLGQxLGQyLGQzKXt2YXIgc29jaz1nZXRTb2NrZXRGcm9tRkQoZmQpO2lmKCFzb2NrLmRhZGRyKXtyZXR1cm4tNTN9dmFyIGVycm5vPXdyaXRlU29ja2FkZHIoYWRkcixzb2NrLmZhbWlseSxETlMubG9va3VwX25hbWUoc29jay5kYWRkciksc29jay5kcG9ydCxhZGRybGVuKTtyZXR1cm4gMH1mdW5jdGlvbiBfX19zeXNjYWxsX2dldHNvY2tvcHQoZmQsbGV2ZWwsb3B0bmFtZSxvcHR2YWwsb3B0bGVuLGQxKXt2YXIgc29jaz1nZXRTb2NrZXRGcm9tRkQoZmQpO2lmKGxldmVsPT09MSl7aWYob3B0bmFtZT09PTQpe0hFQVAzMltvcHR2YWw+Pj4yXT1zb2NrLmVycm9yO0hFQVAzMltvcHRsZW4+Pj4yXT00O3NvY2suZXJyb3I9bnVsbDtyZXR1cm4gMH19cmV0dXJuLTUwfWZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsb3AsdmFyYXJncyl7U1lTQ0FMTFMudmFyYXJncz12YXJhcmdzO3JldHVybiAwfWZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLGJ1Zil7fWZ1bmN0aW9uIF9fX3N5c2NhbGxfbWtkaXJhdChkaXJmZCxwYXRoLG1vZGUpe31mdW5jdGlvbiBfX19zeXNjYWxsX25ld2ZzdGF0YXQoZGlyZmQscGF0aCxidWYsZmxhZ3Mpe31mdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCxwYXRoLGZsYWdzLHZhcmFyZ3Mpe1NZU0NBTExTLnZhcmFyZ3M9dmFyYXJnc31mdW5jdGlvbiBfX19zeXNjYWxsX3JlY3Zmcm9tKGZkLGJ1ZixsZW4sZmxhZ3MsYWRkcixhZGRybGVuKXt2YXIgc29jaz1nZXRTb2NrZXRGcm9tRkQoZmQpO3ZhciBtc2c9c29jay5zb2NrX29wcy5yZWN2bXNnKHNvY2ssbGVuKTtpZighbXNnKXJldHVybiAwO2lmKGFkZHIpe3ZhciBlcnJubz13cml0ZVNvY2thZGRyKGFkZHIsc29jay5mYW1pbHksRE5TLmxvb2t1cF9uYW1lKG1zZy5hZGRyKSxtc2cucG9ydCxhZGRybGVuKX1IRUFQVTguc2V0KG1zZy5idWZmZXIsYnVmPj4+MCk7cmV0dXJuIG1zZy5idWZmZXIuYnl0ZUxlbmd0aH1mdW5jdGlvbiBfX19zeXNjYWxsX3JlbmFtZWF0KG9sZGRpcmZkLG9sZHBhdGgsbmV3ZGlyZmQsbmV3cGF0aCl7fWZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCl7fWZ1bmN0aW9uIF9fX3N5c2NhbGxfc2VuZHRvKGZkLG1lc3NhZ2UsbGVuZ3RoLGZsYWdzLGFkZHIsYWRkcl9sZW4pe31mdW5jdGlvbiBfX19zeXNjYWxsX3NvY2tldChkb21haW4sdHlwZSxwcm90b2NvbCl7fWZ1bmN0aW9uIF9fX3N5c2NhbGxfc3RhdDY0KHBhdGgsYnVmKXt9ZnVuY3Rpb24gX19fc3lzY2FsbF91bmxpbmthdChkaXJmZCxwYXRoLGZsYWdzKXt9dmFyIG5vd0lzTW9ub3RvbmljPXRydWU7ZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCl7cmV0dXJuIG5vd0lzTW9ub3RvbmljfWZ1bmN0aW9uIHJlYWRJNTNGcm9tSTY0KHB0cil7cmV0dXJuIEhFQVBVMzJbcHRyPj4+Ml0rSEVBUDMyW3B0cis0Pj4+Ml0qNDI5NDk2NzI5Nn1mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpe3JldHVybiB5ZWFyJTQ9PT0wJiYoeWVhciUxMDAhPT0wfHx5ZWFyJTQwMD09PTApfXZhciBNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XTt2YXIgTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkU9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24geWRheUZyb21EYXRlKGRhdGUpe3ZhciBsZWFwPWlzTGVhcFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTt2YXIgbW9udGhEYXlzQ3VtdWxhdGl2ZT1sZWFwP01PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFOk1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFO3ZhciB5ZGF5PW1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXStkYXRlLmdldERhdGUoKS0xO3JldHVybiB5ZGF5fWZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsdG1QdHIpe3ZhciBkYXRlPW5ldyBEYXRlKHJlYWRJNTNGcm9tSTY0KHRpbWUpKjFlMyk7SEVBUDMyW3RtUHRyPj4+Ml09ZGF0ZS5nZXRTZWNvbmRzKCk7SEVBUDMyW3RtUHRyKzQ+Pj4yXT1kYXRlLmdldE1pbnV0ZXMoKTtIRUFQMzJbdG1QdHIrOD4+PjJdPWRhdGUuZ2V0SG91cnMoKTtIRUFQMzJbdG1QdHIrMTI+Pj4yXT1kYXRlLmdldERhdGUoKTtIRUFQMzJbdG1QdHIrMTY+Pj4yXT1kYXRlLmdldE1vbnRoKCk7SEVBUDMyW3RtUHRyKzIwPj4+Ml09ZGF0ZS5nZXRGdWxsWWVhcigpLTE5MDA7SEVBUDMyW3RtUHRyKzI0Pj4+Ml09ZGF0ZS5nZXREYXkoKTt2YXIgeWRheT15ZGF5RnJvbURhdGUoZGF0ZSl8MDtIRUFQMzJbdG1QdHIrMjg+Pj4yXT15ZGF5O0hFQVAzMlt0bVB0ciszNj4+PjJdPS0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpKjYwKTt2YXIgc3RhcnQ9bmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLDAsMSk7dmFyIHN1bW1lck9mZnNldD1uZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciB3aW50ZXJPZmZzZXQ9c3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgZHN0PShzdW1tZXJPZmZzZXQhPXdpbnRlck9mZnNldCYmZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpPT1NYXRoLm1pbih3aW50ZXJPZmZzZXQsc3VtbWVyT2Zmc2V0KSl8MDtIRUFQMzJbdG1QdHIrMzI+Pj4yXT1kc3R9ZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cil7dmFyIGxlbj0wO2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjPXN0ci5jaGFyQ29kZUF0KGkpO2lmKGM8PTEyNyl7bGVuKyt9ZWxzZSBpZihjPD0yMDQ3KXtsZW4rPTJ9ZWxzZSBpZihjPj01NTI5NiYmYzw9NTczNDMpe2xlbis9NDsrK2l9ZWxzZXtsZW4rPTN9fXJldHVybiBsZW59ZnVuY3Rpb24gc3RyaW5nVG9OZXdVVEY4KHN0cil7dmFyIHNpemU9bGVuZ3RoQnl0ZXNVVEY4KHN0cikrMTt2YXIgcmV0PV9tYWxsb2Moc2l6ZSk7aWYocmV0KXN0cmluZ1RvVVRGOChzdHIscmV0LHNpemUpO3JldHVybiByZXR9ZnVuY3Rpb24gX190enNldF9qcyh0aW1lem9uZSxkYXlsaWdodCx0em5hbWUpe3ZhciBjdXJyZW50WWVhcj0obmV3IERhdGUpLmdldEZ1bGxZZWFyKCk7dmFyIHdpbnRlcj1uZXcgRGF0ZShjdXJyZW50WWVhciwwLDEpO3ZhciBzdW1tZXI9bmV3IERhdGUoY3VycmVudFllYXIsNiwxKTt2YXIgd2ludGVyT2Zmc2V0PXdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBzdW1tZXJPZmZzZXQ9c3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIHN0ZFRpbWV6b25lT2Zmc2V0PU1hdGgubWF4KHdpbnRlck9mZnNldCxzdW1tZXJPZmZzZXQpO0hFQVBVMzJbdGltZXpvbmU+Pj4yXT1zdGRUaW1lem9uZU9mZnNldCo2MDtIRUFQMzJbZGF5bGlnaHQ+Pj4yXT1OdW1iZXIod2ludGVyT2Zmc2V0IT1zdW1tZXJPZmZzZXQpO2Z1bmN0aW9uIGV4dHJhY3Rab25lKGRhdGUpe3ZhciBtYXRjaD1kYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7cmV0dXJuIG1hdGNoP21hdGNoWzFdOlwiR01UXCJ9dmFyIHdpbnRlck5hbWU9ZXh0cmFjdFpvbmUod2ludGVyKTt2YXIgc3VtbWVyTmFtZT1leHRyYWN0Wm9uZShzdW1tZXIpO3ZhciB3aW50ZXJOYW1lUHRyPXN0cmluZ1RvTmV3VVRGOCh3aW50ZXJOYW1lKTt2YXIgc3VtbWVyTmFtZVB0cj1zdHJpbmdUb05ld1VURjgoc3VtbWVyTmFtZSk7aWYoc3VtbWVyT2Zmc2V0PHdpbnRlck9mZnNldCl7SEVBUFUzMlt0em5hbWU+Pj4yXT13aW50ZXJOYW1lUHRyO0hFQVBVMzJbdHpuYW1lKzQ+Pj4yXT1zdW1tZXJOYW1lUHRyfWVsc2V7SEVBUFUzMlt0em5hbWU+Pj4yXT1zdW1tZXJOYW1lUHRyO0hFQVBVMzJbdHpuYW1lKzQ+Pj4yXT13aW50ZXJOYW1lUHRyfX1mdW5jdGlvbiBfYWJvcnQoKXthYm9ydChcIlwiKX1mdW5jdGlvbiBfZGxvcGVuKGZpbGVuYW1lLGZsYWdzKXthYm9ydChkbG9wZW5NaXNzaW5nRXJyb3IpfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGUocGF0aCxwYXRoTGVuKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jcmVhdGVEaXJlY3RvcnkoTW9kdWxlLHBhdGgscGF0aExlbil9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0cyhwYXRoLHBhdGhMZW4pe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNoZWNrRGlyZWN0b3J5KE1vZHVsZSxwYXRoLHBhdGhMZW4pfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9saXN0X2ZpbGVzKHBhdGgscGF0aExlbil7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUubGlzdERpcmVjdG9yeUVudHJpZXMoTW9kdWxlLHBhdGgscGF0aExlbil9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X3JlbW92ZShwYXRoLHBhdGhMZW4pe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnJlbW92ZURpcmVjdG9yeShNb2R1bGUscGF0aCxwYXRoTGVuKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2Nsb3NlKGZpbGVJZCl7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2xvc2VGaWxlKE1vZHVsZSxmaWxlSWQpfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzKHBhdGgscGF0aExlbil7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2hlY2tGaWxlKE1vZHVsZSxwYXRoLHBhdGhMZW4pfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZ2V0X2xhc3RfbW9kaWZpZWRfdGltZShmaWxlSWQpe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmdldExhc3RGaWxlTW9kaWZpY2F0aW9uVGltZShNb2R1bGUsZmlsZUlkKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX21vdmUoZnJvbSxmcm9tTGVuLHRvLHRvTGVuKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5tb3ZlRmlsZShNb2R1bGUsZnJvbSxmcm9tTGVuLHRvLHRvTGVuKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX29wZW4oZmlsZUlkLGZsYWdzKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5vcGVuRmlsZShNb2R1bGUsZmlsZUlkLGZsYWdzKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX3JlYWQoZmlsZUlkLGJ1ZixzaXplLGxvY2F0aW9uKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5yZWFkRmlsZShNb2R1bGUsZmlsZUlkLGJ1ZixzaXplLGxvY2F0aW9uKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlKGZpbGVJZCxuZXdTaXplKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS50cnVuY2F0ZUZpbGUoTW9kdWxlLGZpbGVJZCxuZXdTaXplKX1mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX3dyaXRlKGZpbGVJZCxidWYsc2l6ZSxsb2NhdGlvbil7cmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUud3JpdGVGaWxlKE1vZHVsZSxmaWxlSWQsYnVmLHNpemUsbG9jYXRpb24pfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2dldF9kZWZhdWx0X2RhdGFfcHJvdG9jb2woTW9kdWxlKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nZXREZWZhdWx0RGF0YVByb3RvY29sKE1vZHVsZSl9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZ2xvYihwYXRoLHBhdGhMZW4pe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmdsb2IoTW9kdWxlLHBhdGgscGF0aExlbil9ZnVuY3Rpb24gX2R1Y2tkYl93ZWJfdGVzdF9wbGF0Zm9ybV9mZWF0dXJlKGZlYXR1cmUpe3JldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnRlc3RQbGF0Zm9ybUZlYXR1cmUoTW9kdWxlLGZlYXR1cmUpfWZ1bmN0aW9uIF9kdWNrZGJfd2ViX3VkZl9zY2FsYXJfY2FsbChmdW5jSWQsZGVzY1B0cixkZXNjU2l6ZSxwdHJzUHRyLHB0cnNTaXplLHJlc3BvbnNlKXtyZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jYWxsU2NhbGFyVURGKE1vZHVsZSxmdW5jSWQsZGVzY1B0cixkZXNjU2l6ZSxwdHJzUHRyLHB0cnNTaXplLHJlc3BvbnNlKX1mdW5jdGlvbiBfZW1zY3JpcHRlbl9kYXRlX25vdygpe3JldHVybiBEYXRlLm5vdygpfWZ1bmN0aW9uIGdldEhlYXBNYXgoKXtyZXR1cm4gNDI5NDkwMTc2MH1mdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgoKXtyZXR1cm4gZ2V0SGVhcE1heCgpfXZhciBfZW1zY3JpcHRlbl9nZXRfbm93O2lmKEVOVklST05NRU5UX0lTX05PREUpe2dsb2JhbC5wZXJmb3JtYW5jZT1yZXF1aXJlKFwicGVyZl9ob29rc1wiKS5wZXJmb3JtYW5jZX1fZW1zY3JpcHRlbl9nZXRfbm93PSgpPT5wZXJmb3JtYW5jZS5ub3coKTtmdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3Qsc3JjLG51bSl7SEVBUFU4LmNvcHlXaXRoaW4oZGVzdD4+PjAsc3JjPj4+MCxzcmMrbnVtPj4+MCl9ZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKXt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjt2YXIgcGFnZXM9c2l6ZS1iLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNjt0cnl7d2FzbU1lbW9yeS5ncm93KHBhZ2VzKTt1cGRhdGVNZW1vcnlWaWV3cygpO3JldHVybiAxfWNhdGNoKGUpe319ZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSl7dmFyIG9sZFNpemU9SEVBUFU4Lmxlbmd0aDtyZXF1ZXN0ZWRTaXplPXJlcXVlc3RlZFNpemU+Pj4wO3ZhciBtYXhIZWFwU2l6ZT1nZXRIZWFwTWF4KCk7aWYocmVxdWVzdGVkU2l6ZT5tYXhIZWFwU2l6ZSl7cmV0dXJuIGZhbHNlfXZhciBhbGlnblVwPSh4LG11bHRpcGxlKT0+eCsobXVsdGlwbGUteCVtdWx0aXBsZSklbXVsdGlwbGU7Zm9yKHZhciBjdXREb3duPTE7Y3V0RG93bjw9NDtjdXREb3duKj0yKXt2YXIgb3Zlckdyb3duSGVhcFNpemU9b2xkU2l6ZSooMSsuMi9jdXREb3duKTtvdmVyR3Jvd25IZWFwU2l6ZT1NYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSxyZXF1ZXN0ZWRTaXplKzEwMDY2MzI5Nik7dmFyIG5ld1NpemU9TWF0aC5taW4obWF4SGVhcFNpemUsYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLG92ZXJHcm93bkhlYXBTaXplKSw2NTUzNikpO3ZhciByZXBsYWNlbWVudD1lbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO2lmKHJlcGxhY2VtZW50KXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfXZhciBFTlY9e307ZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKXtyZXR1cm4gdGhpc1Byb2dyYW18fFwiLi90aGlzLnByb2dyYW1cIn1mdW5jdGlvbiBnZXRFbnZTdHJpbmdzKCl7aWYoIWdldEVudlN0cmluZ3Muc3RyaW5ncyl7dmFyIGxhbmc9KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiO3ZhciBlbnY9e1wiVVNFUlwiOlwid2ViX3VzZXJcIixcIkxPR05BTUVcIjpcIndlYl91c2VyXCIsXCJQQVRIXCI6XCIvXCIsXCJQV0RcIjpcIi9cIixcIkhPTUVcIjpcIi9ob21lL3dlYl91c2VyXCIsXCJMQU5HXCI6bGFuZyxcIl9cIjpnZXRFeGVjdXRhYmxlTmFtZSgpfTtmb3IodmFyIHggaW4gRU5WKXtpZihFTlZbeF09PT11bmRlZmluZWQpZGVsZXRlIGVudlt4XTtlbHNlIGVudlt4XT1FTlZbeF19dmFyIHN0cmluZ3M9W107Zm9yKHZhciB4IGluIGVudil7c3RyaW5ncy5wdXNoKGAke3h9PSR7ZW52W3hdfWApfWdldEVudlN0cmluZ3Muc3RyaW5ncz1zdHJpbmdzfXJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3N9ZnVuY3Rpb24gc3RyaW5nVG9Bc2NpaShzdHIsYnVmZmVyKXtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXtIRUFQOFtidWZmZXIrKz4+PjBdPXN0ci5jaGFyQ29kZUF0KGkpfUhFQVA4W2J1ZmZlcj4+PjBdPTB9ZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbixlbnZpcm9uX2J1Zil7dmFyIGJ1ZlNpemU9MDtnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcsaSl7dmFyIHB0cj1lbnZpcm9uX2J1ZitidWZTaXplO0hFQVBVMzJbX19lbnZpcm9uK2kqND4+PjJdPXB0cjtzdHJpbmdUb0FzY2lpKHN0cmluZyxwdHIpO2J1ZlNpemUrPXN0cmluZy5sZW5ndGgrMX0pO3JldHVybiAwfWZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCxwZW52aXJvbl9idWZfc2l6ZSl7dmFyIHN0cmluZ3M9Z2V0RW52U3RyaW5ncygpO0hFQVBVMzJbcGVudmlyb25fY291bnQ+Pj4yXT1zdHJpbmdzLmxlbmd0aDt2YXIgYnVmU2l6ZT0wO3N0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpe2J1ZlNpemUrPXN0cmluZy5sZW5ndGgrMX0pO0hFQVBVMzJbcGVudmlyb25fYnVmX3NpemU+Pj4yXT1idWZTaXplO3JldHVybiAwfWZ1bmN0aW9uIF9mZF9jbG9zZShmZCl7cmV0dXJuIDUyfWZ1bmN0aW9uIF9mZF9mZHN0YXRfZ2V0KGZkLHBidWYpe3ZhciByaWdodHNCYXNlPTA7dmFyIHJpZ2h0c0luaGVyaXRpbmc9MDt2YXIgZmxhZ3M9MDt7dmFyIHR5cGU9MjtpZihmZD09MCl7cmlnaHRzQmFzZT0yfWVsc2UgaWYoZmQ9PTF8fGZkPT0yKXtyaWdodHNCYXNlPTY0fWZsYWdzPTF9SEVBUDhbcGJ1Zj4+PjBdPXR5cGU7SEVBUDE2W3BidWYrMj4+PjFdPWZsYWdzO3RlbXBJNjQ9W3JpZ2h0c0Jhc2U+Pj4wLCh0ZW1wRG91YmxlPXJpZ2h0c0Jhc2UsK01hdGguYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8rTWF0aC5mbG9vcih0ZW1wRG91YmxlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUtKyh+fnRlbXBEb3VibGU+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApXSxIRUFQMzJbcGJ1Zis4Pj4+Ml09dGVtcEk2NFswXSxIRUFQMzJbcGJ1ZisxMj4+PjJdPXRlbXBJNjRbMV07dGVtcEk2ND1bcmlnaHRzSW5oZXJpdGluZz4+PjAsKHRlbXBEb3VibGU9cmlnaHRzSW5oZXJpdGluZywrTWF0aC5hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPytNYXRoLmZsb29yKHRlbXBEb3VibGUvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltwYnVmKzE2Pj4+Ml09dGVtcEk2NFswXSxIRUFQMzJbcGJ1ZisyMD4+PjJdPXRlbXBJNjRbMV07cmV0dXJuIDB9ZnVuY3Rpb24gX2ZkX3ByZWFkKGZkLGlvdixpb3ZjbnQsb2Zmc2V0X2xvdyxvZmZzZXRfaGlnaCxwbnVtKXtyZXR1cm4gNTJ9ZnVuY3Rpb24gX2ZkX3B3cml0ZShmZCxpb3YsaW92Y250LG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gscG51bSl7cmV0dXJuIDUyfWZ1bmN0aW9uIF9mZF9yZWFkKGZkLGlvdixpb3ZjbnQscG51bSl7cmV0dXJuIDUyfWZ1bmN0aW9uIF9mZF9zZWVrKGZkLG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gsd2hlbmNlLG5ld09mZnNldCl7cmV0dXJuIDcwfWZ1bmN0aW9uIF9mZF9zeW5jKGZkKXtyZXR1cm4gNTJ9dmFyIHByaW50Q2hhckJ1ZmZlcnM9W251bGwsW10sW11dO2Z1bmN0aW9uIHByaW50Q2hhcihzdHJlYW0sY3Vycil7dmFyIGJ1ZmZlcj1wcmludENoYXJCdWZmZXJzW3N0cmVhbV07aWYoY3Vycj09PTB8fGN1cnI9PT0xMCl7KHN0cmVhbT09PTE/b3V0OmVycikoVVRGOEFycmF5VG9TdHJpbmcoYnVmZmVyLDApKTtidWZmZXIubGVuZ3RoPTB9ZWxzZXtidWZmZXIucHVzaChjdXJyKX19ZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLGlvdixpb3ZjbnQscG51bSl7dmFyIG51bT0wO2Zvcih2YXIgaT0wO2k8aW92Y250O2krKyl7dmFyIHB0cj1IRUFQVTMyW2lvdj4+PjJdO3ZhciBsZW49SEVBUFUzMltpb3YrND4+PjJdO2lvdis9ODtmb3IodmFyIGo9MDtqPGxlbjtqKyspe3ByaW50Q2hhcihmZCxIRUFQVThbcHRyK2o+Pj4wXSl9bnVtKz1sZW59SEVBUFUzMltwbnVtPj4+Ml09bnVtO3JldHVybiAwfWZ1bmN0aW9uIF9nZXRhZGRyaW5mbyhub2RlLHNlcnZpY2UsaGludCxvdXQpe3ZhciBhZGRyPTA7dmFyIHBvcnQ9MDt2YXIgZmxhZ3M9MDt2YXIgZmFtaWx5PTA7dmFyIHR5cGU9MDt2YXIgcHJvdG89MDt2YXIgYWk7ZnVuY3Rpb24gYWxsb2NhZGRyaW5mbyhmYW1pbHksdHlwZSxwcm90byxjYW5vbixhZGRyLHBvcnQpe3ZhciBzYSxzYWxlbixhaTt2YXIgZXJybm87c2FsZW49ZmFtaWx5PT09MTA/Mjg6MTY7YWRkcj1mYW1pbHk9PT0xMD9pbmV0TnRvcDYoYWRkcik6aW5ldE50b3A0KGFkZHIpO3NhPV9tYWxsb2Moc2FsZW4pO2Vycm5vPXdyaXRlU29ja2FkZHIoc2EsZmFtaWx5LGFkZHIscG9ydCk7YXNzZXJ0KCFlcnJubyk7YWk9X21hbGxvYygzMik7SEVBUDMyW2FpKzQ+Pj4yXT1mYW1pbHk7SEVBUDMyW2FpKzg+Pj4yXT10eXBlO0hFQVAzMlthaSsxMj4+PjJdPXByb3RvO0hFQVBVMzJbYWkrMjQ+Pj4yXT1jYW5vbjtIRUFQVTMyW2FpKzIwPj4+Ml09c2E7aWYoZmFtaWx5PT09MTApe0hFQVAzMlthaSsxNj4+PjJdPTI4fWVsc2V7SEVBUDMyW2FpKzE2Pj4+Ml09MTZ9SEVBUDMyW2FpKzI4Pj4+Ml09MDtyZXR1cm4gYWl9aWYoaGludCl7ZmxhZ3M9SEVBUDMyW2hpbnQ+Pj4yXTtmYW1pbHk9SEVBUDMyW2hpbnQrND4+PjJdO3R5cGU9SEVBUDMyW2hpbnQrOD4+PjJdO3Byb3RvPUhFQVAzMltoaW50KzEyPj4+Ml19aWYodHlwZSYmIXByb3RvKXtwcm90bz10eXBlPT09Mj8xNzo2fWlmKCF0eXBlJiZwcm90byl7dHlwZT1wcm90bz09PTE3PzI6MX1pZihwcm90bz09PTApe3Byb3RvPTZ9aWYodHlwZT09PTApe3R5cGU9MX1pZighbm9kZSYmIXNlcnZpY2Upe3JldHVybi0yfWlmKGZsYWdzJn4oMXwyfDR8MTAyNHw4fDE2fDMyKSl7cmV0dXJuLTF9aWYoaGludCE9PTAmJkhFQVAzMltoaW50Pj4+Ml0mMiYmIW5vZGUpe3JldHVybi0xfWlmKGZsYWdzJjMyKXtyZXR1cm4tMn1pZih0eXBlIT09MCYmdHlwZSE9PTEmJnR5cGUhPT0yKXtyZXR1cm4tN31pZihmYW1pbHkhPT0wJiZmYW1pbHkhPT0yJiZmYW1pbHkhPT0xMCl7cmV0dXJuLTZ9aWYoc2VydmljZSl7c2VydmljZT1VVEY4VG9TdHJpbmcoc2VydmljZSk7cG9ydD1wYXJzZUludChzZXJ2aWNlLDEwKTtpZihpc05hTihwb3J0KSl7aWYoZmxhZ3MmMTAyNCl7cmV0dXJuLTJ9cmV0dXJuLTh9fWlmKCFub2RlKXtpZihmYW1pbHk9PT0wKXtmYW1pbHk9Mn1pZigoZmxhZ3MmMSk9PT0wKXtpZihmYW1pbHk9PT0yKXthZGRyPV9odG9ubCgyMTMwNzA2NDMzKX1lbHNle2FkZHI9WzAsMCwwLDFdfX1haT1hbGxvY2FkZHJpbmZvKGZhbWlseSx0eXBlLHByb3RvLG51bGwsYWRkcixwb3J0KTtIRUFQVTMyW291dD4+PjJdPWFpO3JldHVybiAwfW5vZGU9VVRGOFRvU3RyaW5nKG5vZGUpO2FkZHI9aW5ldFB0b240KG5vZGUpO2lmKGFkZHIhPT1udWxsKXtpZihmYW1pbHk9PT0wfHxmYW1pbHk9PT0yKXtmYW1pbHk9Mn1lbHNlIGlmKGZhbWlseT09PTEwJiZmbGFncyY4KXthZGRyPVswLDAsX2h0b25sKDY1NTM1KSxhZGRyXTtmYW1pbHk9MTB9ZWxzZXtyZXR1cm4tMn19ZWxzZXthZGRyPWluZXRQdG9uNihub2RlKTtpZihhZGRyIT09bnVsbCl7aWYoZmFtaWx5PT09MHx8ZmFtaWx5PT09MTApe2ZhbWlseT0xMH1lbHNle3JldHVybi0yfX19aWYoYWRkciE9bnVsbCl7YWk9YWxsb2NhZGRyaW5mbyhmYW1pbHksdHlwZSxwcm90byxub2RlLGFkZHIscG9ydCk7SEVBUFUzMltvdXQ+Pj4yXT1haTtyZXR1cm4gMH1pZihmbGFncyY0KXtyZXR1cm4tMn1ub2RlPUROUy5sb29rdXBfbmFtZShub2RlKTthZGRyPWluZXRQdG9uNChub2RlKTtpZihmYW1pbHk9PT0wKXtmYW1pbHk9Mn1lbHNlIGlmKGZhbWlseT09PTEwKXthZGRyPVswLDAsX2h0b25sKDY1NTM1KSxhZGRyXX1haT1hbGxvY2FkZHJpbmZvKGZhbWlseSx0eXBlLHByb3RvLG51bGwsYWRkcixwb3J0KTtIRUFQVTMyW291dD4+PjJdPWFpO3JldHVybiAwfWZ1bmN0aW9uIGluaXRSYW5kb21GaWxsKCl7aWYodHlwZW9mIGNyeXB0bz09XCJvYmplY3RcIiYmdHlwZW9mIGNyeXB0b1tcImdldFJhbmRvbVZhbHVlc1wiXT09XCJmdW5jdGlvblwiKXtyZXR1cm4gdmlldz0+Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2aWV3KX1lbHNlIGlmKEVOVklST05NRU5UX0lTX05PREUpe3RyeXt2YXIgY3J5cHRvX21vZHVsZT1yZXF1aXJlKFwiY3J5cHRvXCIpO3ZhciByYW5kb21GaWxsU3luYz1jcnlwdG9fbW9kdWxlW1wicmFuZG9tRmlsbFN5bmNcIl07aWYocmFuZG9tRmlsbFN5bmMpe3JldHVybiB2aWV3PT5jcnlwdG9fbW9kdWxlW1wicmFuZG9tRmlsbFN5bmNcIl0odmlldyl9dmFyIHJhbmRvbUJ5dGVzPWNyeXB0b19tb2R1bGVbXCJyYW5kb21CeXRlc1wiXTtyZXR1cm4gdmlldz0+KHZpZXcuc2V0KHJhbmRvbUJ5dGVzKHZpZXcuYnl0ZUxlbmd0aCkpLHZpZXcpfWNhdGNoKGUpe319YWJvcnQoXCJpbml0UmFuZG9tRGV2aWNlXCIpfWZ1bmN0aW9uIHJhbmRvbUZpbGwodmlldyl7cmV0dXJuKHJhbmRvbUZpbGw9aW5pdFJhbmRvbUZpbGwoKSkodmlldyl9ZnVuY3Rpb24gX2dldGVudHJvcHkoYnVmZmVyLHNpemUpe3JhbmRvbUZpbGwoSEVBUFU4LnN1YmFycmF5KGJ1ZmZlcj4+PjAsYnVmZmVyK3NpemU+Pj4wKSk7cmV0dXJuIDB9ZnVuY3Rpb24gX2dldG5hbWVpbmZvKHNhLHNhbGVuLG5vZGUsbm9kZWxlbixzZXJ2LHNlcnZsZW4sZmxhZ3Mpe3ZhciBpbmZvPXJlYWRTb2NrYWRkcihzYSxzYWxlbik7aWYoaW5mby5lcnJubyl7cmV0dXJuLTZ9dmFyIHBvcnQ9aW5mby5wb3J0O3ZhciBhZGRyPWluZm8uYWRkcjt2YXIgb3ZlcmZsb3dlZD1mYWxzZTtpZihub2RlJiZub2RlbGVuKXt2YXIgbG9va3VwO2lmKGZsYWdzJjF8fCEobG9va3VwPUROUy5sb29rdXBfYWRkcihhZGRyKSkpe2lmKGZsYWdzJjgpe3JldHVybi0yfX1lbHNle2FkZHI9bG9va3VwfXZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbD1zdHJpbmdUb1VURjgoYWRkcixub2RlLG5vZGVsZW4pO2lmKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsKzE+PW5vZGVsZW4pe292ZXJmbG93ZWQ9dHJ1ZX19aWYoc2VydiYmc2Vydmxlbil7cG9ydD1cIlwiK3BvcnQ7dmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsPXN0cmluZ1RvVVRGOChwb3J0LHNlcnYsc2Vydmxlbik7aWYobnVtQnl0ZXNXcml0dGVuRXhjbE51bGwrMT49c2Vydmxlbil7b3ZlcmZsb3dlZD10cnVlfX1pZihvdmVyZmxvd2VkKXtyZXR1cm4tMTJ9cmV0dXJuIDB9ZnVuY3Rpb24gYXJyYXlTdW0oYXJyYXksaW5kZXgpe3ZhciBzdW09MDtmb3IodmFyIGk9MDtpPD1pbmRleDtzdW0rPWFycmF5W2krK10pe31yZXR1cm4gc3VtfXZhciBNT05USF9EQVlTX0xFQVA9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTt2YXIgTU9OVEhfREFZU19SRUdVTEFSPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07ZnVuY3Rpb24gYWRkRGF5cyhkYXRlLGRheXMpe3ZhciBuZXdEYXRlPW5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTt3aGlsZShkYXlzPjApe3ZhciBsZWFwPWlzTGVhcFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKTt2YXIgY3VycmVudE1vbnRoPW5ld0RhdGUuZ2V0TW9udGgoKTt2YXIgZGF5c0luQ3VycmVudE1vbnRoPShsZWFwP01PTlRIX0RBWVNfTEVBUDpNT05USF9EQVlTX1JFR1VMQVIpW2N1cnJlbnRNb250aF07aWYoZGF5cz5kYXlzSW5DdXJyZW50TW9udGgtbmV3RGF0ZS5nZXREYXRlKCkpe2RheXMtPWRheXNJbkN1cnJlbnRNb250aC1uZXdEYXRlLmdldERhdGUoKSsxO25ld0RhdGUuc2V0RGF0ZSgxKTtpZihjdXJyZW50TW9udGg8MTEpe25ld0RhdGUuc2V0TW9udGgoY3VycmVudE1vbnRoKzEpfWVsc2V7bmV3RGF0ZS5zZXRNb250aCgwKTtuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSsxKX19ZWxzZXtuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkrZGF5cyk7cmV0dXJuIG5ld0RhdGV9fXJldHVybiBuZXdEYXRlfWZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LGRvbnRBZGROdWxsLGxlbmd0aCl7dmFyIGxlbj1sZW5ndGg+MD9sZW5ndGg6bGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpKzE7dmFyIHU4YXJyYXk9bmV3IEFycmF5KGxlbik7dmFyIG51bUJ5dGVzV3JpdHRlbj1zdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LHU4YXJyYXksMCx1OGFycmF5Lmxlbmd0aCk7aWYoZG9udEFkZE51bGwpdThhcnJheS5sZW5ndGg9bnVtQnl0ZXNXcml0dGVuO3JldHVybiB1OGFycmF5fWZ1bmN0aW9uIHdyaXRlQXJyYXlUb01lbW9yeShhcnJheSxidWZmZXIpe0hFQVA4LnNldChhcnJheSxidWZmZXI+Pj4wKX1mdW5jdGlvbiBfc3RyZnRpbWUocyxtYXhzaXplLGZvcm1hdCx0bSl7dmFyIHRtX3pvbmU9SEVBUDMyW3RtKzQwPj4+Ml07dmFyIGRhdGU9e3RtX3NlYzpIRUFQMzJbdG0+Pj4yXSx0bV9taW46SEVBUDMyW3RtKzQ+Pj4yXSx0bV9ob3VyOkhFQVAzMlt0bSs4Pj4+Ml0sdG1fbWRheTpIRUFQMzJbdG0rMTI+Pj4yXSx0bV9tb246SEVBUDMyW3RtKzE2Pj4+Ml0sdG1feWVhcjpIRUFQMzJbdG0rMjA+Pj4yXSx0bV93ZGF5OkhFQVAzMlt0bSsyND4+PjJdLHRtX3lkYXk6SEVBUDMyW3RtKzI4Pj4+Ml0sdG1faXNkc3Q6SEVBUDMyW3RtKzMyPj4+Ml0sdG1fZ210b2ZmOkhFQVAzMlt0bSszNj4+PjJdLHRtX3pvbmU6dG1fem9uZT9VVEY4VG9TdHJpbmcodG1fem9uZSk6XCJcIn07dmFyIHBhdHRlcm49VVRGOFRvU3RyaW5nKGZvcm1hdCk7dmFyIEVYUEFOU0lPTl9SVUxFU18xPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18xKXtwYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZShuZXcgUmVnRXhwKHJ1bGUsXCJnXCIpLEVYUEFOU0lPTl9SVUxFU18xW3J1bGVdKX12YXIgV0VFS0RBWVM9W1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl07dmFyIE1PTlRIUz1bXCJKYW51YXJ5XCIsXCJGZWJydWFyeVwiLFwiTWFyY2hcIixcIkFwcmlsXCIsXCJNYXlcIixcIkp1bmVcIixcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl07ZnVuY3Rpb24gbGVhZGluZ1NvbWV0aGluZyh2YWx1ZSxkaWdpdHMsY2hhcmFjdGVyKXt2YXIgc3RyPXR5cGVvZiB2YWx1ZT09XCJudW1iZXJcIj92YWx1ZS50b1N0cmluZygpOnZhbHVlfHxcIlwiO3doaWxlKHN0ci5sZW5ndGg8ZGlnaXRzKXtzdHI9Y2hhcmFjdGVyWzBdK3N0cn1yZXR1cm4gc3RyfWZ1bmN0aW9uIGxlYWRpbmdOdWxscyh2YWx1ZSxkaWdpdHMpe3JldHVybiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxcIjBcIil9ZnVuY3Rpb24gY29tcGFyZUJ5RGF5KGRhdGUxLGRhdGUyKXtmdW5jdGlvbiBzZ24odmFsdWUpe3JldHVybiB2YWx1ZTwwPy0xOnZhbHVlPjA/MTowfXZhciBjb21wYXJlO2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRGdWxsWWVhcigpLWRhdGUyLmdldEZ1bGxZZWFyKCkpKT09PTApe2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRNb250aCgpLWRhdGUyLmdldE1vbnRoKCkpKT09PTApe2NvbXBhcmU9c2duKGRhdGUxLmdldERhdGUoKS1kYXRlMi5nZXREYXRlKCkpfX1yZXR1cm4gY29tcGFyZX1mdW5jdGlvbiBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoKXtzd2l0Y2goamFuRm91cnRoLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gamFuRm91cnRoO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKXt2YXIgdGhpc0RhdGU9YWRkRGF5cyhuZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCwwLDEpLGRhdGUudG1feWRheSk7dmFyIGphbkZvdXJ0aFRoaXNZZWFyPW5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCksMCw0KTt2YXIgamFuRm91cnRoTmV4dFllYXI9bmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSsxLDAsNCk7dmFyIGZpcnN0V2Vla1N0YXJ0VGhpc1llYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aFRoaXNZZWFyKTt2YXIgZmlyc3RXZWVrU3RhcnROZXh0WWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoTmV4dFllYXIpO2lmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydFRoaXNZZWFyLHRoaXNEYXRlKTw9MCl7aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIsdGhpc0RhdGUpPD0wKXtyZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKSsxfXJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpfXJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLTF9dmFyIEVYUEFOU0lPTl9SVUxFU18yPXtcIiVhXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV0uc3Vic3RyaW5nKDAsMyl9LFwiJUFcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gV0VFS0RBWVNbZGF0ZS50bV93ZGF5XX0sXCIlYlwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBNT05USFNbZGF0ZS50bV9tb25dLnN1YnN0cmluZygwLDMpfSxcIiVCXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIE1PTlRIU1tkYXRlLnRtX21vbl19LFwiJUNcIjpmdW5jdGlvbihkYXRlKXt2YXIgeWVhcj1kYXRlLnRtX3llYXIrMTkwMDtyZXR1cm4gbGVhZGluZ051bGxzKHllYXIvMTAwfDAsMil9LFwiJWRcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheSwyKX0sXCIlZVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBsZWFkaW5nU29tZXRoaW5nKGRhdGUudG1fbWRheSwyLFwiIFwiKX0sXCIlZ1wiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSxcIiVHXCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSl9LFwiJUhcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1faG91ciwyKX0sXCIlSVwiOmZ1bmN0aW9uKGRhdGUpe3ZhciB0d2VsdmVIb3VyPWRhdGUudG1faG91cjtpZih0d2VsdmVIb3VyPT0wKXR3ZWx2ZUhvdXI9MTI7ZWxzZSBpZih0d2VsdmVIb3VyPjEyKXR3ZWx2ZUhvdXItPTEyO3JldHVybiBsZWFkaW5nTnVsbHModHdlbHZlSG91ciwyKX0sXCIlalwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5K2FycmF5U3VtKGlzTGVhcFllYXIoZGF0ZS50bV95ZWFyKzE5MDApP01PTlRIX0RBWVNfTEVBUDpNT05USF9EQVlTX1JFR1VMQVIsZGF0ZS50bV9tb24tMSksMyl9LFwiJW1cIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbW9uKzEsMil9LFwiJU1cIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWluLDIpfSxcIiVuXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcblwifSxcIiVwXCI6ZnVuY3Rpb24oZGF0ZSl7aWYoZGF0ZS50bV9ob3VyPj0wJiZkYXRlLnRtX2hvdXI8MTIpe3JldHVyblwiQU1cIn1yZXR1cm5cIlBNXCJ9LFwiJVNcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fc2VjLDIpfSxcIiV0XCI6ZnVuY3Rpb24oKXtyZXR1cm5cIlxcdFwifSxcIiV1XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuIGRhdGUudG1fd2RheXx8N30sXCIlVVwiOmZ1bmN0aW9uKGRhdGUpe3ZhciBkYXlzPWRhdGUudG1feWRheSs3LWRhdGUudG1fd2RheTtyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguZmxvb3IoZGF5cy83KSwyKX0sXCIlVlwiOmZ1bmN0aW9uKGRhdGUpe3ZhciB2YWw9TWF0aC5mbG9vcigoZGF0ZS50bV95ZGF5KzctKGRhdGUudG1fd2RheSs2KSU3KS83KTtpZigoZGF0ZS50bV93ZGF5KzM3MS1kYXRlLnRtX3lkYXktMiklNzw9Mil7dmFsKyt9aWYoIXZhbCl7dmFsPTUyO3ZhciBkZWMzMT0oZGF0ZS50bV93ZGF5KzctZGF0ZS50bV95ZGF5LTEpJTc7aWYoZGVjMzE9PTR8fGRlYzMxPT01JiZpc0xlYXBZZWFyKGRhdGUudG1feWVhciU0MDAtMSkpe3ZhbCsrfX1lbHNlIGlmKHZhbD09NTMpe3ZhciBqYW4xPShkYXRlLnRtX3dkYXkrMzcxLWRhdGUudG1feWRheSklNztpZihqYW4xIT00JiYoamFuMSE9M3x8IWlzTGVhcFllYXIoZGF0ZS50bV95ZWFyKSkpdmFsPTF9cmV0dXJuIGxlYWRpbmdOdWxscyh2YWwsMil9LFwiJXdcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV93ZGF5fSxcIiVXXCI6ZnVuY3Rpb24oZGF0ZSl7dmFyIGRheXM9ZGF0ZS50bV95ZGF5KzctKGRhdGUudG1fd2RheSs2KSU3O3JldHVybiBsZWFkaW5nTnVsbHMoTWF0aC5mbG9vcihkYXlzLzcpLDIpfSxcIiV5XCI6ZnVuY3Rpb24oZGF0ZSl7cmV0dXJuKGRhdGUudG1feWVhcisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sXCIlWVwiOmZ1bmN0aW9uKGRhdGUpe3JldHVybiBkYXRlLnRtX3llYXIrMTkwMH0sXCIlelwiOmZ1bmN0aW9uKGRhdGUpe3ZhciBvZmY9ZGF0ZS50bV9nbXRvZmY7dmFyIGFoZWFkPW9mZj49MDtvZmY9TWF0aC5hYnMob2ZmKS82MDtvZmY9b2ZmLzYwKjEwMCtvZmYlNjA7cmV0dXJuKGFoZWFkP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrb2ZmKS5zbGljZSgtNCl9LFwiJVpcIjpmdW5jdGlvbihkYXRlKXtyZXR1cm4gZGF0ZS50bV96b25lfSxcIiUlXCI6ZnVuY3Rpb24oKXtyZXR1cm5cIiVcIn19O3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKC8lJS9nLFwiXFwwXFwwXCIpO2Zvcih2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMil7aWYocGF0dGVybi5pbmNsdWRlcyhydWxlKSl7cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLFwiZ1wiKSxFWFBBTlNJT05fUlVMRVNfMltydWxlXShkYXRlKSl9fXBhdHRlcm49cGF0dGVybi5yZXBsYWNlKC9cXDBcXDAvZyxcIiVcIik7dmFyIGJ5dGVzPWludEFycmF5RnJvbVN0cmluZyhwYXR0ZXJuLGZhbHNlKTtpZihieXRlcy5sZW5ndGg+bWF4c2l6ZSl7cmV0dXJuIDB9d3JpdGVBcnJheVRvTWVtb3J5KGJ5dGVzLHMpO3JldHVybiBieXRlcy5sZW5ndGgtMX1mdW5jdGlvbiBfc3RyZnRpbWVfbChzLG1heHNpemUsZm9ybWF0LHRtLGxvYyl7cmV0dXJuIF9zdHJmdGltZShzLG1heHNpemUsZm9ybWF0LHRtKX1mdW5jdGlvbiBfdWNudl9jbG9zZV82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfY2xvc2VfNjRcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91Y252X2NvbnZlcnRFeF82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfY29udmVydEV4XzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNudl9vcGVuXzY0KCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNudl9vcGVuXzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNudl90b0FsZ29yaXRobWljXzY0KCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNudl90b0FsZ29yaXRobWljXzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNzZGV0X2Nsb3NlXzY0KCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2Nsb3NlXzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNzZGV0X2RldGVjdF82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9kZXRlY3RfNjRcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9nZXRDb25maWRlbmNlXzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdWNzZGV0X2dldE5hbWVfNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZ2V0TmFtZV82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vjc2RldF9vcGVuXzY0KCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X29wZW5fNjRcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91Y3NkZXRfc2V0VGV4dF82NCgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9zZXRUZXh0XzY0XCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56Q2xvc2UoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpDbG9zZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuekNsb3NlQ3VycmVudEZpbGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpDbG9zZUN1cnJlbnRGaWxlXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56R2V0Q3VycmVudEZpbGVJbmZvKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R2V0Q3VycmVudEZpbGVJbmZvXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56R2V0Q3VycmVudEZpbGVJbmZvNjQoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHZXRDdXJyZW50RmlsZUluZm82NFwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuekdldEdsb2JhbEluZm8oKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHZXRHbG9iYWxJbmZvXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56R29Ub0ZpcnN0RmlsZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdvVG9GaXJzdEZpbGVcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpHb1RvTmV4dEZpbGUoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHb1RvTmV4dEZpbGVcIik7YWJvcnQoLTEpfWZ1bmN0aW9uIF91bnpMb2NhdGVGaWxlKCl7ZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56TG9jYXRlRmlsZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vuek9wZW4oKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuXCIpO2Fib3J0KC0xKX1mdW5jdGlvbiBfdW56T3BlbjIoKXtlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuMlwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Vuek9wZW5DdXJyZW50RmlsZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuek9wZW5DdXJyZW50RmlsZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3VuelJlYWRDdXJyZW50RmlsZSgpe2VycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuelJlYWRDdXJyZW50RmlsZVwiKTthYm9ydCgtMSl9ZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKXtFWElUU1RBVFVTPWNvZGU7aWYoIWtlZXBSdW50aW1lQWxpdmUoKSl7aWYoTW9kdWxlW1wib25FeGl0XCJdKU1vZHVsZVtcIm9uRXhpdFwiXShjb2RlKTtBQk9SVD10cnVlfXF1aXRfKGNvZGUsbmV3IEV4aXRTdGF0dXMoY29kZSkpfWZ1bmN0aW9uIGV4aXRKUyhzdGF0dXMsaW1wbGljaXQpe0VYSVRTVEFUVVM9c3RhdHVzO19wcm9jX2V4aXQoc3RhdHVzKX1mdW5jdGlvbiBoYW5kbGVFeGNlcHRpb24oZSl7aWYoZSBpbnN0YW5jZW9mIEV4aXRTdGF0dXN8fGU9PVwidW53aW5kXCIpe3JldHVybiBFWElUU1RBVFVTfXF1aXRfKDEsZSl9ZnVuY3Rpb24gZ2V0Q0Z1bmMoaWRlbnQpe3ZhciBmdW5jPU1vZHVsZVtcIl9cIitpZGVudF07cmV0dXJuIGZ1bmN9ZnVuY3Rpb24gc3RyaW5nVG9VVEY4T25TdGFjayhzdHIpe3ZhciBzaXplPWxlbmd0aEJ5dGVzVVRGOChzdHIpKzE7dmFyIHJldD1zdGFja0FsbG9jKHNpemUpO3N0cmluZ1RvVVRGOChzdHIscmV0LHNpemUpO3JldHVybiByZXR9ZnVuY3Rpb24gY2NhbGwoaWRlbnQscmV0dXJuVHlwZSxhcmdUeXBlcyxhcmdzLG9wdHMpe3ZhciB0b0M9e1wic3RyaW5nXCI6c3RyPT57dmFyIHJldD0wO2lmKHN0ciE9PW51bGwmJnN0ciE9PXVuZGVmaW5lZCYmc3RyIT09MCl7cmV0PXN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKX1yZXR1cm4gcmV0fSxcImFycmF5XCI6YXJyPT57dmFyIHJldD1zdGFja0FsbG9jKGFyci5sZW5ndGgpO3dyaXRlQXJyYXlUb01lbW9yeShhcnIscmV0KTtyZXR1cm4gcmV0fX07ZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldCl7aWYocmV0dXJuVHlwZT09PVwic3RyaW5nXCIpe3JldHVybiBVVEY4VG9TdHJpbmcocmV0KX1pZihyZXR1cm5UeXBlPT09XCJib29sZWFuXCIpcmV0dXJuIEJvb2xlYW4ocmV0KTtyZXR1cm4gcmV0fXZhciBmdW5jPWdldENGdW5jKGlkZW50KTt2YXIgY0FyZ3M9W107dmFyIHN0YWNrPTA7aWYoYXJncyl7Zm9yKHZhciBpPTA7aTxhcmdzLmxlbmd0aDtpKyspe3ZhciBjb252ZXJ0ZXI9dG9DW2FyZ1R5cGVzW2ldXTtpZihjb252ZXJ0ZXIpe2lmKHN0YWNrPT09MClzdGFjaz1zdGFja1NhdmUoKTtjQXJnc1tpXT1jb252ZXJ0ZXIoYXJnc1tpXSl9ZWxzZXtjQXJnc1tpXT1hcmdzW2ldfX19dmFyIHJldD1mdW5jLmFwcGx5KG51bGwsY0FyZ3MpO2Z1bmN0aW9uIG9uRG9uZShyZXQpe2lmKHN0YWNrIT09MClzdGFja1Jlc3RvcmUoc3RhY2spO3JldHVybiBjb252ZXJ0UmV0dXJuVmFsdWUocmV0KX1yZXQ9b25Eb25lKHJldCk7cmV0dXJuIHJldH12YXIgd2FzbUltcG9ydHM9e1wiZlwiOl9YTUxfR2V0QnVmZmVyLFwiVlwiOl9YTUxfR2V0RXJyb3JDb2RlLFwiV1wiOl9YTUxfUGFyc2UsXCJtXCI6X1hNTF9QYXJzZUJ1ZmZlcixcIm9cIjpfWE1MX1BhcnNlckNyZWF0ZSxcImJcIjpfWE1MX1BhcnNlckZyZWUsXCJCXCI6X1hNTF9SZXN1bWVQYXJzZXIsXCJkXCI6X1hNTF9TZXRDaGFyYWN0ZXJEYXRhSGFuZGxlcixcImFcIjpfWE1MX1NldEVsZW1lbnRIYW5kbGVyLFwiblwiOl9YTUxfU2V0VXNlckRhdGEsXCJpXCI6X1hNTF9TdG9wUGFyc2VyLFwiTGFcIjpfX19kbHN5bSxcIkdhXCI6X19fc3lzY2FsbF9fbmV3c2VsZWN0LFwiS2FcIjpfX19zeXNjYWxsX2JpbmQsXCJKYVwiOl9fX3N5c2NhbGxfY29ubmVjdCxcIkNhXCI6X19fc3lzY2FsbF9mYWNjZXNzYXQsXCJjXCI6X19fc3lzY2FsbF9mY250bDY0LFwiQmFcIjpfX19zeXNjYWxsX2ZzdGF0NjQsXCJPXCI6X19fc3lzY2FsbF9mdHJ1bmNhdGU2NCxcIndhXCI6X19fc3lzY2FsbF9nZXRkZW50czY0LFwiRWFcIjpfX19zeXNjYWxsX2dldHBlZXJuYW1lLFwiRmFcIjpfX19zeXNjYWxsX2dldHNvY2tvcHQsXCJMXCI6X19fc3lzY2FsbF9pb2N0bCxcInlhXCI6X19fc3lzY2FsbF9sc3RhdDY0LFwieGFcIjpfX19zeXNjYWxsX21rZGlyYXQsXCJ6YVwiOl9fX3N5c2NhbGxfbmV3ZnN0YXRhdCxcIk1cIjpfX19zeXNjYWxsX29wZW5hdCxcIkhhXCI6X19fc3lzY2FsbF9yZWN2ZnJvbSxcInVhXCI6X19fc3lzY2FsbF9yZW5hbWVhdCxcIkdcIjpfX19zeXNjYWxsX3JtZGlyLFwiSWFcIjpfX19zeXNjYWxsX3NlbmR0byxcIklcIjpfX19zeXNjYWxsX3NvY2tldCxcIkFhXCI6X19fc3lzY2FsbF9zdGF0NjQsXCJIXCI6X19fc3lzY2FsbF91bmxpbmthdCxcIlNcIjpfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMsXCJlYVwiOl9fbG9jYWx0aW1lX2pzLFwiZmFcIjpfX3R6c2V0X2pzLFwialwiOl9hYm9ydCxcIk1hXCI6X2Rsb3BlbixcIm1hXCI6X2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2NyZWF0ZSxcIm5hXCI6X2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0cyxcImphXCI6X2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2xpc3RfZmlsZXMsXCJrYVwiOl9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9yZW1vdmUsXCJFXCI6X2R1Y2tkYl93ZWJfZnNfZmlsZV9jbG9zZSxcImhhXCI6X2R1Y2tkYl93ZWJfZnNfZmlsZV9leGlzdHMsXCJOXCI6X2R1Y2tkYl93ZWJfZnNfZmlsZV9nZXRfbGFzdF9tb2RpZmllZF90aW1lLFwiaWFcIjpfZHVja2RiX3dlYl9mc19maWxlX21vdmUsXCJwYVwiOl9kdWNrZGJfd2ViX2ZzX2ZpbGVfb3BlbixcInBcIjpfZHVja2RiX3dlYl9mc19maWxlX3JlYWQsXCJvYVwiOl9kdWNrZGJfd2ViX2ZzX2ZpbGVfdHJ1bmNhdGUsXCJGXCI6X2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZSxcInFhXCI6X2R1Y2tkYl93ZWJfZnNfZ2V0X2RlZmF1bHRfZGF0YV9wcm90b2NvbCxcImdhXCI6X2R1Y2tkYl93ZWJfZnNfZ2xvYixcIkRcIjpfZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmUsXCJyYVwiOl9kdWNrZGJfd2ViX3VkZl9zY2FsYXJfY2FsbCxcIkFcIjpfZW1zY3JpcHRlbl9kYXRlX25vdyxcIlhcIjpfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXCJnXCI6X2Vtc2NyaXB0ZW5fZ2V0X25vdyxcIk9hXCI6X2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcIlBhXCI6X2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsXCJsYVwiOl9lbnZpcm9uX2dldCxcInRhXCI6X2Vudmlyb25fc2l6ZXNfZ2V0LFwia1wiOl9mZF9jbG9zZSxcIk5hXCI6X2ZkX2Zkc3RhdF9nZXQsXCJRXCI6X2ZkX3ByZWFkLFwiUFwiOl9mZF9wd3JpdGUsXCJLXCI6X2ZkX3JlYWQsXCJSXCI6X2ZkX3NlZWssXCJ2YVwiOl9mZF9zeW5jLFwidlwiOl9mZF93cml0ZSxcIkpcIjpfZ2V0YWRkcmluZm8sXCJzYVwiOl9nZXRlbnRyb3B5LFwiRGFcIjpfZ2V0bmFtZWluZm8sXCJiYVwiOl9zdHJmdGltZV9sLFwiZVwiOl91Y252X2Nsb3NlXzY0LFwiWVwiOl91Y252X2NvbnZlcnRFeF82NCxcInVcIjpfdWNudl9vcGVuXzY0LFwiWlwiOl91Y252X3RvQWxnb3JpdGhtaWNfNjQsXCJDXCI6X3Vjc2RldF9jbG9zZV82NCxcImFhXCI6X3Vjc2RldF9kZXRlY3RfNjQsXCIkXCI6X3Vjc2RldF9nZXRDb25maWRlbmNlXzY0LFwiX1wiOl91Y3NkZXRfZ2V0TmFtZV82NCxcImRhXCI6X3Vjc2RldF9vcGVuXzY0LFwiY2FcIjpfdWNzZGV0X3NldFRleHRfNjQsXCJoXCI6X3VuekNsb3NlLFwidFwiOl91bnpDbG9zZUN1cnJlbnRGaWxlLFwieVwiOl91bnpHZXRDdXJyZW50RmlsZUluZm8sXCJxXCI6X3VuekdldEN1cnJlbnRGaWxlSW5mbzY0LFwiVVwiOl91bnpHZXRHbG9iYWxJbmZvLFwielwiOl91bnpHb1RvRmlyc3RGaWxlLFwieFwiOl91bnpHb1RvTmV4dEZpbGUsXCJzXCI6X3VuekxvY2F0ZUZpbGUsXCJ3XCI6X3Vuek9wZW4sXCJUXCI6X3Vuek9wZW4yLFwiclwiOl91bnpPcGVuQ3VycmVudEZpbGUsXCJsXCI6X3VuelJlYWRDdXJyZW50RmlsZX07dmFyIGFzbT1jcmVhdGVXYXNtKCk7dmFyIF9fX3dhc21fY2FsbF9jdG9ycz1mdW5jdGlvbigpe3JldHVybihfX193YXNtX2NhbGxfY3RvcnM9TW9kdWxlW1wiYXNtXCJdW1wiUmFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9tYWluPU1vZHVsZVtcIl9tYWluXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9tYWluPU1vZHVsZVtcIl9tYWluXCJdPU1vZHVsZVtcImFzbVwiXVtcIlNhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIlVhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJWYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZmFpbF93aXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZhaWxfd2l0aFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mYWlsX3dpdGg9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmFpbF93aXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIldhXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9yZXNldD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9yZXNldD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJYYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfY29ubmVjdD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jb25uZWN0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2Nvbm5lY3Q9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29ubmVjdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJZYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZGlzY29ubmVjdD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9kaXNjb25uZWN0XCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3Q9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZGlzY29ubmVjdFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJaYVwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIl09TW9kdWxlW1wiYXNtXCJdW1wiX2FcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mbHVzaF9maWxlPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVcIl09TW9kdWxlW1wiYXNtXCJdW1wiJGFcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX29wZW49TW9kdWxlW1wiX2R1Y2tkYl93ZWJfb3BlblwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9vcGVuPU1vZHVsZVtcIl9kdWNrZGJfd2ViX29wZW5cIl09TW9kdWxlW1wiYXNtXCJdW1wiYWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCJdPU1vZHVsZVtcImFzbVwiXVtcImJiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0cz1Nb2R1bGVbXCJfZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHNcIl09TW9kdWxlW1wiYXNtXCJdW1wiY2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCJdPU1vZHVsZVtcImFzbVwiXVtcImRiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVcIl09TW9kdWxlW1wiYXNtXCJdW1wiZWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlc1wiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXNcIl09TW9kdWxlW1wiYXNtXCJdW1wiZmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvcz1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nbG9iX2ZpbGVfaW5mb3NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvc1wiXT1Nb2R1bGVbXCJhc21cIl1bXCJnYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWQ9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJoYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X25hbWU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCJdPU1vZHVsZVtcImFzbVwiXVtcImliXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJqYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXI9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXJcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXI9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXJcIl09TW9kdWxlW1wiYXNtXCJdW1wia2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXI9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlclwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXJcIl09TW9kdWxlW1wiYXNtXCJdW1wibGJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIm1iXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9nZXRfdmVyc2lvbj1Nb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9nZXRfdmVyc2lvbj1Nb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXT1Nb2R1bGVbXCJhc21cIl1bXCJuYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3M9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3M9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIl09TW9kdWxlW1wiYXNtXCJdW1wib2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3Rva2VuaXplPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3Rva2VuaXplXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX3Rva2VuaXplPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3Rva2VuaXplXCJdPU1vZHVsZVtcImFzbVwiXVtcInBiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJxYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX2NyZWF0ZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wcmVwYXJlZF9jcmVhdGU9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCJdPU1vZHVsZVtcImFzbVwiXVtcInJiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJzYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3J1blwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wcmVwYXJlZF9ydW49TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCJdPU1vZHVsZVtcImFzbVwiXVtcInRiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmRcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCJdPU1vZHVsZVtcImFzbVwiXVtcInViXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9xdWVyeV9ydW49TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfcnVuXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX3F1ZXJ5X3J1bj1Nb2R1bGVbXCJfZHVja2RiX3dlYl9xdWVyeV9ydW5cIl09TW9kdWxlW1wiYXNtXCJdW1widmJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnQ9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0PU1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnRcIl09TW9kdWxlW1wiYXNtXCJdW1wid2JcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3BvbGxcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJ4YlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWw9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWw9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIl09TW9kdWxlW1wiYXNtXCJdW1wieWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHM9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0c1wiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHNcIl09TW9kdWxlW1wiYXNtXCJdW1wiemJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07dmFyIF9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCJdPWZ1bmN0aW9uKCl7cmV0dXJuKF9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCJdPU1vZHVsZVtcImFzbVwiXVtcIkFiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW1cIl09ZnVuY3Rpb24oKXtyZXR1cm4oX2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbT1Nb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCJdPU1vZHVsZVtcImFzbVwiXVtcIkJiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aD1Nb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXT1Nb2R1bGVbXCJhc21cIl1bXCJDYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoPU1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aFwiXT1mdW5jdGlvbigpe3JldHVybihfZHVja2RiX3dlYl9pbnNlcnRfanNvbl9mcm9tX3BhdGg9TW9kdWxlW1wiX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCJdPU1vZHVsZVtcImFzbVwiXVtcIkRiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfX19lcnJub19sb2NhdGlvbj1mdW5jdGlvbigpe3JldHVybihfX19lcnJub19sb2NhdGlvbj1Nb2R1bGVbXCJhc21cIl1bXCJfX2Vycm5vX2xvY2F0aW9uXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfaHRvbmw9ZnVuY3Rpb24oKXtyZXR1cm4oX2h0b25sPU1vZHVsZVtcImFzbVwiXVtcIkViXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfaHRvbnM9ZnVuY3Rpb24oKXtyZXR1cm4oX2h0b25zPU1vZHVsZVtcImFzbVwiXVtcIkZiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbnRvaHM9ZnVuY3Rpb24oKXtyZXR1cm4oX250b2hzPU1vZHVsZVtcImFzbVwiXVtcIkdiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfbWFsbG9jPU1vZHVsZVtcIl9tYWxsb2NcIl09ZnVuY3Rpb24oKXtyZXR1cm4oX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPU1vZHVsZVtcImFzbVwiXVtcIkhiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBfZnJlZT1Nb2R1bGVbXCJfZnJlZVwiXT1mdW5jdGlvbigpe3JldHVybihfZnJlZT1Nb2R1bGVbXCJfZnJlZVwiXT1Nb2R1bGVbXCJhc21cIl1bXCJJYlwiXSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgX19fdHJhcD1mdW5jdGlvbigpe3JldHVybihfX190cmFwPU1vZHVsZVtcImFzbVwiXVtcIkpiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oc3RhY2tTYXZlPU1vZHVsZVtcImFzbVwiXVtcIktiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja1Jlc3RvcmU9ZnVuY3Rpb24oKXtyZXR1cm4oc3RhY2tSZXN0b3JlPU1vZHVsZVtcImFzbVwiXVtcIkxiXCJdKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBzdGFja0FsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKHN0YWNrQWxsb2M9TW9kdWxlW1wiYXNtXCJdW1wiTWJcIl0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX07TW9kdWxlW1wic3RhY2tBbGxvY1wiXT1zdGFja0FsbG9jO01vZHVsZVtcInN0YWNrU2F2ZVwiXT1zdGFja1NhdmU7TW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdPXN0YWNrUmVzdG9yZTtNb2R1bGVbXCJjY2FsbFwiXT1jY2FsbDt2YXIgY2FsbGVkUnVuO2RlcGVuZGVuY2llc0Z1bGZpbGxlZD1mdW5jdGlvbiBydW5DYWxsZXIoKXtpZighY2FsbGVkUnVuKXJ1bigpO2lmKCFjYWxsZWRSdW4pZGVwZW5kZW5jaWVzRnVsZmlsbGVkPXJ1bkNhbGxlcn07ZnVuY3Rpb24gY2FsbE1haW4oKXt2YXIgZW50cnlGdW5jdGlvbj1fbWFpbjt2YXIgYXJnYz0wO3ZhciBhcmd2PTA7dHJ5e3ZhciByZXQ9ZW50cnlGdW5jdGlvbihhcmdjLGFyZ3YpO2V4aXRKUyhyZXQsdHJ1ZSk7cmV0dXJuIHJldH1jYXRjaChlKXtyZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGUpfX1mdW5jdGlvbiBydW4oKXtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59ZnVuY3Rpb24gZG9SdW4oKXtpZihjYWxsZWRSdW4pcmV0dXJuO2NhbGxlZFJ1bj10cnVlO01vZHVsZVtcImNhbGxlZFJ1blwiXT10cnVlO2lmKEFCT1JUKXJldHVybjtpbml0UnVudGltZSgpO3ByZU1haW4oKTtyZWFkeVByb21pc2VSZXNvbHZlKE1vZHVsZSk7aWYoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0oKTtpZihzaG91bGRSdW5Ob3cpY2FsbE1haW4oKTtwb3N0UnVuKCl9aWYoTW9kdWxlW1wic2V0U3RhdHVzXCJdKXtNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiXCIpfSwxKTtkb1J1bigpfSwxKX1lbHNle2RvUnVuKCl9fWlmKE1vZHVsZVtcInByZUluaXRcIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVJbml0XCJdPT1cImZ1bmN0aW9uXCIpTW9kdWxlW1wicHJlSW5pdFwiXT1bTW9kdWxlW1wicHJlSW5pdFwiXV07d2hpbGUoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGg+MCl7TW9kdWxlW1wicHJlSW5pdFwiXS5wb3AoKSgpfX12YXIgc2hvdWxkUnVuTm93PXRydWU7aWYoTW9kdWxlW1wibm9Jbml0aWFsUnVuXCJdKXNob3VsZFJ1bk5vdz1mYWxzZTtydW4oKTtcblxuXG4gIHJldHVybiBEdWNrREIucmVhZHlcbn1cblxuKTtcbn0pKCk7XG5pZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuICBtb2R1bGUuZXhwb3J0cyA9IER1Y2tEQjtcbmVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSlcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbigpIHsgcmV0dXJuIER1Y2tEQjsgfSk7XG5lbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG4gIGV4cG9ydHNbXCJEdWNrREJcIl0gPSBEdWNrREI7XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmtlcjsiLCAiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gIHZhciBfLCBkb25lID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gIGRvbmUgPSB0cnVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZTtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKGVudi5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHZhciByZWMgPSBlbnYuc3RhY2sucG9wKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX19leHBvcnRTdGFyLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxuICBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSxcbiAgX19kaXNwb3NlUmVzb3VyY2VzLFxufTtcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJleHBvcnQgY29uc3QgU0laRU9GX1NIT1JUID0gMjtcbmV4cG9ydCBjb25zdCBTSVpFT0ZfSU5UID0gNDtcbmV4cG9ydCBjb25zdCBGSUxFX0lERU5USUZJRVJfTEVOR1RIID0gNDtcbmV4cG9ydCBjb25zdCBTSVpFX1BSRUZJWF9MRU5HVEggPSA0O1xuIiwgImV4cG9ydCBjb25zdCBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xuZXhwb3J0IGNvbnN0IGZsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KGludDMyLmJ1ZmZlcik7XG5leHBvcnQgY29uc3QgZmxvYXQ2NCA9IG5ldyBGbG9hdDY0QXJyYXkoaW50MzIuYnVmZmVyKTtcbmV4cG9ydCBjb25zdCBpc0xpdHRsZUVuZGlhbiA9IG5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwgMF0pLmJ1ZmZlcilbMF0gPT09IDE7XG4iLCAiZXhwb3J0IHZhciBFbmNvZGluZztcbihmdW5jdGlvbiAoRW5jb2RpbmcpIHtcbiAgICBFbmNvZGluZ1tFbmNvZGluZ1tcIlVURjhfQllURVNcIl0gPSAxXSA9IFwiVVRGOF9CWVRFU1wiO1xuICAgIEVuY29kaW5nW0VuY29kaW5nW1wiVVRGMTZfU1RSSU5HXCJdID0gMl0gPSBcIlVURjE2X1NUUklOR1wiO1xufSkoRW5jb2RpbmcgfHwgKEVuY29kaW5nID0ge30pKTtcbiIsICJpbXBvcnQgeyBGSUxFX0lERU5USUZJRVJfTEVOR1RILCBTSVpFT0ZfSU5UIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBpbnQzMiwgaXNMaXR0bGVFbmRpYW4sIGZsb2F0MzIsIGZsb2F0NjQgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgRW5jb2RpbmcgfSBmcm9tIFwiLi9lbmNvZGluZy5qc1wiO1xuZXhwb3J0IGNsYXNzIEJ5dGVCdWZmZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBhcnJheSBvZiBieXRlcyAoYFVpbnQ4QXJyYXlgKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzXykge1xuICAgICAgICB0aGlzLmJ5dGVzXyA9IGJ5dGVzXztcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xuICAgICAgICB0aGlzLnRleHRfZGVjb2Rlcl8gPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBhbGxvY2F0ZSBhIG5ldyBCeXRlQnVmZmVyIHdpdGggYSBnaXZlbiBzaXplLlxuICAgICAqL1xuICAgIHN0YXRpYyBhbGxvY2F0ZShieXRlX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ5dGVfc2l6ZSkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuZGVybHlpbmcgYFVpbnQ4QXJyYXlgLlxuICAgICAqL1xuICAgIGJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc187XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnVmZmVyJ3MgcG9zaXRpb24uXG4gICAgICovXG4gICAgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uXyA9IHBvc2l0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ1ZmZlcidzIGNhcGFjaXR5LlxuICAgICAqL1xuICAgIGNhcGFjaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc18ubGVuZ3RoO1xuICAgIH1cbiAgICByZWFkSW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQ4KG9mZnNldCkgPDwgMjQgPj4gMjQ7XG4gICAgfVxuICAgIHJlYWRVaW50OChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfW29mZnNldF07XG4gICAgfVxuICAgIHJlYWRJbnQxNihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVpbnQxNihvZmZzZXQpIDw8IDE2ID4+IDE2O1xuICAgIH1cbiAgICByZWFkVWludDE2KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDg7XG4gICAgfVxuICAgIHJlYWRJbnQzMihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfW29mZnNldF0gfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA8PCA4IHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMl0gPDwgMTYgfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAzXSA8PCAyNDtcbiAgICB9XG4gICAgcmVhZFVpbnQzMihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZEludDMyKG9mZnNldCkgPj4+IDA7XG4gICAgfVxuICAgIHJlYWRJbnQ2NChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oNjQsIEJpZ0ludCh0aGlzLnJlYWRVaW50MzIob2Zmc2V0KSkgKyAoQmlnSW50KHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSkgPDwgQmlnSW50KDMyKSkpO1xuICAgIH1cbiAgICByZWFkVWludDY0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gQmlnSW50LmFzVWludE4oNjQsIEJpZ0ludCh0aGlzLnJlYWRVaW50MzIob2Zmc2V0KSkgKyAoQmlnSW50KHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSkgPDwgQmlnSW50KDMyKSkpO1xuICAgIH1cbiAgICByZWFkRmxvYXQzMihvZmZzZXQpIHtcbiAgICAgICAgaW50MzJbMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICByZXR1cm4gZmxvYXQzMlswXTtcbiAgICB9XG4gICAgcmVhZEZsb2F0NjQob2Zmc2V0KSB7XG4gICAgICAgIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMCA6IDFdID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICAgICAgaW50MzJbaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIGZsb2F0NjRbMF07XG4gICAgfVxuICAgIHdyaXRlSW50OChvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgd3JpdGVVaW50OChvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgd3JpdGVJbnQxNihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgIH1cbiAgICB3cml0ZVVpbnQxNihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xuICAgIH1cbiAgICB3cml0ZUludDMyKG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XG4gICAgfVxuICAgIHdyaXRlVWludDMyKG9mZnNldCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAxXSA9IHZhbHVlID4+IDg7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDJdID0gdmFsdWUgPj4gMTY7XG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XG4gICAgfVxuICAgIHdyaXRlSW50NjQob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUpKSk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUgPj4gQmlnSW50KDMyKSkpKTtcbiAgICB9XG4gICAgd3JpdGVVaW50NjQob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgTnVtYmVyKEJpZ0ludC5hc1VpbnROKDMyLCB2YWx1ZSkpKTtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQzMihvZmZzZXQgKyA0LCBOdW1iZXIoQmlnSW50LmFzVWludE4oMzIsIHZhbHVlID4+IEJpZ0ludCgzMikpKSk7XG4gICAgfVxuICAgIHdyaXRlRmxvYXQzMihvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGZsb2F0MzJbMF0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgaW50MzJbMF0pO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0NjQob2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBmbG9hdDY0WzBdID0gdmFsdWU7XG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQsIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMCA6IDFdKTtcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCArIDQsIGludDMyW2lzTGl0dGxlRW5kaWFuID8gMSA6IDBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBmaWxlIGlkZW50aWZpZXIuICAgQmVoYXZpb3IgaXMgdW5kZWZpbmVkIGZvciBGbGF0QnVmZmVycyB3aG9zZVxuICAgICAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXG4gICAgICogc3RhcnQgb2YgYSB0aGUgcm9vdCB2dGFibGUpLlxuICAgICAqL1xuICAgIGdldEJ1ZmZlcklkZW50aWZpZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVzXy5sZW5ndGggPCB0aGlzLnBvc2l0aW9uXyArIFNJWkVPRl9JTlQgK1xuICAgICAgICAgICAgRklMRV9JREVOVElGSUVSX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uXyArIFNJWkVPRl9JTlQgKyBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9vayB1cCBhIGZpZWxkIGluIHRoZSB2dGFibGUsIHJldHVybiBhbiBvZmZzZXQgaW50byB0aGUgb2JqZWN0LCBvciAwIGlmIHRoZVxuICAgICAqIGZpZWxkIGlzIG5vdCBwcmVzZW50LlxuICAgICAqL1xuICAgIF9fb2Zmc2V0KGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xuICAgICAgICBjb25zdCB2dGFibGUgPSBiYl9wb3MgLSB0aGlzLnJlYWRJbnQzMihiYl9wb3MpO1xuICAgICAgICByZXR1cm4gdnRhYmxlX29mZnNldCA8IHRoaXMucmVhZEludDE2KHZ0YWJsZSkgPyB0aGlzLnJlYWRJbnQxNih2dGFibGUgKyB2dGFibGVfb2Zmc2V0KSA6IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYW55IFRhYmxlLWRlcml2ZWQgdHlwZSB0byBwb2ludCB0byB0aGUgdW5pb24gYXQgdGhlIGdpdmVuIG9mZnNldC5cbiAgICAgKi9cbiAgICBfX3VuaW9uKHQsIG9mZnNldCkge1xuICAgICAgICB0LmJiX3BvcyA9IG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XG4gICAgICAgIHQuYmIgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgSmF2YVNjcmlwdCBzdHJpbmcgZnJvbSBVVEYtOCBkYXRhIHN0b3JlZCBpbnNpZGUgdGhlIEZsYXRCdWZmZXIuXG4gICAgICogVGhpcyBhbGxvY2F0ZXMgYSBuZXcgc3RyaW5nIGFuZCBjb252ZXJ0cyB0byB3aWRlIGNoYXJzIHVwb24gZWFjaCBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiBUbyBhdm9pZCB0aGUgY29udmVyc2lvbiB0byBzdHJpbmcsIHBhc3MgRW5jb2RpbmcuVVRGOF9CWVRFUyBhcyB0aGVcbiAgICAgKiBcIm9wdGlvbmFsRW5jb2RpbmdcIiBhcmd1bWVudC4gVGhpcyBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nIGNvbnZlcnNpb24gd2hlblxuICAgICAqIHRoZSBkYXRhIHdpbGwganVzdCBiZSBwYWNrYWdlZCBiYWNrIHVwIGluIGFub3RoZXIgRmxhdEJ1ZmZlciBsYXRlciBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcGFyYW0gb3B0X2VuY29kaW5nIERlZmF1bHRzIHRvIFVURjE2X1NUUklOR1xuICAgICAqL1xuICAgIF9fc3RyaW5nKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XG4gICAgICAgIG9mZnNldCArPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gU0laRU9GX0lOVDtcbiAgICAgICAgY29uc3QgdXRmOGJ5dGVzID0gdGhpcy5ieXRlc18uc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICBpZiAob3B0X2VuY29kaW5nID09PSBFbmNvZGluZy5VVEY4X0JZVEVTKVxuICAgICAgICAgICAgcmV0dXJuIHV0ZjhieXRlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dF9kZWNvZGVyXy5kZWNvZGUodXRmOGJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHVuaW9ucyB0aGF0IGNhbiBjb250YWluIHN0cmluZyBhcyBpdHMgbWVtYmVyLCBpZiBhIFRhYmxlLWRlcml2ZWQgdHlwZSB0aGVuIGluaXRpYWxpemUgaXQsXG4gICAgICogaWYgYSBzdHJpbmcgdGhlbiByZXR1cm4gYSBuZXcgb25lXG4gICAgICpcbiAgICAgKiBXQVJOSU5HOiBzdHJpbmdzIGFyZSBpbW11dGFibGUgaW4gSlMgc28gd2UgY2FuJ3QgY2hhbmdlIHRoZSBzdHJpbmcgdGhhdCB0aGUgdXNlciBnYXZlIHVzLCB0aGlzXG4gICAgICogbWFrZXMgdGhlIGJlaGF2aW91ciBvZiBfX3VuaW9uX3dpdGhfc3RyaW5nIGRpZmZlcmVudCBjb21wYXJlZCB0byBfX3VuaW9uXG4gICAgICovXG4gICAgX191bmlvbl93aXRoX3N0cmluZyhvLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19zdHJpbmcob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX3VuaW9uKG8sIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSByZWxhdGl2ZSBvZmZzZXQgc3RvcmVkIGF0IFwib2Zmc2V0XCJcbiAgICAgKi9cbiAgICBfX2luZGlyZWN0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gb2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFydCBvZiBkYXRhIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBfX3ZlY3RvcihvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCkgKyBTSVpFT0ZfSU5UOyAvLyBkYXRhIHN0YXJ0cyBhZnRlciB0aGUgbGVuZ3RoXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yIHdob3NlIG9mZnNldCBpcyBzdG9yZWQgYXQgXCJvZmZzZXRcIiBpbiB0aGlzIG9iamVjdC5cbiAgICAgKi9cbiAgICBfX3ZlY3Rvcl9sZW4ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpKTtcbiAgICB9XG4gICAgX19oYXNfaWRlbnRpZmllcihpZGVudCkge1xuICAgICAgICBpZiAoaWRlbnQubGVuZ3RoICE9IEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcbiAgICAgICAgICAgICAgICBGSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlkZW50LmNoYXJDb2RlQXQoaSkgIT0gdGhpcy5yZWFkSW50OCh0aGlzLnBvc2l0aW9uKCkgKyBTSVpFT0ZfSU5UICsgaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGxpc3QgZm9yIG9iaiBhcGlcbiAgICAgKi9cbiAgICBjcmVhdGVTY2FsYXJMaXN0KGxpc3RBY2Nlc3NvciwgbGlzdExlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGxpc3RBY2Nlc3NvcihpKTtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIGZvciBnZW5lcmF0aW5nIGxpc3QgZm9yIG9iaiBhcGlcbiAgICAgKiBAcGFyYW0gbGlzdEFjY2Vzc29yIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBpbmRleCBhbmQgcmV0dXJuIGRhdGEgYXQgdGhhdCBpbmRleFxuICAgICAqIEBwYXJhbSBsaXN0TGVuZ3RoIGxpc3RMZW5ndGhcbiAgICAgKiBAcGFyYW0gcmVzIHJlc3VsdCBsaXN0XG4gICAgICovXG4gICAgY3JlYXRlT2JqTGlzdChsaXN0QWNjZXNzb3IsIGxpc3RMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0QWNjZXNzb3IoaSk7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2godmFsLnVucGFjaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBCeXRlQnVmZmVyIH0gZnJvbSBcIi4vYnl0ZS1idWZmZXIuanNcIjtcbmltcG9ydCB7IFNJWkVPRl9TSE9SVCwgU0laRV9QUkVGSVhfTEVOR1RILCBTSVpFT0ZfSU5ULCBGSUxFX0lERU5USUZJRVJfTEVOR1RIIH0gZnJvbSBcIi4vY29uc3RhbnRzLmpzXCI7XG5leHBvcnQgY2xhc3MgQnVpbGRlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRmxhdEJ1ZmZlckJ1aWxkZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0X2luaXRpYWxfc2l6ZSkge1xuICAgICAgICAvKiogTWluaW11bSBhbGlnbm1lbnQgZW5jb3VudGVyZWQgc28gZmFyLiAqL1xuICAgICAgICB0aGlzLm1pbmFsaWduID0gMTtcbiAgICAgICAgLyoqIFRoZSB2dGFibGUgZm9yIHRoZSBjdXJyZW50IHRhYmxlLiAqL1xuICAgICAgICB0aGlzLnZ0YWJsZSA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgYW1vdW50IG9mIGZpZWxkcyB3ZSdyZSBhY3R1YWxseSB1c2luZy4gKi9cbiAgICAgICAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcbiAgICAgICAgLyoqIFdoZXRoZXIgd2UgYXJlIGN1cnJlbnRseSBzZXJpYWxpemluZyBhIHRhYmxlLiAqL1xuICAgICAgICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBTdGFydGluZyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgc3RydWN0L3RhYmxlLiAqL1xuICAgICAgICB0aGlzLm9iamVjdF9zdGFydCA9IDA7XG4gICAgICAgIC8qKiBMaXN0IG9mIG9mZnNldHMgb2YgYWxsIHZ0YWJsZXMuICovXG4gICAgICAgIHRoaXMudnRhYmxlcyA9IFtdO1xuICAgICAgICAvKiogRm9yIHRoZSBjdXJyZW50IHZlY3RvciBiZWluZyBidWlsdC4gKi9cbiAgICAgICAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcbiAgICAgICAgLyoqIEZhbHNlIG9taXRzIGRlZmF1bHQgdmFsdWVzIGZyb20gdGhlIHNlcmlhbGl6ZWQgZGF0YSAqL1xuICAgICAgICB0aGlzLmZvcmNlX2RlZmF1bHRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyaW5nX21hcHMgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHRfZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBsZXQgaW5pdGlhbF9zaXplO1xuICAgICAgICBpZiAoIW9wdF9pbml0aWFsX3NpemUpIHtcbiAgICAgICAgICAgIGluaXRpYWxfc2l6ZSA9IDEwMjQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsX3NpemUgPSBvcHRfaW5pdGlhbF9zaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Qnl0ZUJ1ZmZlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmIgPSBCeXRlQnVmZmVyLmFsbG9jYXRlKGluaXRpYWxfc2l6ZSk7XG4gICAgICAgIHRoaXMuc3BhY2UgPSBpbml0aWFsX3NpemU7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmJiLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc3BhY2UgPSB0aGlzLmJiLmNhcGFjaXR5KCk7XG4gICAgICAgIHRoaXMubWluYWxpZ24gPSAxO1xuICAgICAgICB0aGlzLnZ0YWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMudnRhYmxlX2luX3VzZSA9IDA7XG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLnZ0YWJsZXMgPSBbXTtcbiAgICAgICAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gMDtcbiAgICAgICAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0cmluZ19tYXBzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gc2F2ZSBzcGFjZSwgZmllbGRzIHRoYXQgYXJlIHNldCB0byB0aGVpciBkZWZhdWx0IHZhbHVlXG4gICAgICogZG9uJ3QgZ2V0IHNlcmlhbGl6ZWQgaW50byB0aGUgYnVmZmVyLiBGb3JjaW5nIGRlZmF1bHRzIHByb3ZpZGVzIGFcbiAgICAgKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZURlZmF1bHRzIHRydWUgYWx3YXlzIHNlcmlhbGl6ZXMgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBmb3JjZURlZmF1bHRzKGZvcmNlRGVmYXVsdHMpIHtcbiAgICAgICAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZvcmNlRGVmYXVsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgQnl0ZUJ1ZmZlciByZXByZXNlbnRpbmcgdGhlIEZsYXRCdWZmZXIuIE9ubHkgY2FsbCB0aGlzIGFmdGVyIHlvdSd2ZVxuICAgICAqIGNhbGxlZCBmaW5pc2goKS4gVGhlIGFjdHVhbCBkYXRhIHN0YXJ0cyBhdCB0aGUgQnl0ZUJ1ZmZlcidzIGN1cnJlbnQgcG9zaXRpb24sXG4gICAgICogbm90IG5lY2Vzc2FyaWx5IGF0IDAuXG4gICAgICovXG4gICAgZGF0YUJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcbiAgICAgKiBjYWxsZWQgZmluaXNoKCkuXG4gICAgICovXG4gICAgYXNVaW50OEFycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYi5ieXRlcygpLnN1YmFycmF5KHRoaXMuYmIucG9zaXRpb24oKSwgdGhpcy5iYi5wb3NpdGlvbigpICsgdGhpcy5vZmZzZXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdG8gd3JpdGUgYW4gZWxlbWVudCBvZiBgc2l6ZWAgYWZ0ZXIgYGFkZGl0aW9uYWxfYnl0ZXNgIGhhdmUgYmVlblxuICAgICAqIHdyaXR0ZW4sIGUuZy4gaWYgeW91IHdyaXRlIGEgc3RyaW5nLCB5b3UgbmVlZCB0byBhbGlnbiBzdWNoIHRoZSBpbnQgbGVuZ3RoXG4gICAgICogZmllbGQgaXMgYWxpZ25lZCB0byA0IGJ5dGVzLCBhbmQgdGhlIHN0cmluZyBkYXRhIGZvbGxvd3MgaXQgZGlyZWN0bHkuIElmIGFsbFxuICAgICAqIHlvdSBuZWVkIHRvIGRvIGlzIGFsaWdubWVudCwgYGFkZGl0aW9uYWxfYnl0ZXNgIHdpbGwgYmUgMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzaXplIFRoaXMgaXMgdGhlIG9mIHRoZSBuZXcgZWxlbWVudCB0byB3cml0ZVxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsX2J5dGVzIFRoZSBwYWRkaW5nIHNpemVcbiAgICAgKi9cbiAgICBwcmVwKHNpemUsIGFkZGl0aW9uYWxfYnl0ZXMpIHtcbiAgICAgICAgLy8gVHJhY2sgdGhlIGJpZ2dlc3QgdGhpbmcgd2UndmUgZXZlciBhbGlnbmVkIHRvLlxuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMubWluYWxpZ24pIHtcbiAgICAgICAgICAgIHRoaXMubWluYWxpZ24gPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbmQgdGhlIGFtb3VudCBvZiBhbGlnbm1lbnQgbmVlZGVkIHN1Y2ggdGhhdCBgc2l6ZWAgaXMgcHJvcGVybHlcbiAgICAgICAgLy8gYWxpZ25lZCBhZnRlciBgYWRkaXRpb25hbF9ieXRlc2BcbiAgICAgICAgY29uc3QgYWxpZ25fc2l6ZSA9ICgofih0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlICsgYWRkaXRpb25hbF9ieXRlcykpICsgMSkgJiAoc2l6ZSAtIDEpO1xuICAgICAgICAvLyBSZWFsbG9jYXRlIHRoZSBidWZmZXIgaWYgbmVlZGVkLlxuICAgICAgICB3aGlsZSAodGhpcy5zcGFjZSA8IGFsaWduX3NpemUgKyBzaXplICsgYWRkaXRpb25hbF9ieXRlcykge1xuICAgICAgICAgICAgY29uc3Qgb2xkX2J1Zl9zaXplID0gdGhpcy5iYi5jYXBhY2l0eSgpO1xuICAgICAgICAgICAgdGhpcy5iYiA9IEJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYik7XG4gICAgICAgICAgICB0aGlzLnNwYWNlICs9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIG9sZF9idWZfc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZChhbGlnbl9zaXplKTtcbiAgICB9XG4gICAgcGFkKGJ5dGVfc2l6ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJiLndyaXRlSW50OCgtLXRoaXMuc3BhY2UsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlSW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJiLndyaXRlSW50OCh0aGlzLnNwYWNlIC09IDEsIHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVJbnQxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLmJiLndyaXRlSW50MTYodGhpcy5zcGFjZSAtPSAyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHdyaXRlSW50MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuc3BhY2UgLT0gNCwgdmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUludDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmIud3JpdGVJbnQ2NCh0aGlzLnNwYWNlIC09IDgsIHZhbHVlKTtcbiAgICB9XG4gICAgd3JpdGVGbG9hdDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmIud3JpdGVGbG9hdDMyKHRoaXMuc3BhY2UgLT0gNCwgdmFsdWUpO1xuICAgIH1cbiAgICB3cml0ZUZsb2F0NjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYi53cml0ZUZsb2F0NjQodGhpcy5zcGFjZSAtPSA4LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBgaW50OGAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgYWRkSW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZXAoMSwgMCk7XG4gICAgICAgIHRoaXMud3JpdGVJbnQ4KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGBpbnQxNmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50MTZgIHRvIGFkZCB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFkZEludDE2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlcCgyLCAwKTtcbiAgICAgICAgdGhpcy53cml0ZUludDE2KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGBpbnQzMmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50MzJgIHRvIGFkZCB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFkZEludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlcCg0LCAwKTtcbiAgICAgICAgdGhpcy53cml0ZUludDMyKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGBpbnQ2NGAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50NjRgIHRvIGFkZCB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFkZEludDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlcCg4LCAwKTtcbiAgICAgICAgdGhpcy53cml0ZUludDY0KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgYGZsb2F0MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGZsb2F0MzJgIHRvIGFkZCB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIGFkZEZsb2F0MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVwKDQsIDApO1xuICAgICAgICB0aGlzLndyaXRlRmxvYXQzMih2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGBmbG9hdDY0YCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBmbG9hdDY0YCB0byBhZGQgdGhlIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBhZGRGbG9hdDY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMucHJlcCg4LCAwKTtcbiAgICAgICAgdGhpcy53cml0ZUZsb2F0NjQodmFsdWUpO1xuICAgIH1cbiAgICBhZGRGaWVsZEludDgodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmllbGRJbnQxNih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmllbGRJbnQzMih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmllbGRJbnQ2NCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSW50NjQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEZpZWxkRmxvYXQzMih2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRGbG9hdDMyKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRGaWVsZEZsb2F0NjQodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRmxvYXQ2NCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRmllbGRPZmZzZXQodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkT2Zmc2V0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJ1Y3RzIGFyZSBzdG9yZWQgaW5saW5lLCBzbyBub3RoaW5nIGFkZGl0aW9uYWwgaXMgYmVpbmcgYWRkZWQuIGBkYCBpcyBhbHdheXMgMC5cbiAgICAgKi9cbiAgICBhZGRGaWVsZFN0cnVjdCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubmVzdGVkKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJ1Y3R1cmVzIGFyZSBhbHdheXMgc3RvcmVkIGlubGluZSwgdGhleSBuZWVkIHRvIGJlIGNyZWF0ZWQgcmlnaHRcbiAgICAgKiB3aGVyZSB0aGV5J3JlIHVzZWQuICBZb3UnbGwgZ2V0IHRoaXMgYXNzZXJ0aW9uIGZhaWx1cmUgaWYgeW91XG4gICAgICogY3JlYXRlZCBpdCBlbHNld2hlcmUuXG4gICAgICovXG4gICAgbmVzdGVkKG9iaikge1xuICAgICAgICBpZiAob2JqICE9IHRoaXMub2Zmc2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3VsZCBub3QgYmUgY3JlYXRpbmcgYW55IG90aGVyIG9iamVjdCwgc3RyaW5nIG9yIHZlY3RvclxuICAgICAqIHdoaWxlIGFuIG9iamVjdCBpcyBiZWluZyBjb25zdHJ1Y3RlZFxuICAgICAqL1xuICAgIG5vdE5lc3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZXN0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgdnRhYmxlIGF0IGB2b2Zmc2V0YCB0byB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgYnVmZmVyLlxuICAgICAqL1xuICAgIHNsb3Qodm9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy52dGFibGUgIT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnZ0YWJsZVt2b2Zmc2V0XSA9IHRoaXMub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIE9mZnNldCByZWxhdGl2ZSB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gICAgICovXG4gICAgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG91YmxlcyB0aGUgc2l6ZSBvZiB0aGUgYmFja2luZyBCeXRlQnVmZmVyIGFuZCBjb3BpZXMgdGhlIG9sZCBkYXRhIHRvd2FyZHNcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmIgVGhlIGN1cnJlbnQgYnVmZmVyIHdpdGggdGhlIGV4aXN0aW5nIGRhdGFcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcbiAgICAgKiB0byBpdC4gVGhlIGRhdGEgaXMgbG9jYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXG4gICAgICpcbiAgICAgKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcbiAgICAgKiBpdCBhIHVpbnQ4QXJyYXkgd2UgbmVlZCB0byBzdXBwcmVzcyB0aGUgdHlwZSBjaGVjazpcbiAgICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAgICovXG4gICAgc3RhdGljIGdyb3dCeXRlQnVmZmVyKGJiKSB7XG4gICAgICAgIGNvbnN0IG9sZF9idWZfc2l6ZSA9IGJiLmNhcGFjaXR5KCk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBncm93IGJleW9uZCB3aGF0IGZpdHMgaW4gYW4gaW50LlxuICAgICAgICBpZiAob2xkX2J1Zl9zaXplICYgMHhDMDAwMDAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogY2Fubm90IGdyb3cgYnVmZmVyIGJleW9uZCAyIGdpZ2FieXRlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdfYnVmX3NpemUgPSBvbGRfYnVmX3NpemUgPDwgMTtcbiAgICAgICAgY29uc3QgbmJiID0gQnl0ZUJ1ZmZlci5hbGxvY2F0ZShuZXdfYnVmX3NpemUpO1xuICAgICAgICBuYmIuc2V0UG9zaXRpb24obmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcbiAgICAgICAgbmJiLmJ5dGVzKCkuc2V0KGJiLmJ5dGVzKCksIG5ld19idWZfc2l6ZSAtIG9sZF9idWZfc2l6ZSk7XG4gICAgICAgIHJldHVybiBuYmI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgb24gb2Zmc2V0LCByZWxhdGl2ZSB0byB3aGVyZSBpdCB3aWxsIGJlIHdyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZE9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5wcmVwKFNJWkVPRl9JTlQsIDApOyAvLyBFbnN1cmUgYWxpZ25tZW50IGlzIGFscmVhZHkgZG9uZS5cbiAgICAgICAgdGhpcy53cml0ZUludDMyKHRoaXMub2Zmc2V0KCkgLSBvZmZzZXQgKyBTSVpFT0ZfSU5UKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgZW5jb2RpbmcgYSBuZXcgb2JqZWN0IGluIHRoZSBidWZmZXIuICBVc2VycyB3aWxsIG5vdCB1c3VhbGx5IG5lZWQgdG9cbiAgICAgKiBjYWxsIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGdlbmVyYXRlIGhlbHBlciBtZXRob2RzXG4gICAgICogdGhhdCBjYWxsIHRoaXMgbWV0aG9kIGludGVybmFsbHkuXG4gICAgICovXG4gICAgc3RhcnRPYmplY3QobnVtZmllbGRzKSB7XG4gICAgICAgIHRoaXMubm90TmVzdGVkKCk7XG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZ0YWJsZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudnRhYmxlX2luX3VzZSA9IG51bWZpZWxkcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xuICAgICAgICAgICAgdGhpcy52dGFibGVbaV0gPSAwOyAvLyBUaGlzIHdpbGwgcHVzaCBhZGRpdGlvbmFsIGVsZW1lbnRzIGFzIG5lZWRlZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9iamVjdF9zdGFydCA9IHRoaXMub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmlzaCBvZmYgd3JpdGluZyB0aGUgb2JqZWN0IHRoYXQgaXMgdW5kZXIgY29uc3RydWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCB0byB0aGUgb2JqZWN0IGluc2lkZSBgZGF0YUJ1ZmZlcmBcbiAgICAgKi9cbiAgICBlbmRPYmplY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsIHx8ICF0aGlzLmlzTmVzdGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBlbmRPYmplY3QgY2FsbGVkIHdpdGhvdXQgc3RhcnRPYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEludDMyKDApO1xuICAgICAgICBjb25zdCB2dGFibGVsb2MgPSB0aGlzLm9mZnNldCgpO1xuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIHplcm9lcy5cbiAgICAgICAgbGV0IGkgPSB0aGlzLnZ0YWJsZV9pbl91c2UgLSAxO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgZm9yICg7IGkgPj0gMCAmJiB0aGlzLnZ0YWJsZVtpXSA9PSAwOyBpLS0pIHsgfVxuICAgICAgICBjb25zdCB0cmltbWVkX3NpemUgPSBpICsgMTtcbiAgICAgICAgLy8gV3JpdGUgb3V0IHRoZSBjdXJyZW50IHZ0YWJsZS5cbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuYWRkSW50MTYodGhpcy52dGFibGVbaV0gIT0gMCA/IHZ0YWJsZWxvYyAtIHRoaXMudnRhYmxlW2ldIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhbmRhcmRfZmllbGRzID0gMjsgLy8gVGhlIGZpZWxkcyBiZWxvdzpcbiAgICAgICAgdGhpcy5hZGRJbnQxNih2dGFibGVsb2MgLSB0aGlzLm9iamVjdF9zdGFydCk7XG4gICAgICAgIGNvbnN0IGxlbiA9ICh0cmltbWVkX3NpemUgKyBzdGFuZGFyZF9maWVsZHMpICogU0laRU9GX1NIT1JUO1xuICAgICAgICB0aGlzLmFkZEludDE2KGxlbik7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYW4gZXhpc3RpbmcgdnRhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgY3VycmVudCBvbmUuXG4gICAgICAgIGxldCBleGlzdGluZ192dGFibGUgPSAwO1xuICAgICAgICBjb25zdCB2dDEgPSB0aGlzLnNwYWNlO1xuICAgICAgICBvdXRlcl9sb29wOiBmb3IgKGkgPSAwOyBpIDwgdGhpcy52dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2dDIgPSB0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnZ0YWJsZXNbaV07XG4gICAgICAgICAgICBpZiAobGVuID09IHRoaXMuYmIucmVhZEludDE2KHZ0MikpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gU0laRU9GX1NIT1JUOyBqIDwgbGVuOyBqICs9IFNJWkVPRl9TSE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iYi5yZWFkSW50MTYodnQxICsgaikgIT0gdGhpcy5iYi5yZWFkSW50MTYodnQyICsgaikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyX2xvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdfdnRhYmxlID0gdGhpcy52dGFibGVzW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleGlzdGluZ192dGFibGUpIHtcbiAgICAgICAgICAgIC8vIEZvdW5kIGEgbWF0Y2g6XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxuICAgICAgICAgICAgdGhpcy5zcGFjZSA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHZ0YWJsZWxvYztcbiAgICAgICAgICAgIC8vIFBvaW50IHRhYmxlIHRvIGV4aXN0aW5nIHZ0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLCBleGlzdGluZ192dGFibGUgLSB2dGFibGVsb2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbWF0Y2g6XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IHZ0YWJsZSB0byB0aGUgbGlzdCBvZiB2dGFibGVzLlxuICAgICAgICAgICAgdGhpcy52dGFibGVzLnB1c2godGhpcy5vZmZzZXQoKSk7XG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBjdXJyZW50IHZ0YWJsZS5cbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB2dGFibGVsb2MsIHRoaXMub2Zmc2V0KCkgLSB2dGFibGVsb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHZ0YWJsZWxvYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluYWxpemUgYSBidWZmZXIsIHBvaXRpbmcgdG8gdGhlIGdpdmVuIGByb290X3RhYmxlYC5cbiAgICAgKi9cbiAgICBmaW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgb3B0X3NpemVfcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IHNpemVfcHJlZml4ID0gb3B0X3NpemVfcHJlZml4ID8gU0laRV9QUkVGSVhfTEVOR1RIIDogMDtcbiAgICAgICAgaWYgKG9wdF9maWxlX2lkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVfaWRlbnRpZmllciA9IG9wdF9maWxlX2lkZW50aWZpZXI7XG4gICAgICAgICAgICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgU0laRU9GX0lOVCArXG4gICAgICAgICAgICAgICAgRklMRV9JREVOVElGSUVSX0xFTkdUSCArIHNpemVfcHJlZml4KTtcbiAgICAgICAgICAgIGlmIChmaWxlX2lkZW50aWZpZXIubGVuZ3RoICE9IEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWxlIGlkZW50aWZpZXIgbXVzdCBiZSBsZW5ndGggJyArXG4gICAgICAgICAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IEZJTEVfSURFTlRJRklFUl9MRU5HVEggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJbnQ4KGZpbGVfaWRlbnRpZmllci5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXAodGhpcy5taW5hbGlnbiwgU0laRU9GX0lOVCArIHNpemVfcHJlZml4KTtcbiAgICAgICAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XG4gICAgICAgIGlmIChzaXplX3ByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5hZGRJbnQzMih0aGlzLmJiLmNhcGFjaXR5KCkgLSB0aGlzLnNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5hbGl6ZSBhIHNpemUgcHJlZml4ZWQgYnVmZmVyLCBwb2ludGluZyB0byB0aGUgZ2l2ZW4gYHJvb3RfdGFibGVgLlxuICAgICAqL1xuICAgIGZpbmlzaFNpemVQcmVmaXhlZChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XG4gICAgICAgIHRoaXMuZmluaXNoKHJvb3RfdGFibGUsIG9wdF9maWxlX2lkZW50aWZpZXIsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGNoZWNrcyBhIHJlcXVpcmVkIGZpZWxkIGhhcyBiZWVuIHNldCBpbiBhIGdpdmVuIHRhYmxlIHRoYXQgaGFzXG4gICAgICoganVzdCBiZWVuIGNvbnN0cnVjdGVkLlxuICAgICAqL1xuICAgIHJlcXVpcmVkRmllbGQodGFibGUsIGZpZWxkKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlX3N0YXJ0ID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGFibGU7XG4gICAgICAgIGNvbnN0IHZ0YWJsZV9zdGFydCA9IHRhYmxlX3N0YXJ0IC0gdGhpcy5iYi5yZWFkSW50MzIodGFibGVfc3RhcnQpO1xuICAgICAgICBjb25zdCBvayA9IGZpZWxkIDwgdGhpcy5iYi5yZWFkSW50MTYodnRhYmxlX3N0YXJ0KSAmJlxuICAgICAgICAgICAgdGhpcy5iYi5yZWFkSW50MTYodnRhYmxlX3N0YXJ0ICsgZmllbGQpICE9IDA7XG4gICAgICAgIC8vIElmIHRoaXMgZmFpbHMsIHRoZSBjYWxsZXIgd2lsbCBzaG93IHdoYXQgZmllbGQgbmVlZHMgdG8gYmUgc2V0LlxuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWVsZCAnICsgZmllbGQgKyAnIG11c3QgYmUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBuZXcgYXJyYXkvdmVjdG9yIG9mIG9iamVjdHMuICBVc2VycyB1c3VhbGx5IHdpbGwgbm90IGNhbGxcbiAgICAgKiB0aGlzIGRpcmVjdGx5LiBUaGUgRmxhdEJ1ZmZlcnMgY29tcGlsZXIgd2lsbCBjcmVhdGUgYSBzdGFydC9lbmRcbiAgICAgKiBtZXRob2QgZm9yIHZlY3RvciB0eXBlcyBpbiBnZW5lcmF0ZWQgY29kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtX3NpemUgVGhlIHNpemUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBhcnJheVxuICAgICAqIEBwYXJhbSBudW1fZWxlbXMgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICAgKiBAcGFyYW0gYWxpZ25tZW50IFRoZSBhbGlnbm1lbnQgb2YgdGhlIGFycmF5XG4gICAgICovXG4gICAgc3RhcnRWZWN0b3IoZWxlbV9zaXplLCBudW1fZWxlbXMsIGFsaWdubWVudCkge1xuICAgICAgICB0aGlzLm5vdE5lc3RlZCgpO1xuICAgICAgICB0aGlzLnZlY3Rvcl9udW1fZWxlbXMgPSBudW1fZWxlbXM7XG4gICAgICAgIHRoaXMucHJlcChTSVpFT0ZfSU5ULCBlbGVtX3NpemUgKiBudW1fZWxlbXMpO1xuICAgICAgICB0aGlzLnByZXAoYWxpZ25tZW50LCBlbGVtX3NpemUgKiBudW1fZWxlbXMpOyAvLyBKdXN0IGluIGNhc2UgYWxpZ25tZW50ID4gaW50LlxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5pc2ggb2ZmIHRoZSBjcmVhdGlvbiBvZiBhbiBhcnJheSBhbmQgYWxsIGl0cyBlbGVtZW50cy4gVGhlIGFycmF5IG11c3QgYmVcbiAgICAgKiBjcmVhdGVkIHdpdGggYHN0YXJ0VmVjdG9yYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXlcbiAgICAgKiBzdGFydHMuXG4gICAgICovXG4gICAgZW5kVmVjdG9yKCkge1xuICAgICAgICB0aGlzLndyaXRlSW50MzIodGhpcy52ZWN0b3JfbnVtX2VsZW1zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiB0aGUgc3RyaW5nIHBhc3NlZCBoYXNcbiAgICAgKiBhbHJlYWR5IGJlZW4gc2Vlbiwgd2UgcmV0dXJuIHRoZSBvZmZzZXQgb2YgdGhlIGFscmVhZHkgd3JpdHRlbiBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzIFRoZSBzdHJpbmcgdG8gZW5jb2RlXG4gICAgICogQHJldHVybiBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xuICAgICAqL1xuICAgIGNyZWF0ZVNoYXJlZFN0cmluZyhzKSB7XG4gICAgICAgIGlmICghcykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN0cmluZ19tYXBzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ19tYXBzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0cmluZ19tYXBzLmhhcyhzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nX21hcHMuZ2V0KHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY3JlYXRlU3RyaW5nKHMpO1xuICAgICAgICB0aGlzLnN0cmluZ19tYXBzLnNldChzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgdGhlIHN0cmluZyBgc2AgaW4gdGhlIGJ1ZmZlciB1c2luZyBVVEYtOC4gSWYgYSBVaW50OEFycmF5IGlzIHBhc3NlZFxuICAgICAqIGluc3RlYWQgb2YgYSBzdHJpbmcsIGl0IGlzIGFzc3VtZWQgdG8gY29udGFpbiB2YWxpZCBVVEYtOCBlbmNvZGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxuICAgICAqIEByZXR1cm4gVGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBlbmNvZGVkIHN0cmluZyBzdGFydHNcbiAgICAgKi9cbiAgICBjcmVhdGVTdHJpbmcocykge1xuICAgICAgICBpZiAocyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1dGY4O1xuICAgICAgICBpZiAocyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHV0ZjggPSBzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRmOCA9IHRoaXMudGV4dF9lbmNvZGVyLmVuY29kZShzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEludDgoMCk7XG4gICAgICAgIHRoaXMuc3RhcnRWZWN0b3IoMSwgdXRmOC5sZW5ndGgsIDEpO1xuICAgICAgICB0aGlzLmJiLnNldFBvc2l0aW9uKHRoaXMuc3BhY2UgLT0gdXRmOC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tvZmZzZXQrK10gPSB1dGY4W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBwYWNrIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgb2Zmc2V0IG9mIG9ialxuICAgICAqL1xuICAgIGNyZWF0ZU9iamVjdE9mZnNldChvYmopIHtcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmcob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoucGFjayh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBwYWNrIGEgbGlzdCBvZiBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGxpc3Qgb2Ygb2Zmc2V0cyBvZiBlYWNoIG5vbiBudWxsIG9iamVjdFxuICAgICAqL1xuICAgIGNyZWF0ZU9iamVjdE9mZnNldExpc3QobGlzdCkge1xuICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBsaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHRoaXMuY3JlYXRlT2JqZWN0T2Zmc2V0KHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogQXJndW1lbnQgZm9yIGNyZWF0ZU9iamVjdE9mZnNldExpc3QgY2Fubm90IGNvbnRhaW4gbnVsbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICBjcmVhdGVTdHJ1Y3RPZmZzZXRMaXN0KGxpc3QsIHN0YXJ0RnVuYykge1xuICAgICAgICBzdGFydEZ1bmModGhpcywgbGlzdC5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNyZWF0ZU9iamVjdE9mZnNldExpc3QobGlzdC5zbGljZSgpLnJldmVyc2UoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xuICAgIH1cbn1cbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgeyBEdWNrREJCaW5kaW5ncyB9IGZyb20gJy4vYmluZGluZ3NfaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMsIEFycm93SW5zZXJ0T3B0aW9ucyB9IGZyb20gJy4vaW5zZXJ0X29wdGlvbnMnO1xyXG5cclxuLyoqIEEgdGhpbiBoZWxwZXIgdG8gYmluZCB0aGUgY29ubmVjdGlvbiBpZCBhbmQgdGFsayByZWNvcmQgYmF0Y2hlcyAqL1xyXG5leHBvcnQgY2xhc3MgRHVja0RCQ29ubmVjdGlvbiB7XHJcbiAgICAvKiogVGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgX2JpbmRpbmdzOiBEdWNrREJCaW5kaW5ncztcclxuICAgIC8qKiBUaGUgY29ubmVjdGlvbiBoYW5kbGUgKi9cclxuICAgIHByb3RlY3RlZCBfY29ubjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25uOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IGJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuX2Nvbm4gPSBjb25uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDbG9zZSBhIGNvbm5lY3Rpb24gKi9cclxuICAgIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9iaW5kaW5ncy5kaXNjb25uZWN0KHRoaXMuX2Nvbm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBCcmF2ZSBzb3VscyBtYXkgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29uc3VtZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIGlkICovXHJcbiAgICBwdWJsaWMgdXNlVW5zYWZlPFI+KGNhbGxiYWNrOiAoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25uOiBudW1iZXIpID0+IFIpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSdW4gYSBxdWVyeSAqL1xyXG4gICAgcHVibGljIHF1ZXJ5PFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFycm93LkRhdGFUeXBlIH0gPSBhbnk+KHRleHQ6IHN0cmluZyk6IGFycm93LlRhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9iaW5kaW5ncy5ydW5RdWVyeSh0aGlzLl9jb25uLCB0ZXh0KTtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3luYygpKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNGaWxlKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXJyb3cuVGFibGUocmVhZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2VuZCBhIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2VuZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PihcclxuICAgICAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICApOiBQcm9taXNlPGFycm93LlJlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+PiB7XHJcbiAgICAgICAgbGV0IGhlYWRlciA9IHRoaXMuX2JpbmRpbmdzLnN0YXJ0UGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4sIHRleHQpO1xyXG4gICAgICAgIHdoaWxlIChoZWFkZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBoZWFkZXIgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5fYmluZGluZ3MucG9sbFBlbmRpbmdRdWVyeSh0aGlzLl9jb25uKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFJlc3VsdFN0cmVhbUl0ZXJhdG9yKHRoaXMuX2JpbmRpbmdzLCB0aGlzLl9jb25uLCBoZWFkZXIpO1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGFycm93LlJlY29yZEJhdGNoUmVhZGVyLmZyb208VD4oaXRlcik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3luYygpKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTdHJlYW0oKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2FuY2VsIGEgcXVlcnkgdGhhdCB3YXMgc2VudCBlYXJsaWVyICovXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VudCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MuY2FuY2VsUGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGFibGUgbmFtZXMgKi9cclxuICAgIHB1YmxpYyBnZXRUYWJsZU5hbWVzKHF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmdldFRhYmxlTmFtZXModGhpcy5fY29ubiwgcXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBwcmVwYXJlPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFycm93LkRhdGFUeXBlIH0gPSBhbnk+KHRleHQ6IHN0cmluZyk6IFByZXBhcmVkU3RhdGVtZW50IHtcclxuICAgICAgICBjb25zdCBzdG10ID0gdGhpcy5fYmluZGluZ3MuY3JlYXRlUHJlcGFyZWQodGhpcy5fY29ubiwgdGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFN0YXRlbWVudDxUPih0aGlzLl9iaW5kaW5ncywgdGhpcy5fY29ubiwgc3RtdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0ZSBhIHNjYWxhciBmdW5jdGlvbiAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVNjYWxhckZ1bmN0aW9uKG5hbWU6IHN0cmluZywgcmV0dXJuczogYXJyb3cuRGF0YVR5cGUsIGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKHRoaXMuX2Nvbm4sIG5hbWUsIHJldHVybnMsIGZ1bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnNlcnQgYW4gYXJyb3cgdGFibGUgKi9cclxuICAgIHB1YmxpYyBpbnNlcnRBcnJvd1RhYmxlKHRhYmxlOiBhcnJvdy5UYWJsZSwgb3B0aW9uczogQXJyb3dJbnNlcnRPcHRpb25zKTogdm9pZCB7XHJcblx0Y29uc3QgYnVmZmVyID0gYXJyb3cudGFibGVUb0lQQyh0YWJsZSwgJ3N0cmVhbScpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKGJ1ZmZlciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGFuIGFycm93IHRhYmxlIGZyb20gYW4gaXBjIHN0cmVhbSAqL1xyXG4gICAgcHVibGljIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM6IEFycm93SW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmluc2VydEFycm93RnJvbUlQQ1N0cmVhbSh0aGlzLl9jb25uLCBidWZmZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbmVzcnQgY3N2IGZpbGUgZnJvbSBwYXRoICovXHJcbiAgICBwdWJsaWMgaW5zZXJ0Q1NWRnJvbVBhdGgocGF0aDogc3RyaW5nLCBvcHRpb25zOiBDU1ZJbnNlcnRPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MuaW5zZXJ0Q1NWRnJvbVBhdGgodGhpcy5fY29ubiwgcGF0aCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGpzb24gZmlsZSBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBpbnNlcnRKU09ORnJvbVBhdGgocGF0aDogc3RyaW5nLCBvcHRpb25zOiBKU09OSW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmluc2VydEpTT05Gcm9tUGF0aCh0aGlzLl9jb25uLCBwYXRoLCBvcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIEEgcmVzdWx0IHN0cmVhbSBpdGVyYXRvciAqL1xyXG5leHBvcnQgY2xhc3MgUmVzdWx0U3RyZWFtSXRlcmF0b3IgaW1wbGVtZW50cyBJdGVyYWJsZTxVaW50OEFycmF5PiB7XHJcbiAgICAvKiogRmlyc3QgY2h1bms/ICovXHJcbiAgICBfZmlyc3Q6IGJvb2xlYW47XHJcbiAgICAvKiogUmVhY2hlZCBlbmQgb2Ygc3RyZWFtPyAqL1xyXG4gICAgX2RlcGxldGVkOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIHByb3RlY3RlZCBjb25uOiBudW1iZXIsIHByb3RlY3RlZCBoZWFkZXI6IFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICB0aGlzLl9maXJzdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZGVwbGV0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0KCk6IEl0ZXJhdG9yUmVzdWx0PFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLmhlYWRlciB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVwbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVmZmVySTggPSB0aGlzLmJpbmRpbmdzLmZldGNoUXVlcnlSZXN1bHRzKHRoaXMuY29ubik7XHJcbiAgICAgICAgdGhpcy5fZGVwbGV0ZWQgPSBidWZmZXJJOC5sZW5ndGggPT0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb25lOiB0aGlzLl9kZXBsZXRlZCxcclxuICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlckk4LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBBIHRoaW4gaGVscGVyIHRvIGJpbmQgdGhlIHByZXBhcmVkIHN0YXRlbWVudCBpZCovXHJcbmV4cG9ydCBjbGFzcyBQcmVwYXJlZFN0YXRlbWVudDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PiB7XHJcbiAgICAvKiogVGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzO1xyXG4gICAgLyoqIFRoZSBjb25uZWN0aW9uIGlkICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgY29ubmVjdGlvbklkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHN0YXRlbWVudCBpZCAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0YXRlbWVudElkOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIENvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIGNvbm5lY3Rpb25JZDogbnVtYmVyLCBzdGF0ZW1lbnRJZDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xyXG4gICAgICAgIHRoaXMuc3RhdGVtZW50SWQgPSBzdGF0ZW1lbnRJZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLmJpbmRpbmdzLmNsb3NlUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSdW4gYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBxdWVyeSguLi5wYXJhbXM6IGFueVtdKTogYXJyb3cuVGFibGU8VD4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYmluZGluZ3MucnVuUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQsIHBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihidWZmZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzRmlsZSgpKTtcclxuICAgICAgICByZXR1cm4gbmV3IGFycm93LlRhYmxlKHJlYWRlciBhcyBhcnJvdy5SZWNvcmRCYXRjaEZpbGVSZWFkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTZW5kIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXHJcbiAgICBwdWJsaWMgc2VuZCguLi5wYXJhbXM6IGFueVtdKTogYXJyb3cuUmVjb3JkQmF0Y2hTdHJlYW1SZWFkZXI8VD4ge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuYmluZGluZ3Muc2VuZFByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUmVzdWx0U3RyZWFtSXRlcmF0b3IodGhpcy5iaW5kaW5ncywgdGhpcy5jb25uZWN0aW9uSWQsIGhlYWRlcik7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihpdGVyKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTeW5jKCkpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N0cmVhbSgpKTtcclxuICAgICAgICByZXR1cm4gcmVhZGVyIGFzIGFycm93LlJlY29yZEJhdGNoU3RyZWFtUmVhZGVyO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBEdWNrREJSdW50aW1lIH0gZnJvbSAnLi9ydW50aW1lJztcclxuaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuXHJcbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG5jb25zdCBURVhUX0RFQ09ERVIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XHJcblxyXG5mdW5jdGlvbiBzdG9yZUVycm9yKG1vZDogRHVja0RCTW9kdWxlLCByZXNwb25zZTogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IG1zZ0J1ZmZlciA9IFRFWFRfRU5DT0RFUi5lbmNvZGUobWVzc2FnZSk7XHJcbiAgICBjb25zdCBoZWFwQWRkciA9IG1vZC5fbWFsbG9jKG1zZ0J1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgIGNvbnN0IGhlYXBBcnJheSA9IG1vZC5IRUFQVTguc3ViYXJyYXkoaGVhcEFkZHIsIGhlYXBBZGRyICsgbXNnQnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgaGVhcEFycmF5LnNldChtc2dCdWZmZXIpO1xyXG4gICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF0gPSAxO1xyXG4gICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMV0gPSBoZWFwQWRkcjtcclxuICAgIG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDJdID0gaGVhcEFycmF5LmJ5dGVMZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFR5cGVTaXplKHB0eXBlOiBzdHJpbmcpIHtcclxuICAgIHN3aXRjaCAocHR5cGUpIHtcclxuICAgICAgICBjYXNlICdVSU5UOCc6XHJcbiAgICAgICAgY2FzZSAnSU5UOCc6XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgJ0lOVDMyJzpcclxuICAgICAgICBjYXNlICdGTE9BVCc6XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgIGNhc2UgJ0lOVDY0JzpcclxuICAgICAgICBjYXNlICdVSU5UNjQnOlxyXG4gICAgICAgIGNhc2UgJ0RPVUJMRSc6XHJcbiAgICAgICAgY2FzZSAnVkFSQ0hBUic6XHJcbiAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwdHJUb0FycmF5KG1vZDogRHVja0RCTW9kdWxlLCBwdHI6IG51bWJlciwgcHR5cGU6IHN0cmluZywgbjogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBoZWFwID0gbW9kLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIG4gKiBnZXRUeXBlU2l6ZShwdHlwZSkpO1xyXG4gICAgc3dpdGNoIChwdHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ1VJTlQ4JzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhlYXAuYnVmZmVyLCBoZWFwLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgICAgIGNhc2UgJ0lOVDgnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcclxuICAgICAgICBjYXNlICdJTlQzMic6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcclxuICAgICAgICBjYXNlICdGTE9BVCc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGhlYXAuYnVmZmVyLCBoZWFwLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgICAgIGNhc2UgJ0RPVUJMRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGhlYXAuYnVmZmVyLCBoZWFwLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgICAgIGNhc2UgJ1ZBUkNIQVInOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw+KDApOyAvLyBjb3VnaFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwdHJUb1VpbnQ4QXJyYXkobW9kOiBEdWNrREJNb2R1bGUsIHB0cjogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGhlYXAgPSBtb2QuSEVBUFU4LnN1YmFycmF5KHB0ciwgcHRyICsgbik7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XHJcbn1cclxuZnVuY3Rpb24gcHRyVG9GbG9hdDY0QXJyYXkobW9kOiBEdWNrREJNb2R1bGUsIHB0cjogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGhlYXAgPSBtb2QuSEVBUFU4LnN1YmFycmF5KHB0ciwgcHRyICsgbiAqIDgpO1xyXG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbiB7XHJcbiAgICBuYW1lPzogc3RyaW5nO1xyXG4gICAgc3FsVHlwZTogc3RyaW5nO1xyXG4gICAgcGh5c2ljYWxUeXBlOiBzdHJpbmc7XHJcbiAgICB2YWxpZGl0eUJ1ZmZlcj86IG51bWJlcjtcclxuICAgIGRhdGFCdWZmZXI/OiBudW1iZXI7XHJcbiAgICBsZW5ndGhCdWZmZXI/OiBudW1iZXI7XHJcbiAgICBjaGlsZHJlbj86IEFyZ3VtZW50VHlwZURlc2NyaXB0aW9uW107XHJcbn1cclxuXHJcbmludGVyZmFjZSBSZXR1cm5UeXBlRGVzY3JpcHRpb24ge1xyXG4gICAgc3FsVHlwZTogc3RyaW5nO1xyXG4gICAgcGh5c2ljYWxUeXBlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBTY2hlbWFEZXNjcmlwdGlvbiB7XHJcbiAgICByb3dzOiBudW1iZXI7XHJcbiAgICBhcmdzOiBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbltdO1xyXG4gICAgcmV0OiBSZXR1cm5UeXBlRGVzY3JpcHRpb247XHJcbn1cclxuXHJcbnR5cGUgQXJndW1lbnRSZXNvbHZlciA9IChyb3c6IG51bWJlcikgPT4gYW55IHwgbnVsbDtcclxuXHJcbi8vIHRoaXMgaXMgY2FsbGVkIGZyb20gd2ViZGIuY2MvQ2FsbFNjYWxhclVERkZ1bmN0aW9uLCBjaGFuZ2VzIGhlcmUgbmVlZCB0byBiZSBtYXRjaGVkIHRoZXJlXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxsU2NhbGFyVURGKFxyXG4gICAgcnVudGltZTogRHVja0RCUnVudGltZSxcclxuICAgIG1vZDogRHVja0RCTW9kdWxlLFxyXG4gICAgcmVzcG9uc2U6IG51bWJlcixcclxuICAgIGZ1bmNJZDogbnVtYmVyLFxyXG4gICAgZGVzY1B0cjogbnVtYmVyLFxyXG4gICAgZGVzY1NpemU6IG51bWJlcixcclxuICAgIHB0cnNQdHI6IG51bWJlcixcclxuICAgIHB0cnNTaXplOiBudW1iZXIsXHJcbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1ZGYgPSBydW50aW1lLl91ZGZGdW5jdGlvbnMuZ2V0KGZ1bmNJZCk7XHJcbiAgICAgICAgaWYgKCF1ZGYpIHtcclxuICAgICAgICAgICAgc3RvcmVFcnJvcihtb2QsIHJlc3BvbnNlLCAnVW5rbm93biBVREYgd2l0aCBpZDogJyArIGZ1bmNJZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmF3RGVzYyA9IFRFWFRfREVDT0RFUi5kZWNvZGUobW9kLkhFQVBVOC5zdWJhcnJheShkZXNjUHRyLCBkZXNjUHRyICsgZGVzY1NpemUpKTtcclxuICAgICAgICBjb25zdCBkZXNjID0gSlNPTi5wYXJzZShyYXdEZXNjKSBhcyBTY2hlbWFEZXNjcmlwdGlvbjtcclxuICAgICAgICBjb25zdCBwdHJzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCBwdHJzUHRyLCBwdHJzU2l6ZSAvIDgpO1xyXG5cclxuICAgICAgICBjb25zdCBidWlsZFJlc29sdmVyID0gKGFyZzogQXJndW1lbnRUeXBlRGVzY3JpcHRpb24pOiBBcmd1bWVudFJlc29sdmVyID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbGlkaXR5OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChhcmcudmFsaWRpdHlCdWZmZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRpdHkgPSBwdHJUb1VpbnQ4QXJyYXkobW9kLCBwdHJzW2FyZy52YWxpZGl0eUJ1ZmZlcl0gYXMgbnVtYmVyLCBkZXNjLnJvd3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYXJnLnBoeXNpY2FsVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnVkFSQ0hBUic6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmRhdGFCdWZmZXIgPT09IG51bGwgfHwgYXJnLmRhdGFCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBkYXRhIHZpZXcsIGV4cGVjdGVkIGRhdGEgYnVmZmVyIGZvciBWQVJDSEFSIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoQnVmZmVyID09PSBudWxsIHx8IGFyZy5sZW5ndGhCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBkYXRhIHZpZXcsIGV4cGVjdGVkIGRhdGEgbGVuZ3RoIGJ1ZmZlciBmb3IgVkFSQ0hBUiBhcmd1bWVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBwdHJUb0FycmF5KG1vZCwgcHRyc1thcmcuZGF0YUJ1ZmZlcl0gYXMgbnVtYmVyLCBhcmcucGh5c2ljYWxUeXBlLCBkZXNjLnJvd3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ3M6IChzdHJpbmcgfCBudWxsKVtdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nTGVuZ3RocyA9IHB0clRvRmxvYXQ2NEFycmF5KG1vZCwgcHRyc1thcmcubGVuZ3RoQnVmZmVyXSBhcyBudW1iZXIsIGRlc2Mucm93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjLnJvd3M7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRpdHkgIT0gbnVsbCAmJiAhdmFsaWRpdHlbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YmFycmF5ID0gbW9kLkhFQVBVOC5zdWJhcnJheShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1tqXSBhcyBudW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmF3W2pdIGFzIG51bWJlcikgKyAoc3RyaW5nTGVuZ3Roc1tqXSBhcyBudW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBURVhUX0RFQ09ERVIuZGVjb2RlKHN1YmFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IHN0cmluZ3Nbcm93XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1NUUlVDVCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXA6IGFueSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuOiBBcmd1bWVudFJlc29sdmVyW10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IChhcmcuY2hpbGRyZW4/Lmxlbmd0aCB8fCAwKTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhcmcuY2hpbGRyZW4hW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGJ1aWxkUmVzb2x2ZXIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goKHJvdzogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbYXR0ci5uYW1lIV0gPSBjaGlsZChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZGl0eSFbcm93XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlciBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzb2x2ZXIgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlcihyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5kYXRhQnVmZmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hbGZvcm1lZCBkYXRhIHZpZXcsIGV4cGVjdGVkIGRhdGEgYnVmZmVyIGZvciBhcmd1bWVudCBvZiB0eXBlOiAnICsgYXJnLnBoeXNpY2FsVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHB0clRvQXJyYXkobW9kLCBwdHJzW2FyZy5kYXRhQnVmZmVyXSBhcyBudW1iZXIsIGFyZy5waHlzaWNhbFR5cGUsIGRlc2Mucm93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4gKCF2YWxpZGl0eSFbcm93XSA/IG51bGwgOiBkYXRhW3Jvd10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IGRhdGFbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBUcmFuc2xhdGUgYXJndW1lbnQgZGF0YVxyXG4gICAgICAgIGNvbnN0IGFyZ1Jlc29sdmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzYy5hcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGFyZ1Jlc29sdmVycy5wdXNoKGJ1aWxkUmVzb2x2ZXIoZGVzYy5hcmdzW2ldKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmVwYXJlIHJlc3VsdCBidWZmZXJzXHJcbiAgICAgICAgLy8gVE9ETzogd2UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhvc2UgZXZlcnkgdGltZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdERhdGFMZW4gPSBkZXNjLnJvd3MgKiBnZXRUeXBlU2l6ZShkZXNjLnJldC5waHlzaWNhbFR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdERhdGFQdHIgPSBtb2QuX21hbGxvYyhyZXN1bHREYXRhTGVuKTtcclxuICAgICAgICBjb25zdCByZXN1bHREYXRhID0gcHRyVG9BcnJheShtb2QsIHJlc3VsdERhdGFQdHIsIGRlc2MucmV0LnBoeXNpY2FsVHlwZSwgZGVzYy5yb3dzKTtcclxuICAgICAgICBjb25zdCByZXN1bHRWYWxpZGl0eVB0ciA9IG1vZC5fbWFsbG9jKGRlc2Mucm93cyk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0VmFsaWRpdHkgPSBwdHJUb1VpbnQ4QXJyYXkobW9kLCByZXN1bHRWYWxpZGl0eVB0ciwgZGVzYy5yb3dzKTtcclxuICAgICAgICBpZiAocmVzdWx0RGF0YS5sZW5ndGggPT0gMCB8fCByZXN1bHRWYWxpZGl0eS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICBzdG9yZUVycm9yKG1vZCwgcmVzcG9uc2UsIFwiQ2FuJ3QgY3JlYXRlIHBoeXNpY2FsIGFycmF5cyBmb3IgcmVzdWx0XCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByYXdSZXN1bHREYXRhID0gcmVzdWx0RGF0YTtcclxuICAgICAgICBpZiAoZGVzYy5yZXQucGh5c2ljYWxUeXBlID09ICdWQVJDSEFSJykge1xyXG4gICAgICAgICAgICByYXdSZXN1bHREYXRhID0gbmV3IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw+KGRlc2Mucm93cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2MuYXJncy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzYy5yb3dzOyArK2kpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjLmFyZ3MubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGFyZ3Nbal0gPSBhcmdSZXNvbHZlcnNbal0oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzID0gdWRmLmZ1bmMoLi4uYXJncyk7XHJcbiAgICAgICAgICAgIHJhd1Jlc3VsdERhdGFbaV0gPSByZXM7XHJcbiAgICAgICAgICAgIHJlc3VsdFZhbGlkaXR5W2ldID0gcmVzID09PSB1bmRlZmluZWQgfHwgcmVzID09PSBudWxsID8gMCA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbmNvZGUgcmV0dXJuIHZhbHVlc1xyXG4gICAgICAgIGxldCByZXN1bHRMZW5ndGhzUHRyID0gMDtcclxuICAgICAgICBzd2l0Y2ggKGRlc2MucmV0LnBoeXNpY2FsVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdWQVJDSEFSJzoge1xyXG4gICAgICAgICAgICAgICAgLy8gQWxsb2NhdGUgcmVzdWx0IGJ1ZmZlcnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdERhdGFVVEY4ID0gbmV3IEFycmF5PFVpbnQ4QXJyYXk+KDApOyAvLyBjb3VnaFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0TGVuZ3Roc1B0ciA9IG1vZC5fbWFsbG9jKGRlc2Mucm93cyAqIGdldFR5cGVTaXplKCdET1VCTEUnKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRMZW5ndGhzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCByZXN1bHRMZW5ndGhzUHRyLCBkZXNjLnJvd3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdHdvIGxvb3BzIHRvIGZpZ3VyZSBvdXQgdGhlIHRvdGFsIGxlbmd0aCBidXQgbWF5YmUgd2UgY2FuIGF2b2lkIHRoZSBkb3VibGUgYWxsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGRlc2Mucm93czsgKytyb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1dGY4ID0gVEVYVF9FTkNPREVSLmVuY29kZSgocmF3UmVzdWx0RGF0YSBhcyAoc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZClbXSlbcm93XSB8fCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RGF0YVVURjgucHVzaCh1dGY4KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRMZW5ndGhzW3Jvd10gPSB1dGY4Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSB1dGY4Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBtYWxsb2MgYSBidWZmZXIgZm9yIHRoZSBzdHJpbmdzIHRvIGxpdmUgaW4gZm9yIG5vd1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyaW5nUHRyID0gbW9kLl9tYWxsb2ModG90YWxMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyaW5nQnVmID0gbW9kLkhFQVBVOC5zdWJhcnJheShyZXN1bHRTdHJpbmdQdHIsIHJlc3VsdFN0cmluZ1B0ciArIHRvdGFsTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3cgY29weSBhbGwgdGhlIHN0cmluZ3MgdG8gdGhlIG5ldyBidWZmZXIgYmFjayB0byBiYWNrXHJcbiAgICAgICAgICAgICAgICBsZXQgd3JpdGVyT2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGRlc2Mucm93czsgKytyb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHREYXRhW3Jvd10gPSB3cml0ZXJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0VVRGOCA9IHJlc3VsdERhdGFVVEY4W3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gcmVzdWx0U3RyaW5nQnVmLnN1YmFycmF5KHdyaXRlck9mZnNldCwgd3JpdGVyT2Zmc2V0ICsgcmVzdWx0VVRGOC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5zZXQocmVzdWx0VVRGOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyT2Zmc2V0ICs9IHJlc3VsdFVURjgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOZWVkIHRvIHN0b3JlIHRocmVlIHBvaW50ZXJzLCBkYXRhLCB2YWxpZGl0eSBhbmQgbGVuZ3RoXHJcbiAgICAgICAgY29uc3QgcmV0TGVuID0gMyAqIDg7XHJcbiAgICAgICAgY29uc3QgcmV0UHRyID0gbW9kLl9tYWxsb2MocmV0TGVuKTtcclxuICAgICAgICBjb25zdCByZXRCdWZmZXIgPSBwdHJUb0Zsb2F0NjRBcnJheShtb2QsIHJldFB0ciwgMyk7XHJcbiAgICAgICAgcmV0QnVmZmVyWzBdID0gcmVzdWx0RGF0YVB0cjtcclxuICAgICAgICByZXRCdWZmZXJbMV0gPSByZXN1bHRWYWxpZGl0eVB0cjtcclxuICAgICAgICByZXRCdWZmZXJbMl0gPSByZXN1bHRMZW5ndGhzUHRyO1xyXG5cclxuICAgICAgICAvLyBQYWNrIHJlc3BvbnNlXHJcbiAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF0gPSAwO1xyXG4gICAgICAgIG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDFdID0gcmV0UHRyO1xyXG4gICAgICAgIG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDJdID0gMDtcclxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgIHN0b3JlRXJyb3IobW9kLCByZXNwb25zZSwgZS50b1N0cmluZygpKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuaW1wb3J0IHsgVURGRnVuY3Rpb24gfSBmcm9tICcuL3VkZl9mdW5jdGlvbic7XHJcbmltcG9ydCAqIGFzIHVkZl9ydCBmcm9tICcuL3VkZl9ydW50aW1lJztcclxuXHJcbi8qKiBXcmFwcGVyIGZvciBUZXh0RGVjb2RlciB0byBzdXBwb3J0IHNoYXJlZCBhcnJheSBidWZmZXJzICovXHJcbmZ1bmN0aW9uIFRleHREZWNvZGVyV3JhcHBlcigpOiAoaW5wdXQ/OiBCdWZmZXJTb3VyY2UpID0+IHN0cmluZyB7XHJcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICByZXR1cm4gKGRhdGE6IGFueSkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoZGF0YSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKiBIZWxwZXIgdG8gZGVjb2RlIHRleHQgKi9cclxuZXhwb3J0IGNvbnN0IGRlY29kZVRleHQgPSBUZXh0RGVjb2RlcldyYXBwZXIoKTtcclxuXHJcbi8qKiBDb3B5IGEgYnVmZmVyICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsV2l0aChtb2Q6IER1Y2tEQk1vZHVsZSwgbXNnOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEZBSUwgV0lUSDogJHttc2d9YCk7XHJcbiAgICBtb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfZmFpbF93aXRoJywgbnVsbCwgWydzdHJpbmcnXSwgW21zZ10pO1xyXG59XHJcblxyXG4vKiogQ29weSBhIGJ1ZmZlciAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weUJ1ZmZlcihtb2Q6IER1Y2tEQk1vZHVsZSwgYmVnaW46IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBVaW50OEFycmF5IHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYmVnaW4sIGJlZ2luICsgbGVuZ3RoKTtcclxuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpKTtcclxuICAgIGNvcHkuc2V0KGJ1ZmZlcik7XHJcbiAgICByZXR1cm4gY29weTtcclxufVxyXG5cclxuLyoqIERlY29kZSBhIHN0cmluZyAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmluZyhtb2Q6IER1Y2tEQk1vZHVsZSwgYmVnaW46IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGRlY29kZVRleHQobW9kLkhFQVBVOC5zdWJhcnJheShiZWdpbiwgYmVnaW4gKyBsZW5ndGgpKTtcclxufVxyXG5cclxuLyoqIFRoZSBkYXRhIHByb3RvY29sICovXHJcbmV4cG9ydCBlbnVtIER1Y2tEQkRhdGFQcm90b2NvbCB7XHJcbiAgICBCVUZGRVIgPSAwLFxyXG4gICAgTk9ERV9GUyA9IDEsXHJcbiAgICBCUk9XU0VSX0ZJTEVSRUFERVIgPSAyLFxyXG4gICAgQlJPV1NFUl9GU0FDQ0VTUyA9IDMsXHJcbiAgICBIVFRQID0gNCxcclxuICAgIFMzID0gNSxcclxufVxyXG5cclxuLyoqIEZpbGUgZmxhZ3MgZm9yIG9wZW5pbmcgZmlsZXMqL1xyXG5leHBvcnQgZW51bSBGaWxlRmxhZ3Mge1xyXG4gICAgLy8hIE9wZW4gZmlsZSB3aXRoIHJlYWQgYWNjZXNzXHJcbiAgICBGSUxFX0ZMQUdTX1JFQUQgPSAxIDw8IDAsXHJcbiAgICAvLyEgT3BlbiBmaWxlIHdpdGggd3JpdGUgYWNjZXNzXHJcbiAgICBGSUxFX0ZMQUdTX1dSSVRFID0gMSA8PCAxLFxyXG4gICAgLy8hIFVzZSBkaXJlY3QgSU8gd2hlbiByZWFkaW5nL3dyaXRpbmcgdG8gdGhlIGZpbGVcclxuICAgIEZJTEVfRkxBR1NfRElSRUNUX0lPID0gMSA8PCAyLFxyXG4gICAgLy8hIENyZWF0ZSBmaWxlIGlmIG5vdCBleGlzdHMsIGNhbiBvbmx5IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBXUklURVxyXG4gICAgRklMRV9GTEFHU19GSUxFX0NSRUFURSA9IDEgPDwgMyxcclxuICAgIC8vISBBbHdheXMgY3JlYXRlIGEgbmV3IGZpbGUuIElmIGEgZmlsZSBleGlzdHMsIHRoZSBmaWxlIGlzIHRydW5jYXRlZC4gQ2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBDUkVBVEUuXHJcbiAgICBGSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFX05FVyA9IDEgPDwgNCxcclxuICAgIC8vISBPcGVuIGZpbGUgaW4gYXBwZW5kIG1vZGVcclxuICAgIEZJTEVfRkxBR1NfQVBQRU5EID0gMSA8PCA1LFxyXG59XHJcblxyXG4vKiogQ29uZmlndXJhdGlvbiBmb3IgdGhlIEFXUyBTMyBGaWxlc3lzdGVtICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUzNDb25maWcge1xyXG4gICAgcmVnaW9uPzogc3RyaW5nO1xyXG4gICAgZW5kcG9pbnQ/OiBzdHJpbmc7XHJcbiAgICBhY2Nlc3NLZXlJZD86IHN0cmluZztcclxuICAgIHNlY3JldEFjY2Vzc0tleT86IHN0cmluZztcclxuICAgIHNlc3Npb25Ub2tlbj86IHN0cmluZztcclxufVxyXG5cclxuLyoqIEFuIGluZm8gZm9yIGEgZmlsZSByZWdpc3RlcmVkIHdpdGggRHVja0RCICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCRmlsZUluZm8ge1xyXG4gICAgY2FjaGVFcG9jaDogbnVtYmVyO1xyXG4gICAgZmlsZUlkOiBudW1iZXI7XHJcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xyXG4gICAgZGF0YVByb3RvY29sOiBEdWNrREJEYXRhUHJvdG9jb2w7XHJcbiAgICBkYXRhVXJsOiBzdHJpbmcgfCBudWxsO1xyXG4gICAgYWxsb3dGdWxsSHR0cFJlYWRzPzogYm9vbGVhbjtcclxuICAgIHMzQ29uZmlnPzogUzNDb25maWc7XHJcbn1cclxuXHJcbi8qKiBHbG9iYWwgaW5mbyBmb3IgYWxsIGZpbGVzIHJlZ2lzdGVyZWQgd2l0aCBEdWNrREIgKi9cclxuZXhwb3J0IGludGVyZmFjZSBEdWNrREJHbG9iYWxGaWxlSW5mbyB7XHJcbiAgICBjYWNoZUVwb2NoOiBudW1iZXI7XHJcbiAgICBhbGxvd0Z1bGxIdHRwUmVhZHM/OiBib29sZWFuO1xyXG4gICAgczNDb25maWc/OiBTM0NvbmZpZztcclxufVxyXG5cclxuLyoqIENhbGwgYSBmdW5jdGlvbiB3aXRoIHBhY2tlZCByZXNwb25zZSBidWZmZXIgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxTUmV0KFxyXG4gICAgbW9kOiBEdWNrREJNb2R1bGUsXHJcbiAgICBmdW5jTmFtZTogc3RyaW5nLFxyXG4gICAgYXJnVHlwZXM6IEFycmF5PEVtc2NyaXB0ZW4uSlNUeXBlPixcclxuICAgIGFyZ3M6IEFycmF5PGFueT4sXHJcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XHJcbiAgICBjb25zdCBzdGFja1BvaW50ZXIgPSBtb2Quc3RhY2tTYXZlKCk7XHJcblxyXG4gICAgLy8gQWxsb2NhdGUgdGhlIHBhY2tlZCByZXNwb25zZSBidWZmZXJcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gbW9kLnN0YWNrQWxsb2MoMyAqIDgpO1xyXG4gICAgYXJnVHlwZXMudW5zaGlmdCgnbnVtYmVyJyk7XHJcbiAgICBhcmdzLnVuc2hpZnQocmVzcG9uc2UpO1xyXG5cclxuICAgIC8vIERvIHRoZSBjYWxsXHJcbiAgICBtb2QuY2NhbGwoZnVuY05hbWUsIG51bGwsIGFyZ1R5cGVzLCBhcmdzKTtcclxuXHJcbiAgICAvLyBSZWFkIHRoZSByZXNwb25zZVxyXG4gICAgY29uc3Qgc3RhdHVzID0gbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF07XHJcbiAgICBjb25zdCBkYXRhID0gbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMV07XHJcbiAgICBjb25zdCBkYXRhU2l6ZSA9IG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDJdO1xyXG5cclxuICAgIC8vIFJlc3RvcmUgdGhlIHN0YWNrXHJcbiAgICBtb2Quc3RhY2tSZXN0b3JlKHN0YWNrUG9pbnRlcik7XHJcbiAgICByZXR1cm4gW3N0YXR1cywgZGF0YSwgZGF0YVNpemVdO1xyXG59XHJcblxyXG4vKiogRHJvcCByZXNwb25zZSBidWZmZXJzICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkcm9wUmVzcG9uc2VCdWZmZXJzKG1vZDogRHVja0RCTW9kdWxlKTogdm9pZCB7XHJcbiAgICBtb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2UnLCBudWxsLCBbXSwgW10pO1xyXG59XHJcblxyXG4vKiogVGhlIGR1Y2tkYiBydW50aW1lICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCUnVudGltZSB7XHJcbiAgICBfZmlsZXM/OiBNYXA8c3RyaW5nLCBhbnk+O1xyXG4gICAgX3VkZkZ1bmN0aW9uczogTWFwPG51bWJlciwgVURGRnVuY3Rpb24+O1xyXG5cclxuICAgIC8vIFRlc3QgYSBwbGF0Zm9ybSBmZWF0dXJlXHJcbiAgICB0ZXN0UGxhdGZvcm1GZWF0dXJlKG1vZDogRHVja0RCTW9kdWxlLCBmZWF0dXJlOiBudW1iZXIpOiBib29sZWFuO1xyXG5cclxuICAgIC8vIEZpbGUgQVBJcyB3aXRoIGRlZGljYXRlZCBmaWxlIGlkZW50aWZpZXJcclxuICAgIGdldERlZmF1bHREYXRhUHJvdG9jb2wobW9kOiBEdWNrREJNb2R1bGUpOiBudW1iZXI7XHJcbiAgICBvcGVuRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGZsYWdzOiBGaWxlRmxhZ3MpOiB2b2lkO1xyXG4gICAgc3luY0ZpbGUobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKTogdm9pZDtcclxuICAgIGNsb3NlRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgZ2V0TGFzdEZpbGVNb2RpZmljYXRpb25UaW1lKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IG51bWJlcjtcclxuICAgIHRydW5jYXRlRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIG5ld1NpemU6IG51bWJlcik6IHZvaWQ7XHJcbiAgICByZWFkRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGJ1ZmZlcjogbnVtYmVyLCBieXRlczogbnVtYmVyLCBsb2NhdGlvbjogbnVtYmVyKTogbnVtYmVyO1xyXG4gICAgd3JpdGVGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgYnVmZmVyOiBudW1iZXIsIGJ5dGVzOiBudW1iZXIsIGxvY2F0aW9uOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gICAgLy8gRmlsZSBBUElzIHdpdGggcGF0aCBwYXJhbWV0ZXJcclxuICAgIHJlbW92ZURpcmVjdG9yeShtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgY2hlY2tEaXJlY3RvcnkobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcclxuICAgIGNyZWF0ZURpcmVjdG9yeShtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgbGlzdERpcmVjdG9yeUVudHJpZXMobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcclxuICAgIGdsb2IobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogdm9pZDtcclxuICAgIG1vdmVGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmcm9tUHRyOiBudW1iZXIsIGZyb21MZW46IG51bWJlciwgdG9QdHI6IG51bWJlciwgdG9MZW46IG51bWJlcik6IHZvaWQ7XHJcbiAgICBjaGVja0ZpbGUobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcclxuICAgIHJlbW92ZUZpbGUobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICAvLyBDYWxsIGEgc2NhbGFyIFVERiBmdW5jdGlvblxyXG4gICAgY2FsbFNjYWxhclVERihcclxuICAgICAgICBtb2Q6IER1Y2tEQk1vZHVsZSxcclxuICAgICAgICByZXNwb25zZTogbnVtYmVyLFxyXG4gICAgICAgIGZ1bmNJZDogbnVtYmVyLFxyXG4gICAgICAgIGRlc2NQdHI6IG51bWJlcixcclxuICAgICAgICBkZXNjU2l6ZTogbnVtYmVyLFxyXG4gICAgICAgIHB0cnNQdHI6IG51bWJlcixcclxuICAgICAgICBwdHJzU2l6ZTogbnVtYmVyLFxyXG4gICAgKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUlVOVElNRTogRHVja0RCUnVudGltZSA9IHtcclxuICAgIF91ZGZGdW5jdGlvbnM6IG5ldyBNYXAoKSxcclxuXHJcbiAgICB0ZXN0UGxhdGZvcm1GZWF0dXJlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmVhdHVyZTogbnVtYmVyKTogYm9vbGVhbiA9PiBmYWxzZSxcclxuICAgIGdldERlZmF1bHREYXRhUHJvdG9jb2w6IChfbW9kOiBEdWNrREJNb2R1bGUpOiBudW1iZXIgPT4gRHVja0RCRGF0YVByb3RvY29sLkJVRkZFUixcclxuICAgIG9wZW5GaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmlsZUlkOiBudW1iZXIsIGZsYWdzOiBGaWxlRmxhZ3MpOiB2b2lkID0+IHt9LFxyXG4gICAgc3luY0ZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBjbG9zZUZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBnZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG4gICAgdHJ1bmNhdGVGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmlsZUlkOiBudW1iZXIsIF9uZXdTaXplOiBudW1iZXIpOiB2b2lkID0+IHt9LFxyXG4gICAgcmVhZEZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlciwgX2J1ZmZlcjogbnVtYmVyLCBfYnl0ZXM6IG51bWJlciwgX2xvY2F0aW9uOiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuICAgIHdyaXRlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2ZpbGVJZDogbnVtYmVyLCBfYnVmZmVyOiBudW1iZXIsIF9ieXRlczogbnVtYmVyLCBfbG9jYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZURpcmVjdG9yeTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBjaGVja0RpcmVjdG9yeTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVEaXJlY3Rvcnk6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiB2b2lkID0+IHt9LFxyXG4gICAgbGlzdERpcmVjdG9yeUVudHJpZXM6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZ2xvYjogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBtb3ZlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2Zyb21QdHI6IG51bWJlciwgX2Zyb21MZW46IG51bWJlciwgX3RvUHRyOiBudW1iZXIsIF90b0xlbjogbnVtYmVyKTogdm9pZCA9PiB7fSxcclxuICAgIGNoZWNrRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfcGF0aFB0cjogbnVtYmVyLCBfcGF0aExlbjogbnVtYmVyKTogdm9pZCA9PiB7fSxcclxuICAgIGNhbGxTY2FsYXJVREY6IChcclxuICAgICAgICBtb2Q6IER1Y2tEQk1vZHVsZSxcclxuICAgICAgICByZXNwb25zZTogbnVtYmVyLFxyXG4gICAgICAgIGZ1bmNJZDogbnVtYmVyLFxyXG4gICAgICAgIGRlc2NQdHI6IG51bWJlcixcclxuICAgICAgICBkZXNjU2l6ZTogbnVtYmVyLFxyXG4gICAgICAgIHB0cnNQdHI6IG51bWJlcixcclxuICAgICAgICBwdHJzU2l6ZTogbnVtYmVyLFxyXG4gICAgKTogdm9pZCA9PiB7XHJcbiAgICAgICAgdWRmX3J0LmNhbGxTY2FsYXJVREYoREVGQVVMVF9SVU5USU1FLCBtb2QsIHJlc3BvbnNlLCBmdW5jSWQsIGRlc2NQdHIsIGRlc2NTaXplLCBwdHJzUHRyLCBwdHJzU2l6ZSk7XHJcbiAgICB9LFxyXG59O1xyXG4iLCAiZXhwb3J0IGludGVyZmFjZSBGaWxlQmxvY2tTdGF0aXN0aWNzIHtcclxuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBjb2xkICovXHJcbiAgICBmaWxlX3JlYWRzX2NvbGQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBhaGVhZHMgKi9cclxuICAgIGZpbGVfcmVhZHNfYWhlYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBjYWNoZWQgKi9cclxuICAgIGZpbGVfcmVhZHNfY2FjaGVkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGZpbGUgd3JpdGVzICovXHJcbiAgICBmaWxlX3dyaXRlczogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBwYWdlIGFjY2Vzc2VzICovXHJcbiAgICBwYWdlX2FjY2Vzc2VzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHBhZ2UgbG9hZHMgKi9cclxuICAgIHBhZ2VfbG9hZHM6IG51bWJlcjtcclxufVxyXG5cclxuLyoqIFRoZSBmaWxlIGJsb2NrIHN0YXRpc3RpY3MgKi9cclxuZXhwb3J0IGNsYXNzIEZpbGVTdGF0aXN0aWNzIHtcclxuICAgIC8qKiBUaGUgY29sZCBmaWxlIHJlYWRzICovXHJcbiAgICBwdWJsaWMgdG90YWxGaWxlUmVhZHNDb2xkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGZpbGUgcmVhZGFoZWFkcyAqL1xyXG4gICAgcHVibGljIHRvdGFsRmlsZVJlYWRzQWhlYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgY2FjaGVkIGZpbGUgcmVhZHMgKi9cclxuICAgIHB1YmxpYyB0b3RhbEZpbGVSZWFkc0NhY2hlZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBmaWxlIHdyaXRlcyAqL1xyXG4gICAgcHVibGljIHRvdGFsRmlsZVdyaXRlczogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBwYWdlIGFjY2Vzc2VzICovXHJcbiAgICBwdWJsaWMgdG90YWxQYWdlQWNjZXNzZXM6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcGFnZSBsb2FkcyAqL1xyXG4gICAgcHVibGljIHRvdGFsUGFnZUxvYWRzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGJsb2NrcyAqL1xyXG4gICAgcHVibGljIGJsb2NrU2l6ZTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBibG9ja3MgKi9cclxuICAgIHB1YmxpYyBibG9ja1N0YXRzOiBVaW50OEFycmF5O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHU4YXJyYXk6IFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICBjb25zdCBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KHU4YXJyYXkuYnVmZmVyLCB1OGFycmF5LmJ5dGVPZmZzZXQsIHU4YXJyYXkuYnl0ZUxlbmd0aCAvIDgpO1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcih1OGFycmF5LmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICBibG9ja3Muc2V0KHU4YXJyYXkuc3ViYXJyYXkoNyAqIDgpKTtcclxuICAgICAgICB0aGlzLnRvdGFsRmlsZVJlYWRzQ29sZCA9IGY2NFswXTtcclxuICAgICAgICB0aGlzLnRvdGFsRmlsZVJlYWRzQWhlYWQgPSBmNjRbMV07XHJcbiAgICAgICAgdGhpcy50b3RhbEZpbGVSZWFkc0NhY2hlZCA9IGY2NFsyXTtcclxuICAgICAgICB0aGlzLnRvdGFsRmlsZVdyaXRlcyA9IGY2NFszXTtcclxuICAgICAgICB0aGlzLnRvdGFsUGFnZUFjY2Vzc2VzID0gZjY0WzRdO1xyXG4gICAgICAgIHRoaXMudG90YWxQYWdlTG9hZHMgPSBmNjRbNV07XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBmNjRbNl07XHJcbiAgICAgICAgdGhpcy5ibG9ja1N0YXRzID0gYmxvY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgYmxvY2sgc3RhdHMgKi9cclxuICAgIHB1YmxpYyBnZXRCbG9ja1N0YXRzKGluZGV4OiBudW1iZXIsIG91dD86IEZpbGVCbG9ja1N0YXRpc3RpY3MpOiBGaWxlQmxvY2tTdGF0aXN0aWNzIHtcclxuICAgICAgICBvdXQgPSBvdXQgfHwge1xyXG4gICAgICAgICAgICBmaWxlX3JlYWRzX2NvbGQ6IDAsXHJcbiAgICAgICAgICAgIGZpbGVfcmVhZHNfYWhlYWQ6IDAsXHJcbiAgICAgICAgICAgIGZpbGVfcmVhZHNfY2FjaGVkOiAwLFxyXG4gICAgICAgICAgICBmaWxlX3dyaXRlczogMCxcclxuICAgICAgICAgICAgcGFnZV9hY2Nlc3NlczogMCxcclxuICAgICAgICAgICAgcGFnZV9sb2FkczogMCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIG91dC5maWxlX3dyaXRlcyA9IHRoaXMuYmxvY2tTdGF0c1tpbmRleCAqIDMgKyAwXSAmIDBiMTExMTtcclxuICAgICAgICBvdXQuZmlsZV9yZWFkc19jb2xkID0gdGhpcy5ibG9ja1N0YXRzW2luZGV4ICogMyArIDBdID4+IDQ7XHJcbiAgICAgICAgb3V0LmZpbGVfcmVhZHNfYWhlYWQgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gJiAwYjExMTE7XHJcbiAgICAgICAgb3V0LmZpbGVfcmVhZHNfY2FjaGVkID0gdGhpcy5ibG9ja1N0YXRzW2luZGV4ICogMyArIDFdID4+IDQ7XHJcbiAgICAgICAgb3V0LnBhZ2VfYWNjZXNzZXMgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gJiAwYjExMTE7XHJcbiAgICAgICAgb3V0LnBhZ2VfbG9hZHMgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gPj4gNDtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTUUxUeXBlIHtcclxuICAgIC8vLyBUaGUgc3FsIHR5cGVcclxuICAgIHNxbFR5cGU6IHN0cmluZztcclxuICAgIC8vLyBJcyBudWxsYWJsZT9cclxuICAgIG51bGxhYmxlPzogYm9vbGVhbjtcclxuICAgIC8vLyBEZWNpbWFsIHByZWNpc2lvblxyXG4gICAgcHJlY2lzaW9uPzogbnVtYmVyO1xyXG4gICAgLy8vIERlY2ltYWwgc2NhbGluZ1xyXG4gICAgc2NhbGU/OiBudW1iZXI7XHJcbiAgICAvLy8gVGltZXpvbmVcclxuICAgIHRpbWV6b25lPzogc3RyaW5nO1xyXG4gICAgLy8vIEJ5dGUgd2lkdGggKEZpeGVkU2l6ZUJpbmFyeSlcclxuICAgIGJ5dGVXaWR0aD86IG51bWJlcjtcclxuICAgIC8vLyBLZXkgdHlwZVxyXG4gICAga2V5VHlwZT86IFNRTFR5cGU7XHJcbiAgICAvLy8gVmFsdWUgdHlwZVxyXG4gICAgdmFsdWVUeXBlPzogU1FMVHlwZTtcclxuICAgIC8vLyBGaWVsZHNcclxuICAgIGZpZWxkcz86IFNRTEZpZWxkW107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJvd1RvU1FMVHlwZSh0eXBlOiBhcnJvdy5EYXRhVHlwZSk6IFNRTFR5cGUge1xyXG4gICAgc3dpdGNoICh0eXBlLnR5cGVJZCkge1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5CaW5hcnk6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdiaW5hcnknIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkJvb2w6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdib29sJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5EYXRlOlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZGF0ZScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGF0ZURheTpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2RhdGUzMltkXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGF0ZU1pbGxpc2Vjb25kOlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZGF0ZTY0W21zXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGVjaW1hbDoge1xyXG4gICAgICAgICAgICBjb25zdCBkZWMgPSB0eXBlIGFzIGFycm93LkRlY2ltYWw7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdkZWNpbWFsJywgcHJlY2lzaW9uOiBkZWMucHJlY2lzaW9uLCBzY2FsZTogZGVjLnNjYWxlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDE2OlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZmxvYXQxNicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRmxvYXQzMjpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0MzInIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkZsb2F0NjQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdmbG9hdDY0JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQzMicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50MTY6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQxNicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50MzI6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQzMicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50NjQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQ2NCcgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVWludDE2OlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndWludDE2JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5VaW50MzI6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1aW50MzInIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlVpbnQ2NDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3VpbnQ2NCcgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVWludDg6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1aW50OCcgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50ZXJ2YWxEYXlUaW1lOlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnaW50ZXJ2YWxbZHRdJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnRlcnZhbFllYXJNb250aDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2ludGVydmFsW21dJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5MaXN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB0eXBlIGFzIGFycm93Lkxpc3Q7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzcWxUeXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IGFycm93VG9TUUxUeXBlKGxpc3QudmFsdWVUeXBlKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkZpeGVkU2l6ZUJpbmFyeToge1xyXG4gICAgICAgICAgICBjb25zdCBiaW4gPSB0eXBlIGFzIGFycm93LkZpeGVkU2l6ZUJpbmFyeTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2ZpeGVkc2l6ZWJpbmFyeScsIGJ5dGVXaWR0aDogYmluLmJ5dGVXaWR0aCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuTnVsbDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ251bGwnIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlV0Zjg6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1dGY4JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5TdHJ1Y3Q6IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RydWN0XyA9IHR5cGUgYXMgYXJyb3cuU3RydWN0O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3FsVHlwZTogJ3N0cnVjdCcsXHJcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHN0cnVjdF8uY2hpbGRyZW4ubWFwKGMgPT4gYXJyb3dUb1NRTEZpZWxkKGMubmFtZSwgYy50eXBlKSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5NYXA6IHtcclxuICAgICAgICAgICAgY29uc3QgbWFwXyA9IHR5cGUgYXMgYXJyb3cuTWFwXztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNxbFR5cGU6ICdtYXAnLFxyXG4gICAgICAgICAgICAgICAga2V5VHlwZTogYXJyb3dUb1NRTFR5cGUobWFwXy5rZXlUeXBlKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogYXJyb3dUb1NRTFR5cGUobWFwXy52YWx1ZVR5cGUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZTpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbc10nIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVNaWNyb3NlY29uZDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbdXNdJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lTWlsbGlzZWNvbmQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lW21zXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZU5hbm9zZWNvbmQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lW25zXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZVNlY29uZDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbc10nIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVzdGFtcDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wO1xyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZXN0YW1wJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZXN0YW1wU2Vjb25kOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRzID0gdHlwZSBhcyBhcnJvdy5UaW1lc3RhbXBTZWNvbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbc10nLCB0aW1lem9uZTogdHMudGltZXpvbmUgfHwgdW5kZWZpbmVkIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lc3RhbXBNaWNyb3NlY29uZDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTWljcm9zZWNvbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbdXNdJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZXN0YW1wTmFub3NlY29uZDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTmFub3NlY29uZDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVzdGFtcFtuc10nLCB0aW1lem9uZTogdHMudGltZXpvbmUgfHwgdW5kZWZpbmVkIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lc3RhbXBNaWxsaXNlY29uZDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbbXNdJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXJyb3cgdHlwZTogJHt0eXBlLnRvU3RyaW5nKCl9YCk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNRTEZpZWxkID0gU1FMVHlwZSAmIHsgbmFtZTogc3RyaW5nIH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXJyb3dUb1NRTEZpZWxkKG5hbWU6IHN0cmluZywgdHlwZTogYXJyb3cuRGF0YVR5cGUpOiBTUUxGaWVsZCB7XHJcbiAgICBjb25zdCB0ID0gYXJyb3dUb1NRTFR5cGUodHlwZSkgYXMgU1FMRmllbGQ7XHJcbiAgICB0Lm5hbWUgPSBuYW1lO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuIiwgImltcG9ydCB7IER1Y2tEQk1vZHVsZSwgUFRocmVhZCB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XHJcbmltcG9ydCB7IER1Y2tEQkNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLi9wcm9ncmVzcyc7XHJcbmltcG9ydCB7IER1Y2tEQkJpbmRpbmdzIH0gZnJvbSAnLi9iaW5kaW5nc19pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBEdWNrREJDb25uZWN0aW9uIH0gZnJvbSAnLi9jb25uZWN0aW9uJztcclxuaW1wb3J0IHsgU3RhdHVzQ29kZSB9IGZyb20gJy4uL3N0YXR1cyc7XHJcbmltcG9ydCB7IGRyb3BSZXNwb25zZUJ1ZmZlcnMsIER1Y2tEQlJ1bnRpbWUsIHJlYWRTdHJpbmcsIGNhbGxTUmV0LCBjb3B5QnVmZmVyLCBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuL3J1bnRpbWUnO1xyXG5pbXBvcnQgeyBDU1ZJbnNlcnRPcHRpb25zLCBKU09OSW5zZXJ0T3B0aW9ucywgQXJyb3dJbnNlcnRPcHRpb25zIH0gZnJvbSAnLi9pbnNlcnRfb3B0aW9ucyc7XHJcbmltcG9ydCB7IFNjcmlwdFRva2VucyB9IGZyb20gJy4vdG9rZW5zJztcclxuaW1wb3J0IHsgRmlsZVN0YXRpc3RpY3MgfSBmcm9tICcuL2ZpbGVfc3RhdHMnO1xyXG5pbXBvcnQgeyBhcnJvd1RvU1FMRmllbGQsIGFycm93VG9TUUxUeXBlIH0gZnJvbSAnLi4vanNvbl90eXBlZGVmJztcclxuaW1wb3J0IHsgV2ViRmlsZSB9IGZyb20gJy4vd2ViX2ZpbGUnO1xyXG5pbXBvcnQgeyBVREZGdW5jdGlvbiwgVURGRnVuY3Rpb25EZWNsYXJhdGlvbiB9IGZyb20gJy4vdWRmX2Z1bmN0aW9uJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG5cclxuZGVjbGFyZSBnbG9iYWwge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxyXG4gICAgdmFyIERVQ0tEQl9SVU5USU1FOiBhbnk7XHJcbn1cclxuXHJcbi8qKiBBIER1Y2tEQiBGZWF0dXJlICovXHJcbmV4cG9ydCBlbnVtIER1Y2tEQkZlYXR1cmUge1xyXG4gICAgV0FTTV9FWENFUFRJT05TID0gMSA8PCAwLFxyXG4gICAgV0FTTV9USFJFQURTID0gMSA8PCAxLFxyXG4gICAgV0FTTV9TSU1EID0gMSA8PCAyLFxyXG4gICAgV0FTTV9CVUxLX01FTU9SWSA9IDEgPDwgMyxcclxuICAgIEVNSVRfQklHSU5UID0gMSA8PCA0LFxyXG59XHJcblxyXG4vKiogVGhlIHByb3h5IGZvciBlaXRoZXIgdGhlIGJyb3dzZXItIG9yZGVyIG5vZGUtYmFzZWQgRHVja0RCIEFQSSAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRHVja0RCQmluZGluZ3NCYXNlIGltcGxlbWVudHMgRHVja0RCQmluZGluZ3Mge1xyXG4gICAgLyoqIFRoZSBsb2dnZXIgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBfbG9nZ2VyOiBMb2dnZXI7XHJcbiAgICAvKiogQmFja2VuZC1kZXBlbmRlbnQgbmF0aXZlLWdsdWUgY29kZSBmb3IgRHVja0RCICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3J1bnRpbWU6IER1Y2tEQlJ1bnRpbWU7XHJcbiAgICAvKiogVGhlIGluc3RhbmNlICovXHJcbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBEdWNrREJNb2R1bGUgfCBudWxsID0gbnVsbDtcclxuICAgIC8qKiBUaGUgbG9hZGluZyBwcm9taXNlICovXHJcbiAgICBwcm90ZWN0ZWQgX2luaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcbiAgICAvKiogVGhlIHJlc29sdmVyIGZvciB0aGUgb3BlbiBwcm9taXNlIChjYWxsZWQgYnkgb25SdW50aW1lSW5pdGlhbGl6ZWQpICovXHJcbiAgICBwcm90ZWN0ZWQgX2luaXRQcm9taXNlUmVzb2x2ZXI6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcclxuICAgIC8qKiBUaGUgbmV4dCBVREYgaWQgKi9cclxuICAgIHByb3RlY3RlZCBfbmV4dFVERklkOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXIsIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICAgICAgdGhpcy5fcnVudGltZSA9IHJ1bnRpbWU7XHJcbiAgICAgICAgdGhpcy5fbmV4dFVERklkID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBsb2dnZXIgKi9cclxuICAgIHB1YmxpYyBnZXQgbG9nZ2VyKCk6IExvZ2dlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlcjtcclxuICAgIH1cclxuICAgIC8qKiBHZXQgdGhlIGluc3RhbmNlICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vZCgpOiBEdWNrREJNb2R1bGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSE7XHJcbiAgICB9XHJcbiAgICAvKiogR2V0IHRoZSBpbnN0YW5jZSAqL1xyXG4gICAgcHVibGljIGdldCBwdGhyZWFkKCk6IFBUaHJlYWQgfCBudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QuUFRocmVhZCB8fCBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgbW9kdWxlICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+O1xyXG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSBtb2R1bGUgKi9cclxuICAgIHByb3RlY3RlZCBvbkluc3RhbnRpYXRpb25Qcm9ncmVzczogKChwOiBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MpID0+IHZvaWQpW10gPSBbXTtcclxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnN0YW50aWF0ZShvblByb2dyZXNzOiAocHJvZ3Jlc3M6IEluc3RhbnRpYXRpb25Qcm9ncmVzcykgPT4gdm9pZCA9IF8gPT4ge30pOiBQcm9taXNlPHRoaXM+IHtcclxuICAgICAgICAvLyBBbHJlYWR5IG9wZW5lZD9cclxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3BlbiBpbiBwcm9ncmVzcz9cclxuICAgICAgICBpZiAodGhpcy5faW5pdFByb21pc2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uSW5zdGFudGlhdGlvblByb2dyZXNzLnB1c2gob25Qcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2UgY2FuIGF3YWl0XHJcbiAgICAgICAgdGhpcy5faW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgcHJvZ3Jlc3MgaGFuZGxlclxyXG4gICAgICAgIHRoaXMub25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSBbb25Qcm9ncmVzc107XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkdWNrZGJcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGF3YWl0IHRoaXMuaW5zdGFudGlhdGVJbXBsKHtcclxuICAgICAgICAgICAgcHJpbnQ6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXHJcbiAgICAgICAgICAgIHByaW50RXJyOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxyXG4gICAgICAgICAgICBvblJ1bnRpbWVJbml0aWFsaXplZDogdGhpcy5faW5pdFByb21pc2VSZXNvbHZlcixcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXYWl0IGZvciBvblJ1bnRpbWVJbml0aWFsaXplZFxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIHRoaXMuX2luaXRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvLyBSZW1vdmUgb3duIHByb2dyZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgdGhpcy5vbkluc3RhbnRpYXRpb25Qcm9ncmVzcyA9IHRoaXMub25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MuZmlsdGVyKHggPT4geCAhPSBvblByb2dyZXNzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKiBPcGVuIGEgZGF0YWJhc2Ugd2l0aCBhIGNvbmZpZyAqL1xyXG4gICAgcHVibGljIG9wZW4oY29uZmlnOiBEdWNrREJDb25maWcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfb3BlbicsIFsnc3RyaW5nJ10sIFtKU09OLnN0cmluZ2lmeShjb25maWcpXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzZXQgdGhlIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX3Jlc2V0JywgW10sIFtdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIHZlcnNpb24gKi9cclxuICAgIHB1YmxpYyBnZXRWZXJzaW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2dldF92ZXJzaW9uJywgW10sIFtdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH1cclxuICAgIC8qKiBHZXQgdGhlIGZlYXR1cmUgZmxhZ3MgKi9cclxuICAgIHB1YmxpYyBnZXRGZWF0dXJlRmxhZ3MoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3MnLCAnbnVtYmVyJywgW10sIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVG9rZW5pemUgYSBzY3JpcHQgKi9cclxuICAgIHB1YmxpYyB0b2tlbml6ZSh0ZXh0OiBzdHJpbmcpOiBTY3JpcHRUb2tlbnMge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl90b2tlbml6ZScsIFsnc3RyaW5nJ10sIFt0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXMpIGFzIFNjcmlwdFRva2VucztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29ubmVjdCB0byBkYXRhYmFzZSAqL1xyXG4gICAgcHVibGljIGNvbm5lY3QoKTogRHVja0RCQ29ubmVjdGlvbiB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2Nvbm5lY3QnLCAnbnVtYmVyJywgW10sIFtdKTtcclxuICAgICAgICByZXR1cm4gbmV3IER1Y2tEQkNvbm5lY3Rpb24odGhpcywgY29ubik7XHJcbiAgICB9XHJcbiAgICAvKiogRGlzY29ubmVjdCBmcm9tIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgZGlzY29ubmVjdChjb25uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1vZC5jY2FsbCgnZHVja2RiX3dlYl9kaXNjb25uZWN0JywgbnVsbCwgWydudW1iZXInXSwgW2Nvbm5dKTtcclxuICAgICAgICBpZiAodGhpcy5wdGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIFsuLi50aGlzLnB0aHJlYWQucnVubmluZ1dvcmtlcnMsIC4uLnRoaXMucHRocmVhZC51bnVzZWRXb3JrZXJzXSkge1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdkcm9wVURGRnVuY3Rpb25zJyxcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogU2VuZCBhIHF1ZXJ5IGFuZCByZXR1cm4gdGhlIGZ1bGwgcmVzdWx0ICovXHJcbiAgICBwdWJsaWMgcnVuUXVlcnkoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcXVlcnlfcnVuJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3RhcnQgYSBwZW5kaW5nIHF1ZXJ5IGFzeW5jaHJvbm91c2x5LlxyXG4gICAgICogIFRoaXMgbWV0aG9kIHJldHVybnMgZWl0aGVyIHRoZSBhcnJvdyBpcGMgc2NoZW1hIG9yIG51bGwuXHJcbiAgICAgKiAgT24gbnVsbCwgdGhlIHF1ZXJ5IGhhcyB0byBiZSBleGVjdXRlZCB1c2luZyBgcG9sbFBlbmRpbmdRdWVyeWAgdW50aWwgdGhhdCByZXR1cm5zICE9IG51bGwuXHJcbiAgICAgKiAgUmVzdWx0cyBjYW4gdGhlbiBiZSBmZXRjaGVkIHVzaW5nIGBmZXRjaFF1ZXJ5UmVzdWx0c2BcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXJ0UGVuZGluZ1F1ZXJ5KGNvbm46IG51bWJlciwgdGV4dDogc3RyaW5nKTogVWludDhBcnJheSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0JywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIFBvbGwgYSBwZW5kaW5nIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgcG9sbFBlbmRpbmdRdWVyeShjb25uOiBudW1iZXIpOiBVaW50OEFycmF5IHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbCcsIFsnbnVtYmVyJ10sIFtjb25uXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbmNlbCBhIHBlbmRpbmcgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBjYW5jZWxQZW5kaW5nUXVlcnkoY29ubjogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsJywgJ2Jvb2xlYW4nLCBbJ251bWJlciddLCBbY29ubl0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEZldGNoIHF1ZXJ5IHJlc3VsdHMgKi9cclxuICAgIHB1YmxpYyBmZXRjaFF1ZXJ5UmVzdWx0cyhjb25uOiBudW1iZXIpOiBVaW50OEFycmF5IHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0cycsIFsnbnVtYmVyJ10sIFtjb25uXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIEdldCB0YWJsZSBuYW1lcyAqL1xyXG4gICAgcHVibGljIGdldFRhYmxlTmFtZXMoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXMpIGFzIHN0cmluZ1tdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGUgYSBzY2FsYXIgZnVuY3Rpb24gKi9cclxuICAgIHB1YmxpYyBjcmVhdGVTY2FsYXJGdW5jdGlvbihcclxuICAgICAgICBjb25uOiBudW1iZXIsXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIHJldHVybnM6IGFycm93LkRhdGFUeXBlLFxyXG4gICAgICAgIGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCxcclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGRlY2w6IFVERkZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHRoaXMuX25leHRVREZJZCxcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgcmV0dXJuVHlwZTogYXJyb3dUb1NRTFR5cGUocmV0dXJucyksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWY6IFVERkZ1bmN0aW9uID0ge1xyXG4gICAgICAgICAgICBmdW5jdGlvbklkOiBkZWNsLmZ1bmN0aW9uSWQsXHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubixcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgcmV0dXJuVHlwZTogcmV0dXJucyxcclxuICAgICAgICAgICAgZnVuYyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX25leHRVREZJZCArPSAxO1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxyXG4gICAgICAgICAgICB0aGlzLm1vZCxcclxuICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGUnLFxyXG4gICAgICAgICAgICBbJ251bWJlcicsICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW2Nvbm4sIEpTT04uc3RyaW5naWZ5KGRlY2wpXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICAgICAgZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5fdWRmRnVuY3Rpb25zID0gKGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuX3VkZkZ1bmN0aW9ucyB8fCBuZXcgTWFwKCkpLnNldChcclxuICAgICAgICAgICAgZGVmLmZ1bmN0aW9uSWQsXHJcbiAgICAgICAgICAgIGRlZixcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICh0aGlzLnB0aHJlYWQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB3b3JrZXIgb2YgWy4uLnRoaXMucHRocmVhZC5ydW5uaW5nV29ya2VycywgLi4udGhpcy5wdGhyZWFkLnVudXNlZFdvcmtlcnNdKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3JlZ2lzdGVyVURGRnVuY3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHVkZjogZGVmLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFByZXBhcmUgYSBzdGF0ZW1lbnQgYW5kIHJldHVybiBpdHMgaWRlbnRpZmllciAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVByZXBhcmVkKGNvbm46IG51bWJlciwgdGV4dDogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBjbG9zZVByZXBhcmVkKGNvbm46IG51bWJlciwgc3RhdGVtZW50OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2UnLCBbJ251bWJlcicsICdudW1iZXInXSwgW2Nvbm4sIHN0YXRlbWVudF0pO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEV4ZWN1dGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgYW5kIHJldHVybiB0aGUgZnVsbCByZXN1bHQgKi9cclxuICAgIHB1YmxpYyBydW5QcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogVWludDhBcnJheSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9wcmVwYXJlZF9ydW4nLFxyXG4gICAgICAgICAgICBbJ251bWJlcicsICdudW1iZXInLCAnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnQsIEpTT04uc3RyaW5naWZ5KHBhcmFtcyldLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFeGVjdXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50IGFuZCBzdHJlYW0gdGhlIHJlc3VsdCAqL1xyXG4gICAgcHVibGljIHNlbmRQcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogVWludDhBcnJheSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kJyxcclxuICAgICAgICAgICAgWydudW1iZXInLCAnbnVtYmVyJywgJ3N0cmluZyddLFxyXG4gICAgICAgICAgICBbY29ubiwgc3RhdGVtZW50LCBKU09OLnN0cmluZ2lmeShwYXJhbXMpXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gY29weUJ1ZmZlcih0aGlzLm1vZCwgZCwgbik7XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IHJlY29yZCBiYXRjaGVzIGZyb20gYW4gYXJyb3cgaXBjIHN0cmVhbSAqL1xyXG4gICAgcHVibGljIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShjb25uOiBudW1iZXIsIGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEFycm93SW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IDApIHJldHVybjtcclxuICAgICAgICAvLyBTdG9yZSBidWZmZXJcclxuICAgICAgICBjb25zdCBidWZmZXJQdHIgPSB0aGlzLm1vZC5fbWFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlck9mcyA9IHRoaXMubW9kLkhFQVBVOC5zdWJhcnJheShidWZmZXJQdHIsIGJ1ZmZlclB0ciArIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGJ1ZmZlck9mcy5zZXQoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCBvcHRKU09OID0gb3B0aW9ucyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpIDogJyc7XHJcblxyXG4gICAgICAgIC8vIENhbGwgd2FzbSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxyXG4gICAgICAgICAgICB0aGlzLm1vZCxcclxuICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbScsXHJcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgIFtjb25uLCBidWZmZXJQdHIsIGJ1ZmZlci5sZW5ndGgsIG9wdEpTT05dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IGNzdiBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBpbnNlcnRDU1ZGcm9tUGF0aChjb25uOiBudW1iZXIsIHBhdGg6IHN0cmluZywgb3B0aW9uczogQ1NWSW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIC8vIFN0cmluZ2lmeSBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sdW1uc0ZsYXQgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG9wdGlvbnMuY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdC5wdXNoKGFycm93VG9TUUxGaWVsZChrLCBvcHRpb25zLmNvbHVtbnNba10pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHQgPSB7IC4uLm9wdGlvbnMgfSBhcyBhbnk7XHJcbiAgICAgICAgb3B0LmNvbHVtbnMgPSBvcHQuY29sdW1uc0ZsYXQ7XHJcbiAgICAgICAgZGVsZXRlIG9wdC5jb2x1bW5zRmxhdDtcclxuICAgICAgICBjb25zdCBvcHRKU09OID0gSlNPTi5zdHJpbmdpZnkob3B0KTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCB3YXNtIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aCcsXHJcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ3N0cmluZycsICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdEpTT05dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnQganNvbiBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBpbnNlcnRKU09ORnJvbVBhdGgoY29ubjogbnVtYmVyLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IEpTT05JbnNlcnRPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgLy8gU3RyaW5naWZ5IG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2x1bW5zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbHVtbnNGbGF0LnB1c2goYXJyb3dUb1NRTEZpZWxkKGssIG9wdGlvbnMuY29sdW1uc1trXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdCA9IHsgLi4ub3B0aW9ucyB9IGFzIGFueTtcclxuICAgICAgICBvcHQuY29sdW1ucyA9IG9wdC5jb2x1bW5zRmxhdDtcclxuICAgICAgICBkZWxldGUgb3B0LmNvbHVtbnNGbGF0O1xyXG4gICAgICAgIGNvbnN0IG9wdEpTT04gPSBKU09OLnN0cmluZ2lmeShvcHQpO1xyXG5cclxuICAgICAgICAvLyBDYWxsIHdhc20gZnVuY3Rpb25cclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcclxuICAgICAgICAgICAgdGhpcy5tb2QsXHJcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aCcsXHJcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ3N0cmluZycsICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdEpTT05dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBHbG9iIGZpbGUgaW5mb3MgKi9cclxuICAgIHB1YmxpYyBnbG9iRmlsZXMocGF0aDogc3RyaW5nKTogV2ViRmlsZVtdIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zJywgWydzdHJpbmcnXSwgW3BhdGhdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZm9TdHIgPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShpbmZvU3RyKSBhcyBXZWJGaWxlW107XHJcbiAgICAgICAgaWYgKGluZm8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlZ2lzdGVyIGEgZmlsZSBvYmplY3QgVVJMICovXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJGaWxlVVJMKG5hbWU6IHN0cmluZywgdXJsOiBzdHJpbmcsIHByb3RvOiBEdWNrREJEYXRhUHJvdG9jb2wsIGRpcmVjdElPID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdXJsID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybCcsXHJcbiAgICAgICAgICAgIFsnc3RyaW5nJywgJ3N0cmluZyddLFxyXG4gICAgICAgICAgICBbbmFtZSwgdXJsLCBwcm90bywgZGlyZWN0SU9dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgIH1cclxuICAgIC8qKiBSZWdpc3RlciBmaWxlIHRleHQgKi9cclxuICAgIHB1YmxpYyByZWdpc3RlckZpbGVUZXh0KG5hbWU6IHN0cmluZywgdGV4dDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gVEVYVF9FTkNPREVSLmVuY29kZSh0ZXh0KTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmlsZUJ1ZmZlcihuYW1lLCBidWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlZ2lzdGVyIGEgZmlsZSBidWZmZXIgKi9cclxuICAgIHB1YmxpYyByZWdpc3RlckZpbGVCdWZmZXIobmFtZTogc3RyaW5nLCBidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLm1vZC5fbWFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGRzdCA9IHRoaXMubW9kLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGRzdC5zZXQoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcclxuICAgICAgICAgICAgdGhpcy5tb2QsXHJcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyJyxcclxuICAgICAgICAgICAgWydzdHJpbmcnLCAnbnVtYmVyJywgJ251bWJlciddLFxyXG4gICAgICAgICAgICBbbmFtZSwgcHRyLCBidWZmZXIubGVuZ3RoXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmVnaXN0ZXIgYSBmaWxlIG9iamVjdCBVUkwgKi9cclxuICAgIHB1YmxpYyByZWdpc3RlckZpbGVIYW5kbGU8SGFuZGxlVHlwZT4oXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGhhbmRsZTogSGFuZGxlVHlwZSxcclxuICAgICAgICBwcm90b2NvbDogRHVja0RCRGF0YVByb3RvY29sLFxyXG4gICAgICAgIGRpcmVjdElPOiBib29sZWFuLFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybCcsXHJcbiAgICAgICAgICAgIFsnc3RyaW5nJywgJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddLFxyXG4gICAgICAgICAgICBbbmFtZSwgbmFtZSwgcHJvdG9jb2wsIGRpcmVjdElPXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICAgICAgZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5fZmlsZXMgPSAoZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5fZmlsZXMgfHwgbmV3IE1hcCgpKS5zZXQobmFtZSwgaGFuZGxlKTtcclxuICAgICAgICBpZiAodGhpcy5wdGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIHRoaXMucHRocmVhZC5ydW5uaW5nV29ya2Vycykge1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdyZWdpc3RlckZpbGVIYW5kbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVIYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIHRoaXMucHRocmVhZC51bnVzZWRXb3JrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ2Ryb3BGaWxlSGFuZGxlJyxcclxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIERyb3AgZmlsZSAqL1xyXG4gICAgcHVibGljIGRyb3BGaWxlKG5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9mc19kcm9wX2ZpbGUnLCBbJ3N0cmluZyddLCBbbmFtZV0pO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICB9XHJcbiAgICAvKiogRHJvcCBmaWxlcyAqL1xyXG4gICAgcHVibGljIGRyb3BGaWxlcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlcycsIFtdLCBbXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgIH1cclxuICAgIC8qKiBGbHVzaCBhbGwgZmlsZXMgKi9cclxuICAgIHB1YmxpYyBmbHVzaEZpbGVzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzJywgbnVsbCwgW10sIFtdKTtcclxuICAgIH1cclxuICAgIC8qKiBXcml0ZSBhIGZpbGUgdG8gYSBwYXRoICovXHJcbiAgICBwdWJsaWMgY29weUZpbGVUb1BhdGgobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGgnLCBbJ3N0cmluZycsICdzdHJpbmcnXSwgW25hbWUsIHBhdGhdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xyXG4gICAgfVxyXG4gICAgLyoqIFdyaXRlIGEgZmlsZSB0byBhIGJ1ZmZlciAqL1xyXG4gICAgcHVibGljIGNvcHlGaWxlVG9CdWZmZXIobmFtZTogc3RyaW5nKTogVWludDhBcnJheSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXInLCBbJ3N0cmluZyddLCBbbmFtZV0pO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5tb2QuSEVBUFU4LnN1YmFycmF5KGQsIGQgKyBuKTtcclxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQoYnVmZmVyKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5hYmxlIHRyYWNraW5nIG9mIGZpbGUgc3RhdGlzdGljcyAqL1xyXG4gICAgcHVibGljIGNvbGxlY3RGaWxlU3RhdGlzdGljcyhmaWxlOiBzdHJpbmcsIGVuYWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHMnLCBbJ3N0cmluZycsICdib29sZWFuJ10sIFtmaWxlLCBlbmFibGVdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEV4cG9ydCBmaWxlIHN0YXRpc3RpY3MgKi9cclxuICAgIHB1YmxpYyBleHBvcnRGaWxlU3RhdGlzdGljcyhmaWxlOiBzdHJpbmcpOiBGaWxlU3RhdGlzdGljcyB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzJywgWydzdHJpbmcnXSwgW2ZpbGVdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmlsZVN0YXRpc3RpY3ModGhpcy5tb2QuSEVBUFU4LnN1YmFycmF5KGQsIGQgKyBuKSk7XHJcbiAgICB9XHJcbn1cclxuIiwgImV4cG9ydCBlbnVtIExvZ0xldmVsIHtcclxuICAgIE5PTkUgPSAwLFxyXG4gICAgREVCVUcgPSAxLFxyXG4gICAgSU5GTyA9IDIsXHJcbiAgICBXQVJOSU5HID0gMyxcclxuICAgIEVSUk9SID0gNCxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTG9nVG9waWMge1xyXG4gICAgTk9ORSA9IDAsXHJcbiAgICBDT05ORUNUID0gMSxcclxuICAgIERJU0NPTk5FQ1QgPSAyLFxyXG4gICAgT1BFTiA9IDMsXHJcbiAgICBRVUVSWSA9IDQsXHJcbiAgICBJTlNUQU5USUFURSA9IDUsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIExvZ0V2ZW50IHtcclxuICAgIE5PTkUgPSAwLFxyXG4gICAgT0sgPSAxLFxyXG4gICAgRVJST1IgPSAyLFxyXG4gICAgU1RBUlQgPSAzLFxyXG4gICAgUlVOID0gNCxcclxuICAgIENBUFRVUkUgPSA1LFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBMb2dPcmlnaW4ge1xyXG4gICAgTk9ORSA9IDAsXHJcbiAgICBXRUJfV09SS0VSID0gMSxcclxuICAgIE5PREVfV09SS0VSID0gMixcclxuICAgIEJJTkRJTkdTID0gMyxcclxuICAgIEFTWU5DX0RVQ0tEQiA9IDQsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIExvZ0VudHJ5PE8sIFQsIEUsIFY+ID0ge1xyXG4gICAgcmVhZG9ubHkgdGltZXN0YW1wOiBEYXRlO1xyXG4gICAgcmVhZG9ubHkgbGV2ZWw6IExvZ0xldmVsO1xyXG4gICAgcmVhZG9ubHkgb3JpZ2luOiBPO1xyXG4gICAgcmVhZG9ubHkgdG9waWM6IFQ7XHJcbiAgICByZWFkb25seSBldmVudDogRTtcclxuICAgIHJlYWRvbmx5IHZhbHVlOiBWO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTG9nRW50cnlWYXJpYW50ID1cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5JTlNUQU5USUFURSwgTG9nRXZlbnQuRVJST1IsIHN0cmluZz5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5RVUVSWSwgTG9nRXZlbnQuU1RBUlQsIHZvaWQ+XHJcbiAgICB8IExvZ0VudHJ5PExvZ09yaWdpbi5CSU5ESU5HUywgTG9nVG9waWMuUVVFUlksIExvZ0V2ZW50Lk9LLCB2b2lkPlxyXG4gICAgfCBMb2dFbnRyeTxMb2dPcmlnaW4uQklORElOR1MsIExvZ1RvcGljLlFVRVJZLCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5DT05ORUNULCBMb2dFdmVudC5PSywgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5DT05ORUNULCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5ESVNDT05ORUNULCBMb2dFdmVudC5PSywgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5ESVNDT05ORUNULCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5TVEFSVCwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5PSywgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkFTWU5DX0RVQ0tEQiwgTG9nVG9waWMuUVVFUlksIExvZ0V2ZW50LlJVTiwgc3RyaW5nPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyIHtcclxuICAgIGxvZyhlbnRyeTogTG9nRW50cnlWYXJpYW50KTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFZvaWRMb2dnZXIgaW1wbGVtZW50cyBMb2dnZXIge1xyXG4gICAgcHVibGljIGxvZyhfZW50cnk6IExvZ0VudHJ5VmFyaWFudCk6IHZvaWQge31cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENvbnNvbGVMb2dnZXIgaW1wbGVtZW50cyBMb2dnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk8pIHt9XHJcbiAgICBwdWJsaWMgbG9nKGVudHJ5OiBMb2dFbnRyeVZhcmlhbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50cnkubGV2ZWwgPj0gdGhpcy5sZXZlbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9nTGV2ZWxMYWJlbChsZXZlbDogTG9nTGV2ZWwpOiBzdHJpbmcge1xyXG4gICAgc3dpdGNoIChsZXZlbCkge1xyXG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuTk9ORTpcclxuICAgICAgICAgICAgcmV0dXJuICdOT05FJztcclxuICAgICAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0RFQlVHJztcclxuICAgICAgICBjYXNlIExvZ0xldmVsLklORk86XHJcbiAgICAgICAgICAgIHJldHVybiAnSU5GTyc7XHJcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5XQVJOSU5HOlxyXG4gICAgICAgICAgICByZXR1cm4gJ1dBUk5JTkcnO1xyXG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XHJcbiAgICAgICAgICAgIHJldHVybiAnRVJST1InO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnPyc7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dFdmVudExhYmVsKGV2ZW50OiBMb2dFdmVudCk6IHN0cmluZyB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50KSB7XHJcbiAgICAgICAgY2FzZSBMb2dFdmVudC5OT05FOlxyXG4gICAgICAgICAgICByZXR1cm4gJ05PTkUnO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuT0s6XHJcbiAgICAgICAgICAgIHJldHVybiAnT0snO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuRVJST1I6XHJcbiAgICAgICAgICAgIHJldHVybiAnRVJST1InO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuU1RBUlQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnU1RBUlQnO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuUlVOOlxyXG4gICAgICAgICAgICByZXR1cm4gJ1JVTic7XHJcbiAgICAgICAgY2FzZSBMb2dFdmVudC5DQVBUVVJFOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0NBUFRVUkUnO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnPyc7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dUb3BpY0xhYmVsKHRvcGljOiBMb2dUb3BpYyk6IHN0cmluZyB7XHJcbiAgICBzd2l0Y2ggKHRvcGljKSB7XHJcbiAgICAgICAgY2FzZSBMb2dUb3BpYy5DT05ORUNUOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0NPTk5FQ1QnO1xyXG4gICAgICAgIGNhc2UgTG9nVG9waWMuRElTQ09OTkVDVDpcclxuICAgICAgICAgICAgcmV0dXJuICdESVNDT05ORUNUJztcclxuICAgICAgICBjYXNlIExvZ1RvcGljLklOU1RBTlRJQVRFOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0lOU1RBTlRJQVRFJztcclxuICAgICAgICBjYXNlIExvZ1RvcGljLk9QRU46XHJcbiAgICAgICAgICAgIHJldHVybiAnT1BFTic7XHJcbiAgICAgICAgY2FzZSBMb2dUb3BpYy5RVUVSWTpcclxuICAgICAgICAgICAgcmV0dXJuICdRVUVSWSc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuICc/JztcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ09yaWdpbkxhYmVsKG9yaWdpbjogTG9nT3JpZ2luKTogc3RyaW5nIHtcclxuICAgIHN3aXRjaCAob3JpZ2luKSB7XHJcbiAgICAgICAgY2FzZSBMb2dPcmlnaW4uTk9ORTpcclxuICAgICAgICAgICAgcmV0dXJuICdOT05FJztcclxuICAgICAgICBjYXNlIExvZ09yaWdpbi5XRUJfV09SS0VSOlxyXG4gICAgICAgICAgICByZXR1cm4gJ1dFQiBXT1JLRVInO1xyXG4gICAgICAgIGNhc2UgTG9nT3JpZ2luLk5PREVfV09SS0VSOlxyXG4gICAgICAgICAgICByZXR1cm4gJ05PREUgV09SS0VSJztcclxuICAgICAgICBjYXNlIExvZ09yaWdpbi5CSU5ESU5HUzpcclxuICAgICAgICAgICAgcmV0dXJuICdEVUNLREIgQklORElOR1MnO1xyXG4gICAgICAgIGNhc2UgTG9nT3JpZ2luLkFTWU5DX0RVQ0tEQjpcclxuICAgICAgICAgICAgcmV0dXJuICdEVUNLREInO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnPyc7XHJcbiAgICB9XHJcbn1cclxuIiwgImV4cG9ydCBjb25zdCBiaWdJbnQ9KCk9Pihhc3luYyBlPT57dHJ5e3JldHVybihhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlKSkuaW5zdGFuY2UuZXhwb3J0cy5iKEJpZ0ludCgwKSk9PT1CaWdJbnQoMCl9Y2F0Y2goZSl7cmV0dXJuITF9fSkobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNiwxLDk2LDEsMTI2LDEsMTI2LDMsMiwxLDAsNyw1LDEsMSw5OCwwLDAsMTAsNiwxLDQsMCwzMiwwLDExXSkpLGJ1bGtNZW1vcnk9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsMywxLDAsMSwxMCwxNCwxLDEyLDAsNjUsMCw2NSwwLDY1LDAsMjUyLDEwLDAsMCwxMV0pKSxleGNlcHRpb25zPWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCw4LDEsNiwwLDYsNjQsMjUsMTEsMTFdKSksZXh0ZW5kZWRDb25zdD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsNSwzLDEsMCwxLDExLDksMSwwLDY1LDEsNjUsMiwxMDYsMTEsMF0pKSxnYz1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSwxMCwyLDk1LDEsMTI1LDAsOTYsMCwxLDEwNywwLDMsMiwxLDEsMTAsMTIsMSwxMCwwLDY3LDAsMCwwLDAsMjUxLDcsMCwxMV0pKSxtZW1vcnk2ND1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsNSwzLDEsNCwxXSkpLG11bHRpVmFsdWU9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNiwxLDk2LDAsMiwxMjcsMTI3LDMsMiwxLDAsMTAsOCwxLDYsMCw2NSwwLDY1LDAsMTFdKSksbXV0YWJsZUdsb2JhbHM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDIsOCwxLDEsOTcsMSw5OCwzLDEyNywxLDYsNiwxLDEyNywxLDY1LDAsMTEsNyw1LDEsMSw5NywzLDFdKSkscmVmZXJlbmNlVHlwZXM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDcsMSw1LDAsMjA4LDExMiwyNiwxMV0pKSxyZWxheGVkU2ltZD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw1LDEsOTYsMCwxLDEyMywzLDIsMSwwLDEwLDE1LDEsMTMsMCw2NSwxLDI1MywxNSw2NSwyLDI1MywxNSwyNTMsMTI4LDIsMTFdKSksc2F0dXJhdGVkRmxvYXRUb0ludD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMTIsMSwxMCwwLDY3LDAsMCwwLDAsMjUyLDAsMjYsMTFdKSksc2lnbkV4dGVuc2lvbnM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDgsMSw2LDAsNjUsMCwxOTIsMjYsMTFdKSksc2ltZD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw1LDEsOTYsMCwxLDEyMywzLDIsMSwwLDEwLDEwLDEsOCwwLDY1LDAsMjUzLDE1LDI1Myw5OCwxMV0pKSxzdHJlYW1pbmdDb21waWxhdGlvbj0oKT0+KGFzeW5jKCk9PlwiY29tcGlsZVN0cmVhbWluZ1wiaW4gV2ViQXNzZW1ibHkpKCksdGFpbENhbGw9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDYsMSw0LDAsMTgsMCwxMV0pKSx0aHJlYWRzPSgpPT4oYXN5bmMgZT0+e3RyeXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgTWVzc2FnZUNoYW5uZWwmJihuZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUoZSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKTtcbiIsICJpbXBvcnQgKiBhcyBjaGVjayBmcm9tICd3YXNtLWZlYXR1cmUtZGV0ZWN0JztcclxuaW1wb3J0IHsgUEFDS0FHRV9OQU1FLCBQQUNLQUdFX1ZFUlNJT04gfSBmcm9tICcuL3ZlcnNpb24nO1xyXG5cclxuLy8gUGxhdGZvcm0gY2hlY2sgdGFrZW4gZnJvbSBoZXJlOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20veHRlcm1qcy94dGVybS5qcy9ibG9iL21hc3Rlci9zcmMvY29tbW9uL1BsYXRmb3JtLnRzI0wyMVxyXG5cclxuaW50ZXJmYWNlIElOYXZpZ2F0b3Ige1xyXG4gICAgdXNlckFnZW50OiBzdHJpbmc7XHJcbiAgICBsYW5ndWFnZTogc3RyaW5nO1xyXG4gICAgcGxhdGZvcm06IHN0cmluZztcclxufVxyXG5cclxuLy8gV2UncmUgZGVjbGFyaW5nIGEgbmF2aWdhdG9yIGdsb2JhbCBoZXJlIGFzIHdlIGV4cGVjdCBpdCBpbiBhbGwgcnVudGltZXMgKG5vZGUgYW5kIGJyb3dzZXIpLCBidXRcclxuLy8gd2Ugd2FudCB0aGlzIG1vZHVsZSB0byBsaXZlIGluIGNvbW1vbi5cclxuZGVjbGFyZSBjb25zdCBuYXZpZ2F0b3I6IElOYXZpZ2F0b3I7XHJcblxyXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGZhbHNlKTtcclxuY29uc3QgdXNlckFnZW50ID0gKCkgPT4gKGlzTm9kZSgpID8gJ25vZGUnIDogbmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSAoKSA9PiB1c2VyQWdlbnQoKS5pbmNsdWRlcygnRmlyZWZveCcpO1xyXG5leHBvcnQgY29uc3QgaXNTYWZhcmkgPSAoKSA9PiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCgpKTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCQnVuZGxlcyB7XHJcbiAgICBtdnA6IHtcclxuICAgICAgICBtYWluTW9kdWxlOiBzdHJpbmc7XHJcbiAgICAgICAgbWFpbldvcmtlcjogc3RyaW5nO1xyXG4gICAgfTtcclxuICAgIGVoPzoge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IHN0cmluZztcclxuICAgICAgICBtYWluV29ya2VyOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgY29pPzoge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IHN0cmluZztcclxuICAgICAgICBtYWluV29ya2VyOiBzdHJpbmc7XHJcbiAgICAgICAgcHRocmVhZFdvcmtlcjogc3RyaW5nO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEpzRGVsaXZyQnVuZGxlcygpOiBEdWNrREJCdW5kbGVzIHtcclxuICAgIGNvbnN0IGpzZGVsaXZyX2Rpc3RfdXJsID0gYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vJHtQQUNLQUdFX05BTUV9QCR7UEFDS0FHRV9WRVJTSU9OfS9kaXN0L2A7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG12cDoge1xyXG4gICAgICAgICAgICBtYWluTW9kdWxlOiBgJHtqc2RlbGl2cl9kaXN0X3VybH1kdWNrZGItbXZwLndhc21gLFxyXG4gICAgICAgICAgICBtYWluV29ya2VyOiBgJHtqc2RlbGl2cl9kaXN0X3VybH1kdWNrZGItYnJvd3Nlci1tdnAud29ya2VyLmpzYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVoOiB7XHJcbiAgICAgICAgICAgIG1haW5Nb2R1bGU6IGAke2pzZGVsaXZyX2Rpc3RfdXJsfWR1Y2tkYi1laC53YXNtYCxcclxuICAgICAgICAgICAgbWFpbldvcmtlcjogYCR7anNkZWxpdnJfZGlzdF91cmx9ZHVja2RiLWJyb3dzZXItZWgud29ya2VyLmpzYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIENPSSBpcyBzdGlsbCBleHBlcmltZW50YWwsIGxldCB0aGUgdXNlciBvcHQgaW4gZXhwbGljaXRseVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEdWNrREJCdW5kbGUge1xyXG4gICAgbWFpbk1vZHVsZTogc3RyaW5nO1xyXG4gICAgbWFpbldvcmtlcjogc3RyaW5nIHwgbnVsbDtcclxuICAgIHB0aHJlYWRXb3JrZXI6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGxhdGZvcm1GZWF0dXJlcyB7XHJcbiAgICBiaWdJbnQ2NEFycmF5OiBib29sZWFuO1xyXG4gICAgY3Jvc3NPcmlnaW5Jc29sYXRlZDogYm9vbGVhbjtcclxuICAgIHdhc21FeGNlcHRpb25zOiBib29sZWFuO1xyXG4gICAgd2FzbVNJTUQ6IGJvb2xlYW47XHJcbiAgICB3YXNtQnVsa01lbW9yeTogYm9vbGVhbjtcclxuICAgIHdhc21UaHJlYWRzOiBib29sZWFuO1xyXG59XHJcblxyXG5sZXQgYmlnSW50NjRBcnJheTogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xyXG5sZXQgd2FzbUV4Y2VwdGlvbnM6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxubGV0IHdhc21UaHJlYWRzOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XHJcbmxldCB3YXNtU0lNRDogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xyXG5sZXQgd2FzbUJ1bGtNZW1vcnk6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXHJcbmRlY2xhcmUgbmFtZXNwYWNlIGdsb2JhbFRoaXMge1xyXG4gICAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQbGF0Zm9ybUZlYXR1cmVzKCk6IFByb21pc2U8UGxhdGZvcm1GZWF0dXJlcz4ge1xyXG4gICAgaWYgKGJpZ0ludDY0QXJyYXkgPT0gbnVsbCkge1xyXG4gICAgICAgIGJpZ0ludDY0QXJyYXkgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPSAndW5kZWZpbmVkJztcclxuICAgIH1cclxuICAgIGlmICh3YXNtRXhjZXB0aW9ucyA9PSBudWxsKSB7XHJcbiAgICAgICAgd2FzbUV4Y2VwdGlvbnMgPSBhd2FpdCBjaGVjay5leGNlcHRpb25zKCk7XHJcbiAgICB9XHJcbiAgICBpZiAod2FzbVRocmVhZHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHdhc21UaHJlYWRzID0gYXdhaXQgY2hlY2sudGhyZWFkcygpO1xyXG4gICAgfVxyXG4gICAgaWYgKHdhc21TSU1EID09IG51bGwpIHtcclxuICAgICAgICB3YXNtU0lNRCA9IGF3YWl0IGNoZWNrLnNpbWQoKTtcclxuICAgIH1cclxuICAgIGlmICh3YXNtQnVsa01lbW9yeSA9PSBudWxsKSB7XHJcbiAgICAgICAgd2FzbUJ1bGtNZW1vcnkgPSBhd2FpdCBjaGVjay5idWxrTWVtb3J5KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJpZ0ludDY0QXJyYXk6IGJpZ0ludDY0QXJyYXkhLFxyXG4gICAgICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWQ6IGlzTm9kZSgpIHx8IGdsb2JhbFRoaXMuY3Jvc3NPcmlnaW5Jc29sYXRlZCB8fCBmYWxzZSxcclxuICAgICAgICB3YXNtRXhjZXB0aW9uczogd2FzbUV4Y2VwdGlvbnMhLFxyXG4gICAgICAgIHdhc21TSU1EOiB3YXNtU0lNRCEsXHJcbiAgICAgICAgd2FzbVRocmVhZHM6IHdhc21UaHJlYWRzISxcclxuICAgICAgICB3YXNtQnVsa01lbW9yeTogd2FzbUJ1bGtNZW1vcnkhLFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbGVjdEJ1bmRsZShidW5kbGVzOiBEdWNrREJCdW5kbGVzKTogUHJvbWlzZTxEdWNrREJCdW5kbGU+IHtcclxuICAgIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZ2V0UGxhdGZvcm1GZWF0dXJlcygpO1xyXG4gICAgaWYgKHBsYXRmb3JtLndhc21FeGNlcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHBsYXRmb3JtLndhc21TSU1EICYmIHBsYXRmb3JtLndhc21UaHJlYWRzICYmIHBsYXRmb3JtLmNyb3NzT3JpZ2luSXNvbGF0ZWQgJiYgYnVuZGxlcy5jb2kpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1haW5Nb2R1bGU6IGJ1bmRsZXMuY29pLm1haW5Nb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBtYWluV29ya2VyOiBidW5kbGVzLmNvaS5tYWluV29ya2VyLFxyXG4gICAgICAgICAgICAgICAgcHRocmVhZFdvcmtlcjogYnVuZGxlcy5jb2kucHRocmVhZFdvcmtlcixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1bmRsZXMuZWgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1haW5Nb2R1bGU6IGJ1bmRsZXMuZWgubWFpbk1vZHVsZSxcclxuICAgICAgICAgICAgICAgIG1haW5Xb3JrZXI6IGJ1bmRsZXMuZWgubWFpbldvcmtlcixcclxuICAgICAgICAgICAgICAgIHB0aHJlYWRXb3JrZXI6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYWluTW9kdWxlOiBidW5kbGVzLm12cC5tYWluTW9kdWxlLFxyXG4gICAgICAgIG1haW5Xb3JrZXI6IGJ1bmRsZXMubXZwLm1haW5Xb3JrZXIsXHJcbiAgICAgICAgcHRocmVhZFdvcmtlcjogbnVsbCxcclxuICAgIH07XHJcbn1cclxuIiwgImltcG9ydCB7UzNDb25maWd9IGZyb20gXCIuLi9iaW5kaW5nc1wiO1xyXG5pbXBvcnQge3NoYTI1Nn0gZnJvbSBcImpzLXNoYTI1NlwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTM1BhcmFtcyB7XHJcbiAgICB1cmw6IHN0cmluZyxcclxuICAgIHF1ZXJ5OiBzdHJpbmcsXHJcbiAgICBob3N0OiBzdHJpbmcsXHJcbiAgICByZWdpb246IHN0cmluZyxcclxuICAgIHNlcnZpY2U6IHN0cmluZyxcclxuICAgIG1ldGhvZDogc3RyaW5nLFxyXG4gICAgYWNjZXNzS2V5SWQ6IHN0cmluZyxcclxuICAgIHNlY3JldEFjY2Vzc0tleTogc3RyaW5nLFxyXG4gICAgc2Vzc2lvblRva2VuOiBzdHJpbmcsXHJcbiAgICBkYXRlTm93OiBzdHJpbmcsXHJcbiAgICBkYXRldGltZU5vdzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUzNQYXlsb2FkUGFyYW1zIHtcclxuICAgIGNvbnRlbnRIYXNoOiBzdHJpbmcgfCBudWxsLFxyXG4gICAgY29udGVudFR5cGU6IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuY29uc3QgZ2V0SFRUUEhvc3QgPSBmdW5jdGlvbiAoY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZywgYnVja2V0IDogc3RyaW5nKSA6IHN0cmluZyB7XHJcbiAgICBpZiAoY29uZmlnPy5lbmRwb2ludD8uc3RhcnRzV2l0aChcImh0dHBcIikpIHtcclxuICAgICAgICAvLyBFbmRwb2ludCBpcyBhIGZ1bGwgdXJsLCB3ZSBhcHBlbmQgdGhlIGJ1Y2tldFxyXG4gICAgICAgIGNvbnN0IGh0dHBIb3N0ID0gYCR7Y29uZmlnPy5lbmRwb2ludH1gO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGh0dHBIb3N0LmluZGV4T2YoXCI6Ly9cIikrMztcclxuICAgICAgICByZXR1cm4gaHR0cEhvc3Quc3Vic3RyaW5nKG9mZnNldCk7XHJcbiAgICB9IGVsc2UgaWYgKGNvbmZpZz8uZW5kcG9pbnQpIHtcclxuICAgICAgICAvLyBFbmRwb2ludCBpcyBub3QgYSBmdWxsIHVybCBhbmQgdGhlIGh0dHBzOi8ve2J1Y2tldH0ue2RvbWFpbn0gZm9ybWF0IHdpbGwgYmUgdXNlZFxyXG4gICAgICAgIHJldHVybiBgJHtidWNrZXR9LiR7Y29uZmlnPy5lbmRwb2ludH1gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBEZWZhdWx0IGF3cyBzMyB1cmxcclxuICAgICAgICByZXR1cm4gYCR7YnVja2V0fS5zMy5hbWF6b25hd3MuY29tYDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFMzUGFyYW1zIChjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCwgdXJsOiBzdHJpbmcsIG1ldGhvZCA6IHN0cmluZykgOiBTM1BhcmFtcyB7XHJcbiAgICBjb25zdCBwYXJzZWRTM1VybCA9IHBhcnNlUzNVcmwodXJsKTtcclxuXHJcbiAgICAvLyB3aGVuIHVzaW5nIFMzIHBhdGgtc3R5bGUgYWNjZXNzLCB0aGUgc2lnbmVkIFVSTCBzaG91bGQgYWxzbyBpbmNsdWRlIHRoZSBidWNrZXQgbmFtZSwgXHJcbiAgICAvLyAgYXMgaXQgaXMgcHJlc2VudCBpbiB0aGUgSFRUUCBVUkwgcGF0aC5cclxuICAgIC8vIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvYWNjZXNzLWJ1Y2tldC1pbnRyby5odG1sI3BhdGgtc3R5bGUtdXJsLWV4XHJcbiAgICBsZXQgcGF0aCA9ICBwYXJzZWRTM1VybC5wYXRoO1xyXG4gICAgaWYgKGlzUGF0aFN0eWxlQWNjZXNzKGNvbmZpZykpIHtcclxuICAgICAgICBwYXRoID0gYC8ke3BhcnNlZFMzVXJsLmJ1Y2tldH0ke3BhdGh9YDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXJsOiBwYXRoLFxyXG4gICAgICAgIHF1ZXJ5OiBcIlwiLFxyXG4gICAgICAgIGhvc3Q6IGdldEhUVFBIb3N0KGNvbmZpZywgdXJsLCBwYXJzZWRTM1VybC5idWNrZXQpLFxyXG4gICAgICAgIHJlZ2lvbjogKGNvbmZpZz8ucmVnaW9uKSA/PyBcIlwiLFxyXG4gICAgICAgIHNlcnZpY2U6IFwiczNcIixcclxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICBhY2Nlc3NLZXlJZDogKGNvbmZpZz8uYWNjZXNzS2V5SWQpID8/IFwiXCIsXHJcbiAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAoY29uZmlnPy5zZWNyZXRBY2Nlc3NLZXkpID8/IFwiXCIsXHJcbiAgICAgICAgc2Vzc2lvblRva2VuOiAoY29uZmlnPy5zZXNzaW9uVG9rZW4pID8/IFwiXCIsXHJcbiAgICAgICAgZGF0ZU5vdzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoLy0vZywnJykuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgICBkYXRldGltZU5vdzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoLy0vZywnJykucmVwbGFjZSgvOi9nLCcnKS5zcGxpdCgnLicpWzBdKyAnWicsXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXJpRW5jb2RlKGlucHV0IDogc3RyaW5nLCBlbmNvZGVfc2xhc2ggPSBmYWxzZSkge1xyXG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC9BUEkvc2lndjQtcXVlcnktc3RyaW5nLWF1dGguaHRtbFxyXG5cclxuICAgIGNvbnN0IGhleERpZ2l0ID0gXCIwMTIzNDU2Nzg5QUJDREVGXCI7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2ggOiBzdHJpbmcgPSBpbnB1dFtpXTtcclxuXHJcbiAgICAgICAgaWYgKChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fCAoY2ggPj0gJ2EnICYmIGNoIDw9ICd6JykgfHwgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHx8IGNoID09ICdfJyB8fFxyXG4gICAgICAgICAgICBjaCA9PSAnLScgfHwgY2ggPT0gJ34nIHx8IGNoID09ICcuJykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSAnLycpIHtcclxuICAgICAgICAgICAgaWYgKGVuY29kZV9zbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJTJGXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIlXCI7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBoZXhEaWdpdFtjaC5jaGFyQ29kZUF0KDApID4+IDRdO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gaGV4RGlnaXRbY2guY2hhckNvZGVBdCgwKSAmIDE1XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUzNIZWFkZXJzKHBhcmFtczogUzNQYXJhbXMsIHBheWxvYWRQYXJhbXMgOiBTM1BheWxvYWRQYXJhbXMgfCBudWxsID0gbnVsbCkgOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcclxuICAgIC8vIHRoaXMgaXMgdGhlIHNoYTI1NiBvZiB0aGUgZW1wdHkgc3RyaW5nLCBpdHMgdXNlZnVsIHNpbmNlIHdlIGhhdmUgbm8gcGF5bG9hZCBmb3IgR0VUIHJlcXVlc3RzXHJcbiAgICBjb25zdCBwYXlsb2FkSGFzaCA9IChwYXlsb2FkUGFyYW1zPy5jb250ZW50SGFzaCkgPz8gXCJlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1XCI7XHJcblxyXG4gICAgY29uc3QgcmVzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgIC8vIHJlcy5zZXQoXCJob3N0XCIsIHBhcmFtcy5ob3N0KVxyXG4gICAgcmVzLnNldChcIngtYW16LWRhdGVcIiwgcGFyYW1zLmRhdGV0aW1lTm93KTtcclxuICAgIHJlcy5zZXQoXCJ4LWFtei1jb250ZW50LXNoYTI1NlwiLCBwYXlsb2FkSGFzaCk7XHJcblxyXG4gICAgaWYgKHBhcmFtcy5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICByZXMuc2V0KFwieC1hbXotc2VjdXJpdHktdG9rZW5cIiwgcGFyYW1zLnNlc3Npb25Ub2tlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc3RydWN0IHN0cmluZyB0byBzaWduXHJcbiAgICBsZXQgc2lnbmVkSGVhZGVycyA9IFwiXCI7XHJcbiAgICBpZiAocGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGUpIHtcclxuICAgICAgICBzaWduZWRIZWFkZXJzICs9IFwiY29udGVudC10eXBlO1wiO1xyXG4gICAgfVxyXG4gICAgc2lnbmVkSGVhZGVycyArPSBcImhvc3Q7eC1hbXotY29udGVudC1zaGEyNTY7eC1hbXotZGF0ZVwiO1xyXG4gICAgaWYgKHBhcmFtcy5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICBzaWduZWRIZWFkZXJzICs9IFwiO3gtYW16LXNlY3VyaXR5LXRva2VuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhbm9uaWNhbFJlcXVlc3QgPSBwYXJhbXMubWV0aG9kICsgXCJcXG5cIiArIHVyaUVuY29kZShwYXJhbXMudXJsKSArIFwiXFxuXCIgKyBwYXJhbXMucXVlcnk7XHJcbiAgICBpZiAocGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGUpIHtcclxuICAgICAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxuY29udGVudC10eXBlOlwiICsgcGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxuaG9zdDpcIiArIHBhcmFtcy5ob3N0ICtcclxuICAgICAgICBcIlxcbngtYW16LWNvbnRlbnQtc2hhMjU2OlwiICsgcGF5bG9hZEhhc2ggKyBcIlxcbngtYW16LWRhdGU6XCIgKyBwYXJhbXMuZGF0ZXRpbWVOb3c7XHJcbiAgICBpZiAocGFyYW1zLnNlc3Npb25Ub2tlbiAmJiBwYXJhbXMuc2Vzc2lvblRva2VuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxueC1hbXotc2VjdXJpdHktdG9rZW46XCIgKyBwYXJhbXMuc2Vzc2lvblRva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbm9uaWNhbFJlcXVlc3QgKz0gXCJcXG5cXG5cIiArIHNpZ25lZEhlYWRlcnMgKyBcIlxcblwiICsgcGF5bG9hZEhhc2g7XHJcbiAgICBjb25zdCBjYW5vbmljYWxSZXF1ZXN0SGFzaFN0ciA9IHNoYTI1NihjYW5vbmljYWxSZXF1ZXN0KTtcclxuXHJcbiAgICBjb25zdCBzdHJpbmdUb1NpZ24gPSBcIkFXUzQtSE1BQy1TSEEyNTZcXG5cIiArIHBhcmFtcy5kYXRldGltZU5vdyArIFwiXFxuXCIgKyBwYXJhbXMuZGF0ZU5vdyArIFwiL1wiICsgcGFyYW1zLnJlZ2lvbiArIFwiL1wiICsgcGFyYW1zLnNlcnZpY2UgK1xyXG4gICAgICAgIFwiL2F3czRfcmVxdWVzdFxcblwiICsgY2Fub25pY2FsUmVxdWVzdEhhc2hTdHI7XHJcblxyXG4gICAgLy8gdHMtaWdub3JlJ3MgYmVjYXVzZSBsaWJyYXJ5IGNhbiBhY2NlcHQgYXJyYXkgYnVmZmVyIGFzIGtleSwgYnV0IFRTIGFyZyBpcyBpbmNvcnJlY3RcclxuICAgIGNvbnN0IHNpZ25LZXkgPSBcIkFXUzRcIiArIHBhcmFtcy5zZWNyZXRBY2Nlc3NLZXk7XHJcbiAgICBjb25zdCBrRGF0ZSA9IHNoYTI1Ni5obWFjLmFycmF5QnVmZmVyKHNpZ25LZXksIHBhcmFtcy5kYXRlTm93KTtcclxuXHJcbiAgICAvLyBOb3RlLCBqcy1zaGEyNTYgaGFzIGEgYnVnIGluIHRoZSBUUyBpbnRlcmZhY2UgdGhhdCBvbmx5IHN1cHBvcnRzIHN0cmluZ3MgYXMga2V5cywgd2hpbGUgd2UgbmVlZCBhIGJ5dGVhcnJheVxyXG4gICAgLy8gYXMga2V5LiBQUiBpcyBvcGVuIGJ1dCB1bm1lcmdlZDogaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEyNTYvcHVsbC8yNVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBjb25zdCBrUmVnaW9uID0gc2hhMjU2LmhtYWMuYXJyYXlCdWZmZXIoa0RhdGUsIHBhcmFtcy5yZWdpb24pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBjb25zdCBrU2VydmljZSA9IHNoYTI1Ni5obWFjLmFycmF5QnVmZmVyKGtSZWdpb24sIHBhcmFtcy5zZXJ2aWNlLCk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBzaGEyNTYuaG1hYy5hcnJheUJ1ZmZlcihrU2VydmljZSwgXCJhd3M0X3JlcXVlc3RcIik7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNoYTI1Ni5obWFjKHNpZ25pbmdLZXksIHN0cmluZ1RvU2lnbik7XHJcblxyXG4gICAgcmVzLnNldChcIkF1dGhvcml6YXRpb25cIiwgXCJBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9XCIgKyBwYXJhbXMuYWNjZXNzS2V5SWQgKyBcIi9cIiArIHBhcmFtcy5kYXRlTm93ICsgXCIvXCIgKyBwYXJhbXMucmVnaW9uICsgXCIvXCIgK1xyXG4gICAgICAgIHBhcmFtcy5zZXJ2aWNlICsgXCIvYXdzNF9yZXF1ZXN0LCBTaWduZWRIZWFkZXJzPVwiICsgc2lnbmVkSGVhZGVycyArXHJcbiAgICAgICAgXCIsIFNpZ25hdHVyZT1cIiArIHNpZ25hdHVyZSk7XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuY29uc3QgY3JlYXRlUzNIZWFkZXJzRnJvbVMzQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZyA6IFMzQ29uZmlnIHwgdW5kZWZpbmVkLCB1cmwgOiBzdHJpbmcsIG1ldGhvZCA6IHN0cmluZywgY29udGVudFR5cGU6IHN0cmluZyB8IG51bGwgPSBudWxsLCBwYXlsb2FkIDogVWludDhBcnJheSB8IG51bGwgPSBudWxsKSA6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xyXG4gICAgY29uc3QgcGFyYW1zID0gZ2V0UzNQYXJhbXMoY29uZmlnLCB1cmwsIG1ldGhvZCk7XHJcbiAgICBjb25zdCBwYXlsb2FkUGFyYW1zID0ge1xyXG4gICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSxcclxuICAgICAgICBjb250ZW50SGFzaDogcGF5bG9hZCA/IHNoYTI1Ni5oZXgocGF5bG9hZCEpIDogbnVsbFxyXG4gICAgfSBhcyBTM1BheWxvYWRQYXJhbXM7XHJcbiAgICByZXR1cm4gY3JlYXRlUzNIZWFkZXJzKHBhcmFtcywgcGF5bG9hZFBhcmFtcyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRTM0hlYWRlcnMoeGhyOiBYTUxIdHRwUmVxdWVzdCwgY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGNvbnRlbnRUeXBlOiBzdHJpbmcgfCBudWxsID0gbnVsbCwgcGF5bG9hZCA6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbCkge1xyXG4gICAgaWYgKGNvbmZpZz8uYWNjZXNzS2V5SWQgfHwgY29uZmlnPy5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUzNIZWFkZXJzRnJvbVMzQ29uZmlnKGNvbmZpZywgdXJsLCBtZXRob2QsIGNvbnRlbnRUeXBlLCBwYXlsb2FkKTtcclxuICAgICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlOiBzdHJpbmcsIGhlYWRlcjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgY29udGVudFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUzNVcmwgKHVybDogc3RyaW5nKSA6IHtidWNrZXQgOiBzdHJpbmcsIHBhdGggOiBzdHJpbmd9IHtcclxuICAgIGlmICh1cmwuaW5kZXhPZihcInMzOi8vXCIpICE9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgbmVlZHMgdG8gc3RhcnQgd2l0aCBzMzovL1wiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNsYXNoUG9zID0gdXJsLmluZGV4T2YoJy8nLCA1KTtcclxuXHJcbiAgICBpZiAoc2xhc2hQb3MgPT0gLTEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgbmVlZHMgdG8gY29udGFpbiBhICcvJyBhZnRlciB0aGUgaG9zdFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWNrZXQgPSB1cmwuc3Vic3RyaW5nKDUsIHNsYXNoUG9zKTtcclxuICAgIGlmICghYnVja2V0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIG5lZWRzIHRvIGNvbnRhaW4gYSBidWNrZXQgbmFtZVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhdGggPSB1cmwuc3Vic3RyaW5nKHNsYXNoUG9zKTtcclxuICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBuZWVkcyB0byBjb250YWluIGtleVwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge2J1Y2tldDogYnVja2V0LCBwYXRoOiBwYXRofVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1BhdGhTdHlsZUFjY2Vzcyhjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCkgOiBib29sZWFuIHtcclxuICAgIGlmIChjb25maWc/LmVuZHBvaW50Py5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhUVFBVcmwoY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZykgOiBzdHJpbmcge1xyXG4gICAgY29uc3QgcGFyc2VkVXJsID0gcGFyc2VTM1VybCh1cmwpO1xyXG4gICAgaWYgKGlzUGF0aFN0eWxlQWNjZXNzKGNvbmZpZykpIHtcclxuICAgICAgICAvLyBFbmRwb2ludCBpcyBhIGZ1bGwgdXJsLCB3ZSBhcHBlbmQgdGhlIGJ1Y2tldFxyXG4gICAgICAgIHJldHVybiBgJHtjb25maWc/LmVuZHBvaW50fS8ke3BhcnNlZFVybC5idWNrZXR9YCArIHBhcnNlZFVybC5wYXRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICdodHRwczovLycgKyBnZXRIVFRQSG9zdChjb25maWcsIHVybCwgcGFyc2VkVXJsLmJ1Y2tldCkgKyBwYXJzZWRVcmwucGF0aDtcclxufSIsICJpbXBvcnQgeyBTdGF0dXNDb2RlIH0gZnJvbSAnLi4vc3RhdHVzJztcclxuaW1wb3J0IHsgYWRkUzNIZWFkZXJzLCBnZXRIVFRQVXJsIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW1wb3J0IHtcclxuICAgIGNhbGxTUmV0LFxyXG4gICAgZHJvcFJlc3BvbnNlQnVmZmVycyxcclxuICAgIER1Y2tEQkRhdGFQcm90b2NvbCxcclxuICAgIER1Y2tEQkZpbGVJbmZvLFxyXG4gICAgRHVja0RCR2xvYmFsRmlsZUluZm8sXHJcbiAgICBEdWNrREJSdW50aW1lLFxyXG4gICAgZmFpbFdpdGgsXHJcbiAgICBGaWxlRmxhZ3MsXHJcbiAgICByZWFkU3RyaW5nLFxyXG59IGZyb20gJy4vcnVudGltZSc7XHJcbmltcG9ydCB7IER1Y2tEQk1vZHVsZSB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XHJcbmltcG9ydCAqIGFzIHVkZiBmcm9tICcuL3VkZl9ydW50aW1lJztcclxuXHJcbmV4cG9ydCBjb25zdCBCUk9XU0VSX1JVTlRJTUU6IER1Y2tEQlJ1bnRpbWUgJiB7XHJcbiAgICBfZmlsZUluZm9DYWNoZTogTWFwPG51bWJlciwgRHVja0RCRmlsZUluZm8+O1xyXG4gICAgX2dsb2JhbEZpbGVJbmZvOiBEdWNrREJHbG9iYWxGaWxlSW5mbyB8IG51bGw7XHJcblxyXG4gICAgZ2V0RmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKTogRHVja0RCRmlsZUluZm8gfCBudWxsO1xyXG4gICAgZ2V0R2xvYmFsRmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUpOiBEdWNrREJHbG9iYWxGaWxlSW5mbyB8IG51bGw7XHJcbn0gPSB7XHJcbiAgICBfZmlsZXM6IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCksXHJcbiAgICBfZmlsZUluZm9DYWNoZTogbmV3IE1hcDxudW1iZXIsIER1Y2tEQkZpbGVJbmZvPigpLFxyXG4gICAgX3VkZkZ1bmN0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgX2dsb2JhbEZpbGVJbmZvOiBudWxsLFxyXG5cclxuICAgIGdldEZpbGVJbmZvKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IER1Y2tEQkZpbGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmdldChmaWxlSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcclxuICAgICAgICAgICAgICAgIG1vZCxcclxuICAgICAgICAgICAgICAgICdkdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWQnLFxyXG4gICAgICAgICAgICAgICAgWydudW1iZXInLCAnbnVtYmVyJ10sXHJcbiAgICAgICAgICAgICAgICBbZmlsZUlkLCBjYWNoZWQ/LmNhY2hlRXBvY2ggfHwgMF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEVwb2NoIGlzIHVwIHRvIGRhdGVcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGluZm9TdHIgPSByZWFkU3RyaW5nKG1vZCwgZCwgbik7XHJcbiAgICAgICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnMobW9kKTtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UoaW5mb1N0cik7XHJcbiAgICAgICAgICAgIGlmIChpbmZvID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB7IC4uLmluZm8sIGJsb2I6IG51bGwgfSBhcyBEdWNrREJGaWxlSW5mbztcclxuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLnNldChmaWxlSWQsIGZpbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZ2V0R2xvYmFsRmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUpOiBEdWNrREJHbG9iYWxGaWxlSW5mbyB8IG51bGwge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxyXG4gICAgICAgICAgICAgICAgbW9kLFxyXG4gICAgICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfZ2V0X2dsb2JhbF9maWxlX2luZm8nLFxyXG4gICAgICAgICAgICAgICAgWydudW1iZXInXSxcclxuICAgICAgICAgICAgICAgIFtCUk9XU0VSX1JVTlRJTUUuX2dsb2JhbEZpbGVJbmZvPy5jYWNoZUVwb2NoIHx8IDBdLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFcG9jaCBpcyB1cCB0byBkYXRlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJPV1NFUl9SVU5USU1FLl9nbG9iYWxGaWxlSW5mbyE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaW5mb1N0ciA9IHJlYWRTdHJpbmcobW9kLCBkLCBuKTtcclxuICAgICAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyhtb2QpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShpbmZvU3RyKTtcclxuICAgICAgICAgICAgaWYgKGluZm8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9nbG9iYWxGaWxlSW5mbyA9IHsgLi4uaW5mbywgYmxvYjogbnVsbCB9IGFzIER1Y2tEQkdsb2JhbEZpbGVJbmZvO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIEJST1dTRVJfUlVOVElNRS5fZ2xvYmFsRmlsZUluZm87XHJcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHRlc3RQbGF0Zm9ybUZlYXR1cmU6IChfbW9kOiBEdWNrREJNb2R1bGUsIGZlYXR1cmU6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIHN3aXRjaCAoZmVhdHVyZSkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGB0ZXN0IGZvciB1bmtub3duIGZlYXR1cmU6ICR7ZmVhdHVyZX1gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIGdldERlZmF1bHREYXRhUHJvdG9jb2wobW9kOiBEdWNrREJNb2R1bGUpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSO1xyXG4gICAgfSxcclxuXHJcbiAgICBvcGVuRmlsZTogKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgZmxhZ3M6IEZpbGVGbGFncyk6IG51bWJlciA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmRlbGV0ZShmaWxlSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gQlJPV1NFUl9SVU5USU1FLmdldEZpbGVJbmZvKG1vZCwgZmlsZUlkKTtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIEZpbGVGbGFncy5GSUxFX0ZMQUdTX1JFQUQgJiYgZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19XUklURSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT3BlbmluZyBmaWxlICR7ZmlsZS5maWxlTmFtZX0gZmFpbGVkOiBjYW5ub3Qgb3BlbiBmaWxlIHdpdGggYm90aCByZWFkIGFuZCB3cml0ZSBmbGFncyBzZXRgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19BUFBFTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogYXBwZW5kaW5nIHRvIEhUVFAvUzMgZmlsZXMgaXMgbm90IHN1cHBvcnRlZGAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmbGFncyAmIEZpbGVGbGFncy5GSUxFX0ZMQUdTX1dSSVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNlbmQgYSBIRUFEIHJlcXVlc3QgdG8gdHJ5IHRvIGRldGVybWluZSBpZiB3ZSBjYW4gd3JpdGUgdG8gZGF0YV91cmxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLmRhdGFQcm90b2NvbCA9PSBEdWNrREJEYXRhUHJvdG9jb2wuUzMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZ2V0SFRUUFVybChmaWxlLnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISwgJ0hFQUQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZmlsZS5kYXRhVXJsISwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwZWN0IDIwMCBmb3IgZXhpc3RpbmcgZmlsZXMgdGhhdCB3ZSB3aWxsIG92ZXJ3cml0ZSBvciA0MDQgZm9yIG5vbi1leGlzdGVudCBmaWxlcyBjYW4gYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPSAyMDAgJiYgeGhyLnN0YXR1cyAhPSA0MDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT3BlbmluZyBmaWxlICR7ZmlsZS5maWxlTmFtZX0gZmFpbGVkOiBVbmV4cGVjdGVkIHJldHVybiBzdGF0dXMgZnJvbSBzZXJ2ZXIgKCR7eGhyLnN0YXR1c30pYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzID09IDQwNCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIShmbGFncyAmIEZpbGVGbGFncy5GSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFIHx8IGZsYWdzICYgRmlsZUZsYWdzLkZJTEVfRkxBR1NfRklMRV9DUkVBVEVfTkVXKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT3BlbmluZyBmaWxlICR7ZmlsZS5maWxlTmFtZX0gZmFpbGVkOiBDYW5ub3Qgd3JpdGUgdG8gbm9uLWV4aXN0ZW50IGZpbGUgd2l0aG91dCBGSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFIG9yIEZJTEVfRkxBR1NfRklMRV9DUkVBVEVfTkVXIGZsYWcuYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGFuIGVtcHR5IGJ1ZmZlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1ZmZlciB0aGUgd3JpdGVzIHRvIHRoaXMgczMvaHR0cCBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2QuX21hbGxvYygxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjID0gbmV3IFVpbnQ4QXJyYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoc3JjLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMV0gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgIT0gRmlsZUZsYWdzLkZJTEVfRkxBR1NfUkVBRCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogdW5zdXBwb3J0ZWQgZmlsZSBmbGFnczogJHtmbGFnc31gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnRzIHJhbmdlcz9cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudExlbmd0aCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yOiBhbnkgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIGEgZHVtbXkgSEVBRCByZXF1ZXN0IHdpdGggcmFuZ2UgcHJvdG9jb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgLT4gZ29vZCBJRkYgc3RhdHVzIGlzIDIwNiBhbmQgY29udGVudExlbmdodCBpcyBwcmVzZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIGdldEhUVFBVcmwoZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIsIGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdIRUFEJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIGZpbGUuZGF0YVVybCEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCBgYnl0ZXM9MC1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0cyByYW5nZSByZXF1ZXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LUxlbmd0aCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCAhPT0gbnVsbCAmJiB4aHIuc3RhdHVzID09IDIwNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDBdID0gK2NvbnRlbnRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSEVBRCByZXF1ZXN0IHdpdGggcmFuZ2UgaGVhZGVyIGZhaWxlZDogJHtlfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZhbGxiYWNrIHRvIGZ1bGwgcmVhZD9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5hbGxvd0Z1bGxIdHRwUmVhZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZW50TGVuZ3RoICE9PSBudWxsKSAmJiAoK2NvbnRlbnRMZW5ndGggPiAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4gU2VuZCBhIGR1bW15IEdFVCByYW5nZSByZXF1ZXN0IHF1ZXJ5aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBmaWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAtPiBnb29kIElGRiBzdGF0dXMgaXMgMjA2IGFuZCBjb250ZW50TGVuZ2h0MiBpcyAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAtPiBvdGhlcndpc2UsIGlmZiAyMDAgYW5kIGNvbnRlbnRMZW5naHQyID09IGNvbnRlbnRMZW5naHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICB3ZSBqdXN0IGRvd25sb2FkZWQgdGhlIGZpbGUsIHNhdmUgaXQgYW5kIG1vdmUgZnVydGhlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGdldEhUVFBVcmwoZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBmaWxlLnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhLCAnR0VUJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLmRhdGFVcmwhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCBgYnl0ZXM9MC0wYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGgyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LUxlbmd0aCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwNiAmJiBjb250ZW50TGVuZ3RoMiAhPT0gbnVsbCAmJiArY29udGVudExlbmd0aDIgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSArY29udGVudExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgJiYgY29udGVudExlbmd0aDIgIT09IG51bGwgJiYgK2NvbnRlbnRMZW5ndGgyID09ICtjb250ZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBmYWxsIGJhY2sgdG8gZnVsbCBIVFRQIHJlYWQgZm9yOiAke2ZpbGUuZGF0YVVybH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbW9kLl9tYWxsb2MoeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSwgMCwgeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQVTguc2V0KHNyYywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9IHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAxXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGZhbGxpbmcgYmFjayB0byBmdWxsIEhUVFAgcmVhZCBmb3I6ICR7ZmlsZS5kYXRhVXJsfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzLiBTZW5kIG5vbi1yYW5nZSByZXF1ZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgZ2V0SFRUUFVybChmaWxlLnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISwgJ0dFVCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGZpbGUuZGF0YVVybCEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYnVmZmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1vZC5fbWFsbG9jKHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSwgMCwgeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoc3JjLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9IHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhaXNlIGVycm9yP1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVhZGluZyBmaWxlICR7ZmlsZS5maWxlTmFtZX0gZmFpbGVkIHdpdGggZXJyb3I6ICR7ZXJyb3J9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRmlsZSByZWFkZXIgRmlsZVxyXG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gQlJPV1NFUl9SVU5USU1FLl9maWxlcz8uZ2V0KGZpbGUuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSBoYW5kbGUuc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBlbXB0eSBidWZmZXJlZCBmaWxlIGluIHRoZSBicm93c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBCdWZmZXJpbmcgbWlzc2luZyBmaWxlOiAke2ZpbGUuZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1vZC5fbWFsbG9jKDEpOyAvLyBtYWxsb2MoMCkgaXMgYWxsb3dlZCB0byByZXR1cm4gYSBudWxscHRyXHJcbiAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDBdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMV0gPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPIChzYW1hbnNtaW5rKTogdGhpcyBwYXRoIGNhdXNlcyB0aGUgV0FTTSBjb2RlIHRvIGhhbmdcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBmYWlsV2l0aChtb2QsIGUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuICAgIGdsb2I6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBodHRwP1xyXG4gICAgICAgICAgICAvLyBUcnkgYSBIVFRQIEhFQUQgcmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdodHRwJykgfHwgcGF0aC5zdGFydHNXaXRoKCdzMzovLycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGEgZHVtbXkgcmFuZ2UgcmVxdWVzdCBxdWVyeWluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdzMzovLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsSW5mbyA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZ2V0SFRUUFVybChnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCwgJ0hFQUQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBwYXRoISwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPSAyMDAgJiYgeGhyLnN0YXR1cyAhPT0gMjA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlLXNpZ25lZCByZXNvdXJjZXMgb24gUzMgaW4gY29tbW9uIGNvbmZpZ3VyYXRpb25zIGZhaWwgb24gYW55IEhFQUQgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9zZGstZm9yLWdvL3YxL2RldmVsb3Blci1ndWlkZS9zMy1leGFtcGxlLXByZXNpZ25lZC11cmxzLmh0bWxcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIChpZiBlbmFibGVkKSB0byBidW1wIHRvIGEgcmFuZ2VkIEdFVFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghQlJPV1NFUl9SVU5USU1FLmdldEdsb2JhbEZpbGVJbmZvKG1vZCk/LmFsbG93RnVsbEh0dHBSZWFkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBIRUFEIHJlcXVlc3QgZmFpbGVkOiAke3BhdGh9LCB3aXRoIGZ1bGwgaHR0cCByZWFkcyBhcmUgZGlzYWJsZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB4aHIyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnczM6Ly8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxJbmZvID0gQlJPV1NFUl9SVU5USU1FLmdldEdsb2JhbEZpbGVJbmZvKG1vZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhocjIub3BlbignR0VUJywgZ2V0SFRUUFVybChnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhocjIsIGdsb2JhbEluZm8/LnMzQ29uZmlnLCBwYXRoLCAnSEVBRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhocjIub3BlbignR0VUJywgcGF0aCEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyMi5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsIGBieXRlcz0wLTBgKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhocjIuc3RhdHVzICE9IDIwMCAmJiB4aHIyLnN0YXR1cyAhPT0gMjA2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgYEhFQUQgYW5kIEdFVCByZXF1ZXN0cyBmYWlsZWQ6ICR7cGF0aH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0geGhyMi5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCAmJiAoK2NvbnRlbnRMZW5ndGggPiAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJhbmdlIHJlcXVlc3QgZm9yICR7cGF0aH0gZGlkIG5vdCByZXR1cm4gYSBwYXJ0aWFsIHJlc3BvbnNlOiAke3hocjIuc3RhdHVzfSBcIiR7eGhyMi5zdGF0dXNUZXh0fVwiYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbW9kLmNjYWxsKCdkdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGgnLCBudWxsLCBbJ3N0cmluZyddLCBbcGF0aF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICBmYWlsV2l0aChtb2QsIGUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjaGVja0ZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBodHRwIG9yIFMzP1xyXG4gICAgICAgICAgICAvLyBUcnkgYSBIVFRQIEhFQUQgcmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdodHRwJykgfHwgcGF0aC5zdGFydHNXaXRoKCdzMzovLycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGEgZHVtbXkgcmFuZ2UgcmVxdWVzdCBxdWVyeWluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdzMzovLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsSW5mbyA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZ2V0SFRUUFVybChnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCwgJ0hFQUQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBwYXRoISwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geGhyLnN0YXR1cyA9PSAyMDYgfHwgeGhyLnN0YXR1cyA9PSAyMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIHN5bmNGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmlsZUlkOiBudW1iZXIpID0+IHt9LFxyXG4gICAgY2xvc2VGaWxlOiAobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IEJST1dTRVJfUlVOVElNRS5nZXRGaWxlSW5mbyhtb2QsIGZpbGVJZCk7XHJcbiAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmRlbGV0ZShmaWxlSWQpO1xyXG4gICAgICAgIHN3aXRjaCAoZmlsZT8uZGF0YVByb3RvY29sKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJVRkZFUjpcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuSFRUUDpcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuUzM6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuTk9ERV9GUzpcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSOlxyXG4gICAgICAgICAgICAgICAgLy8gWFhYIFJlbW92ZSBmcm9tIHJlZ2lzdHJ5XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRlNBQ0NFU1M6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBPUEZTIGFjY2VzcyBoYW5kbGUgcmVnaXN0ZXJlZCB3aXRoIG5hbWU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUuZmx1c2goKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0cnVuY2F0ZUZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIG5ld1NpemU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xyXG4gICAgICAgIHN3aXRjaCAoZmlsZT8uZGF0YVByb3RvY29sKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBDYW5ub3QgdHJ1bmNhdGUgYSBodHRwIGZpbGVgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuUzM6XHJcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBDYW5ub3QgdHJ1bmNhdGUgYW4gczMgZmlsZWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CVUZGRVI6XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLk5PREVfRlM6XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUjpcclxuICAgICAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgYHRydW5jYXRlRmlsZSBub3QgaW1wbGVtZW50ZWRgKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GU0FDQ0VTUzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gQlJPV1NFUl9SVU5USU1FLl9maWxlcz8uZ2V0KGZpbGUuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE9QRlMgYWNjZXNzIGhhbmRsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS50cnVuY2F0ZShuZXdTaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH0sXHJcbiAgICByZWFkRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGJ1ZjogbnVtYmVyLCBieXRlczogbnVtYmVyLCBsb2NhdGlvbjogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKGJ5dGVzID09IDApIHtcclxuICAgICAgICAgICAgLy8gQmUgcm9idXN0IHRvIGVtcHR5IHJlYWRzXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gQlJPV1NFUl9SVU5USU1FLmdldEZpbGVJbmZvKG1vZCwgZmlsZUlkKTtcclxuICAgICAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpbGUgcmVhZGluZyBmcm9tIEJMT0Igb3IgSFRUUCBNVVNUIGJlIGRvbmUgd2l0aCByYW5nZSByZXF1ZXN0cy5cclxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgaW4gT1BFTiBpZiBzdWNoIGZpbGUgc3VwcG9ydHMgcmFuZ2UgcmVxdWVzdHMgYW5kIHVwZ3JhZGUgdG8gQlVGRkVSIGlmIG5vdC5cclxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsZS5kYXRhVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBkYXRhIFVSTCBmb3IgZmlsZSAke2ZpbGVJZH1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLmRhdGFQcm90b2NvbCA9PSBEdWNrREJEYXRhUHJvdG9jb2wuUzMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBnZXRIVFRQVXJsKGZpbGU/LnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdHRVQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLmRhdGFVcmwhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdSYW5nZScsIGBieXRlcz0ke2xvY2F0aW9ufS0ke2xvY2F0aW9uICsgYnl0ZXMgLSAxfWApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA9PSAyMDYgLyogUGFydGlhbCBjb250ZW50ICovIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeGhyLnN0YXR1cyA9PSAyMDAgJiYgYnl0ZXMgPT0geGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGggJiYgbG9jYXRpb24gPT0gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UsIDAsIE1hdGgubWluKHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoLCBieXRlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoc3JjLCBidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyYy5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBoZXJlIHdlIGFyZSBhY3R1YWxseSB0aHJvd2luZyBhd2F5IGFsbCBub24tcmVsZXZhbnQgYnl0ZXMsIGJ1dCB0aGlzIGlzIHN0aWxsIGJldHRlciB0aGFuIGZhaWxpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHByb3BlciBzb2x1dGlvbiB3b3VsZCByZXF1aXJlIG5vdGlmeWluZyBkdWNrZGItd2FzbSBjYWNoZSwgd2hpbGUgd2UgYXJlIHBpZ2d5YmFja2lnbiBvbiBicm93c2VyIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJhbmdlIHJlcXVlc3QgZm9yICR7ZmlsZS5kYXRhVXJsfSBkaWQgbm90IHJldHVybiBhIHBhcnRpYWwgcmVzcG9uc2U6ICR7eGhyLnN0YXR1c30gXCIke3hoci5zdGF0dXNUZXh0fVwiYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UsIGxvY2F0aW9uLCBNYXRoLm1pbih4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aC1sb2NhdGlvbiwgYnl0ZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQVTguc2V0KHNyYywgYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcmMuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgUmFuZ2UgcmVxdWVzdCBmb3IgJHtmaWxlLmRhdGFVcmx9IGRpZCByZXR1cm5lZCBub24tc3VjY2VzcyBzdGF0dXM6ICR7eGhyLnN0YXR1c30gXCIke3hoci5zdGF0dXNUZXh0fVwiYCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJhbmdlIHJlcXVlc3QgZm9yICR7ZmlsZS5kYXRhVXJsfSBmYWlsZWQgd2l0aCBlcnJvcjogJHtlfVwiYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gQlJPV1NFUl9SVU5USU1FLl9maWxlcz8uZ2V0KGZpbGUuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gSFRNTDUgZmlsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzbGljZWQgPSBoYW5kbGUhLnNsaWNlKGxvY2F0aW9uLCBsb2NhdGlvbiArIGJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobmV3IEZpbGVSZWFkZXJTeW5jKCkucmVhZEFzQXJyYXlCdWZmZXIoc2xpY2VkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoZGF0YSwgYnVmKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GU0FDQ0VTUzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE9QRlMgYWNjZXNzIGhhbmRsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBtb2QuSEVBUFU4LnN1YmFycmF5KGJ1ZiwgYnVmICsgYnl0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUucmVhZChvdXQsIHsgYXQ6IGxvY2F0aW9uIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd3JpdGVGaWxlOiAobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyLCBidWY6IG51bWJlciwgYnl0ZXM6IG51bWJlciwgbG9jYXRpb246IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xyXG4gICAgICAgIHN3aXRjaCAoZmlsZT8uZGF0YVByb3RvY29sKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsICdDYW5ub3Qgd3JpdGUgdG8gSFRUUCBmaWxlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuUzM6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdQVVQnLCBnZXRIVFRQVXJsKGZpbGU/LnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdQVVQnLCAnJywgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHhoci5zZW5kKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFpbFdpdGgobW9kLCAnRmFpbGVkIHdyaXRpbmcgZmlsZTogSFRUUCAnICsgeGhyLnN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSOlxyXG4gICAgICAgICAgICAgICAgZmFpbFdpdGgobW9kLCAnY2Fubm90IHdyaXRlIHVzaW5nIHRoZSBodG1sNSBmaWxlIHJlYWRlciBhcGknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZTQUNDRVNTOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gT1BGUyBhY2Nlc3MgaGFuZGxlIHJlZ2lzdGVyZWQgd2l0aCBuYW1lOiAke2ZpbGUuZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLndyaXRlKGlucHV0LCB7IGF0OiBsb2NhdGlvbiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH0sXHJcbiAgICBnZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBmaWxlID0gQlJPV1NFUl9SVU5USU1FLmdldEZpbGVJbmZvKG1vZCwgZmlsZUlkKTtcclxuICAgICAgICBzd2l0Y2ggKGZpbGU/LmRhdGFQcm90b2NvbCkge1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE5vIGhhbmRsZSBhdmFpbGFibGUgZm9yIGZpbGU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG4gICAgY2hlY2tEaXJlY3Rvcnk6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBjaGVja0RpcmVjdG9yeTogJHtwYXRofWApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVEaXJlY3Rvcnk6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBjcmVhdGVEaXJlY3Rvcnk6ICR7cGF0aH1gKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVEaXJlY3Rvcnk6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGByZW1vdmVEaXJlY3Rvcnk6ICR7cGF0aH1gKTtcclxuICAgIH0sXHJcbiAgICBsaXN0RGlyZWN0b3J5RW50cmllczogKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSByZWFkU3RyaW5nKG1vZCwgcGF0aFB0ciwgcGF0aExlbik7XHJcbiAgICAgICAgY29uc29sZS5sb2coYGxpc3REaXJlY3RvcnlFbnRyaWVzOiAke3BhdGh9YCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIG1vdmVGaWxlOiAobW9kOiBEdWNrREJNb2R1bGUsIGZyb21QdHI6IG51bWJlciwgZnJvbUxlbjogbnVtYmVyLCB0b1B0cjogbnVtYmVyLCB0b0xlbjogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IHJlYWRTdHJpbmcobW9kLCBmcm9tUHRyLCBmcm9tTGVuKTtcclxuICAgICAgICBjb25zdCB0byA9IHJlYWRTdHJpbmcobW9kLCB0b1B0ciwgdG9MZW4pO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmcm9tKTtcclxuICAgICAgICBpZiAoaGFuZGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlcyEuZGVsZXRlKGhhbmRsZSk7XHJcbiAgICAgICAgICAgIEJST1dTRVJfUlVOVElNRS5fZmlsZXMhLnNldCh0bywgaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlPy5lbnRyaWVzKCkgfHwgW10pIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmRhdGFVcmwgPT0gZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcikgPT4ge30sXHJcbiAgICBjYWxsU2NhbGFyVURGOiAoXHJcbiAgICAgICAgbW9kOiBEdWNrREJNb2R1bGUsXHJcbiAgICAgICAgcmVzcG9uc2U6IG51bWJlcixcclxuICAgICAgICBmdW5jSWQ6IG51bWJlcixcclxuICAgICAgICBkZXNjUHRyOiBudW1iZXIsXHJcbiAgICAgICAgZGVzY1NpemU6IG51bWJlcixcclxuICAgICAgICBwdHJzUHRyOiBudW1iZXIsXHJcbiAgICAgICAgcHRyc1NpemU6IG51bWJlcixcclxuICAgICk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHVkZi5jYWxsU2NhbGFyVURGKEJST1dTRVJfUlVOVElNRSwgbW9kLCByZXNwb25zZSwgZnVuY0lkLCBkZXNjUHRyLCBkZXNjU2l6ZSwgcHRyc1B0ciwgcHRyc1NpemUpO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJST1dTRVJfUlVOVElNRTtcclxuIiwgImltcG9ydCBEdWNrREJXYXNtIGZyb20gJy4vZHVja2RiLW12cC5qcyc7XHJcbmltcG9ydCB7IER1Y2tEQkJyb3dzZXJCaW5kaW5ncyB9IGZyb20gJy4vYmluZGluZ3NfYnJvd3Nlcl9iYXNlJztcclxuaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuaW1wb3J0IHsgRHVja0RCUnVudGltZSB9IGZyb20gJy4vcnVudGltZSc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XHJcblxyXG4vKiogRHVja0RCIGJpbmRpbmdzIGZvciB0aGUgYnJvd3NlciAqL1xyXG5leHBvcnQgY2xhc3MgRHVja0RCIGV4dGVuZHMgRHVja0RCQnJvd3NlckJpbmRpbmdzIHtcclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyLFxyXG4gICAgICAgIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsXHJcbiAgICAgICAgbWFpbk1vZHVsZVVSTDogc3RyaW5nLFxyXG4gICAgICAgIHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGwgPSBudWxsLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIobG9nZ2VyLCBydW50aW1lLCBtYWluTW9kdWxlVVJMLCBwdGhyZWFkV29ya2VyVVJMKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+IHtcclxuICAgICAgICByZXR1cm4gRHVja0RCV2FzbSh7XHJcbiAgICAgICAgICAgIC4uLm1vZHVsZU92ZXJyaWRlcyxcclxuICAgICAgICAgICAgaW5zdGFudGlhdGVXYXNtOiB0aGlzLmluc3RhbnRpYXRlV2FzbS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBsb2NhdGVGaWxlOiB0aGlzLmxvY2F0ZUZpbGUuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuaW1wb3J0IHsgRHVja0RCQmluZGluZ3NCYXNlIH0gZnJvbSAnLi9iaW5kaW5nc19iYXNlJztcclxuaW1wb3J0IHsgRHVja0RCUnVudGltZSB9IGZyb20gJy4vcnVudGltZSc7XHJcbmltcG9ydCB7IExvZ0xldmVsLCBMb2dUb3BpYywgTG9nT3JpZ2luLCBMb2dFdmVudCB9IGZyb20gJy4uL2xvZyc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XHJcbmltcG9ydCB7IEluc3RhbnRpYXRpb25Qcm9ncmVzcyB9IGZyb20gJy4nO1xyXG5cclxuLyoqIER1Y2tEQiBiaW5kaW5ncyBmb3IgdGhlIGJyb3dzZXIgKi9cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIER1Y2tEQkJyb3dzZXJCaW5kaW5ncyBleHRlbmRzIER1Y2tEQkJpbmRpbmdzQmFzZSB7XHJcbiAgICAvKiogVGhlIHBhdGggb2YgdGhlIHdhc20gbW9kdWxlICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgbWFpbk1vZHVsZVVSTDogc3RyaW5nO1xyXG4gICAgLyoqIFRoZSBwYXRoIG9mIHRoZSBwdGhyZWFkIHdvcmtlciBzY3JpcHQgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBwdGhyZWFkV29ya2VyVVJMOiBzdHJpbmcgfCBudWxsO1xyXG5cclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKGxvZ2dlcjogTG9nZ2VyLCBydW50aW1lOiBEdWNrREJSdW50aW1lLCBtYWluTW9kdWxlVVJMOiBzdHJpbmcsIHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGwpIHtcclxuICAgICAgICBzdXBlcihsb2dnZXIsIHJ1bnRpbWUpO1xyXG4gICAgICAgIHRoaXMubWFpbk1vZHVsZVVSTCA9IG1haW5Nb2R1bGVVUkw7XHJcbiAgICAgICAgdGhpcy5wdGhyZWFkV29ya2VyVVJMID0gcHRocmVhZFdvcmtlclVSTDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogTG9jYXRlIGEgZmlsZSAqL1xyXG4gICAgcHJvdGVjdGVkIGxvY2F0ZUZpbGUocGF0aDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy53YXNtJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFpbk1vZHVsZVVSTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy53b3JrZXIuanMnKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucHRocmVhZFdvcmtlclVSTCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIER1Y2tEQiB3b3JrZXIgVVJMIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB0aHJlYWRXb3JrZXJVUkwhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdBU00gaW5zdGFudGlhdGlvbiByZXF1ZXN0ZWQgdW5leHBlY3RlZCBmaWxlOiBwcmVmaXg9JHtwcmVmaXh9IHBhdGg9JHtwYXRofWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgd2FzbSBtb2R1bGUgKi9cclxuICAgIHByb3RlY3RlZCBpbnN0YW50aWF0ZVdhc20oXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgICAgICBpbXBvcnRzOiBhbnksXHJcbiAgICAgICAgc3VjY2VzczogKGluc3RhbmNlOiBXZWJBc3NlbWJseS5JbnN0YW5jZSwgbW9kdWxlOiBXZWJBc3NlbWJseS5Nb2R1bGUpID0+IHZvaWQsXHJcbiAgICApOiBFbXNjcmlwdGVuLldlYkFzc2VtYmx5RXhwb3J0cyB7XHJcbiAgICAgICAgLy8gV2UgcmVseSBvbiB0aGUgZm9sbG93aW5nIGhlcmU6XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAuLi53aGVuIGEgUmVxdWVzdCBvYmplY3QgaXMgY3JlYXRlZCB1c2luZyB0aGUgUmVxdWVzdC5SZXF1ZXN0IGNvbnN0cnVjdG9yLFxyXG4gICAgICAgIC8vIHRoZSB2YWx1ZSBvZiB0aGUgbW9kZSBwcm9wZXJ0eSBmb3IgdGhhdCBSZXF1ZXN0IGlzIHNldCB0byBjb3JzLlxyXG4gICAgICAgIC8vIFtyZWY6IE1ETl1cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIENsb3VkZmxhcmUgdGhyb3dzIHdoZW4gbW9kZTogJ2NvcnMnIGlzIHNldFxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRSA9IHRoaXMuX3J1bnRpbWU7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB0aGlzLm9uSW5zdGFudGlhdGlvblByb2dyZXNzO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgc3RyZWFtaW5nIGluc3RhbnRpYXRpb24/XHJcbiAgICAgICAgaWYgKFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCB0cmFuc2Zvcm0gc3RyZWFtcz9cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1TdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoV2l0aFByb2dyZXNzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZXRlcm1pbmUgZmlsZSBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMubWFpbk1vZHVsZVVSTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoSGRyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtbGVuZ3RoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGhIZHIgPyBwYXJzZUludChjb250ZW50TGVuZ3RoSGRyLCAxMCkgfHwgMCA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgc3RyZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzOiBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRBdDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzVG90YWw6IGNvbnRlbnRMZW5ndGggfHwgMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0oY2h1bms6IGFueSwgY3RybDogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLmJ5dGVzTG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdy5nZXRUaW1lKCkgLSBwcm9ncmVzcy51cGRhdGVkQXQuZ2V0VGltZSgpIDwgMjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy51cGRhdGVkQXQgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lbnF1ZXVlKGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwKHByb2dyZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZW5xdWV1ZShjaHVuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhY2tlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShyZXNwb25zZS5ib2R5Py5waXBlVGhyb3VnaCh0cyksIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSBzdHJlYW1pbmdcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZmV0Y2hXaXRoUHJvZ3Jlc3MoKTtcclxuICAgICAgICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbXBvcnRzKS50aGVuKG91dHB1dCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhvdXRwdXQuaW5zdGFuY2UsIG91dHB1dC5tb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luc3RhbnRpYXRpbmcgd2l0aG91dCBwcm9ncmVzcyBoYW5kbGVyIHNpbmNlIHRyYW5zZm9ybSBzdHJlYW1zIGFyZSB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMubWFpbk1vZHVsZVVSTCk7XHJcbiAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaChyZXF1ZXN0KSwgaW1wb3J0cykudGhlbihvdXRwdXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Mob3V0cHV0Lmluc3RhbmNlLCBvdXRwdXQubW9kdWxlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgZmFsbCBiYWNrIHRvIFhIUnNcclxuICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHRoaXMubWFpbk1vZHVsZVVSTDtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzczogSW5zdGFudGlhdGlvblByb2dyZXNzID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRlZEF0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBieXRlc1RvdGFsOiAwLFxyXG4gICAgICAgICAgICAgICAgYnl0ZXNMb2FkZWQ6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xyXG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coe1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWwuRVJST1IsXHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBMb2dPcmlnaW4uQklORElOR1MsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9waWM6IExvZ1RvcGljLklOU1RBTlRJQVRFLFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBMb2dFdmVudC5FUlJPUixcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0ZhaWxlZCB0byBsb2FkIFdBU006ICcgKyBlcnJvcixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub25wcm9ncmVzcyA9IGUgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MuYnl0ZXNUb3RhbCA9IGUudG90YWw7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcy5ieXRlc0xvYWRlZCA9IGUubG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgIGlmIChub3cuZ2V0VGltZSgpIC0gcHJvZ3Jlc3MudXBkYXRlZEF0LmdldFRpbWUoKSA8IDIwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MudXBkYXRlZEF0ID0gbm93O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBoYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAocHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoeGhyLnJlc3BvbnNlLCBpbXBvcnRzKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG91dHB1dCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Mob3V0cHV0Lmluc3RhbmNlLCBvdXRwdXQubW9kdWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWwuRVJST1IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IExvZ09yaWdpbi5CSU5ESU5HUyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiBMb2dUb3BpYy5JTlNUQU5USUFURSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBMb2dFdmVudC5FUlJPUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRmFpbGVkIHRvIGluc3RhbnRpYXRlIFdBU006ICcgKyBlcnJvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdpbnN0YW50aWF0aW5nIHdpdGggbWFudWFsIGZldGNoIHNpbmNlIHN0cmVhbWluZyBpbnN0YW50aWF0aW9uIGFuZCB4aHJzIGFyZSB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5tYWluTW9kdWxlVVJMKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYnVmZmVyLCBpbXBvcnRzKS50aGVuKG91dHB1dCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhvdXRwdXQuaW5zdGFuY2UsIG91dHB1dC5tb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcblxyXG4gICAgLy8vIEluc3RhbnRpYXRpb24gbXVzdCBiZSBkb25lIGJ5IHRoZSBicm93c2VyIHZhcmlhbnRzXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+O1xyXG59XHJcbiIsICJpbXBvcnQgRHVja0RCV2FzbSBmcm9tICcuL2R1Y2tkYi1laC5qcyc7XHJcbmltcG9ydCB7IER1Y2tEQkJyb3dzZXJCaW5kaW5ncyB9IGZyb20gJy4vYmluZGluZ3NfYnJvd3Nlcl9iYXNlJztcclxuaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuaW1wb3J0IHsgRHVja0RCUnVudGltZSB9IGZyb20gJy4vcnVudGltZSc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XHJcblxyXG4vKiogRHVja0RCIGJpbmRpbmdzIGZvciB0aGUgYnJvd3NlciAqL1xyXG5leHBvcnQgY2xhc3MgRHVja0RCIGV4dGVuZHMgRHVja0RCQnJvd3NlckJpbmRpbmdzIHtcclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyLFxyXG4gICAgICAgIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsXHJcbiAgICAgICAgbWFpbk1vZHVsZVVSTDogc3RyaW5nLFxyXG4gICAgICAgIHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGwgPSBudWxsLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIobG9nZ2VyLCBydW50aW1lLCBtYWluTW9kdWxlVVJMLCBwdGhyZWFkV29ya2VyVVJMKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+IHtcclxuICAgICAgICByZXR1cm4gRHVja0RCV2FzbSh7XHJcbiAgICAgICAgICAgIC4uLm1vZHVsZU92ZXJyaWRlcyxcclxuICAgICAgICAgICAgaW5zdGFudGlhdGVXYXNtOiB0aGlzLmluc3RhbnRpYXRlV2FzbS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBsb2NhdGVGaWxlOiB0aGlzLmxvY2F0ZUZpbGUuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHVja0RCO1xyXG4iLCAiZXhwb3J0ICogZnJvbSAnLi4vYmluZGluZ3MnO1xyXG5leHBvcnQgKiBmcm9tICcuLi9sb2cnO1xyXG5leHBvcnQgKiBmcm9tICcuLi9wbGF0Zm9ybSc7XHJcbmV4cG9ydCAqIGZyb20gJy4uL3N0YXR1cyc7XHJcbmV4cG9ydCAqIGZyb20gJy4uL3ZlcnNpb24nO1xyXG5leHBvcnQgeyBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuLi9iaW5kaW5ncy9ydW50aW1lJztcclxuZXhwb3J0IHsgREVGQVVMVF9SVU5USU1FIH0gZnJvbSAnLi4vYmluZGluZ3MvcnVudGltZSc7XHJcbmV4cG9ydCB7IEJST1dTRVJfUlVOVElNRSB9IGZyb20gJy4uL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlcic7XHJcblxyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2cnO1xyXG5pbXBvcnQgeyBEdWNrREJSdW50aW1lLCBEdWNrREJCaW5kaW5ncyB9IGZyb20gJy4uL2JpbmRpbmdzJztcclxuaW1wb3J0IHsgRHVja0RCQnVuZGxlcywgZ2V0UGxhdGZvcm1GZWF0dXJlcyB9IGZyb20gJy4uL3BsYXRmb3JtJztcclxuaW1wb3J0IHsgRHVja0RCIGFzIER1Y2tEQk1WUCB9IGZyb20gJy4uL2JpbmRpbmdzL2JpbmRpbmdzX2Jyb3dzZXJfbXZwJztcclxuaW1wb3J0IHsgRHVja0RCIGFzIER1Y2tEQk5leHQgfSBmcm9tICcuLi9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX2VoJztcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVEdWNrREIoXHJcbiAgICBidW5kbGVzOiBEdWNrREJCdW5kbGVzLFxyXG4gICAgbG9nZ2VyOiBMb2dnZXIsXHJcbiAgICBydW50aW1lOiBEdWNrREJSdW50aW1lLFxyXG4pOiBQcm9taXNlPER1Y2tEQkJpbmRpbmdzPiB7XHJcbiAgICBjb25zdCBwbGF0Zm9ybSA9IGF3YWl0IGdldFBsYXRmb3JtRmVhdHVyZXMoKTtcclxuICAgIGlmIChwbGF0Zm9ybS53YXNtRXhjZXB0aW9ucykge1xyXG4gICAgICAgIGlmIChidW5kbGVzLmVoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRHVja0RCTmV4dChsb2dnZXIsIHJ1bnRpbWUsIGJ1bmRsZXMuZWghLm1haW5Nb2R1bGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRHVja0RCTVZQKGxvZ2dlciwgcnVudGltZSwgYnVuZGxlcy5tdnAubWFpbk1vZHVsZSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcbmltcG9ydCB7IEFzeW5jRHVja0RCIH0gZnJvbSAnLi9hc3luY19iaW5kaW5ncyc7XHJcbmltcG9ydCB7IExvZ0xldmVsLCBMb2dUb3BpYywgTG9nT3JpZ2luLCBMb2dFdmVudCB9IGZyb20gJy4uL2xvZyc7XHJcbmltcG9ydCB7IEFycm93SW5zZXJ0T3B0aW9ucywgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMgfSBmcm9tICcuLi9iaW5kaW5ncy9pbnNlcnRfb3B0aW9ucyc7XHJcblxyXG4vKiogQSB0aGluIGhlbHBlciB0byBtZW1vaXplIHRoZSBjb25uZWN0aW9uIGlkICovXHJcbmV4cG9ydCBjbGFzcyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24ge1xyXG4gICAgLyoqIFRoZSBhc3luYyBkdWNrZGIgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBfYmluZGluZ3M6IEFzeW5jRHVja0RCO1xyXG4gICAgLyoqIFRoZSBjb25uIGhhbmRsZSAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9jb25uOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYmluZGluZ3M6IEFzeW5jRHVja0RCLCBjb25uOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IGJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuX2Nvbm4gPSBjb25uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBY2Nlc3MgdGhlIGRhdGFiYXNlIGJpbmRpbmdzICovXHJcbiAgICBwdWJsaWMgZ2V0IGJpbmRpbmdzKCk6IEFzeW5jRHVja0RCIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3M7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIERpc2Nvbm5lY3QgZnJvbSB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MuZGlzY29ubmVjdCh0aGlzLl9jb25uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQnJhdmUgc291bHMgbWF5IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbnN1bWUgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBpZCAqL1xyXG4gICAgcHVibGljIHVzZVVuc2FmZTxSPihjYWxsYmFjazogKGJpbmRpbmdzOiBBc3luY0R1Y2tEQiwgY29ubjogbnVtYmVyKSA9PiBSKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2JpbmRpbmdzLCB0aGlzLl9jb25uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUnVuIGEgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBhc3luYyBxdWVyeTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55Pih0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPGFycm93LlRhYmxlPFQ+PiB7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MubG9nZ2VyLmxvZyh7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsLklORk8sXHJcbiAgICAgICAgICAgIG9yaWdpbjogTG9nT3JpZ2luLkFTWU5DX0RVQ0tEQixcclxuICAgICAgICAgICAgdG9waWM6IExvZ1RvcGljLlFVRVJZLFxyXG4gICAgICAgICAgICBldmVudDogTG9nRXZlbnQuUlVOLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB0aGlzLl9iaW5kaW5ncy5ydW5RdWVyeSh0aGlzLl9jb25uLCB0ZXh0KTtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3luYygpLCBcIlJlYWRlciBpcyBub3Qgc3luY1wiKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNGaWxlKCksIFwiUmVhZGVyIGlzIG5vdCBmaWxlXCIpO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXJyb3cuVGFibGUocmVhZGVyIGFzIGFycm93LlJlY29yZEJhdGNoRmlsZVJlYWRlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFNlbmQgYSBxdWVyeSAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNlbmQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYXJyb3cuRGF0YVR5cGUgfSA9IGFueT4oXHJcbiAgICAgICAgdGV4dDogc3RyaW5nLFxyXG4gICAgKTogUHJvbWlzZTxhcnJvdy5Bc3luY1JlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+PiB7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MubG9nZ2VyLmxvZyh7XHJcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsLklORk8sXHJcbiAgICAgICAgICAgIG9yaWdpbjogTG9nT3JpZ2luLkFTWU5DX0RVQ0tEQixcclxuICAgICAgICAgICAgdG9waWM6IExvZ1RvcGljLlFVRVJZLFxyXG4gICAgICAgICAgICBldmVudDogTG9nRXZlbnQuUlVOLFxyXG4gICAgICAgICAgICB2YWx1ZTogdGV4dCxcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgaGVhZGVyID0gYXdhaXQgdGhpcy5fYmluZGluZ3Muc3RhcnRQZW5kaW5nUXVlcnkodGhpcy5fY29ubiwgdGV4dCk7XHJcbiAgICAgICAgd2hpbGUgKGhlYWRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGhlYWRlciA9IGF3YWl0IHRoaXMuX2JpbmRpbmdzLnBvbGxQZW5kaW5nUXVlcnkodGhpcy5fY29ubik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgQXN5bmNSZXN1bHRTdHJlYW1JdGVyYXRvcih0aGlzLl9iaW5kaW5ncywgdGhpcy5fY29ubiwgaGVhZGVyKTtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGl0ZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0FzeW5jKCkpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N0cmVhbSgpKTtcclxuICAgICAgICByZXR1cm4gcmVhZGVyIGFzIHVua25vd24gYXMgYXJyb3cuQXN5bmNSZWNvcmRCYXRjaFN0cmVhbVJlYWRlcjxUPjsgLy8gWFhYXHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENhbmNlbCBhIHF1ZXJ5IHRoYXQgd2FzIHNlbnQgZWFybGllciAqL1xyXG4gICAgcHVibGljIGFzeW5jIGNhbmNlbFNlbnQoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2JpbmRpbmdzLmNhbmNlbFBlbmRpbmdRdWVyeSh0aGlzLl9jb25uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRhYmxlIG5hbWVzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0VGFibGVOYW1lcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9iaW5kaW5ncy5nZXRUYWJsZU5hbWVzKHRoaXMuX2Nvbm4sIHF1ZXJ5KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ3JlYXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJlcGFyZTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PihcclxuICAgICAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICApOiBQcm9taXNlPEFzeW5jUHJlcGFyZWRTdGF0ZW1lbnQ+IHtcclxuICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgdGhpcy5fYmluZGluZ3MuY3JlYXRlUHJlcGFyZWQodGhpcy5fY29ubiwgdGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luY1ByZXBhcmVkU3RhdGVtZW50PFQ+KHRoaXMuX2JpbmRpbmdzLCB0aGlzLl9jb25uLCBzdG10KTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IGFuIGFycm93IHRhYmxlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0QXJyb3dUYWJsZSh0YWJsZTogYXJyb3cuVGFibGUsIG9wdGlvbnM6IEFycm93SW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGFycm93LnRhYmxlVG9JUEModGFibGUsICdzdHJlYW0nKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShidWZmZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqIEluc2VydCBhbiBhcnJvdyB0YWJsZSBmcm9tIGFuIGlwYyBzdHJlYW0gKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnNlcnRBcnJvd0Zyb21JUENTdHJlYW0oYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zOiBBcnJvd0luc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLl9iaW5kaW5ncy5pbnNlcnRBcnJvd0Zyb21JUENTdHJlYW0odGhpcy5fY29ubiwgYnVmZmVyLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnQgY3N2IGZpbGUgZnJvbSBwYXRoICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0Q1NWRnJvbVBhdGgodGV4dDogc3RyaW5nLCBvcHRpb25zOiBDU1ZJbnNlcnRPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fYmluZGluZ3MuaW5zZXJ0Q1NWRnJvbVBhdGgodGhpcy5fY29ubiwgdGV4dCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGpzb24gZmlsZSBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnNlcnRKU09ORnJvbVBhdGgodGV4dDogc3RyaW5nLCBvcHRpb25zOiBKU09OSW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2JpbmRpbmdzLmluc2VydEpTT05Gcm9tUGF0aCh0aGlzLl9jb25uLCB0ZXh0LCBvcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIEFuIGFzeW5jIHJlc3VsdCBzdHJlYW0gaXRlcmF0b3IgKi9cclxuZXhwb3J0IGNsYXNzIEFzeW5jUmVzdWx0U3RyZWFtSXRlcmF0b3IgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPFVpbnQ4QXJyYXk+IHtcclxuICAgIC8qKiBGaXJzdCBjaHVuaz8gKi9cclxuICAgIHByb3RlY3RlZCBfZmlyc3Q6IGJvb2xlYW47XHJcbiAgICAvKiogUmVhY2hlZCBlbmQgb2Ygc3RyZWFtPyAqL1xyXG4gICAgcHJvdGVjdGVkIF9kZXBsZXRlZDogYm9vbGVhbjtcclxuICAgIC8qKiBJbi1mbGlnaHQgKi9cclxuICAgIHByb3RlY3RlZCBfaW5GbGlnaHQ6IFByb21pc2U8VWludDhBcnJheT4gfCBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBkYjogQXN5bmNEdWNrREIsXHJcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbm46IG51bWJlcixcclxuICAgICAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgaGVhZGVyOiBVaW50OEFycmF5LFxyXG4gICAgKSB7XHJcbiAgICAgICAgdGhpcy5fZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2RlcGxldGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5GbGlnaHQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxVaW50OEFycmF5Pj4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9maXJzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuaGVhZGVyIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9kZXBsZXRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYnVmZmVyOiBVaW50OEFycmF5O1xyXG4gICAgICAgIGlmICh0aGlzLl9pbkZsaWdodCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IGF3YWl0IHRoaXMuX2luRmxpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLl9pbkZsaWdodCA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyID0gYXdhaXQgdGhpcy5kYi5mZXRjaFF1ZXJ5UmVzdWx0cyh0aGlzLmNvbm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZXBsZXRlZCA9IGJ1ZmZlci5sZW5ndGggPT0gMDtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlcGxldGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luRmxpZ2h0ID0gdGhpcy5kYi5mZXRjaFF1ZXJ5UmVzdWx0cyh0aGlzLmNvbm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb25lOiB0aGlzLl9kZXBsZXRlZCxcclxuICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcixcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBBIHRoaW4gaGVscGVyIHRvIGJpbmQgdGhlIHByZXBhcmVkIHN0YXRlbWVudCBpZCAqL1xyXG5leHBvcnQgY2xhc3MgQXN5bmNQcmVwYXJlZFN0YXRlbWVudDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PiB7XHJcbiAgICAvKiogVGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYmluZGluZ3M6IEFzeW5jRHVja0RCO1xyXG4gICAgLyoqIFRoZSBjb25uZWN0aW9uIGlkICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgY29ubmVjdGlvbklkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHN0YXRlbWVudCBpZCAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0YXRlbWVudElkOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIENvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nczogQXN5bmNEdWNrREIsIGNvbm5lY3Rpb25JZDogbnVtYmVyLCBzdGF0ZW1lbnRJZDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xyXG4gICAgICAgIHRoaXMuc3RhdGVtZW50SWQgPSBzdGF0ZW1lbnRJZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjbG9zZSgpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmJpbmRpbmdzLmNsb3NlUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSdW4gYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBhc3luYyBxdWVyeSguLi5wYXJhbXM6IGFueVtdKTogUHJvbWlzZTxhcnJvdy5UYWJsZTxUPj4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHRoaXMuYmluZGluZ3MucnVuUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQsIHBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihidWZmZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzRmlsZSgpKTtcclxuICAgICAgICByZXR1cm4gbmV3IGFycm93LlRhYmxlKHJlYWRlciBhcyBhcnJvdy5SZWNvcmRCYXRjaEZpbGVSZWFkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTZW5kIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2VuZCguLi5wYXJhbXM6IGFueVtdKTogUHJvbWlzZTxhcnJvdy5Bc3luY1JlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+PiB7XHJcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgdGhpcy5iaW5kaW5ncy5zZW5kUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQsIHBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBBc3luY1Jlc3VsdFN0cmVhbUl0ZXJhdG9yKHRoaXMuYmluZGluZ3MsIHRoaXMuY29ubmVjdGlvbklkLCBoZWFkZXIpO1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGF3YWl0IGFycm93LlJlY29yZEJhdGNoUmVhZGVyLmZyb208VD4oaXRlcik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzQXN5bmMoKSk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3RyZWFtKCkpO1xyXG4gICAgICAgIHJldHVybiByZWFkZXIgYXMgdW5rbm93biBhcyBhcnJvdy5Bc3luY1JlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+OyAvLyBYWFhcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMsIEFycm93SW5zZXJ0T3B0aW9ucyB9IGZyb20gJy4uL2JpbmRpbmdzL2luc2VydF9vcHRpb25zJztcclxuaW1wb3J0IHsgTG9nRW50cnlWYXJpYW50IH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgU2NyaXB0VG9rZW5zIH0gZnJvbSAnLi4vYmluZGluZ3MvdG9rZW5zJztcclxuaW1wb3J0IHsgRmlsZVN0YXRpc3RpY3MgfSBmcm9tICcuLi9iaW5kaW5ncy9maWxlX3N0YXRzJztcclxuaW1wb3J0IHsgRHVja0RCQ29uZmlnIH0gZnJvbSAnLi4vYmluZGluZ3MvY29uZmlnJztcclxuaW1wb3J0IHsgV2ViRmlsZSB9IGZyb20gJy4uL2JpbmRpbmdzL3dlYl9maWxlJztcclxuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLi4vYmluZGluZ3MvcHJvZ3Jlc3MnO1xyXG5pbXBvcnQgeyBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuLi9iaW5kaW5ncyc7XHJcblxyXG5leHBvcnQgdHlwZSBDb25uZWN0aW9uSUQgPSBudW1iZXI7XHJcbmV4cG9ydCB0eXBlIFN0YXRlbWVudElEID0gbnVtYmVyO1xyXG5cclxuZXhwb3J0IGVudW0gV29ya2VyUmVxdWVzdFR5cGUge1xyXG4gICAgQ0FOQ0VMX1BFTkRJTkdfUVVFUlkgPSAnQ0FOQ0VMX1BFTkRJTkdfUVVFUlknLFxyXG4gICAgQ0xPU0VfUFJFUEFSRUQgPSAnQ0xPU0VfUFJFUEFSRUQnLFxyXG4gICAgQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1MgPSAnQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1MnLFxyXG4gICAgQ09OTkVDVCA9ICdDT05ORUNUJyxcclxuICAgIENPUFlfRklMRV9UT19CVUZGRVIgPSAnQ09QWV9GSUxFX1RPX0JVRkZFUicsXHJcbiAgICBDT1BZX0ZJTEVfVE9fUEFUSCA9ICdDT1BZX0ZJTEVfVE9fUEFUSCcsXHJcbiAgICBDUkVBVEVfUFJFUEFSRUQgPSAnQ1JFQVRFX1BSRVBBUkVEJyxcclxuICAgIERJU0NPTk5FQ1QgPSAnRElTQ09OTkVDVCcsXHJcbiAgICBEUk9QX0ZJTEUgPSAnRFJPUF9GSUxFJyxcclxuICAgIERST1BfRklMRVMgPSAnRFJPUF9GSUxFUycsXHJcbiAgICBFWFBPUlRfRklMRV9TVEFUSVNUSUNTID0gJ0VYUE9SVF9GSUxFX1NUQVRJU1RJQ1MnLFxyXG4gICAgRkVUQ0hfUVVFUllfUkVTVUxUUyA9ICdGRVRDSF9RVUVSWV9SRVNVTFRTJyxcclxuICAgIEZMVVNIX0ZJTEVTID0gJ0ZMVVNIX0ZJTEVTJyxcclxuICAgIEdFVF9GRUFUVVJFX0ZMQUdTID0gJ0dFVF9GRUFUVVJFX0ZMQUdTJyxcclxuICAgIEdFVF9UQUJMRV9OQU1FUyA9ICdHRVRfVEFCTEVfTkFNRVMnLFxyXG4gICAgR0VUX1ZFUlNJT04gPSAnR0VUX1ZFUlNJT04nLFxyXG4gICAgR0xPQl9GSUxFX0lORk9TID0gJ0dMT0JfRklMRV9JTkZPUycsXHJcbiAgICBJTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNID0gJ0lOU0VSVF9BUlJPV19GUk9NX0lQQ19TVFJFQU0nLFxyXG4gICAgSU5TRVJUX0NTVl9GUk9NX1BBVEggPSAnSU1QT1JUX0NTVl9GUk9NX1BBVEgnLFxyXG4gICAgSU5TRVJUX0pTT05fRlJPTV9QQVRIID0gJ0lNUE9SVF9KU09OX0ZST01fUEFUSCcsXHJcbiAgICBJTlNUQU5USUFURSA9ICdJTlNUQU5USUFURScsXHJcbiAgICBPUEVOID0gJ09QRU4nLFxyXG4gICAgUElORyA9ICdQSU5HJyxcclxuICAgIFBPTExfUEVORElOR19RVUVSWSA9ICdQT0xMX1BFTkRJTkdfUVVFUlknLFxyXG4gICAgUkVHSVNURVJfRklMRV9CVUZGRVIgPSAnUkVHSVNURVJfRklMRV9CVUZGRVInLFxyXG4gICAgUkVHSVNURVJfRklMRV9IQU5ETEUgPSAnUkVHSVNURVJfRklMRV9IQU5ETEUnLFxyXG4gICAgUkVHSVNURVJfRklMRV9VUkwgPSAnUkVHSVNURVJfRklMRV9VUkwnLFxyXG4gICAgUkVTRVQgPSAnUkVTRVQnLFxyXG4gICAgUlVOX1BSRVBBUkVEID0gJ1JVTl9QUkVQQVJFRCcsXHJcbiAgICBSVU5fUVVFUlkgPSAnUlVOX1FVRVJZJyxcclxuICAgIFNFTkRfUFJFUEFSRUQgPSAnU0VORF9QUkVQQVJFRCcsXHJcbiAgICBTVEFSVF9QRU5ESU5HX1FVRVJZID0gJ1NUQVJUX1BFTkRJTkdfUVVFUlknLFxyXG4gICAgVE9LRU5JWkUgPSAnVE9LRU5JWkUnLFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBXb3JrZXJSZXNwb25zZVR5cGUge1xyXG4gICAgQ09OTkVDVElPTl9JTkZPID0gJ0NPTk5FQ1RJT05fSU5GTycsXHJcbiAgICBFUlJPUiA9ICdFUlJPUicsXHJcbiAgICBGRUFUVVJFX0ZMQUdTID0gJ0ZFQVRVUkVfRkxBR1MnLFxyXG4gICAgRklMRV9CVUZGRVIgPSAnRklMRV9CVUZGRVInLFxyXG4gICAgRklMRV9JTkZPUyA9ICdGSUxFX0lORk9TJyxcclxuICAgIEZJTEVfU0laRSA9ICdGSUxFX1NJWkUnLFxyXG4gICAgRklMRV9TVEFUSVNUSUNTID0gJ0ZJTEVfU1RBVElTVElDUycsXHJcbiAgICBJTlNUQU5USUFURV9QUk9HUkVTUyA9ICdJTlNUQU5USUFURV9QUk9HUkVTUycsXHJcbiAgICBMT0cgPSAnTE9HJyxcclxuICAgIE9LID0gJ09LJyxcclxuICAgIFBSRVBBUkVEX1NUQVRFTUVOVF9JRCA9ICdQUkVQQVJFRF9TVEFURU1FTlRfSUQnLFxyXG4gICAgUVVFUllfUExBTiA9ICdRVUVSWV9QTEFOJyxcclxuICAgIFFVRVJZX1JFU1VMVCA9ICdRVUVSWV9SRVNVTFQnLFxyXG4gICAgUVVFUllfUkVTVUxUX0NIVU5LID0gJ1FVRVJZX1JFU1VMVF9DSFVOSycsXHJcbiAgICBRVUVSWV9SRVNVTFRfSEVBREVSID0gJ1FVRVJZX1JFU1VMVF9IRUFERVInLFxyXG4gICAgUVVFUllfUkVTVUxUX0hFQURFUl9PUl9OVUxMID0gJ1FVRVJZX1JFU1VMVF9IRUFERVJfT1JfTlVMTCcsXHJcbiAgICBSRUdJU1RFUkVEX0ZJTEUgPSAnUkVHSVNURVJFRF9GSUxFJyxcclxuICAgIFNDUklQVF9UT0tFTlMgPSAnU0NSSVBUX1RPS0VOUycsXHJcbiAgICBTVUNDRVNTID0gJ1NVQ0NFU1MnLFxyXG4gICAgVEFCTEVfTkFNRVMgPSAnVEFCTEVfTkFNRVMnLFxyXG4gICAgVkVSU0lPTl9TVFJJTkcgPSAnVkVSU0lPTl9TVFJJTkcnLFxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBXb3JrZXJSZXF1ZXN0PFQsIFA+ID0ge1xyXG4gICAgcmVhZG9ubHkgbWVzc2FnZUlkOiBudW1iZXI7XHJcbiAgICByZWFkb25seSB0eXBlOiBUO1xyXG4gICAgcmVhZG9ubHkgZGF0YTogUDtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFdvcmtlclJlc3BvbnNlPFQsIFA+ID0ge1xyXG4gICAgcmVhZG9ubHkgbWVzc2FnZUlkOiBudW1iZXI7XHJcbiAgICByZWFkb25seSByZXF1ZXN0SWQ6IG51bWJlcjtcclxuICAgIHJlYWRvbmx5IHR5cGU6IFQ7XHJcbiAgICByZWFkb25seSBkYXRhOiBQO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgV29ya2VyVGFza1JldHVyblR5cGU8VCBleHRlbmRzIFdvcmtlclRhc2tWYXJpYW50PiA9IFQgZXh0ZW5kcyBXb3JrZXJUYXNrPGFueSwgYW55LCBpbmZlciBQPiA/IFAgOiBuZXZlcjtcclxuXHJcbmV4cG9ydCBjbGFzcyBXb3JrZXJUYXNrPFQsIEQsIFA+IHtcclxuICAgIHJlYWRvbmx5IHR5cGU6IFQ7XHJcbiAgICByZWFkb25seSBkYXRhOiBEO1xyXG4gICAgcHJvbWlzZTogUHJvbWlzZTxQPjtcclxuICAgIHByb21pc2VSZXNvbHZlcjogKHZhbHVlOiBQIHwgUHJvbWlzZUxpa2U8UD4pID0+IHZvaWQgPSAoKSA9PiB7fTtcclxuICAgIHByb21pc2VSZWplY3RlcjogKHZhbHVlOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7fTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlOiBULCBkYXRhOiBEKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlPFA+KFxyXG4gICAgICAgICAgICAocmVzb2x2ZTogKHZhbHVlOiBQIHwgUHJvbWlzZUxpa2U8UD4pID0+IHZvaWQsIHJlamVjdDogKHJlYXNvbj86IHZvaWQpID0+IHZvaWQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZVJlamVjdGVyID0gcmVqZWN0O1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFdvcmtlclJlcXVlc3RWYXJpYW50ID1cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCwgW0Nvbm5lY3Rpb25JRCwgU3RhdGVtZW50SURdPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNBTkNFTF9QRU5ESU5HX1FVRVJZLCBudW1iZXI+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1MsIFtzdHJpbmcsIGJvb2xlYW5dPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNPTk5FQ1QsIG51bGw+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUiwgc3RyaW5nPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19QQVRILCBbc3RyaW5nLCBzdHJpbmddPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNSRUFURV9QUkVQQVJFRCwgW0Nvbm5lY3Rpb25JRCwgc3RyaW5nXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5ESVNDT05ORUNULCBudW1iZXI+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFLCBzdHJpbmc+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbD5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTLCBzdHJpbmc+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUywgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkZMVVNIX0ZJTEVTLCBudWxsPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkdFVF9GRUFUVVJFX0ZMQUdTLCBudWxsPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkdFVF9UQUJMRV9OQU1FUywgW251bWJlciwgc3RyaW5nXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVkVSU0lPTiwgbnVsbD5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1MsIHN0cmluZz5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxcclxuICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9BUlJPV19GUk9NX0lQQ19TVFJFQU0sXHJcbiAgICAgICAgICBbbnVtYmVyLCBVaW50OEFycmF5LCBBcnJvd0luc2VydE9wdGlvbnMgfCB1bmRlZmluZWRdXHJcbiAgICAgID5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQ1NWX0ZST01fUEFUSCwgW251bWJlciwgc3RyaW5nLCBDU1ZJbnNlcnRPcHRpb25zXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfSlNPTl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgSlNPTkluc2VydE9wdGlvbnNdPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLklOU1RBTlRJQVRFLCBbc3RyaW5nLCBzdHJpbmcgfCBudWxsXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOLCBEdWNrREJDb25maWc+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUElORywgbnVsbD5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5QT0xMX1BFTkRJTkdfUVVFUlksIG51bWJlcj5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUiwgW3N0cmluZywgVWludDhBcnJheV0+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsIFtzdHJpbmcsIGFueSwgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCwgW3N0cmluZywgc3RyaW5nLCBEdWNrREJEYXRhUHJvdG9jb2wsIGJvb2xlYW5dPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJFU0VULCBudWxsPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyLCBhbnlbXV0+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLCBbbnVtYmVyLCBzdHJpbmddPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlciwgYW55W11dPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlNUQVJUX1BFTkRJTkdfUVVFUlksIFtudW1iZXIsIHN0cmluZ10+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuVE9LRU5JWkUsIHN0cmluZz47XHJcblxyXG5leHBvcnQgdHlwZSBXb3JrZXJSZXNwb25zZVZhcmlhbnQgPVxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuQ09OTkVDVElPTl9JTkZPLCBudW1iZXI+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5FUlJPUiwgYW55PlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuRkVBVFVSRV9GTEFHUywgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuRklMRV9CVUZGRVIsIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX0lORk9TLCBXZWJGaWxlW10+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NJWkUsIG51bWJlcj5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfU1RBVElTVElDUywgRmlsZVN0YXRpc3RpY3M+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5JTlNUQU5USUFURV9QUk9HUkVTUywgSW5zdGFudGlhdGlvblByb2dyZXNzPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuTE9HLCBMb2dFbnRyeVZhcmlhbnQ+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5PSywgbnVsbD5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlBSRVBBUkVEX1NUQVRFTUVOVF9JRCwgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUExBTiwgVWludDhBcnJheT5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVCwgVWludDhBcnJheT5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVF9DSFVOSywgVWludDhBcnJheT5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVF9IRUFERVIsIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfSEVBREVSX09SX05VTEwsIFVpbnQ4QXJyYXkgfCBudWxsPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuU0NSSVBUX1RPS0VOUywgU2NyaXB0VG9rZW5zPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuU1VDQ0VTUywgYm9vbGVhbj5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlRBQkxFX05BTUVTLCBzdHJpbmdbXT5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlZFUlNJT05fU1RSSU5HLCBzdHJpbmc+O1xyXG5cclxuZXhwb3J0IHR5cGUgV29ya2VyVGFza1ZhcmlhbnQgPVxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLCBbc3RyaW5nLCBib29sZWFuXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNULCBudWxsLCBDb25uZWN0aW9uSUQ+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUiwgc3RyaW5nLCBVaW50OEFycmF5PlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19QQVRILCBbc3RyaW5nLCBzdHJpbmddLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNSRUFURV9QUkVQQVJFRCwgW251bWJlciwgc3RyaW5nXSwgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkRJU0NPTk5FQ1QsIENvbm5lY3Rpb25JRCwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEUsIHN0cmluZywgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEVTLCBudWxsLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkVYUE9SVF9GSUxFX1NUQVRJU1RJQ1MsIHN0cmluZywgRmlsZVN0YXRpc3RpY3M+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUywgQ29ubmVjdGlvbklELCBVaW50OEFycmF5PlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkZMVVNIX0ZJTEVTLCBudWxsLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9GRUFUVVJFX0ZMQUdTLCBudWxsLCBudW1iZXI+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuR0VUX1RBQkxFX05BTUVTLCBbbnVtYmVyLCBzdHJpbmddLCBzdHJpbmdbXT5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVkVSU0lPTiwgbnVsbCwgc3RyaW5nPlxyXG4gICAgfCBXb3JrZXJUYXNrPFxyXG4gICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0FSUk9XX0ZST01fSVBDX1NUUkVBTSxcclxuICAgICAgICAgIFtudW1iZXIsIFVpbnQ4QXJyYXksIEFycm93SW5zZXJ0T3B0aW9ucyB8IHVuZGVmaW5lZF0sXHJcbiAgICAgICAgICBudWxsXHJcbiAgICAgID5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQ1NWX0ZST01fUEFUSCwgW251bWJlciwgc3RyaW5nLCBDU1ZJbnNlcnRPcHRpb25zXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfSlNPTl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgSlNPTkluc2VydE9wdGlvbnNdLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLklOU1RBTlRJQVRFLCBbc3RyaW5nLCBzdHJpbmcgfCBudWxsXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOLCBEdWNrREJDb25maWcsIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUElORywgbnVsbCwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUiwgW3N0cmluZywgVWludDhBcnJheV0sIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsIFtzdHJpbmcsIGFueSwgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCwgW3N0cmluZywgc3RyaW5nLCBEdWNrREJEYXRhUHJvdG9jb2wsIGJvb2xlYW5dLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdMT0JfRklMRV9JTkZPUywgc3RyaW5nLCBXZWJGaWxlW10+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUkVTRVQsIG51bGwsIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUlVOX1BSRVBBUkVELCBbbnVtYmVyLCBudW1iZXIsIGFueVtdXSwgVWludDhBcnJheT5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUVVFUlksIFtDb25uZWN0aW9uSUQsIHN0cmluZ10sIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyLCBhbnlbXV0sIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWSwgW0Nvbm5lY3Rpb25JRCwgc3RyaW5nXSwgVWludDhBcnJheSB8IG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLCBDb25uZWN0aW9uSUQsIFVpbnQ4QXJyYXkgfCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNBTkNFTF9QRU5ESU5HX1FVRVJZLCBDb25uZWN0aW9uSUQsIGJvb2xlYW4+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuVE9LRU5JWkUsIHN0cmluZywgU2NyaXB0VG9rZW5zPjtcclxuIiwgImltcG9ydCB7XHJcbiAgICBXb3JrZXJSZXF1ZXN0VHlwZSxcclxuICAgIFdvcmtlclJlc3BvbnNlVHlwZSxcclxuICAgIFdvcmtlclJlc3BvbnNlVmFyaWFudCxcclxuICAgIFdvcmtlclRhc2tWYXJpYW50LFxyXG4gICAgV29ya2VyVGFzayxcclxuICAgIENvbm5lY3Rpb25JRCxcclxuICAgIFdvcmtlclRhc2tSZXR1cm5UeXBlLFxyXG59IGZyb20gJy4vd29ya2VyX3JlcXVlc3QnO1xyXG5pbXBvcnQgeyBBc3luY0R1Y2tEQkJpbmRpbmdzIH0gZnJvbSAnLi9hc3luY19iaW5kaW5nc19pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2cnO1xyXG5pbXBvcnQgeyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24gfSBmcm9tICcuL2FzeW5jX2Nvbm5lY3Rpb24nO1xyXG5pbXBvcnQgeyBDU1ZJbnNlcnRPcHRpb25zLCBKU09OSW5zZXJ0T3B0aW9ucywgQXJyb3dJbnNlcnRPcHRpb25zIH0gZnJvbSAnLi4vYmluZGluZ3MvaW5zZXJ0X29wdGlvbnMnO1xyXG5pbXBvcnQgeyBTY3JpcHRUb2tlbnMgfSBmcm9tICcuLi9iaW5kaW5ncy90b2tlbnMnO1xyXG5pbXBvcnQgeyBGaWxlU3RhdGlzdGljcyB9IGZyb20gJy4uL2JpbmRpbmdzL2ZpbGVfc3RhdHMnO1xyXG5pbXBvcnQgeyBEdWNrREJDb25maWcgfSBmcm9tICcuLi9iaW5kaW5ncy9jb25maWcnO1xyXG5pbXBvcnQgeyBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MgfSBmcm9tICcuLi9iaW5kaW5ncy9wcm9ncmVzcyc7XHJcbmltcG9ydCB7IGFycm93VG9TUUxGaWVsZCB9IGZyb20gJy4uL2pzb25fdHlwZWRlZic7XHJcbmltcG9ydCB7IFdlYkZpbGUgfSBmcm9tICcuLi9iaW5kaW5ncy93ZWJfZmlsZSc7XHJcbmltcG9ydCB7IER1Y2tEQkRhdGFQcm90b2NvbCB9IGZyb20gJy4uL2JpbmRpbmdzJztcclxuXHJcbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFzeW5jRHVja0RCIGltcGxlbWVudHMgQXN5bmNEdWNrREJCaW5kaW5ncyB7XHJcbiAgICAvKiogVGhlIG1lc3NhZ2UgaGFuZGxlciAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9vbk1lc3NhZ2VIYW5kbGVyOiAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4gdm9pZDtcclxuICAgIC8qKiBUaGUgZXJyb3IgaGFuZGxlciAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9vbkVycm9ySGFuZGxlcjogKGV2ZW50OiBFcnJvckV2ZW50KSA9PiB2b2lkO1xyXG4gICAgLyoqIFRoZSBjbG9zZSBoYW5kbGVyICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX29uQ2xvc2VIYW5kbGVyOiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgbW9kdWxlICovXHJcbiAgICBwcm90ZWN0ZWQgX29uSW5zdGFudGlhdGlvblByb2dyZXNzOiAoKHA6IEluc3RhbnRpYXRpb25Qcm9ncmVzcykgPT4gdm9pZClbXSA9IFtdO1xyXG5cclxuICAgIC8qKiBUaGUgbG9nZ2VyICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2xvZ2dlcjogTG9nZ2VyO1xyXG4gICAgLyoqIFRoZSB3b3JrZXIgKi9cclxuICAgIHByb3RlY3RlZCBfd29ya2VyOiBXb3JrZXIgfCBudWxsID0gbnVsbDtcclxuICAgIC8qKiBUaGUgcHJvbWlzZSBmb3IgdGhlIHdvcmtlciBzaHV0ZG93biAqL1xyXG4gICAgcHJvdGVjdGVkIF93b3JrZXJTaHV0ZG93blByb21pc2U6IFByb21pc2U8bnVsbD4gfCBudWxsID0gbnVsbDtcclxuICAgIC8qKiBNYWtlIHRoZSB3b3JrZXIgYXMgdGVybWluYXRlZCAqL1xyXG4gICAgcHJvdGVjdGVkIF93b3JrZXJTaHV0ZG93blJlc29sdmVyOiAodmFsdWU6IFByb21pc2VMaWtlPG51bGw+IHwgbnVsbCkgPT4gdm9pZCA9ICgpID0+IHt9O1xyXG5cclxuICAgIC8qKiBUaGUgbmV4dCBtZXNzYWdlIGlkICovXHJcbiAgICBwcm90ZWN0ZWQgX25leHRNZXNzYWdlSWQgPSAwO1xyXG4gICAgLyoqIFRoZSBwZW5kaW5nIHJlcXVlc3RzICovXHJcbiAgICBwcm90ZWN0ZWQgX3BlbmRpbmdSZXF1ZXN0czogTWFwPG51bWJlciwgV29ya2VyVGFza1ZhcmlhbnQ+ID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcjogTG9nZ2VyLCB3b3JrZXI6IFdvcmtlciB8IG51bGwgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyO1xyXG4gICAgICAgIHRoaXMuX29uTWVzc2FnZUhhbmRsZXIgPSB0aGlzLm9uTWVzc2FnZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29uRXJyb3JIYW5kbGVyID0gdGhpcy5vbkVycm9yLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fb25DbG9zZUhhbmRsZXIgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcclxuICAgICAgICBpZiAod29ya2VyICE9IG51bGwpIHRoaXMuYXR0YWNoKHdvcmtlcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCB0aGUgbG9nZ2VyICovXHJcbiAgICBwdWJsaWMgZ2V0IGxvZ2dlcigpOiBMb2dnZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dnZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEF0dGFjaCB0byB3b3JrZXIgKi9cclxuICAgIHByb3RlY3RlZCBhdHRhY2god29ya2VyOiBXb3JrZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXI7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2VIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl93b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25DbG9zZUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUHJvbWlzZSA9IG5ldyBQcm9taXNlPG51bGw+KFxyXG4gICAgICAgICAgICAocmVzb2x2ZTogKHZhbHVlOiBQcm9taXNlTGlrZTxudWxsPiB8IG51bGwpID0+IHZvaWQsIF9yZWplY3Q6IChyZWFzb24/OiB2b2lkKSA9PiB2b2lkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blJlc29sdmVyID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEZXRhY2ggZnJvbSB3b3JrZXIgKi9cclxuICAgIHB1YmxpYyBkZXRhY2goKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93b3JrZXIpIHJldHVybjtcclxuICAgICAgICB0aGlzLl93b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX29uTWVzc2FnZUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3JIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl93b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vbkNsb3NlSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blJlc29sdmVyKG51bGwpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUHJvbWlzZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyU2h1dGRvd25SZXNvbHZlciA9ICgpID0+IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBLaWxsIHRoZSB3b3JrZXIgKi9cclxuICAgIHB1YmxpYyBhc3luYyB0ZXJtaW5hdGUoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93b3JrZXIpIHJldHVybjtcclxuICAgICAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICAgICAgLy9hd2FpdCB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2U7IFRPRE8gZGVhZGxvY2tpbmcgaW4ga2FybWE/XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUmVzb2x2ZXIgPSAoKSA9PiB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUG9zdCBhIHRhc2sgKi9cclxuICAgIHByb3RlY3RlZCBhc3luYyBwb3N0VGFzazxXIGV4dGVuZHMgV29ya2VyVGFza1ZhcmlhbnQ+KFxyXG4gICAgICAgIHRhc2s6IFcsXHJcbiAgICAgICAgdHJhbnNmZXI6IEFycmF5QnVmZmVyW10gPSBbXSxcclxuICAgICk6IFByb21pc2U8V29ya2VyVGFza1JldHVyblR5cGU8Vz4+IHtcclxuICAgICAgICBpZiAoIXRoaXMuX3dvcmtlcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjYW5ub3Qgc2VuZCBhIG1lc3NhZ2Ugc2luY2UgdGhlIHdvcmtlciBpcyBub3Qgc2V0IScpO1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkIGFzIGFueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWlkID0gdGhpcy5fbmV4dE1lc3NhZ2VJZCsrO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zZXQobWlkLCB0YXNrKTtcclxuICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2UoXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWlkLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdGFzay50eXBlLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogdGFzay5kYXRhLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0cmFuc2ZlcixcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiAoYXdhaXQgdGFzay5wcm9taXNlKSBhcyBXb3JrZXJUYXNrUmV0dXJuVHlwZTxXPjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVjZWl2ZWQgYSBtZXNzYWdlICovXHJcbiAgICBwcm90ZWN0ZWQgb25NZXNzYWdlKGV2ZW50OiBNZXNzYWdlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICAvLyBVbmFzc29jaWF0ZWQgcmVzcG9uc2VzP1xyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXZlbnQuZGF0YSBhcyBXb3JrZXJSZXNwb25zZVZhcmlhbnQ7XHJcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS50eXBlKSB7XHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgZmFpbGVkP1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlc3BvbnNlVHlwZS5MT0c6IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5sb2cocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2FsbCBwcm9ncmVzcyBjYWxsYmFja1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlc3BvbnNlVHlwZS5JTlNUQU5USUFURV9QUk9HUkVTUzoge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMuX29uSW5zdGFudGlhdGlvblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcChyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IGFzc29jaWF0ZWQgdGFza1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZ2V0KHJlc3BvbnNlLnJlcXVlc3RJZCk7XHJcbiAgICAgICAgaWYgKCF0YXNrKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdW5hc3NvY2lhdGVkIHJlc3BvbnNlOiBbJHtyZXNwb25zZS5yZXF1ZXN0SWR9LCAke3Jlc3BvbnNlLnR5cGUudG9TdHJpbmcoKX1dYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShyZXNwb25zZS5yZXF1ZXN0SWQpO1xyXG5cclxuICAgICAgICAvLyBSZXF1ZXN0IGZhaWxlZD9cclxuICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRVJST1IpIHtcclxuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgRmlyZWZveCBub3QgYmVpbmcgYWJsZSB0byBwZXJmb3JtIHN0cnVjdHVyZWQtY2xvbmUgb24gTmF0aXZlIEVycm9yc1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTU2NjA0XHJcbiAgICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IocmVzcG9uc2UuZGF0YS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgZS5uYW1lID0gcmVzcG9uc2UuZGF0YS5uYW1lO1xyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCAnc3RhY2snKT8ud3JpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIGUuc3RhY2sgPSByZXNwb25zZS5kYXRhLnN0YWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlamVjdGVyKGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB0YXNrcyBmaXJzdFxyXG4gICAgICAgIHN3aXRjaCAodGFzay50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ0xPU0VfUFJFUEFSRUQ6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1M6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEg6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVDpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEU6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUzpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5GTFVTSF9GSUxFUzpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNOlxyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRIOlxyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9KU09OX0ZST01fUEFUSDpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOOlxyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlBJTkc6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9CVUZGRVI6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEU6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9VUkw6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVTRVQ6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNUQU5USUFURTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5zdGFudGlhdGlvblByb2dyZXNzID0gW107XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1M6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRklMRV9JTkZPUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlZFUlNJT05fU1RSSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuR0VUX0ZFQVRVUkVfRkxBR1M6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRkVBVFVSRV9GTEFHUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkdFVF9UQUJMRV9OQU1FUzpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5UQUJMRV9OQU1FUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlNDUklQVF9UT0tFTlMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfQlVGRkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRVhQT1JUX0ZJTEVfU1RBVElTVElDUzpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NUQVRJU1RJQ1MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNUOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkNPTk5FQ1RJT05fSU5GTykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRDpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUVVFUlk6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRDpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfSEVBREVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWTpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfSEVBREVSX09SX05VTEwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5QT0xMX1BFTkRJTkdfUVVFUlk6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0hFQURFUl9PUl9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ0FOQ0VMX1BFTkRJTkdfUVVFUlk6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkluc3RhbnRpYXRpb25Qcm9ncmVzcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5GRVRDSF9RVUVSWV9SRVNVTFRTOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVF9DSFVOSykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkNSRUFURV9QUkVQQVJFRDpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5QUkVQQVJFRF9TVEFURU1FTlRfSUQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFzay5wcm9taXNlUmVqZWN0ZXIobmV3IEVycm9yKGB1bmV4cGVjdGVkIHJlc3BvbnNlIHR5cGU6ICR7cmVzcG9uc2UudHlwZS50b1N0cmluZygpfWApKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVjZWl2ZWQgYW4gZXJyb3IgKi9cclxuICAgIHByb3RlY3RlZCBvbkVycm9yKGV2ZW50OiBFcnJvckV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihldmVudCk7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgZXJyb3IgaW4gZHVja2RiIHdvcmtlcjogJHtldmVudC5tZXNzYWdlfWApO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgd29ya2VyIHdhcyBjbG9zZWQgKi9cclxuICAgIHByb3RlY3RlZCBvbkNsb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUmVzb2x2ZXIobnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaXplICE9IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB3b3JrZXIgdGVybWluYXRlZCB3aXRoICR7dGhpcy5fcGVuZGluZ1JlcXVlc3RzLnNpemV9IHBlbmRpbmcgcmVxdWVzdHNgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzZXQgdGhlIGR1Y2tkYiAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlc2V0KCk6IFByb21pc2U8bnVsbD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRVNFVCwgbnVsbCwgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuUkVTRVQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBQaW5nIHRoZSB3b3JrZXIgdGhyZWFkICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcGluZygpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsLCBudWxsPihXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG4gICAgLyoqIFRyeSB0byBkcm9wIGEgZmlsZSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGRyb3BGaWxlKG5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVsbD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEUsIHN0cmluZywgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFLCBuYW1lKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuICAgIC8qKiBUcnkgdG8gZHJvcCBmaWxlcyAqL1xyXG4gICAgcHVibGljIGFzeW5jIGRyb3BGaWxlcygpOiBQcm9taXNlPG51bGw+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbCwgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogRmx1c2ggYWxsIGZpbGVzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZmx1c2hGaWxlcygpOiBQcm9taXNlPG51bGw+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkxVU0hfRklMRVMsIG51bGwsIG51bGw+KFdvcmtlclJlcXVlc3RUeXBlLkZMVVNIX0ZJTEVTLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3BlbiB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnN0YW50aWF0ZShcclxuICAgICAgICBtYWluTW9kdWxlVVJMOiBzdHJpbmcsXHJcbiAgICAgICAgcHRocmVhZFdvcmtlclVSTDogc3RyaW5nIHwgbnVsbCA9IG51bGwsXHJcbiAgICAgICAgcHJvZ3Jlc3M6IChwcm9ncmVzczogSW5zdGFudGlhdGlvblByb2dyZXNzKSA9PiB2b2lkID0gX3AgPT4ge30sXHJcbiAgICApOiBQcm9taXNlPG51bGw+IHtcclxuICAgICAgICB0aGlzLl9vbkluc3RhbnRpYXRpb25Qcm9ncmVzcy5wdXNoKHByb2dyZXNzKTtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TVEFOVElBVEUsIFtzdHJpbmcsIHN0cmluZyB8IG51bGxdLCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TVEFOVElBVEUsXHJcbiAgICAgICAgICAgIFttYWluTW9kdWxlVVJMLCBwdGhyZWFkV29ya2VyVVJMXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIHZlcnNpb24gKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRWZXJzaW9uKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OLCBudWxsLCBzdHJpbmc+KFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OLCBudWxsKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBmZWF0dXJlIGZsYWdzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0RmVhdHVyZUZsYWdzKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9GRUFUVVJFX0ZMQUdTLCBudWxsLCBudW1iZXI+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfRkVBVFVSRV9GTEFHUyxcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBPcGVuIGEgbmV3IGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgb3Blbihjb25maWc6IER1Y2tEQkNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOLCBEdWNrREJDb25maWcsIG51bGw+KFdvcmtlclJlcXVlc3RUeXBlLk9QRU4sIGNvbmZpZyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVG9rZW5pemUgYSBzY3JpcHQgdGV4dCAqL1xyXG4gICAgcHVibGljIGFzeW5jIHRva2VuaXplKHRleHQ6IHN0cmluZyk6IFByb21pc2U8U2NyaXB0VG9rZW5zPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFLCBzdHJpbmcsIFNjcmlwdFRva2Vucz4oV29ya2VyUmVxdWVzdFR5cGUuVE9LRU5JWkUsIHRleHQpO1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29ubmVjdCB0byB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0SW50ZXJuYWwoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09OTkVDVCwgbnVsbCwgQ29ubmVjdGlvbklEPihXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNULCBudWxsKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29ubmVjdCB0byB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8QXN5bmNEdWNrREJDb25uZWN0aW9uPiB7XHJcbiAgICAgICAgY29uc3QgY2lkID0gYXdhaXQgdGhpcy5jb25uZWN0SW50ZXJuYWwoKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFzeW5jRHVja0RCQ29ubmVjdGlvbih0aGlzLCBjaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEaXNjb25uZWN0IGZyb20gdGhlIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZGlzY29ubmVjdChjb25uOiBDb25uZWN0aW9uSUQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCwgQ29ubmVjdGlvbklELCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCxcclxuICAgICAgICAgICAgY29ubixcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJ1biBhIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcnVuUXVlcnkoY29ubjogQ29ubmVjdGlvbklELCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLCBbQ29ubmVjdGlvbklELCBzdHJpbmddLCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLFxyXG4gICAgICAgICAgICBbY29ubiwgdGV4dF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU3RhcnQgYSBwZW5kaW5nIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc3RhcnRQZW5kaW5nUXVlcnkoY29ubjogQ29ubmVjdGlvbklELCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNUQVJUX1BFTkRJTkdfUVVFUlksIFtDb25uZWN0aW9uSUQsIHN0cmluZ10sIFVpbnQ4QXJyYXkgfCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWSxcclxuICAgICAgICAgICAgW2Nvbm4sIHRleHRdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogUG9sbCBhIHBlbmRpbmcgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBhc3luYyBwb2xsUGVuZGluZ1F1ZXJ5KGNvbm46IENvbm5lY3Rpb25JRCk6IFByb21pc2U8VWludDhBcnJheSB8IG51bGw+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLCBDb25uZWN0aW9uSUQsIFVpbnQ4QXJyYXkgfCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLFxyXG4gICAgICAgICAgICBjb25uLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogQ2FuY2VsIGEgcGVuZGluZyBxdWVyeSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGNhbmNlbFBlbmRpbmdRdWVyeShjb25uOiBDb25uZWN0aW9uSUQpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ0FOQ0VMX1BFTkRJTkdfUVVFUlksIENvbm5lY3Rpb25JRCwgYm9vbGVhbj4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNBTkNFTF9QRU5ESU5HX1FVRVJZLFxyXG4gICAgICAgICAgICBjb25uLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZldGNoIHF1ZXJ5IHJlc3VsdHMgKi9cclxuICAgIHB1YmxpYyBhc3luYyBmZXRjaFF1ZXJ5UmVzdWx0cyhjb25uOiBDb25uZWN0aW9uSUQpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUywgQ29ubmVjdGlvbklELCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUyxcclxuICAgICAgICAgICAgY29ubixcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGFibGUgbmFtZXMgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUYWJsZU5hbWVzKGNvbm46IG51bWJlciwgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVEFCTEVfTkFNRVMsIFtudW1iZXIsIHN0cmluZ10sIHN0cmluZ1tdPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuR0VUX1RBQkxFX05BTUVTLFxyXG4gICAgICAgICAgICBbY29ubiwgdGV4dF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUHJlcGFyZSBhIHN0YXRlbWVudCBhbmQgcmV0dXJuIGl0cyBpZGVudGlmaWVyICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlUHJlcGFyZWQoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsIFtudW1iZXIsIHN0cmluZ10sIG51bWJlcj4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNSRUFURV9QUkVQQVJFRCxcclxuICAgICAgICAgICAgW2Nvbm4sIHRleHRdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjbG9zZVByZXBhcmVkKGNvbm46IG51bWJlciwgc3RhdGVtZW50OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ0xPU0VfUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlcl0sIG51bGw+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCxcclxuICAgICAgICAgICAgW2Nvbm4sIHN0YXRlbWVudF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG4gICAgLyoqIEV4ZWN1dGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgYW5kIHJldHVybiB0aGUgZnVsbCByZXN1bHQgKi9cclxuICAgIHB1YmxpYyBhc3luYyBydW5QcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRCwgW0Nvbm5lY3Rpb25JRCwgbnVtYmVyLCBhbnlbXV0sIFVpbnQ4QXJyYXk+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUFJFUEFSRUQsXHJcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnQsIHBhcmFtc10sXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuICAgIC8qKiBFeGVjdXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50IGFuZCBzdHJlYW0gdGhlIHJlc3VsdCAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNlbmRQcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsIFtDb25uZWN0aW9uSUQsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRCxcclxuICAgICAgICAgICAgW2Nvbm4sIHN0YXRlbWVudCwgcGFyYW1zXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG4gICAgLyoqIEdsb2IgZmlsZSBpbmZvcyAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdsb2JGaWxlcyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFdlYkZpbGVbXT4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1MsIHN0cmluZywgV2ViRmlsZVtdPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuR0xPQl9GSUxFX0lORk9TLFxyXG4gICAgICAgICAgICBwYXRoLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogUmVnaXN0ZXIgZmlsZSB0ZXh0ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJGaWxlVGV4dChuYW1lOiBzdHJpbmcsIHRleHQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRFWFRfRU5DT0RFUi5lbmNvZGUodGV4dCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlckZpbGVCdWZmZXIobmFtZSwgYnVmZmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgcGF0aC4gKi9cclxuICAgIHB1YmxpYyBhc3luYyByZWdpc3RlckZpbGVVUkwoXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIHVybDogc3RyaW5nLFxyXG4gICAgICAgIHByb3RvOiBEdWNrREJEYXRhUHJvdG9jb2wsXHJcbiAgICAgICAgZGlyZWN0SU86IGJvb2xlYW4sXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdXJsID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCxcclxuICAgICAgICAgICAgW3N0cmluZywgc3RyaW5nLCBEdWNrREJEYXRhUHJvdG9jb2wsIGJvb2xlYW5dLFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgPihXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCwgW25hbWUsIHVybCwgcHJvdG8sIGRpcmVjdElPXSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVnaXN0ZXIgYW4gZW1wdHkgZmlsZSBidWZmZXIuICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIobmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSLCBbc3RyaW5nLCBVaW50OEFycmF5XSwgbnVsbD4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSLFxyXG4gICAgICAgICAgICBbbmFtZSwgbmV3IFVpbnQ4QXJyYXkoKV0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgYnVmZmVyLiAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlZ2lzdGVyRmlsZUJ1ZmZlcihuYW1lOiBzdHJpbmcsIGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUiwgW3N0cmluZywgVWludDhBcnJheV0sIG51bGw+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUixcclxuICAgICAgICAgICAgW25hbWUsIGJ1ZmZlcl0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtidWZmZXIuYnVmZmVyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlZ2lzdGVyIGEgZmlsZSBoYW5kbGUuICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJGaWxlSGFuZGxlPEhhbmRsZVR5cGU+KFxyXG4gICAgICAgIG5hbWU6IHN0cmluZyxcclxuICAgICAgICBoYW5kbGU6IEhhbmRsZVR5cGUsXHJcbiAgICAgICAgcHJvdG9jb2w6IER1Y2tEQkRhdGFQcm90b2NvbCxcclxuICAgICAgICBkaXJlY3RJTzogYm9vbGVhbixcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsXHJcbiAgICAgICAgICAgIFtzdHJpbmcsIGFueSwgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXSxcclxuICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgID4oV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsIFtuYW1lLCBoYW5kbGUsIHByb3RvY29sLCBkaXJlY3RJT10pO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzaywgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFbmFibGUgZmlsZSBzdGF0aXN0aWNzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY29sbGVjdEZpbGVTdGF0aXN0aWNzKG5hbWU6IHN0cmluZywgZW5hYmxlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLCBbc3RyaW5nLCBib29sZWFuXSwgbnVsbD4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLFxyXG4gICAgICAgICAgICBbbmFtZSwgZW5hYmxlXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzaywgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFeHBvcnQgZmlsZSBzdGF0aXN0aWNzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZXhwb3J0RmlsZVN0YXRpc3RpY3MobmFtZTogc3RyaW5nKTogUHJvbWlzZTxGaWxlU3RhdGlzdGljcz4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTLCBzdHJpbmcsIEZpbGVTdGF0aXN0aWNzPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRVhQT1JUX0ZJTEVfU1RBVElTVElDUyxcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29weSBhIGZpbGUgdG8gYSBidWZmZXIuICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY29weUZpbGVUb0J1ZmZlcihuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUiwgc3RyaW5nLCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUixcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDb3B5IGEgZmlsZSB0byBhIHBhdGguICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY29weUZpbGVUb1BhdGgobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEgsIFtzdHJpbmcsIHN0cmluZ10sIG51bGw+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fUEFUSCxcclxuICAgICAgICAgICAgW25hbWUsIHBhdGhdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IGFycm93IGZyb20gYW4gaXBjIHN0cmVhbSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShcclxuICAgICAgICBjb25uOiBDb25uZWN0aW9uSUQsXHJcbiAgICAgICAgYnVmZmVyOiBVaW50OEFycmF5LFxyXG4gICAgICAgIG9wdGlvbnM/OiBBcnJvd0luc2VydE9wdGlvbnMsXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICAgICAgLy8gUGFzcyB0byB0aGUgd29ya2VyXHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNLFxyXG4gICAgICAgICAgICBbbnVtYmVyLCBVaW50OEFycmF5LCBBcnJvd0luc2VydE9wdGlvbnMgfCB1bmRlZmluZWRdLFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgPihXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNLCBbY29ubiwgYnVmZmVyLCBvcHRpb25zXSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrLCBbYnVmZmVyLmJ1ZmZlcl0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEluc2VydCBhIGNzdiBmaWxlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0Q1NWRnJvbVBhdGgoY29ubjogQ29ubmVjdGlvbklELCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IENTVkluc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBGbGF0dGVuIHRoZSB0YWJsZSBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5jb2x1bW5zW2tdO1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2goYXJyb3dUb1NRTEZpZWxkKGssIHR5cGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zLmNvbHVtbnNGbGF0ID0gb3V0O1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jb2x1bW5zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFzcyB0byB0aGUgd29ya2VyXHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIENTVkluc2VydE9wdGlvbnNdLCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0NTVl9GUk9NX1BBVEgsXHJcbiAgICAgICAgICAgIFtjb25uLCBwYXRoLCBvcHRpb25zXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGEganNvbiBmaWxlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0SlNPTkZyb21QYXRoKGNvbm46IENvbm5lY3Rpb25JRCwgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBKU09OSW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIHRhYmxlIG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2x1bW5zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBvcHRpb25zLmNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLmNvbHVtbnNba107XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChhcnJvd1RvU1FMRmllbGQoaywgdHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sdW1uc0ZsYXQgPSBvdXQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNvbHVtbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXNzIHRvIHRoZSB3b3JrZXJcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0pTT05fRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIEpTT05JbnNlcnRPcHRpb25zXSwgbnVsbD4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9KU09OX0ZST01fUEFUSCxcclxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdGlvbnNdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IFdvcmtlciBmcm9tICd3ZWItd29ya2VyJztcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVXb3JrZXIodXJsOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwpO1xyXG4gICAgY29uc3Qgd29ya2VyU2NyaXB0ID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgICBjb25zdCB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGF3YWl0IHdvcmtlclNjcmlwdC5ibG9iKCkpO1xyXG4gICAgcmV0dXJuIG5ldyBXb3JrZXIod29ya2VyVVJMKTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBWZWN0b3IgfSBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgeyBEdWNrREJRdWVyeUNvbmZpZyB9IGZyb20gJy4uL3NyYy8nO1xyXG5cclxuLy8gVGhlIG1heCBpbnRlcnZhbCBpbiBtaWNyb3NlYyBmcm9tIER1Y2tEQiBpcyA4MyB5ZWFycyAzIG1vbnRocyA5OTkgZGF5cyAwMDoxNjozOS45OTk5OTksIHdpdGggbW9udGhzIGFzIDMwIGRheXMuXHJcbi8vIE5vdGUgdGhhdCBkdWUgdG8gQXJyb3cgSlMgbm90IHN1cHBvcnRpbmcgdGhlIGR1cmF0aW9uIHR5cGUsIHRoZSBjYXN0RHVyYXRpb25Ub0ludGVydmFsIG9wdGlvbiBpcyB1c2VkIGZvciBpbnRlcnZhbHMuXHJcbi8vIFRoaXMgaGFzIGEgc2lkZS1lZmZlY3QgdGhhdCB3aGlsZSB0aGUgdmFsdWUgaXMgaW4gbWljcm9zZWNvbmRzLCBpdCBvbmx5IGhhcyBtaWxsaXNlY29uZCBhY2N1cmFjeS4gVGhpcyBpc1xyXG4vLyBiZWNhdXNlIER1Y2tEQiBlbWl0cyBpbnRlcnZhbHMgaW4gbWlsbGlzZWNvbmRzIGFuZCB0aGUgQXJyb3cgVGltZTY0IHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBtaWxsaXNlY29uZHMgYXMgdW5pdC5cclxuLy9jb25zdCBNQVhfSU5URVJWQUxfVVMgPSAoKCg4MyAqICgxMiAqIDMwKSArIDMgKiAzMCArIDk5OSkgKiAyNCAqIDYwICsgMTYpICogNjAgKyAzOSkgKiAxMDAwMDAwICsgOTk5MDAwO1xyXG5cclxuLy8gSlMgRGF0ZSBhdCArLy04NjQwMDAwMDAwMDAwMDAwbXNcclxuY29uc3QgTUlOSU1VTV9EQVRFX1NUUiA9ICctMjcxODIxLTA0LTIwJztcclxuY29uc3QgTUlOSU1VTV9EQVRFID0gbmV3IERhdGUoRGF0ZS5VVEMoLTI3MTgyMSwgMywgMjApKTtcclxuY29uc3QgTUFYSU1VTV9EQVRFX1NUUiA9ICcyNzU3NjAtMDktMTMnO1xyXG5jb25zdCBNQVhJTVVNX0RBVEUgPSBuZXcgRGF0ZShEYXRlLlVUQygyNzU3NjAsIDgsIDEzKSk7XHJcblxyXG4vLyBBbGwgY29sdW1ucyBjb250YWluIDMgdmFsdWVzOiBbbWluX3ZhbHVlLCBtYXhfdmFsdWUsIG51bGxdXHJcbnR5cGUgQW5zd2VyT2JqZWN0VHlwZSA9IHtcclxuICAgIFtrZXk6IHN0cmluZ106IGFueVtdO1xyXG59O1xyXG5cclxuaW50ZXJmYWNlIEFsbFR5cGVzVGVzdCB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBxdWVyeTogc3RyaW5nO1xyXG4gICAgc2tpcDogc3RyaW5nW107XHJcbiAgICBhbnN3ZXJNYXA6IEFuc3dlck9iamVjdFR5cGU7XHJcbiAgICBhbnN3ZXJDb3VudDogbnVtYmVyO1xyXG4gICAgcXVlcnlDb25maWc6IER1Y2tEQlF1ZXJ5Q29uZmlnIHwgbnVsbDtcclxufVxyXG5cclxuLy8gVGhlc2UgdHlwZXMgY3VycmVudGx5IGRvIG5vdCB3b3JrIGluIER1Y2tEQi1XQVNNXHJcbi8vIHRpbWVzdGFtcF94eCBhbmQgZGF0ZV90eiB0eXBlcyB3aWxsIHNvb24gYmUgZnVsbHkgc3VwcG9ydGVkIGJ5IGR1Y2tkYiBhbmQgc2hvdWxkIGJlIGFkZGVkIHRoZW4uXHJcbi8vIGh1Z2VpbnQsIGRlY18xOF8zLCBkZWMzOF8xMCBhbmQgdXVpZCByZXF1aXJlIEpTIEJpZ0ludHMgZm9yIGZ1bGwgc3VwcG9ydCwgd2hpY2ggaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnkgQXJyb3dKU1xyXG5jb25zdCBOT1RfSU1QTEVNRU5URURfVFlQRVMgPSBbXHJcbiAgICAndGltZXN0YW1wX3MnLFxyXG4gICAgJ3RpbWVzdGFtcF9tcycsXHJcbiAgICAndGltZXN0YW1wX25zJyxcclxuICAgICd0aW1lc3RhbXBfdHonLFxyXG4gICAgJ2h1Z2VpbnQnLFxyXG4gICAgJ2RlY18xOF82JyxcclxuICAgICdkZWMzOF8xMCcsXHJcbiAgICAndXVpZCcsXHJcbiAgICAnbWFwJyxcclxuICAgICdqc29uJyxcclxuICAgICdkYXRlX2FycmF5JyxcclxuICAgICd0aW1lc3RhbXBfYXJyYXknLFxyXG4gICAgJ3RpbWVzdGFtcHR6X2FycmF5JyxcclxuXTtcclxuXHJcbi8vIFRoZXNlIHR5cGVzIGFyZSBzdXBwb3J0ZWQsIGJ1dCBub3QgdGhlIGZ1bGwgcmFuZ2UgcmV0dXJuZWQgZnJvbSB0aGUgdGVzdF9hbGxfdHlwZXMoKSB0YWJsZSBmdW5jdGlvbiwgaGVyZSB3ZSBkZWZpbmVcclxuLy8gdGhlIGxpbWl0cyB3ZSBkbyBleHBlY3QgdG8gYmUgc3VwcG9ydGVkLlxyXG5jb25zdCBQQVJUSUFMTFlfSU1QTEVNRU5URURfVFlQRVMgPSBbJ2RhdGUnLCAndGltZXN0YW1wJ107XHJcbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQOiBBbnN3ZXJPYmplY3RUeXBlID0ge1xyXG4gICAgZGF0ZTogW01JTklNVU1fREFURS52YWx1ZU9mKCksIE1BWElNVU1fREFURS52YWx1ZU9mKCksIG51bGxdLFxyXG4gICAgdGltZXN0YW1wOiBbTUlOSU1VTV9EQVRFLnZhbHVlT2YoKSwgTUFYSU1VTV9EQVRFLnZhbHVlT2YoKSwgbnVsbF0sXHJcbn07XHJcblxyXG4vLyBTdWJxdWVyaWVzIHRoYXQgcmV0dXJuIHRoZSBsaW1pdHMgb2YgdGhlIHN1YnNldCBvZiB0aGUgZnVsbCByYW5nZSB0aGF0IGlzIGltcGxlbWVudGVkXHJcbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFU19TVUJTVElUVVRJT05TID0gW1xyXG4gICAgYChTRUxFQ1QgYXJyYXlfZXh0cmFjdChbJyR7TUlOSU1VTV9EQVRFX1NUUn0nOjpEYXRlLCcke01BWElNVU1fREFURV9TVFJ9Jzo6RGF0ZSxudWxsXSxpICsgMSkpIGFzIGRhdGVgLFxyXG4gICAgYChTRUxFQ1QgYXJyYXlfZXh0cmFjdChbJyR7TUlOSU1VTV9EQVRFX1NUUn0nOjpUaW1lc3RhbXAsJyR7TUFYSU1VTV9EQVRFX1NUUn0nOjpUaW1lc3RhbXAsbnVsbF0saSArIDEpKSBhcyB0aW1lc3RhbXBgLFxyXG5dO1xyXG5cclxuLy8gVGhlc2UgdHlwZXMgZG8gbm90IHdvcmsgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24sIGJ1dCBoYXZlXHJcbmNvbnN0IFRZUEVTX1JFUVVJUklOR19DVVNUT01fQ09ORklHID0gWydkZWNfNF8xJywgJ2RlY185XzQnXTtcclxuXHJcbi8vIFR5cGVzIHRoYXQgYXJlIGZ1bGx5IHN1cHBvcnRlZC5cclxuY29uc3QgRlVMTFlfSU1QTEVNRU5URURfQU5TV0VSX01BUDogQW5zd2VyT2JqZWN0VHlwZSA9IHtcclxuICAgIGJvb2w6IFtmYWxzZSwgdHJ1ZSwgbnVsbF0sXHJcbiAgICB0aW55aW50OiBbLTEyOCwgMTI3LCBudWxsXSxcclxuICAgIHNtYWxsaW50OiBbLTMyNzY4LCAzMjc2NywgbnVsbF0sXHJcbiAgICBpbnQ6IFstMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0NywgbnVsbF0sXHJcbiAgICB1dGlueWludDogWzAsIDI1NSwgbnVsbF0sXHJcbiAgICB1c21hbGxpbnQ6IFswLCA2NTUzNSwgbnVsbF0sXHJcbiAgICB1aW50OiBbMCwgNDI5NDk2NzI5NSwgbnVsbF0sXHJcbiAgICB1YmlnaW50OiBbQmlnSW50KDApLCBCaWdJbnQoJzE4NDQ2NzQ0MDczNzA5NTUxNjE1JyksIG51bGxdLFxyXG4gICAgYmlnaW50OiBbQmlnSW50KCctOTIyMzM3MjAzNjg1NDc3NTgwOCcpLCBCaWdJbnQoJzkyMjMzNzIwMzY4NTQ3NzU4MDcnKSwgbnVsbF0sXHJcblxyXG4gICAgLy8gTm90ZSB0aGF0IHdlIG11bHRpcGx5IGJ5IHRob3VzYW5kIChhbmQgYWRkIDk5OSBmb3IgdGhlIG1heCkgYmVjYXVzZSB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgRHVja0RCIGlzIGluIG1pY3Jvc2Vjb25kcyxcclxuICAgIC8vIHdoZXJlYXMgdGhlIERhdGUgb2JqZWN0IGlzIGluIG1pbGxpc2Vjb25kcy5cclxuICAgIHRpbWU6IFtCaWdJbnQoMCksIEJpZ0ludChuZXcgRGF0ZSgnMTk3MC0wMS0wMVQyMzo1OTo1OS45OTkrMDA6MDAnKS52YWx1ZU9mKCkpICogQmlnSW50KDEwMDApICsgQmlnSW50KDk5OSksIG51bGxdLFxyXG4gICAgdGltZV90ejogW1xyXG4gICAgICAgIEJpZ0ludCgwKSxcclxuICAgICAgICBCaWdJbnQobmV3IERhdGUoJzE5NzAtMDEtMDFUMjM6NTk6NTkuOTk5KzAwOjAwJykudmFsdWVPZigpKSAqIEJpZ0ludCgxMDAwKSArIEJpZ0ludCg5OTkpLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICBdLFxyXG4gICAgaW50ZXJ2YWw6IFtuZXcgSW50MzJBcnJheShbMCwwXSksICBuZXcgSW50MzJBcnJheShbMCwwXSksIG51bGxdLFxyXG5cclxuICAgIGZsb2F0OiBbLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgMy40MDI4MjM0NjYzODUyODg2ZTM4LCBudWxsXSxcclxuICAgIGRvdWJsZTogWy0xLjc5NzY5MzEzNDg2MjMxNTdlMzA4LCAxLjc5NzY5MzEzNDg2MjMxNTdlMzA4LCBudWxsXSxcclxuICAgIHZhcmNoYXI6IFsnXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2JywgJ2dvb1xceDAwc2UnLCBudWxsXSxcclxuICAgIHNtYWxsX2VudW06IFsnRFVDS19EVUNLX0VOVU0nLCAnR09PU0UnLCBudWxsXSxcclxuICAgIG1lZGl1bV9lbnVtOiBbJ2VudW1fMCcsICdlbnVtXzI5OScsIG51bGxdLFxyXG4gICAgbGFyZ2VfZW51bTogWydlbnVtXzAnLCAnZW51bV82OTk5OScsIG51bGxdLFxyXG5cclxuICAgIGludF9hcnJheTogW1tdLCBbNDIsIDk5OSwgbnVsbCwgbnVsbCwgLTQyXSwgbnVsbF0sXHJcbiAgICBkb3VibGVfYXJyYXk6IFtbXSwgWzQyLjAsIE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSwgbnVsbCwgLTQyLjBdLCBudWxsXSxcclxuICAgIHZhcmNoYXJfYXJyYXk6IFtbXSwgWydcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODYnLCAnZ29vc2UnLCBudWxsLCAnJ10sIG51bGxdLFxyXG4gICAgbmVzdGVkX2ludF9hcnJheTogW1tdLCBbW10sIFs0MiwgOTk5LCBudWxsLCBudWxsLCAtNDJdLCBudWxsLCBbXSwgWzQyLCA5OTksIG51bGwsIG51bGwsIC00Ml1dLCBudWxsXSxcclxuXHJcbiAgICBzdHJ1Y3Q6IFsne1wiYVwiOm51bGwsXCJiXCI6bnVsbH0nLCAne1wiYVwiOjQyLFwiYlwiOlwiXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XCJ9JywgbnVsbF0sXHJcbiAgICBzdHJ1Y3Rfb2ZfYXJyYXlzOiBbXHJcbiAgICAgICAgJ3tcImFcIjpudWxsLFwiYlwiOm51bGx9JyxcclxuICAgICAgICAne1wiYVwiOls0Miw5OTksbnVsbCxudWxsLC00Ml0sXCJiXCI6W1wiXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XCIsXCJnb29zZVwiLG51bGwsXCJcIl19JyxcclxuICAgICAgICBudWxsLFxyXG4gICAgXSxcclxuICAgIGFycmF5X29mX3N0cnVjdHM6IFtbXSwgWyd7XCJhXCI6bnVsbCxcImJcIjpudWxsfScsICd7XCJhXCI6NDIsXCJiXCI6XCJcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcIn0nLCBudWxsXSwgbnVsbF0sXHJcblxyXG4gICAgLy8gWFhYIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgIC8vIG1hcDogWyd7fScsICd7XCJrZXkxXCI6XCJcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcIixcImtleTJcIjpcImdvb3NlXCJ9JywgbnVsbF0sXHJcbiAgICBibG9iOiBbXHJcbiAgICAgICAgVWludDhBcnJheS5mcm9tKFtcclxuICAgICAgICAgICAgMTE2LCAxMDQsIDEwNSwgMTE1LCAxMDUsIDExNSwgOTcsIDEwOCwgMTExLCAxMTAsIDEwMywgOTgsIDEwOCwgMTExLCA5OCwgMCwgMTE5LCAxMDUsIDExNiwgMTA0LCAxMTAsIDExNyxcclxuICAgICAgICAgICAgMTA4LCAxMDgsIDk4LCAxMjEsIDExNiwgMTAxLCAxMTUsXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgVWludDhBcnJheS5mcm9tKFswLCAwLCAwLCA5N10pLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICBdLFxyXG59O1xyXG5cclxuLy8gUmVwbGFjZW1lbnRzIGZvciB0aGUgdmFsdWVzIHdlIGtub3dpbmdseSBkb24ndCBzdXBwb3J0IGZyb20gdGhlIHRlc3RfYWxsX3R5cGVzIHF1ZXJ5XHJcbmNvbnN0IFJFUExBQ0VfQ09MVU1OUyA9IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFUy5jb25jYXQoTk9UX0lNUExFTUVOVEVEX1RZUEVTKS5jb25jYXQoVFlQRVNfUkVRVUlSSU5HX0NVU1RPTV9DT05GSUcpO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrKHY6IGFueSk6IGFueSB7XHJcbiAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgaWYgKHYgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICBjb25zdCByZXQgPSBBcnJheS5mcm9tKHYudG9BcnJheSgpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXYuaXNWYWxpZChpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5wYWNrKHJldCk7XHJcbiAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IHJldDogYW55ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHVucGFjayh2W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0gZWxzZSBpZiAodi50b0pTT04gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2LnRvSlNPTigpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWUoeDogYW55KTogYW55IHtcclxuICAgIGlmICh0eXBlb2YgeD8udmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiB4LnZhbHVlT2YoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IEFMTF9UWVBFU19URVNUOiBBbGxUeXBlc1Rlc3RbXSA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnZnVsbHkgc3VwcG9ydGVkIHR5cGVzJyxcclxuICAgICAgICBxdWVyeTogYFNFTEVDVCAqIFJFUExBQ0UoJ25vdF9pbXBsZW1lbnRlZCcgYXMgbWFwKSBGUk9NIHRlc3RfYWxsX3R5cGVzKClgLFxyXG4gICAgICAgIHNraXA6IFJFUExBQ0VfQ09MVU1OUyxcclxuICAgICAgICBhbnN3ZXJNYXA6IEZVTExZX0lNUExFTUVOVEVEX0FOU1dFUl9NQVAsXHJcbiAgICAgICAgYW5zd2VyQ291bnQ6IFJFUExBQ0VfQ09MVU1OUy5sZW5ndGggKyBPYmplY3Qua2V5cyhGVUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQKS5sZW5ndGgsXHJcbiAgICAgICAgcXVlcnlDb25maWc6IG51bGwsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdwYXJ0aWFsbHkgc3VwcG9ydGVkIHR5cGVzJyxcclxuICAgICAgICBxdWVyeTogYFNFTEVDVCAke1BBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFU19TVUJTVElUVVRJT05TLmpvaW4oJywgJyl9XHJcbiAgICAgICAgICAgICAgICBGUk9NIHJhbmdlKDAsIDMpIHRibChpKWAsXHJcbiAgICAgICAgc2tpcDogW10sXHJcbiAgICAgICAgYW5zd2VyTWFwOiBQQVJUSUFMTFlfSU1QTEVNRU5URURfQU5TV0VSX01BUCxcclxuICAgICAgICBhbnN3ZXJDb3VudDogUEFSVElBTExZX0lNUExFTUVOVEVEX1RZUEVTLmxlbmd0aCxcclxuICAgICAgICBxdWVyeUNvbmZpZzogbnVsbCxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3R5cGVzIHdpdGggY3VzdG9tIGNvbmZpZycsXHJcbiAgICAgICAgcXVlcnk6IGBTRUxFQ1QgJHtUWVBFU19SRVFVSVJJTkdfQ1VTVE9NX0NPTkZJRy5qb2luKCcsJyl9IEZST00gdGVzdF9hbGxfdHlwZXMoKWAsXHJcbiAgICAgICAgc2tpcDogW10sXHJcbiAgICAgICAgYW5zd2VyTWFwOiB7XHJcbiAgICAgICAgICAgIGRlY180XzE6IFstOTk5LjkwMDAwMDAwMDAwMDEsIDk5OS45MDAwMDAwMDAwMDAxLCBudWxsXSxcclxuICAgICAgICAgICAgZGVjXzlfNDogWy05OTk5OS45OTk5MDAwMDAwMSwgOTk5OTkuOTk5OTAwMDAwMDEsIG51bGxdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5zd2VyQ291bnQ6IFRZUEVTX1JFUVVJUklOR19DVVNUT01fQ09ORklHLmxlbmd0aCxcclxuICAgICAgICBxdWVyeUNvbmZpZzoge1xyXG4gICAgICAgICAgICBjYXN0RGVjaW1hbFRvRG91YmxlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBbGxUeXBlcyhkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb24gfCBudWxsO1xyXG5cclxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgICAgIGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnVGVzdCBBbGwgVHlwZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEFMTF9UWVBFU19URVNUKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3QucXVlcnlDb25maWcpIGRiKCkub3Blbih7IHF1ZXJ5OiB0ZXN0LnF1ZXJ5Q29uZmlnIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLm51bUNvbHMpLnRvRXF1YWwodGVzdC5hbnN3ZXJDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0ZXN0LnNraXApIHtcclxuICAgICAgICAgICAgICAgICAgICBza2lwLnNldChzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5udW1Db2xzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcmVzdWx0cy5zY2hlbWEuZmllbGRzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJiaXRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gcmVzdWx0cy5nZXRDaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwLmdldChuYW1lKSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbCkubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbD8ubGVuZ3RoKS5ub3QudG9FcXVhbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHVucGFjayhnZXRWYWx1ZShjb2whLmdldCgwKSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzBdKTsgLy8gTWluXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHVucGFjayhnZXRWYWx1ZShjb2whLmdldCgxKSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzFdKTsgLy8gTWF4XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbCEuZ2V0KDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzJdKTsgLy8gTnVsbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBbGxUeXBlc0FzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbm4pIHtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjb25uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdUZXN0IEFsbCBUeXBlcyBBc3luYycsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgQUxMX1RZUEVTX1RFU1QpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdC5xdWVyeUNvbmZpZykgZGIoKS5vcGVuKHsgcXVlcnk6IHRlc3QucXVlcnlDb25maWcgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0cy5udW1Db2xzKS50b0VxdWFsKHRlc3QuYW5zd2VyQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGVzdC5za2lwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcC5zZXQocywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubnVtQ29sczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHJlc3VsdHMuc2NoZW1hLmZpZWxkc1tpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiYml0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHJlc3VsdHMuZ2V0Q2hpbGRBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcC5nZXQobmFtZSkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChjb2wpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChjb2w/Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChPYmplY3Qua2V5cyh0ZXN0LmFuc3dlck1hcCkpLnRvQ29udGFpbihuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodW5wYWNrKGdldFZhbHVlKGNvbCEuZ2V0KDApKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lICsgJ3wnICsgY29sPy50b1N0cmluZygpICsgJ3xbMF0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbCh0ZXN0LmFuc3dlck1hcFtuYW1lXVswXSk7IC8vIE1pblxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh1bnBhY2soZ2V0VmFsdWUoY29sIS5nZXQoMSkpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhDb250ZXh0KG5hbWUgKyAnfCcgKyBjb2w/LnRvU3RyaW5nKCkgKyAnfFsxXScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzFdKTsgLy8gTWF4XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbCEuZ2V0KDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aENvbnRleHQobmFtZSArICd8JyArIGNvbD8udG9TdHJpbmcoKSArICd8WzJdJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwodGVzdC5hbnN3ZXJNYXBbbmFtZV1bMl0pOyAvLyBOdWxsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCB7IGdldFMzUGFyYW1zLCBTM1BhcmFtcywgUzNQYXlsb2FkUGFyYW1zLCBjcmVhdGVTM0hlYWRlcnMsIHVyaUVuY29kZSwgZ2V0SFRUUFVybCB9IGZyb20gJy4uL3NyYy91dGlscyc7XHJcbmltcG9ydCB7IEFzeW5jRHVja0RCQ29ubmVjdGlvbiwgRHVja0RCQmluZGluZ3MsIER1Y2tEQkJpbmRpbmdzQmFzZSwgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCBCUk9XU0VSX1JVTlRJTUUgZnJvbSAnLi4vc3JjL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlcic7XHJcblxyXG4vLyBTMyBjb25maWcgZm9yIHRlc3RzXHJcbmNvbnN0IEJVQ0tFVF9OQU1FID0gJ3Rlc3QtYnVja2V0JztcclxuY29uc3QgQUNDRVNTX0tFWV9JRCA9ICdTM1JWRVInO1xyXG5jb25zdCBBQ0NFU1NfS0VZX1NFQ1JFVCA9ICdTM1JWRVInO1xyXG5jb25zdCBTM19FTkRQT0lOVCA9ICdodHRwOi8vbG9jYWxob3N0OjQ5MjMnO1xyXG5jb25zdCBTM19SRUdJT04gPSAnZXUtd2VzdC0xJztcclxuXHJcbmVudW0gQVdTQ29uZmlnVHlwZSB7XHJcbiAgICBFTVBUWSxcclxuICAgIFZBTElELFxyXG4gICAgSU5WQUxJRCxcclxufVxyXG5jb25zdCBzZXRBd3NDb25maWcgPSBhc3luYyBmdW5jdGlvbiAoY29ubjogQXN5bmNEdWNrREJDb25uZWN0aW9uLCB0eXBlOiBBV1NDb25maWdUeXBlID0gQVdTQ29uZmlnVHlwZS5WQUxJRCkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLkVNUFRZOlxyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3JlZ2lvbj0nJztcIik7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfYWNjZXNzX2tleV9pZD0nJztcIik7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfc2VjcmV0X2FjY2Vzc19rZXk9Jyc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49Jyc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfZW5kcG9pbnQ9JyR7UzNfRU5EUE9JTlR9JztgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLlZBTElEOlxyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfcmVnaW9uPScke1MzX1JFR0lPTn0nO2ApO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfYWNjZXNzX2tleV9pZD0nJHtBQ0NFU1NfS0VZX0lEfSc7YCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYFNFVCBzM19zZWNyZXRfYWNjZXNzX2tleT0nJHtBQ0NFU1NfS0VZX1NFQ1JFVH0nO2ApO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49Jyc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfZW5kcG9pbnQ9JyR7UzNfRU5EUE9JTlR9JztgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLklOVkFMSUQ6XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfcmVnaW9uPSdhLXZlcnktcmVtb3RlLWFuZC1ub24tZXhpc3RlbnQtczMtcmVnaW9uJztcIik7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfYWNjZXNzX2tleV9pZD0nVEhJU0FDQ0VTU0tFWUlESVNOT1RWQUxJRCc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PSdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49J0lOVkFMSURTRVNTSU9OVE9LRU4nO1wiKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgU0VUIHMzX2VuZHBvaW50PScke1MzX0VORFBPSU5UfSc7YCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RIVFRQRlMoc2RiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbiB8IG51bGw7XHJcblxyXG4gICAgY29uc3QgZ2V0TW9kdWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBtb2R1bGU6IER1Y2tEQk1vZHVsZSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGNvbm4hLnVzZVVuc2FmZSgoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25fbnVtYmVyOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgbW9kdWxlID0gKGJpbmRpbmdzIGFzIER1Y2tEQkJpbmRpbmdzQmFzZSkubW9kO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV4cGVjdChtb2R1bGUpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNldCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBzZGIoKS5yZXNldCgpO1xyXG4gICAgICAgIGNvbm4gPSBzZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9O1xyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiBhd2FpdCByZXNldCgpKTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiBhd2FpdCByZXNldCgpKTtcclxuXHJcbiAgICBkZXNjcmliZSgnSFRUUEZTJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzMyBjb25maWcgaXMgc2V0IGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gZ2V0TW9kdWxlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBhcmUgZW1wdHlcclxuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm8gPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRXBvY2ggPSBnbG9iYWxGaWxlSW5mbyEuY2FjaGVFcG9jaDtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZykudG9CZURlZmluZWQoKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZz8ucmVnaW9uKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZz8uYWNjZXNzS2V5SWQpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5zZWNyZXRBY2Nlc3NLZXkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5lbmRwb2ludCkudG9FcXVhbCgnJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25maXJtIHNldHRpbmdzIGFyZSBjb3JyZWN0bHkgc2V0XHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX3JlZ2lvbj0nYS12ZXJ5LXJlbW90ZS1hbmQtbm9uLWV4aXN0ZW50LXMzLXJlZ2lvbic7XCIpO1xyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19hY2Nlc3Nfa2V5X2lkPSdUSElTQUNDRVNTS0VZSURJU05PVFZBTElEJztcIik7XHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PSdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCc7XCIpO1xyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19zZXNzaW9uX3Rva2VuPSdBTklDRVNFU1NJT05UT0tFTic7XCIpO1xyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0nczMuc29tZS5zb3J0Lm9mLmNsb3VkJztcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvVXBkYXRlZCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvVXBkYXRlZD8uczNDb25maWcpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mb1VwZGF0ZWQ/LmNhY2hlRXBvY2gpLnRvRXF1YWwoY2FjaGVFcG9jaCArIDUpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBnZXRTM1BhcmFtcyhnbG9iYWxGaWxlSW5mb1VwZGF0ZWQ/LnMzQ29uZmlnLCAnczM6Ly90ZXN0LWJ1Y2tldC90ZXN0ZmlsZS50eHQnLCAnR0VUJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMudXJsKS50b0VxdWFsKCcvdGVzdGZpbGUudHh0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMucXVlcnkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLmhvc3QpLnRvRXF1YWwoJ3Rlc3QtYnVja2V0LnMzLnNvbWUuc29ydC5vZi5jbG91ZCcpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnJlZ2lvbikudG9FcXVhbCgnYS12ZXJ5LXJlbW90ZS1hbmQtbm9uLWV4aXN0ZW50LXMzLXJlZ2lvbicpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnNlcnZpY2UpLnRvRXF1YWwoJ3MzJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMubWV0aG9kKS50b0VxdWFsKCdHRVQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5hY2Nlc3NLZXlJZCkudG9FcXVhbCgnVEhJU0FDQ0VTU0tFWUlESVNOT1RWQUxJRCcpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnNlY3JldEFjY2Vzc0tleSkudG9FcXVhbCgnVEhJU1NFQ1JFVEFDQ0VTU0tFWUlTTk9UVkFMSUQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJ0FOSUNFU0VTU0lPTlRPS0VOJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3ZlciBmdWxsIGh0dHAgZW5kcG9pbnQgY29uZmlnXHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdodHRwOi8vbG9jYWxob3N0OjEzMzcnO1wiKTtcclxuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm9GdWxsSHR0cEVuZHBvaW50ID0gQlJPV1NFUl9SVU5USU1FLmdldEdsb2JhbEZpbGVJbmZvKG1vZHVsZSEpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXNGdWxsSHR0cEVuZHBvaW50ID0gZ2V0UzNQYXJhbXMoXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxGaWxlSW5mb0Z1bGxIdHRwRW5kcG9pbnQ/LnMzQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgJ3MzOi8vdGVzdC1idWNrZXQvdGVzdGZpbGUudHh0JyxcclxuICAgICAgICAgICAgICAgICdHRVQnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zRnVsbEh0dHBFbmRwb2ludC5ob3N0KS50b0VxdWFsKCdsb2NhbGhvc3Q6MTMzNycpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgc2hvdWxkIGNsZWFyIGNvbmZpZ1xyXG4gICAgICAgICAgICBhd2FpdCByZXNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0NsZWFyZWQgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0NsZWFyZWQgPSBnZXRTM1BhcmFtcyhnbG9iYWxGaWxlSW5mb0NsZWFyZWQ/LnMzQ29uZmlnLCAnczM6Ly90ZXN0LWJ1Y2tldC90ZXN0ZmlsZS50eHQnLCAnR0VUJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLnVybCkudG9FcXVhbCgnL3Rlc3RmaWxlLnR4dCcpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5xdWVyeSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLmhvc3QpLnRvRXF1YWwoJ3Rlc3QtYnVja2V0LnMzLmFtYXpvbmF3cy5jb20nKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQucmVnaW9uKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQuc2VydmljZSkudG9FcXVhbCgnczMnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQubWV0aG9kKS50b0VxdWFsKCdHRVQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQuYWNjZXNzS2V5SWQpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5zZWNyZXRBY2Nlc3NLZXkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJycpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgndXJsIHBhcnNpbmcgaXMgY29ycmVjdCcsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gZ2V0TW9kdWxlKCk7XHJcblxyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0nJztcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvRGVmYXVsdCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvRGVmYXVsdD8uczNDb25maWcpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRVcmwgPSBnZXRIVFRQVXJsKGdsb2JhbEZpbGVJbmZvRGVmYXVsdD8uczNDb25maWcsIGBzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3QtZmlsZS5jc3ZgKTtcclxuICAgICAgICAgICAgZXhwZWN0KGRlZmF1bHRVcmwpLnRvRXF1YWwoYGh0dHBzOi8vJHtCVUNLRVRfTkFNRX0uczMuYW1hem9uYXdzLmNvbS90ZXN0LWZpbGUuY3N2YCk7XHJcblxyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0naHR0cHM6Ly9kdWNrZGJsYWJzLmNvbSc7XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0Z1bGxVcmwgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XHJcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mb0Z1bGxVcmw/LnMzQ29uZmlnKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gZ2V0SFRUUFVybChnbG9iYWxGaWxlSW5mb0Z1bGxVcmw/LnMzQ29uZmlnLCBgczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChmdWxsVXJsKS50b0VxdWFsKGBodHRwczovL2R1Y2tkYmxhYnMuY29tLyR7QlVDS0VUX05BTUV9L3Rlc3QtZmlsZS5jc3ZgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdkdWNrZGJsYWJzLmNvbSc7XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0RvbWFpbiA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvRG9tYWluPy5zM0NvbmZpZykudG9CZURlZmluZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgZG9tYWluT25seVVybCA9IGdldEhUVFBVcmwoZ2xvYmFsRmlsZUluZm9Eb21haW4/LnMzQ29uZmlnLCBgczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChkb21haW5Pbmx5VXJsKS50b0VxdWFsKGBodHRwczovLyR7QlVDS0VUX05BTUV9LmR1Y2tkYmxhYnMuY29tL3Rlc3QtZmlsZS5jc3ZgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gdmFsaWRhdGUgYXV0aG9yaXphdGlvbiBoZWFkZXJzIGZvciBrbm93biByZXF1ZXN0cywgYmFzZWQgb246IGh0dHBzOi8vY3phay5wbC8yMDE1LzA5LzE1L3MzLXJlc3QtYXBpLXdpdGgtY3VybC5odG1sXHJcbiAgICAgICAgaXQoJ3MzIGhlbHBlciBwYXNzZXMgdmFsaWRhdGlvbicsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGVzdFBhcmFtczE6IFMzUGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdXJsOiAnLycsXHJcbiAgICAgICAgICAgICAgICBxdWVyeTogJycsXHJcbiAgICAgICAgICAgICAgICBob3N0OiAnbXktcHJlY2lvdXMtYnVja2V0LnMzLmFtYXpvbmF3cy5jb20nLFxyXG4gICAgICAgICAgICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdzMycsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6ICdBS0lBSU9TRk9ETk43RVhBTVBMRScsXHJcbiAgICAgICAgICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6ICd3SmFsclhVdG5GRU1JL0s3TURFTkcvYlB4UmZpQ1lFWEFNUExFS0VZJyxcclxuICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogJycsXHJcbiAgICAgICAgICAgICAgICBkYXRlTm93OiAnMjAxNTA5MTUnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZXRpbWVOb3c6ICcyMDE1MDkxNVQxMjQ1MDBaJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlUzNIZWFkZXJzKHRlc3RQYXJhbXMxKS5nZXQoJ0F1dGhvcml6YXRpb24nKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChcclxuICAgICAgICAgICAgICAgICdBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9QUtJQUlPU0ZPRE5ON0VYQU1QTEUvMjAxNTA5MTUvdXMtZWFzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1ob3N0O3gtYW16LWNvbnRlbnQtc2hhMjU2O3gtYW16LWRhdGUsIFNpZ25hdHVyZT0xODIwNzJlYjUzZDg1YzM2YjJkNzkxYTFmYTQ2YTEyZDIzNDU0ZWMxZTkyMWIwMjA3NWMyM2FlZTQwMTY2ZDVhJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbF9xdWVyeV9zdHJpbmcgPSAnZGVsaW1pdGVyPSUyRiZlbmNvZGluZy10eXBlPXVybCZsaXN0LXR5cGU9MiZwcmVmaXg9JzsgLy8gYXdzIHMzIGxzIDxidWNrZXQ+XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQYXJhbXMyOiBTM1BhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogJy8nLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6IGNhbm9uaWNhbF9xdWVyeV9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBob3N0OiAnbXktcHJlY2lvdXMtYnVja2V0LnMzLmV1LXdlc3QtMS5hbWF6b25hd3MuY29tJyxcclxuICAgICAgICAgICAgICAgIHJlZ2lvbjogJ2V1LXdlc3QtMScsXHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiAnczMnLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiAnQVNJQVlTUElPWURUSFRCSUlUVkMnLFxyXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAndnMxQlpQeFNMMnFWQVJCU2c1dkNNS0pzYXZDb0VQbG8vSFNIUmFWZScsXHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uVG9rZW46XHJcbiAgICAgICAgICAgICAgICAgICAgJ0lRb0piM0pwWjJsdVgyVmpFTlgvLy8vLy8vLy8vd0VhQ1dWMUxYZGxjM1F0TVNKSE1FVUNJUURmanpzOUJZSHJFWERNVS9OUitQSFYxdVNUcjdDU1ZTUWRqS1NmaVBSTGRnSWdDQ3p0RjBWTWJpOSt1SEhBZkJWS2hWNHQ5TWxVclFnM1ZBT0lzTHhyV3lvcWxBSUlIUkFBR2d3MU9EazBNelE0T1RZMk1UUWlET0dsMkRzWXhFTmNLQ2JoK2lyeEFSZTkxZmFJK2h3VWhUNjBzTUdSRmcwR1dlZktuUGNsSDR1UkZ6Y3pyRE9jSmxBQWFRUko3S09zVDhCckpsclkxalNnamtPN1BrVmpQcDkydmk2bEpYNzdiZzk5TWtVVEpBY3RpT0ttZDg0WHZBRTViRmMvakZicWVjaHRCalh6b3BBUGtLc0d1YXFBaENlblhuRnQ2Y3dxK0xaaWt2L05KR1Z3N1RScGhMVitBcTlQU0w5WHdkeklnc1cycVh3ZTFjM3J4RE5qNTN5U3RSWkhWZ2dkeEowT2dIeDV2MDQwYzk4Z0ZwaHpTVUxIeWcwT1k2d21DTVRZY3N3cGI0a08ySUlpNkFpRDljWTI1VGx3UEtSS1BpNUNkQnNUUG55VGVXNjJ1N1B2d0swZlRTeTRadUpVdUdLUW5IMmNLbUNYcXVFd29PSEVpUVk2blFIOWZ6WS9FREdITVJ4V1doeHUwSGlxSWZzdUZxQzdHUzBwMFRvS1FFK3B6TnN2VndNalpjK0tJTElERFFwZENXUkl3dTUzSTVQWnkyQ3ZrKzN5NFhMdmRaS1FDc0FLcWVPYzRjOTRVQVM0Tm1VVDdtQ0RPdVJWMGNMQlZNOEYwSllCR3JVeHlJK1lvSXZIaFFXbW5STHVLZ1RiNVBrRjdaV3JYQkhGV0c1L3RaRE92QmJiYUNXVGxSQ0w5YjBWcGc1K0JNLzgxeGQ4akNoUDR3ODMnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZU5vdzogJzIwMjEwOTA0JyxcclxuICAgICAgICAgICAgICAgIGRhdGV0aW1lTm93OiAnMjAyMTA5MDRUMTIxNzQ2WicsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBjcmVhdGVTM0hlYWRlcnModGVzdFBhcmFtczIpLmdldCgnQXV0aG9yaXphdGlvbicpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0MikudG9FcXVhbChcclxuICAgICAgICAgICAgICAgICdBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9QVNJQVlTUElPWURUSFRCSUlUVkMvMjAyMTA5MDQvZXUtd2VzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1ob3N0O3gtYW16LWNvbnRlbnQtc2hhMjU2O3gtYW16LWRhdGU7eC1hbXotc2VjdXJpdHktdG9rZW4sIFNpZ25hdHVyZT00ZDlkNmI1OWQ3ODM2YjY0ODVmNmFkODIyZGU5N2JlNDAyODdkYTMwMzQ3ZDgzMDQyZWE3ZmJlZDUzMGRjNGMwJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQYXJhbXMzOiBTM1BhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogJy9jb3JyZWN0X2F1dGhfdGVzdC5jc3YnLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6ICcnLFxyXG4gICAgICAgICAgICAgICAgaG9zdDogJ3Rlc3QtYnVja2V0LWNlaXZlcmFuLnMzLmFtYXpvbmF3cy5jb20nLFxyXG4gICAgICAgICAgICAgICAgcmVnaW9uOiAnZXUtd2VzdC0xJyxcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdzMycsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6ICdTM1JWRVInLFxyXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAnUzNSVkVSJyxcclxuICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogJycsXHJcbiAgICAgICAgICAgICAgICBkYXRlTm93OiAnMjAyMjAxMjEnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZXRpbWVOb3c6ICcyMDIyMDEyMVQxNDE0NTJaJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdDNQYXlsb2FkUGFyYW1zOiBTM1BheWxvYWRQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50SGFzaDogJzI4YTBjZjZhYzVjNGNiNzM3OTMwOTFmZTZlY2M2YTY4YmY5MDg1NWFjOTE4NjE1ODc0ODE1OGY1MDI0MWJiMGMnLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICd0ZXh0L2RhdGE7Y2hhcnNldD11dGYtOCcsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDMgPSBjcmVhdGVTM0hlYWRlcnModGVzdFBhcmFtczMsIHRlc3QzUGF5bG9hZFBhcmFtcykuZ2V0KCdBdXRob3JpemF0aW9uJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQzKS50b0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgJ0FXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD1TM1JWRVIvMjAyMjAxMjEvZXUtd2VzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1jb250ZW50LXR5cGU7aG9zdDt4LWFtei1jb250ZW50LXNoYTI1Njt4LWFtei1kYXRlLCBTaWduYXR1cmU9NWQ5YTZjYmZhYTc4YTZkMGYyYWI3ZGYwNDQ1ZTJmMWNjOWM4MGNkMzY1NWFjN2RlOWU3MjE5YzAzNmYyM2YwMicsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvY2F0ZWdvcnk9Qm9va3MvJykpLnRvRXF1YWwoJy9jYXRlZ29yeSUzREJvb2tzLycpO1xyXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvP2NhdGVnb3J5PUJvb2tzJnRpdGxlPUR1Y2tzIFJldHJlYXQvJykpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICAnLyUzRmNhdGVnb3J5JTNEQm9va3MlMjZ0aXRsZSUzRER1Y2tzJTIwUmV0cmVhdC8nLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvP2NhdGVnb3J5PUJvb2tzJnRpdGxlPUR1Y2tzIFJldHJlYXQvJywgdHJ1ZSkpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICAnJTJGJTNGY2F0ZWdvcnklM0RCb29rcyUyNnRpdGxlJTNERHVja3MlMjBSZXRyZWF0JTJGJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdEhUVFBGU0FzeW5jKFxyXG4gICAgYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXHJcbiAgICByZXNvbHZlRGF0YTogKHVybDogc3RyaW5nKSA9PiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPixcclxuICAgIGJhc2VEaXI6IHN0cmluZyxcclxuKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGw7XHJcblxyXG4gICAgLy8gUFVUcyBhbiBTMyBmaWxlIHRvIHRoZSBTMyB0ZXN0IHNlcnZlclxyXG4gICAgY29uc3QgcHV0VGVzdEZpbGVUb1MzID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVOYW1lOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nLCB0ZXN0X2RhdGE6IFVpbnQ4QXJyYXkgfCBudWxsKSB7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCd0ZXN0X2ZpbGUucGFycXVldCcsIHRlc3RfZGF0YSEpO1xyXG4gICAgICAgIGlmICghY29ubikge1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiwgQVdTQ29uZmlnVHlwZS5WQUxJRCk7XHJcbiAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHRlc3RfdGFibGUgQVMgKFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCd0ZXN0X2ZpbGUucGFycXVldCcpKTtgKTtcclxuICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDT1BZIHRlc3RfdGFibGUgVE8gJ3MzOi8vJHtCVUNLRVRfTkFNRX0vJHtmaWxlTmFtZX0uJHtmb3JtYXR9JyAoRk9STUFUICcke2Zvcm1hdH0nKTtgKTtcclxuICAgICAgICBhd2FpdCBhZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlcXVpcmVzIGFuIG9wZW4gY29ublxyXG4gICAgY29uc3QgYXNzZXJ0VGVzdEZpbGVSZXN1bHRDb3JyZWN0ID0gYXN5bmMgZnVuY3Rpb24gKHJlc3VsdDogYW55LCB0ZXN0X2RhdGE6IFVpbnQ4QXJyYXkgfCBudWxsKSB7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCd0ZXN0X2ZpbGVfYmFzZWxpbmUucGFycXVldCcsIHRlc3RfZGF0YSEpO1xyXG4gICAgICAgIGF3YWl0IGNvbm4hLnF1ZXJ5KGBTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2NhbigndGVzdF9maWxlX2Jhc2VsaW5lLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAvLyBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCkudG9BcnJheSgpKS50b0VxdWFsKHJlc3VsdF9iYXNlbGluZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXNldCBkYXRhYmFzZXMgYmV0d2VlbiB0ZXN0c1xyXG4gICAgY29uc3QgcmVzZXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkucmVzZXQoKTtcclxuICAgICAgICBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgfTtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4gYXdhaXQgcmVzZXQoKSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4gYXdhaXQgcmVzZXQoKSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0hUVFBGUyBBc3luYycsICgpID0+IHtcclxuICAgICAgICBpdCgnY2FuIGZldGNoIGh0dHBzIGZpbGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uIS5xdWVyeShcclxuICAgICAgICAgICAgICAgIGBzZWxlY3QgKiBmcm9tIFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2R1Y2tkYi9kdWNrZGItd2FzbS9tYXN0ZXIvZGF0YS90ZXN0LmNzdlwiO2AsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGV4cGVjdChCaWdJbnQocmVzdWx0cy5nZXRDaGlsZEF0KDIpPy5nZXQoMikpKS50b0VxdWFsKEJpZ0ludCg5bikpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnY2FuIHJlYWQgYW5kIHdyaXRlIGNzdiBmaWxlIGZyb20gUzMgd2l0aCBjb3JyZWN0IGF1dGggY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hKTtcclxuICAgICAgICAgICAgYXdhaXQgcHV0VGVzdEZpbGVUb1MzKCdjb3JyZWN0X2F1dGhfdGVzdCcsICdjc3YnLCBkYXRhKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0c193aXRoX2F1dGggPSBhd2FpdCBjb25uIS5xdWVyeShgc2VsZWN0ICogZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vY29ycmVjdF9hdXRoX3Rlc3QuY3N2XCI7YCk7XHJcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBhc3NlcnRUZXN0RmlsZVJlc3VsdENvcnJlY3QocmVzdWx0c193aXRoX2F1dGgsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnY2FuIHJlYWQgYW5kIHdyaXRlIHBhcnF1ZXQgZmlsZSBmcm9tIFMzIHdpdGggY29ycmVjdCBhdXRoIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHB1dFRlc3RGaWxlVG9TMygnY29ycmVjdF9hdXRoX3Rlc3QnLCAncGFycXVldCcsIGRhdGEpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzX3dpdGhfYXV0aCA9IGF3YWl0IGNvbm4hLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgYHNlbGVjdCAqIGZyb20gXCJzMzovLyR7QlVDS0VUX05BTUV9L2NvcnJlY3RfYXV0aF90ZXN0LnBhcnF1ZXRcIjtgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgYXNzZXJ0VGVzdEZpbGVSZXN1bHRDb3JyZWN0KHJlc3VsdHNfd2l0aF9hdXRoLCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ2NhbiBub3QgcmVhZCBhIGZpbGUgd2l0aCBpbmNvcnJlY3QgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBhd2FpdCBwdXRUZXN0RmlsZVRvUzMoJ2luY29ycmVjdF9hdXRoX3Rlc3QnLCAncGFycXVldCcsIGRhdGEpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEsIEFXU0NvbmZpZ1R5cGUuSU5WQUxJRCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29ubiEucXVlcnkoYHNlbGVjdCAqIGZyb20gXCJzMzovLyR7QlVDS0VUX05BTUV9L2luY29ycmVjdF9hdXRoX3Rlc3QuY3N2XCI7YCksXHJcbiAgICAgICAgICAgICkudG9CZVJlamVjdGVkKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdwcm9wZXJseSBpbnZhbGlkYXRlcyBmaWxlIGNhY2hlcyBvbiBzZXR0aW5ncyB1cGRhdGUuJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHB1dFRlc3RGaWxlVG9TMygnZmlsZV9jYWNoZV9pbnZhbGlkYXRpb25fdGVzdCcsICdwYXJxdWV0JywgZGF0YSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldEF3c0NvbmZpZyhjb25uISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNfY29ycmVjdCA9IGF3YWl0IGNvbm4hLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgYHNlbGVjdCBsX3BhcnRrZXkgZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vZmlsZV9jYWNoZV9pbnZhbGlkYXRpb25fdGVzdC5wYXJxdWV0XCIgbGltaXQgMTtgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0c19jb3JyZWN0LmdldENoaWxkQXQoMCk/LmdldCgwKSkudG9FcXVhbCgxNTUyKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hLCBBV1NDb25maWdUeXBlLklOVkFMSUQpO1xyXG4gICAgICAgICAgICBhd2FpdCBleHBlY3RBc3luYyhcclxuICAgICAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KGBzZWxlY3QgYXZnKGxfcGFydGtleSkgZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vbGluZWl0ZW0ucGFycXVldFwiO2ApLFxyXG4gICAgICAgICAgICApLnRvQmVSZWplY3RlZCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnd3JpdGUgYWZ0ZXIgcmVhZCB0aHJvd3MgaW5jb3JyZWN0IGZsYWcgZXJyb3Igd2l0aG91dCBkcm9wcGluZyBmaWxlcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubiEucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgQ09QWSAoU0VMRUNUICogRlJPTSByYW5nZSgxMDAwLDEwMTApIHRibChpKSkgVE8gJ3MzOi8vJHtCVUNLRVRfTkFNRX0vdGVzdF93cml0dGVuLmNzdicgKEZPUk1BVCAnY3N2Jyk7YCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubiEucXVlcnkoYFNFTEVDVCAqIEZST00gXCJzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3Rfd3JpdHRlbi5jc3ZcIjtgKTtcclxuICAgICAgICAgICAgZXhwZWN0KE51bWJlcigocmVzdWx0LmdldENoaWxkQXQoMCk/LmdldCg2KSkpKS50b0VxdWFsKE51bWJlcigxMDA2KSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29ubiEucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgYENPUFkgKFNFTEVDVCAqIEZST00gcmFuZ2UoMjAwMCwyMDEwKSB0YmwoaSkpIFRPICdzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3Rfd3JpdHRlbi5jc3YnIChGT1JNQVQgJ2NzdicpO2AsXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICApLnRvQmVSZWplY3RlZFdpdGhFcnJvcignSW52YWxpZCBFcnJvcjogRmlsZSBpcyBub3Qgb3BlbmVkIGluIHdyaXRlIG1vZGUnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCB7IER1Y2tEQkFjY2Vzc01vZGUsIER1Y2tEQkRhdGFQcm90b2NvbCB9IGZyb20gJy4uL3NyYy8nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RCaW5kaW5ncyhkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzLCBiYXNlVVJMOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0R1Y2tEQkJpbmRpbmdzJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdlcnJvciBoYW5kbGluZycsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ0lOVkFMSUQgU1FMJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnNlbmQoJ0lOVkFMSUQnKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChlcnJvcikubm90LnRvQmUobnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnQ2hlY2sgdmVyc2lvbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1ZlcnNpb24gY2hlY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gY29ubi5xdWVyeTx7IG5hbWU6IGFycm93LlV0ZjggfT4oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzZWxlY3QgKiBmcm9tIChzZWxlY3QgdmVyc2lvbigpKSB3aGVyZSB2ZXJzaW9uKCkgIT0gJ3YwLjAuMS1kZXYwJztcIixcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gdmVyc2lvbi50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnQ2hlY2sgcGxhdGZvcm0nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdQbGF0Zm9ybSBjaGVjaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBjb25uLnF1ZXJ5PHsgbmFtZTogYXJyb3cuVXRmOCB9PihcclxuICAgICAgICAgICAgICAgICAgICBcIlBSQUdNQSBwbGF0Zm9ybTtcIixcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gdmVyc2lvbi5nZXRDaGlsZEF0KDApPy50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93c1swXS50b1N0cmluZygpLnN1YnN0cigwLDUpKS50b0VxdWFsKFwid2FzbV9cIik7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL2Rlc2NyaWJlKCdPcGVuJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIFhYWCBhcHBhcmVudGx5IHN5bmNocm9ub3VzIFhIUiBvbiB0aGUgbWFpbiB0aHJlYWQgZG9lcyBub3QgYWxsb3cgZm9yIGFycmF5YnVmZmVyIHJlc3BvbnNlIHR5cGU/XHJcbiAgICAgICAgLy8gaXQoJ1JlbW90ZSBUUENIIDBfMDEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlVVJMKCd0cGNoXzBfMDEuZGInLCBgJHtiYXNlVVJMfS90cGNoLzBfMDEvZHVja2RiL2RiYCk7XHJcbiAgICAgICAgLy8gICAgIGRiKCkub3BlbigndHBjaF8wXzAxLmRiJyk7XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ1Jlc2V0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgndGFibGUgbXVzdCBkaXNhcHBlYXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KCdDUkVBVEUgVEFCTEUgZm9vIChhIGludCknKTtcclxuICAgICAgICAgICAgICAgIGxldCB0YWJsZSA9IGNvbm4ucXVlcnk8eyBuYW1lOiBhcnJvdy5VdGY4IH0+KCdQUkFHTUEgc2hvd190YWJsZXM7Jyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm93cyA9IHRhYmxlLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzLmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzWzBdPy5uYW1lKS50b0VxdWFsKCdmb28nKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIHRhYmxlID0gY29ubi5xdWVyeTx7IG5hbWU6IGFycm93LlV0ZjggfT4oJ1BSQUdNQSBzaG93X3RhYmxlczsnKTtcclxuICAgICAgICAgICAgICAgIHJvd3MgPSB0YWJsZS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnUHJlcGFyZWQgU3RhdGVtZW50JywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnTWF0ZXJpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGNvbm4ucHJlcGFyZSgnU0VMRUNUIHY6OklOVEVHRVIgKyA/IEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdG10LnF1ZXJ5KDIzNCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMTAwMDEpO1xyXG4gICAgICAgICAgICAgICAgc3RtdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTdHJlYW1pbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gY29ubi5wcmVwYXJlKCdTRUxFQ1Qgdjo6SU5URUdFUiArID8gQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTsnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHN0bXQuc2VuZCgyMzQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGJhdGNoLm51bVJvd3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qoc2l6ZSkudG9CZSgxMDAwMSk7XHJcbiAgICAgICAgICAgICAgICBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpdCgnVHlwZWNoZWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHR5cGVjaGVjayAoXHJcbiAgICAgICAgICAgICAgICAgICAgYSBCT09MRUFOIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBiIFRJTllJTlQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgU01BTExJTlQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgSU5URUdFUiBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZSBCSUdJTlQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgRkxPQVQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgRE9VQkxFIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBoIENIQVIoMTEpIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBpIFZBUkNIQVIoMTEpIERFRkFVTFQgTlVMTFxyXG4gICAgICAgICAgICAgICAgKWApO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBjb25uLnByZXBhcmUoJ0lOU0VSVCBJTlRPIHR5cGVjaGVjayBWQUxVRVMoPyw/LD8sPyw/LD8sPyw/LD8pJyk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KHRydWUsIDEwMCwgMTBfMDAwLCAxXzAwMF8wMDAsIDVfMDAwXzAwMF8wMDAsIDAuNSwgTWF0aC5QSSwgJ2hlbGxvIHdvcmxkJywgJ2hpJyksXHJcbiAgICAgICAgICAgICAgICApLm5vdC50b1Rocm93KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAndGVzdCcsIC8vIHZhcmNoYXIgZm9yIGJvb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICApLnRvVGhyb3coKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCgoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCwgLy8gc21hbGxpbnQgZm9yIHRpbnlpbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlbGxvIHdvcmxkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpJyxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgKS50b1Rocm93KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCwgLy8gaW50IGZvciBzbWFsbGludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlbGxvIHdvcmxkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpJyxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgKS50b1Rocm93KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCwgLy8gYmlnaW50IGZvciBpbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICApLnRvVGhyb3coKTtcclxuICAgICAgICAgICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBc3luY0JpbmRpbmdzKFxyXG4gICAgYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXHJcbiAgICBiYXNlVVJMOiBzdHJpbmcsXHJcbiAgICBiYXNlRGlyUHJvdG86IER1Y2tEQkRhdGFQcm90b2NvbCxcclxuKTogdm9pZCB7XHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHt9KTtcclxuXHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGFkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBhZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdCaW5kaW5ncycsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnT3BlbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1JlbW90ZSBUUENIIDBfMDEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5yZWdpc3RlckZpbGVVUkwoJ3RwY2hfMF8wMS5kYicsIGAke2Jhc2VVUkx9L3RwY2gvMF8wMS9kdWNrZGIvZGJgLCBiYXNlRGlyUHJvdG8sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICd0cGNoXzBfMDEuZGInLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogQWRkIHRoaXMgYmFja1xyXG4gICAgICAgICAgICAgICAgLy9jb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnk8e1xyXG4gICAgICAgICAgICAgICAgLy8gICAgYTogYXJyb3cuSW50O1xyXG4gICAgICAgICAgICAgICAgLy99Pignc2VsZWN0IGNvdW50KCopOjpJTlRFR0VSIGFzIGEgZnJvbSBsaW5laXRlbScpO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zdCByb3dzID0gdGFibGUudG9BcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgLy9leHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgICAgICAvL2V4cGVjdChyb3dzWzBdPy5hKS50b0VxdWFsKDYwMTc1KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRlc2NyaWJlKCdQYXRjaGluZycsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ0NvdW50KCopIERlZmF1bHQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RCaWdJbnRUb0RvdWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0IDE6OkJJR0lOVCcpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHMubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHNbMF0udHlwZUlkKS50b0VxdWFsKGFycm93LlR5cGUuSW50KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQ291bnQoKikgTm8gQmlnSW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXN0QmlnSW50VG9Eb3VibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0IDE6OkJJR0lOVCcpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHMubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHNbMF0udHlwZUlkKS50b0VxdWFsKGFycm93LlR5cGUuRmxvYXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ1ByZXBhcmVkIFN0YXRlbWVudCcsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ01hdGVyaWFsaXplZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgY29ubi5wcmVwYXJlKCdTRUxFQ1QgdiArID8gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG10LnF1ZXJ5KDIzNCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMTAwMDEpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTdHJlYW1pbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IGNvbm4ucHJlcGFyZSgnU0VMRUNUIHY6OklOVEVHRVIgKyA/IEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzdG10LnNlbmQoMjM0KTtcclxuICAgICAgICAgICAgICAgIGxldCBzaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2Ygc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBiYXRjaC5udW1Sb3dzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHNpemUpLnRvQmUoMTAwMDEpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1R5cGVjaGVjaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDUkVBVEUgVEFCTEUgdHlwZWNoZWNrIChcclxuICAgICAgICAgICAgICAgICAgICBhIEJPT0xFQU4gREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgVElOWUlOVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgYyBTTUFMTElOVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZCBJTlRFR0VSIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBlIEJJR0lOVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZiBGTE9BVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZyBET1VCTEUgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGggQ0hBUigxMSkgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgVkFSQ0hBUigxMSkgREVGQVVMVCBOVUxMXHJcbiAgICAgICAgICAgICAgICApYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IGNvbm4ucHJlcGFyZSgnSU5TRVJUIElOVE8gdHlwZWNoZWNrIFZBTFVFUyg/LD8sPyw/LD8sPyw/LD8sPyknKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RUb1Rocm93ID0gYXN5bmMgKGZuOiAoKSA9PiBQcm9taXNlPHZvaWQ+KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRocm93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh0aHJvd2VkKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXN0JywgLy8gdmFyY2hhciBmb3IgYm9vbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMV8wMDBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaScsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0VG9UaHJvdyhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5xdWVyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTBfMDAwLCAvLyBzbWFsbGludCBmb3IgdGlueWludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMV8wMDBfMDAwLCAvLyBpbnQgZm9yIHNtYWxsaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLCAvLyBiaWdpbnQgZm9yIGludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaScsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ0FjY2Vzc01vZGUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdSRUFEX09OTFknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleHBlY3RBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzTW9kZTogRHVja0RCQWNjZXNzTW9kZS5SRUFEX09OTFksXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICApLnRvQmVSZWplY3RlZFdpdGhFcnJvcigvQ2Fubm90IGxhdW5jaCBpbi1tZW1vcnkgZGF0YWJhc2UgaW4gcmVhZC1vbmx5IG1vZGUvKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGl0KCdSRUFEX1dSSVRFJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXhwZWN0QXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgYWRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc01vZGU6IER1Y2tEQkFjY2Vzc01vZGUuUkVBRF9XUklURSxcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICkudG9CZVJlc29sdmVkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnQ2FuY2VsbGF0aW9uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnaGVsbG8gY2FuY2VsJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHF1ZXJ5IHBvbGxpbmcgaW50ZXJ2YWwgdG8gMCB0byBwb2xsIDEgdGFzayBhdCBhIHRpbWVcclxuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQb2xsaW5nSW50ZXJ2YWw6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4udXNlVW5zYWZlKChkYiwgaWQpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgZGIuc3RhcnRQZW5kaW5nUXVlcnkoaWQsICdTRUxFQ1QgU1VNKGkpIEZST00gcmFuZ2UoMTAwMDAwMCkgdGJsKGkpOycpLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxPSyA9IGF3YWl0IGNvbm4udXNlVW5zYWZlKChkYiwgaWQpID0+IGRiLmNhbmNlbFBlbmRpbmdRdWVyeShpZCkpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGNhbmNlbE9LKS50b0JlVHJ1ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvbGxlZEhlYWRlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9sbGVkRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2xsZWRIZWFkZXIgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PiBkYi5wb2xsUGVuZGluZ1F1ZXJ5KGlkKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2xsZWRFcnJvciA9IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocG9sbGVkSGVhZGVyKS50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEVycm9yKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChwb2xsZWRFcnJvci50b1N0cmluZygpKS50b0VxdWFsKCdFcnJvcjogcXVlcnkgd2FzIGNhbmNlbGVkJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxlZEFnYWluID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoY2FuY2VsZWRBZ2FpbikudG9CZUZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgY29ubmVjdGlvbiBpcyBkZXN0cm95ZWQgb3Igbm90IHdoZW4gd2UgY2FuY2VsIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoJ3NlbGVjdCA0Mjo6aW50ZWdlcjsnKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzLmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnbm9vcCBjYW5jZWwnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UG9sbGluZ0ludGVydmFsOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGRiLnN0YXJ0UGVuZGluZ1F1ZXJ5KGlkLCAnU0VMRUNUIFNVTShpKSBGUk9NIHJhbmdlKDEwMDAwMDApIHRibChpKTsnKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvbGxlZEhlYWRlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9sbGVkRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBleGVjdXRlIDEgdGFzayBhdCBhIHRpbWUsIHNvIHRoaXMgbWF5IHRha2UgbXVsdGlwbGUgcG9sbHNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9sbGVkSGVhZGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbGVkSGVhZGVyID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIucG9sbFBlbmRpbmdRdWVyeShpZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbGxlZEVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChwb2xsZWRIZWFkZXIpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEVycm9yKS50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsT0sgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PiBkYi5jYW5jZWxQZW5kaW5nUXVlcnkoaWQpKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChjYW5jZWxPSykudG9CZUZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbm90aGVyT25lID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoYW5vdGhlck9uZSkudG9CZUZhbHNlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuXHJcbmNvbnN0IHRlc3RSb3dzID0gMTAwMDA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdEJhdGNoU3RyZWFtKGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Fycm93IFJlY29yZC1CYXRjaGVzIFJvdy1NYWpvcicsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3chLnYpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdCSUdJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKEJpZ0ludChpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgYmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdyEudikudG9CZShTdHJpbmcoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXJyb3cgUmVjb3JkLUJhdGNoZXMgQ29sdW1uLU1ham9yJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAxMjcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKyspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShTdHJpbmcoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXJyb3cgVGFibGUgUm93LU1ham9yJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrICYgMTI3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKysgJiAzMjc2Nyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoQmlnSW50KGkrKykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYudmFsdWVPZigpKS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Fycm93IFRhYmxlIENvbHVtbi1NYWpvcicsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMTI3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdCSUdJTlQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoQmlnSW50KGkrKykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShTdHJpbmcoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcblxyXG5jb25zdCB0ZXN0Um93cyA9IDEwMDAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBc3luY0JhdGNoU3RyZWFtKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uO1xyXG5cclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXN5bmNEdWNrREInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3BpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucGluZygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Fycm93IFJlY29yZC1CYXRjaGVzIFJvdy1NYWpvcicsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKEJpZ0ludChpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ3NjcmlwdHMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCd0ZXN0MScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgeCwgKHNpbih2KSAqIDEwMCArIDEwMCk6OklOVEVHRVIgQVMgeSBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KVxyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3chLngpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdBcnJvdyBSZWNvcmQtQmF0Y2hlcyBDb2x1bW4tTWFqb3InLCAoKSA9PiB7XHJcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKEJpZ0ludChpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdBcnJvdyBUYWJsZSBSb3ctTWFqb3InLCAoKSA9PiB7XHJcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKysgJiAxMjcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93Py52KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKyspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShCaWdJbnQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udi52YWx1ZU9mKCkpLnRvQmUoU3RyaW5nKGkrKykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXJyb3cgVGFibGUgQ29sdW1uLU1ham9yJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAxMjcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnSU5URUdFUicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0RmlsZXN5c3RlbShcclxuICAgIGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXHJcbiAgICByZXNvbHZlRGF0YTogKHVybDogc3RyaW5nKSA9PiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPixcclxuICAgIGJhc2VEaXI6IHN0cmluZyxcclxuICAgIGJhc2VEaXJQcm90bzogZHVja2RiLkR1Y2tEQkRhdGFQcm90b2NvbCxcclxuKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0ZpbGUgYnVmZmVyIHJlZ2lzdHJhdGlvbicsICgpID0+IHtcclxuICAgICAgICBjb25zdCB0ZXN0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFNFTEVDVCBtYXRybnIgRlJPTSBwYXJxdWV0X3NjYW4oJ3N0dWRlbnRlbi5wYXJxdWV0Jyk7YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChiYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludCB9PihiYXRjaGVzKTtcclxuICAgICAgICAgICAgZXhwZWN0KHRhYmxlLmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChcclxuICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KFsyNDAwMiwgMjU0MDMsIDI2MTIwLCAyNjgzMCwgMjc1NTAsIDI4MTA2LCAyOTEyMCwgMjk1NTVdKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGl0KCdGaWxlIGJ1ZmZlciB1c2VkIG9uY2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcclxuICAgICAgICAgICAgYXdhaXQgdGVzdCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0KCdGaWxlIGJ1ZmZlciByZWdpc3RlcmVkIHR3aWNlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50czAgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50czEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMwKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzMSkubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzMCEpO1xyXG4gICAgICAgICAgICBhd2FpdCB0ZXN0KCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzMSEpO1xyXG4gICAgICAgICAgICBhd2FpdCB0ZXN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaXQoJ0ZpbGUgYnVmZmVyIHVzZWQgdHdpY2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcclxuICAgICAgICAgICAgYXdhaXQgdGVzdCgpO1xyXG4gICAgICAgICAgICBhd2FpdCB0ZXN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnUGFycXVldCBTY2FucycsICgpID0+IHtcclxuICAgICAgICBpdCgnc2luZ2xlIHRhYmxlIGZyb20gYnVmZmVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgU0VMRUNUIG1hdHJuciBGUk9NIHBhcnF1ZXRfc2Nhbignc3R1ZGVudGVuLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hlcy5wdXNoKGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IG5ldyBhcnJvdy5UYWJsZTx7IG1hdHJucjogYXJyb3cuSW50IH0+KGJhdGNoZXMpO1xyXG4gICAgICAgICAgICBleHBlY3QodGFibGUuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoWzI0MDAyLCAyNTQwMywgMjYxMjAsIDI2ODMwLCAyNzU1MCwgMjgxMDYsIDI5MTIwLCAyOTU1NV0pLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2ltcGxlIGpvaW4nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgY29uc3QgaG9lcmVuID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvaG9lcmVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgY29uc3Qgdm9ybGVzdW5nZW4gPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS92b3JsZXN1bmdlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChob2VyZW4pLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICBleHBlY3Qodm9ybGVzdW5nZW4pLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50cyEpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignaG9lcmVuLnBhcnF1ZXQnLCBob2VyZW4hKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3Zvcmxlc3VuZ2VuLnBhcnF1ZXQnLCB2b3JsZXN1bmdlbiEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgc3R1ZGVudHMubWF0cm5yLCB2b3JsZXN1bmdlbi50aXRlbFxyXG4gICAgICAgICAgICAgICAgICAgIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpIHN0dWRlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgSU5ORVIgSk9JTiBwYXJxdWV0X3NjYW4oJ2hvZXJlbi5wYXJxdWV0JykgaG9lcmVuIE9OIChzdHVkZW50cy5tYXRybnIgPSBob2VyZW4ubWF0cm5yKVxyXG4gICAgICAgICAgICAgICAgICAgIElOTkVSIEpPSU4gcGFycXVldF9zY2FuKCd2b3JsZXN1bmdlbi5wYXJxdWV0Jykgdm9ybGVzdW5nZW4gT04gKHZvcmxlc3VuZ2VuLnZvcmxuciA9IGhvZXJlbi52b3JsbnIpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChiYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludDsgdGl0ZWw6IGFycm93LlV0ZjggfT4oYmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5udW1Db2xzKS50b0JlKDIpO1xyXG4gICAgICAgICAgICBjb25zdCBmbGF0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBmbGF0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJucjogcm93Py5tYXRybnIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0ZWw6IHJvdz8udGl0ZWw/LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHBlY3QoZmxhdCkudG9FcXVhbChbXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjYxMjAsIHRpdGVsOiAnR3J1bmR6XHUwMEZDZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjc1NTAsIHRpdGVsOiAnR3J1bmR6XHUwMEZDZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjc1NTAsIHRpdGVsOiAnTG9naWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnRXRoaWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnV2lzc2Vuc2NoYWZ0c3RoZW9yaWUnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnQmlvZXRoaWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnRGVyIFdpZW5lciBLcmVpcycgfSxcclxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdHcnVuZHpcdTAwRkNnZScgfSxcclxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdFdGhpaycgfSxcclxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdNXHUwMEU0ZXV0aWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjk1NTUsIHRpdGVsOiAnR2xhdWJlIHVuZCBXaXNzZW4nIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjU0MDMsIHRpdGVsOiAnR2xhdWJlIHVuZCBXaXNzZW4nIH0sXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ1dyaXRpbmcnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ0NvcHkgVG8gQ1NWIEJ1ZmZlcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3R1ZGVudHMgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50cyEpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRW1wdHlGaWxlQnVmZmVyKCdzdHVkZW50cy5jc3YnKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzIEFTIFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDT1BZIHN0dWRlbnRzIFRPICdzdHVkZW50cy5jc3YnIFdJVEggKEhFQURFUiAxLCBERUxJTUlURVIgJzsnLCBGT1JNQVQgQ1NWKTtgKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgc3R1ZGVudHNgKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50cy5jc3YnKTtcclxuICAgICAgICAgICAgZXhwZWN0KG91dEJ1ZmZlcikubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShvdXRCdWZmZXIhKTtcclxuICAgICAgICAgICAgZXhwZWN0KHRleHQpLnRvQmUoYG1hdHJucjtuYW1lO3NlbWVzdGVyXHJcbjI0MDAyO1hlbm9rcmF0ZXM7MThcclxuMjU0MDM7Sm9uYXM7MTJcclxuMjYxMjA7RmljaHRlOzEwXHJcbjI2ODMwO0FyaXN0b3hlbm9zOzhcclxuMjc1NTA7U2Nob3BlbmhhdWVyOzZcclxuMjgxMDY7Q2FybmFwOzNcclxuMjkxMjA7VGhlb3BocmFzdG9zOzJcclxuMjk1NTU7RmV1ZXJiYWNoOzJcclxuYCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdDb3B5IFRvIFBhcnF1ZXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckVtcHR5RmlsZUJ1ZmZlcignc3R1ZGVudHMyLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzMiBBUyBTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2Nhbignc3R1ZGVudGVuLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ09QWSBzdHVkZW50czIgVE8gJ3N0dWRlbnRzMi5wYXJxdWV0JyAoRk9STUFUIFBBUlFVRVQpO2ApO1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJ3N0dWRlbnRzMi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh1cmwpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnQ29weSBUbyBQYXJxdWV0IEFuZCBMb2FkIEFnYWluJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzISk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIoJ3N0dWRlbnRzMy5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYENSRUFURSBUQUJMRSBzdHVkZW50czMgQVMgU0VMRUNUICogRlJPTSBwYXJxdWV0X3NjYW4oJ3N0dWRlbnRlbi5wYXJxdWV0Jyk7YCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYENPUFkgc3R1ZGVudHMzIFRPICdzdHVkZW50czMucGFycXVldCcgKEZPUk1BVCBQQVJRVUVUKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50czMucGFycXVldCcpO1xyXG4gICAgICAgICAgICBleHBlY3QodXJsKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzNCBBUyBTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2Nhbignc3R1ZGVudHMzLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gc3R1ZGVudHM0O2ApO1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgbmV3IGFycm93LlRhYmxlPHsgbWF0cm5yOiBhcnJvdy5JbnQgfT4oYmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShbMjQwMDIsIDI1NDAzLCAyNjEyMCwgMjY4MzAsIDI3NTUwLCAyODEwNiwgMjkxMjAsIDI5NTU1XSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnRmlsZSBhY2Nlc3MnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ1NtYWxsIFBhcnF1ZXQgZmlsZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVVUkwoJ3N0dWRlbnRlbi5wYXJxdWV0JywgYCR7YmFzZURpcn0vdW5pL3N0dWRlbnRlbi5wYXJxdWV0YCwgYmFzZURpclByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgbmV3IGFycm93LlRhYmxlPHsgbWF0cm5yOiBhcnJvdy5JbnQgfT4oYmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShbMjQwMDIsIDI1NDAzLCAyNjEyMCwgMjY4MzAsIDI3NTUwLCAyODEwNiwgMjkxMjAsIDI5NTU1XSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdMYXJnZSBQYXJxdWV0IGZpbGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlVVJMKFxyXG4gICAgICAgICAgICAgICAgJ2xpbmVpdGVtLnBhcnF1ZXQnLFxyXG4gICAgICAgICAgICAgICAgYCR7YmFzZURpcn0vdHBjaC8wXzAxL3BhcnF1ZXQvbGluZWl0ZW0ucGFycXVldGAsXHJcbiAgICAgICAgICAgICAgICBiYXNlRGlyUHJvdG8sXHJcbiAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFNFTEVDVCBjb3VudCgqKTo6SU5URUdFUiBhcyBjbnQgRlJPTSBwYXJxdWV0X3NjYW4oJ2xpbmVpdGVtLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hlcy5wdXNoKGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IG5ldyBhcnJvdy5UYWJsZTx7IGNudDogYXJyb3cuSW50IH0+KGJhdGNoZXMpO1xyXG4gICAgICAgICAgICBleHBlY3QodGFibGUuZ2V0Q2hpbGRBdCgwKT8uZ2V0KDApKS50b0JlR3JlYXRlclRoYW4oNjBfMDAwKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdFeHBvcnQnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ0dlbmVyYXRlIFNlcmllcyBhcyBDU1YnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0NSRUFURSBUQUJMRSBmb28gQVMgU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KScpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBFWFBPUlQgREFUQUJBU0UgJy90bXAvZHVja2RiZXhwb3J0Y3N2J2ApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRiKCkuZ2xvYkZpbGVzKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi8qJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzKS5ub3QudG9FcXVhbChbXSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9FcXVhbCgzKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVzID0gcmVzdWx0cy5tYXAoZmlsZSA9PiBmaWxlLmZpbGVOYW1lKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChmaWxlbmFtZXMpLnRvRXF1YWwoW1xyXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnLFxyXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0Y3N2L2xvYWQuc3FsJyxcclxuICAgICAgICAgICAgICAgICcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9zY2hlbWEuc3FsJyxcclxuICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjc3ZfYnVmZmVyX3V0ZjggPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnKTtcclxuICAgICAgICAgICAgY29uc3QgbG9hZF9zY3JpcHRfdXRmOCA9IGF3YWl0IGRiKCkuY29weUZpbGVUb0J1ZmZlcignL3RtcC9kdWNrZGJleHBvcnRjc3YvbG9hZC5zcWwnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9zY2hlbWEuc3FsJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChsb2FkX3NjcmlwdF91dGY4Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzY2hlbWFfc2NyaXB0X3V0ZjgubGVuZ3RoKS5ub3QudG9FcXVhbCgwKTtcclxuICAgICAgICAgICAgZXhwZWN0KGNzdl9idWZmZXJfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbG9hZF9zY3JpcHQgPSBkZWNvZGVyLmRlY29kZShsb2FkX3NjcmlwdF91dGY4KTtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdCA9IGRlY29kZXIuZGVjb2RlKHNjaGVtYV9zY3JpcHRfdXRmOCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzdl9idWZmZXIgPSBkZWNvZGVyLmRlY29kZShjc3ZfYnVmZmVyX3V0ZjgpO1xyXG4gICAgICAgICAgICBleHBlY3QobG9hZF9zY3JpcHQudHJpbSgpKS50b0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgYENPUFkgZm9vIEZST00gJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnIChGT1JNQVQgJ2NzdicsIHF1b3RlICdcIicsIGRlbGltaXRlciAnLCcsIGhlYWRlciAwKTtgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3Qoc2NoZW1hX3NjcmlwdC50cmltKCkpLnRvRXF1YWwoYENSRUFURSBUQUJMRSBmb28odiBCSUdJTlQpO2ApO1xyXG4gICAgICAgICAgICBleHBlY3QoY3N2X2J1ZmZlci50cmltKCkpLnRvRXF1YWwoYDFcXG4yXFxuM1xcbjRcXG41YCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdHZW5lcmF0ZSBTZXJpZXMgYXMgUGFycXVldCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeSgnQ1JFQVRFIFRBQkxFIGZvbyBBUyBTRUxFQ1QgKiBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCA1KSB0KHYpJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYEVYUE9SVCBEQVRBQkFTRSAnL3RtcC9kdWNrZGJleHBvcnRwYXJxdWV0JyAoRk9STUFUIFBBUlFVRVQpYCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZGIoKS5nbG9iRmlsZXMoJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC8qJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzKS5ub3QudG9FcXVhbChbXSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9FcXVhbCgzKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVzID0gcmVzdWx0cy5tYXAoZmlsZSA9PiBmaWxlLmZpbGVOYW1lKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChmaWxlbmFtZXMpLnRvRXF1YWwoW1xyXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcsXHJcbiAgICAgICAgICAgICAgICAnL3RtcC9kdWNrZGJleHBvcnRwYXJxdWV0L2xvYWQuc3FsJyxcclxuICAgICAgICAgICAgICAgICcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvc2NoZW1hLnNxbCcsXHJcbiAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGFycXVldF9idWZmZXIgPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBjb25zdCBsb2FkX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvbG9hZC5zcWwnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvc2NoZW1hLnNxbCcpO1xyXG4gICAgICAgICAgICBleHBlY3QobG9hZF9zY3JpcHRfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG4gICAgICAgICAgICBleHBlY3Qoc2NoZW1hX3NjcmlwdF91dGY4Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJxdWV0X2J1ZmZlci5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgU0VMRUNUIHY6OmludGVnZXIgRlJPTSBwYXJxdWV0X3NjYW4oJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcpYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQubnVsbENvdW50KS50b0VxdWFsKDApO1xyXG4gICAgICAgICAgICBleHBlY3QoY29udGVudC5udW1Sb3dzKS50b0VxdWFsKDUpO1xyXG4gICAgICAgICAgICBleHBlY3QoY29udGVudC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzEsIDIsIDMsIDQsIDVdKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQ29weScsICgpID0+IHtcclxuICAgICAgICBpdCgnR2VuZXJhdGUgU2VyaWVzIGFzIFBhcnF1ZXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgQ09QWSAoU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KSkgVE8gJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcgKEZPUk1BVCAncGFycXVldCcpYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRiKCkuZ2xvYkZpbGVzKCcvdG1wL2R1Y2tkYmNvcHl0ZXN0KicpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cykubm90LnRvRXF1YWwoW10pO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lcyA9IHJlc3VsdHMubWFwKGZpbGUgPT4gZmlsZS5maWxlTmFtZSkuc29ydCgpO1xyXG4gICAgICAgICAgICBleHBlY3QoZmlsZW5hbWVzKS50b0VxdWFsKFsnL3RtcC9kdWNrZGJjb3B5dGVzdC5wYXJxdWV0J10pO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJxdWV0X2J1ZmZlciA9IGF3YWl0IGRiKCkuY29weUZpbGVUb0J1ZmZlcignL3RtcC9kdWNrZGJjb3B5dGVzdC5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJxdWV0X2J1ZmZlci5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgY29ubi5xdWVyeShgU0VMRUNUIHY6OmludGVnZXIgRlJPTSBwYXJxdWV0X3NjYW4oJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcpYCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50Lm51bVJvd3MpLnRvRXF1YWwoNSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbMSwgMiwgMywgNCwgNV0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdmFsdWVzOiBhbnlbXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVUYWJsZSh0YWJsZTogYXJyb3cuVGFibGUsIGV4cGVjdGVkOiBDb2x1bW5bXSk6IHZvaWQge1xyXG4gICAgLy8gQ2hlY2sgY29sdW1uIGNvdW50XHJcbiAgICBjb25zdCBjb2xDb3VudCA9IGV4cGVjdGVkLmxlbmd0aDtcclxuICAgIGV4cGVjdCh0YWJsZS5udW1Db2xzKS50b0VxdWFsKGNvbENvdW50KTtcclxuICAgIGlmIChjb2xDb3VudCA9PSAwKSByZXR1cm47XHJcblxyXG4gICAgLy8gQ2hlY2sgY29sdW1uc1xyXG4gICAgY29uc3Qgcm93Q291bnQgPSBleHBlY3RlZFswXS52YWx1ZXMubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgKytpKSB7XHJcbiAgICAgICAgZXhwZWN0KGV4cGVjdGVkW2ldLnZhbHVlcy5sZW5ndGgpLnRvRXF1YWwocm93Q291bnQpO1xyXG4gICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KGkpPy5sZW5ndGgpLnRvRXF1YWwocm93Q291bnQpO1xyXG4gICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzW2ldPy5uYW1lKS50b0VxdWFsKGV4cGVjdGVkW2ldLm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXBhcmUgdGhlIGFjdHVhbCB2YWx1ZXNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ291bnQ7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGNvbCA9IHRhYmxlLmdldENoaWxkQXQoaSkhO1xyXG4gICAgICAgIGNvbnN0IGhhdmUgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd0NvdW50OyArK2opIHtcclxuICAgICAgICAgICAgaGF2ZS5wdXNoKGNvbC5nZXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBlY3QoTnVtYmVyKGhhdmUpKS50b0VxdWFsKE51bWJlcihleHBlY3RlZFtpXS52YWx1ZXMpKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBDb2x1bW4sIGNvbXBhcmVUYWJsZSB9IGZyb20gJy4vdGFibGVfdGVzdCc7XHJcblxyXG4vLy8gVW5mb3J0dW5hdGVseSwgYXJyb3cuVGFibGUuZnJvbSBkb2VzIG5vdCBidWlsZCBhIHByb3BlciBTY2hlbWEuXHJcbi8vLyBXaGVuIGl0IGRvZXMsIHdlIG1pZ2h0IHdhbnQgdG8gc3dpdGNoIGJhY2sgdG8gYXJyb3cuVGFibGUgaGVyZSBpbnN0ZWFkXHJcbi8vLyBvZiBhcnJvdyBTY2hlbWEgKyBBcnJvd0JhdGNoLlxyXG5pbnRlcmZhY2UgQXJyb3dJbnNlcnRUZXN0IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHNjaGVtYTogYXJyb3cuU2NoZW1hO1xyXG4gICAgYmF0Y2hlczogQXJyb3dCYXRjaFtdO1xyXG4gICAgb3B0aW9uczogZHVja2RiLkFycm93SW5zZXJ0T3B0aW9ucztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICBleHBlY3RlZENvbHVtbnM6IENvbHVtbltdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXJyb3dCYXRjaCB7XHJcbiAgICBudW1Sb3dzOiBudW1iZXI7XHJcbiAgICBjb2x1bW5zOiBhcnJvdy5EYXRhW107XHJcbn1cclxuXHJcbmNvbnN0IGJ1aWxkVXRmOEFycmF5ID0gKHZhbHVlczogc3RyaW5nW10pID0+IHtcclxuICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgYXJyb3cuVXRmOEJ1aWxkZXIoe1xyXG4gICAgICAgIHR5cGU6IG5ldyBhcnJvdy5VdGY4KCksXHJcbiAgICB9KTtcclxuICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcclxuICAgICAgICBidWlsZGVyLmFwcGVuZCh2KTtcclxuICAgIH1cclxuICAgIGJ1aWxkZXIuZmluaXNoKCk7XHJcbiAgICByZXR1cm4gYnVpbGRlci5mbHVzaCgpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWEludDMyKG46IG51bWJlciwgY29sczogbnVtYmVyKTogbnVtYmVyW11bXSB7XHJcbiAgICBjb25zdCBjb2x1bW5zID0gW107XHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbi5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2x1bW5zO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVBcnJvd1hJbnQzMihuOiBudW1iZXIsIGNvbHM6IG51bWJlcik6IFthcnJvdy5TY2hlbWEsIGFycm93LlJlY29yZEJhdGNoW11dIHtcclxuICAgIGNvbnN0IGNvbHVtbnMgPSBnZW5lcmF0ZVhJbnQzMihuLCBjb2xzKTtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcclxuICAgICAgICBmaWVsZHMucHVzaChuZXcgYXJyb3cuRmllbGQoYHYke2p9YCwgbmV3IGFycm93LkludDMyKCkpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBhcnJvdy5TY2hlbWEoZmllbGRzKTtcclxuICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKSB7XHJcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWluKDEwMDAsIG4gLSBpKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXJyb3cubWFrZURhdGEoe1xyXG4gICAgICAgICAgICB0eXBlOiBuZXcgYXJyb3cuU3RydWN0KGZpZWxkcyksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjb2x1bW5zLm1hcChjID0+XHJcbiAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmV3IEludDMyQXJyYXkoYy5zbGljZShpLCBpICsgcm93cykpLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmF0Y2hlcy5wdXNoKG5ldyBhcnJvdy5SZWNvcmRCYXRjaChzY2hlbWEsIGRhdGEpKTtcclxuICAgICAgICBpICs9IHJvd3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3NjaGVtYSwgYmF0Y2hlc107XHJcbn1cclxuXHJcbmNvbnN0IEFSUk9XX0lOU0VSVF9URVNUUzogQXJyb3dJbnNlcnRUZXN0W10gPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ludGVnZXJzXzEnLFxyXG4gICAgICAgIHNjaGVtYTogbmV3IGFycm93LlNjaGVtYShbXHJcbiAgICAgICAgICAgIG5ldyBhcnJvdy5GaWVsZCgnYScsIG5ldyBhcnJvdy5JbnQzMigpKSxcclxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdiJywgbmV3IGFycm93LkludDMyKCkpLFxyXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2MnLCBuZXcgYXJyb3cuSW50MzIoKSksXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgYmF0Y2hlczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBudW1Sb3dzOiAzLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDMyKCksIGRhdGE6IG5ldyBJbnQzMkFycmF5KFsxLCA0LCA3XSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSwgZGF0YTogbmV3IEludDMyQXJyYXkoWzIsIDUsIDhdKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMywgNiwgOV0pIH0pLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnY29tYmluZWRfMScsXHJcbiAgICAgICAgc2NoZW1hOiBuZXcgYXJyb3cuU2NoZW1hKFtcclxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdhJywgbmV3IGFycm93LkludDMyKCkpLFxyXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2InLCBuZXcgYXJyb3cuSW50MTYoKSksXHJcbiAgICAgICAgICAgIG5ldyBhcnJvdy5GaWVsZCgnYycsIG5ldyBhcnJvdy5VdGY4KCkpLFxyXG4gICAgICAgIF0pLFxyXG4gICAgICAgIGJhdGNoZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbnVtUm93czogMyxcclxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMSwgNCwgN10pIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDE2KCksIGRhdGE6IG5ldyBJbnQxNkFycmF5KFsyLCA1LCA4XSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVdGY4QXJyYXkoWyczJywgJzYnLCAnOSddKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXHJcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYycsIHZhbHVlczogWyczJywgJzYnLCAnOSddIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2NvbWJpbmVkXzInLFxyXG4gICAgICAgIHNjaGVtYTogbmV3IGFycm93LlNjaGVtYShbXHJcbiAgICAgICAgICAgIG5ldyBhcnJvdy5GaWVsZCgnYScsIG5ldyBhcnJvdy5JbnQzMigpKSxcclxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdiJywgbmV3IGFycm93LkludDE2KCkpLFxyXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2MnLCBuZXcgYXJyb3cuVXRmOCgpKSxcclxuICAgICAgICBdKSxcclxuICAgICAgICBiYXRjaGVzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG51bVJvd3M6IDMsXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSwgZGF0YTogbmV3IEludDMyQXJyYXkoWzEsIDQsIDddKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQxNigpLCBkYXRhOiBuZXcgSW50MTZBcnJheShbMiwgNSwgOF0pIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkVXRmOEFycmF5KFsnMycsICc2JywgJzknXSksXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBudW1Sb3dzOiAyLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDMyKCksIGRhdGE6IG5ldyBJbnQzMkFycmF5KFsxMCwgMTNdKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQxNigpLCBkYXRhOiBuZXcgSW50MTZBcnJheShbMTEsIDE0XSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVdGY4QXJyYXkoWycxMicsICcxNSddKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXHJcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3LCAxMCwgMTNdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4LCAxMSwgMTRdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFsnMycsICc2JywgJzknLCAnMTInLCAnMTUnXSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBcnJvd0luc2VydChkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnQXJyb3cgaW5zZXJ0IGZyb20gaXRlcmFibGUnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEFSUk9XX0lOU0VSVF9URVNUUykge1xyXG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbm4ucXVlcnkoYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGVzdC5vcHRpb25zLnNjaGVtYSB8fCAnbWFpbid9LiR7dGVzdC5vcHRpb25zLm5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gdGVzdC5iYXRjaGVzLm1hcChiID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXJyb3cubWFrZURhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXcgYXJyb3cuU3RydWN0KHRlc3Quc2NoZW1hLmZpZWxkcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBiLmNvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhcnJvdy5SZWNvcmRCYXRjaCh0ZXN0LnNjaGVtYSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IGFycm93LlRhYmxlKHRlc3Quc2NoZW1hLCBiYXRjaGVzKTtcclxuICAgICAgICAgICAgICAgIGNvbm4uaW5zZXJ0QXJyb3dUYWJsZSh0YWJsZSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0QXJyb3dJbnNlcnRBc3luYyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdBcnJvdyBhc3luYyBpbnNlcnQgZnJvbSBpdGVyYWJsZScsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgQVJST1dfSU5TRVJUX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0ZXN0LmJhdGNoZXMubWFwKGIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhcnJvdy5tYWtlRGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG5ldyBhcnJvdy5TdHJ1Y3QodGVzdC5zY2hlbWEuZmllbGRzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGIuY29sdW1ucyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFycm93LlJlY29yZEJhdGNoKHRlc3Quc2NoZW1hLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgYXJyb3cuVGFibGUodGVzdC5zY2hlbWEsIGJhdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRBcnJvd1RhYmxlKHRhYmxlLCB0ZXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdBcnJvdyBhc3luYyBpbnNlcnQgZnJvbSB0YWJsZScsICgpID0+IHtcclxuICAgICAgICBpdCgnc2ltcGxlIGludGVnZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyBpbnNlcnRfZnJvbV90YWJsZWApO1xyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBhcnJvdy5UYWJsZSh7XHJcbiAgICAgICAgICAgICAgICBhOiBhcnJvdy5tYWtlVmVjdG9yKG5ldyBJbnQzMkFycmF5KFsxLCA0LCA3XSkpLFxyXG4gICAgICAgICAgICAgICAgYjogYXJyb3cubWFrZVZlY3RvcihuZXcgSW50MzJBcnJheShbMiwgNSwgOF0pKSxcclxuICAgICAgICAgICAgICAgIGM6IGFycm93LnZlY3RvckZyb21BcnJheTxhcnJvdy5VdGY4PihbJzMnLCAnNicsICc5J10pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRBcnJvd1RhYmxlKHRhYmxlLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5zZXJ0X2Zyb21fdmVjdG9ycycsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0ICogZnJvbSBpbnNlcnRfZnJvbV92ZWN0b3JzJyk7XHJcbiAgICAgICAgICAgIGNvbXBhcmVUYWJsZShyZXN1bHRzLCBbXHJcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnYycsIHZhbHVlczogWyczJywgJzYnLCAnOSddIH0sXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcbmltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuaW1wb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCB7IENvbHVtbiwgY29tcGFyZVRhYmxlIH0gZnJvbSAnLi90YWJsZV90ZXN0JztcclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlQnJvd3NlcihkZXNjcmlwdGlvbjogc3RyaW5nLCBzcGVjRGVmaW5pdGlvbnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcblxyXG5pbnRlcmZhY2UgSlNPTkluc2VydFRlc3Qge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgaW5wdXQ6IHN0cmluZztcclxuICAgIG9wdGlvbnM6IGR1Y2tkYi5KU09OSW5zZXJ0T3B0aW9ucztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICBleHBlY3RlZENvbHVtbnM6IENvbHVtbltdO1xyXG59XHJcblxyXG5jb25zdCBKU09OX0lOU0VSVF9URVNUUzogSlNPTkluc2VydFRlc3RbXSA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAncm93c19pbnRlZ2VycycsXHJcbiAgICAgICAgaW5wdXQ6IGBbXHJcbiAgICAgICAgICAgIHtcImFcIjoxLCBcImJcIjoyLCBcImNcIjozfSxcclxuICAgICAgICAgICAge1wiYVwiOjQsIFwiYlwiOjUsIFwiY1wiOjZ9LFxyXG4gICAgICAgICAgICB7XCJhXCI6NywgXCJiXCI6OCwgXCJjXCI6OX0sXHJcbiAgICAgICAgXWAsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcclxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFszLCA2LCA5XSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdjb2xzX2ludGVnZXJzJyxcclxuICAgICAgICBpbnB1dDogYHtcclxuICAgICAgICAgICAgXCJhXCI6IFsxLCA0LCA3XSxcclxuICAgICAgICAgICAgXCJiXCI6IFsyLCA1LCA4XSxcclxuICAgICAgICAgICAgXCJjXCI6IFszLCA2LCA5XVxyXG4gICAgICAgIH1gLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnb3B0aW9uc18xJyxcclxuICAgICAgICBpbnB1dDogYFtcclxuICAgICAgICAgICAge1wiYVwiOjEsIFwiYlwiOjIsIFwiY1wiOjN9LFxyXG4gICAgICAgICAgICB7XCJhXCI6NCwgXCJiXCI6NSwgXCJjXCI6Nn0sXHJcbiAgICAgICAgICAgIHtcImFcIjo3LCBcImJcIjo4LCBcImNcIjo5fSxcclxuICAgICAgICBdYCxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICAgICAgc2hhcGU6IGR1Y2tkYi5KU09OVGFibGVTaGFwZS5ST1dfQVJSQVksXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcclxuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxyXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuVXRmOCgpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbJzMnLCAnNicsICc5J10gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXTtcclxuXHJcbmNvbnN0IFRFU1RfRklMRSA9ICdURVNUJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0SlNPTkluc2VydChkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnSlNPTiBJbnNlcnQgU3luYycsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgSlNPTl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcihURVNUX0ZJTEUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBjb25uLmluc2VydEpTT05Gcm9tUGF0aChURVNUX0ZJTEUsIHRlc3Qub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVUYWJsZShyZXN1bHRzLCB0ZXN0LmV4cGVjdGVkQ29sdW1ucyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdEpTT05JbnNlcnRBc3luYyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdKU09OIEluc2VydCBCdWZmZXIgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEpTT05fSU5TRVJUX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoVEVTVF9GSUxFLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRKU09ORnJvbVBhdGgoVEVTVF9GSUxFLCB0ZXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZUJyb3dzZXIoJ0pTT04gSW5zZXJ0IEJsb2IgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEpTT05fSU5TRVJUX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlSGFuZGxlKFRFU1RfRklMRSwgYmxvYiwgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRKU09ORnJvbVBhdGgoVEVTVF9GSUxFLCB0ZXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuLi9zcmMvJztcclxuaW1wb3J0IHsgQ29sdW1uLCBjb21wYXJlVGFibGUgfSBmcm9tICcuL3RhYmxlX3Rlc3QnO1xyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVCcm93c2VyKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHNwZWNEZWZpbml0aW9uczogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuXHJcbmludGVyZmFjZSBDU1ZJbnNlcnRUZXN0IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGlucHV0OiBzdHJpbmc7XHJcbiAgICBvcHRpb25zOiBkdWNrZGIuQ1NWSW5zZXJ0T3B0aW9ucztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICBleHBlY3RlZENvbHVtbnM6IENvbHVtbltdO1xyXG59XHJcblxyXG5jb25zdCBDU1ZfSU5TRVJUX1RFU1RTOiBDU1ZJbnNlcnRUZXN0W10gPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ludGVnZXJzX2F1dG9fMScsXHJcbiAgICAgICAgaW5wdXQ6IGBcImFcIixcImJcIixcImNcIlxyXG4xLDIsM1xyXG40LDUsNlxyXG43LDgsOVxyXG5gLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnaW50ZWdlcnNfYXV0b18yJyxcclxuICAgICAgICBpbnB1dDogYGEsYixjXHJcbjEsMiwzXHJcbjQsNSw2XHJcbjcsOCw5XHJcbmAsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcclxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFszLCA2LCA5XSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdpbnRlZ2Vyc19hdXRvXzMnLFxyXG4gICAgICAgIGlucHV0OiBgYSxiLGNgLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMCcsIHZhbHVlczogWydhJ10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMScsIHZhbHVlczogWydiJ10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMicsIHZhbHVlczogWydjJ10gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnaW50ZWdlcnNfYXV0b18yJyxcclxuICAgICAgICBpbnB1dDogYGFcclxuMVxyXG40XHJcbjdcclxuYCxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXHJcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH1dLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnb3B0aW9uc18xJyxcclxuICAgICAgICBpbnB1dDogYDEsMiwzXHJcbjQsNSw2XHJcbjcsOCw5XHJcbmAsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcclxuICAgICAgICAgICAgbmFtZTogJ2ZvbzInLFxyXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZXRlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiB7XHJcbiAgICAgICAgICAgICAgICBhOiBuZXcgYXJyb3cuSW50MTYoKSxcclxuICAgICAgICAgICAgICAgIGI6IG5ldyBhcnJvdy5JbnQzMigpLFxyXG4gICAgICAgICAgICAgICAgYzogbmV3IGFycm93LlV0ZjgoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbzInLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFsnMycsICc2JywgJzknXSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdvcHRpb25zXzInLFxyXG4gICAgICAgIGlucHV0OiBgMXwyfDAxLzAyLzIwMjBcclxuNHw1fDAxLzAzLzIwMjBcclxuN3w4fDAxLzA0LzIwMjBcclxuYCxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICAgICAgZGV0ZWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgZGVsaW1pdGVyOiAnfCcsXHJcbiAgICAgICAgICAgIGRhdGVGb3JtYXQ6ICclbS8lZC8lWScsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcclxuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxyXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuRGF0ZURheSgpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnYycsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygyMDIwLCAwLCAyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoRGF0ZS5VVEMoMjAyMCwgMCwgMykpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKERhdGUuVVRDKDIwMjAsIDAsIDQpKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ29wdGlvbnNfMycsXHJcbiAgICAgICAgaW5wdXQ6IGAxfDJ8MjA6MzI6NDUgMTk5Mi0wMy0wMlxyXG40fDV8MjA6MzI6NTAgMTk5Mi0wMy0wMlxyXG43fDh8MjA6MzI6NTUgMTk5Mi0wMy0wMlxyXG5gLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgICAgICBkZXRlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZWxpbWl0ZXI6ICd8JyxcclxuICAgICAgICAgICAgcXVvdGU6IFwiJ1wiLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXBGb3JtYXQ6ICclSDolTTolUyAlWS0lbS0lZCcsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcclxuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxyXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuVGltZXN0YW1wU2Vjb25kKCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdjJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKERhdGUuVVRDKDE5OTIsIDIsIDIsIDIwLCAzMiwgNDUpKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoRGF0ZS5VVEMoMTk5MiwgMiwgMiwgMjAsIDMyLCA1MCkpLmdldFRpbWUoKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyLCAyMCwgMzIsIDU1KSkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXTtcclxuXHJcbmNvbnN0IFRFU1RfRklMRSA9ICdURVNUJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0Q1NWSW5zZXJ0KGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdDU1YgSW5zZXJ0IFN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcihURVNUX0ZJTEUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0Q1NWSW5zZXJ0QXN5bmMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb247XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnQ1NWIEluc2VydCBCdWZmZXIgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcihURVNUX0ZJTEUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmVCcm93c2VyKCdDU1YgSW5zZXJ0IEJsb2IgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVIYW5kbGUoVEVTVF9GSUxFLCBibG9iLCBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0VG9rZW5pemF0aW9uKGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGRlc2NyaWJlKCdUb2tlbml6ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ1NFTEVDVCAxJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBleHBlY3QoZGIoKS50b2tlbml6ZSgnU0VMRUNUIDEnKSkudG9FcXVhbCh7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzOiBbMCwgN10sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDFdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpdCgnU0VMRUNUICogRlJPTSByZWdpb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4cGVjdChkYigpLnRva2VuaXplKCdTRUxFQ1QgKiBGUk9NIHJlZ2lvbicpKS50b0VxdWFsKHtcclxuICAgICAgICAgICAgICAgIG9mZnNldHM6IFswLCA3LCA5LCAxNF0sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDMsIDQsIDBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRva2VuaXphdGlvbkFzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGRlc2NyaWJlKCdUb2tlbml6ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ1NFTEVDVCAxJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBleHBlY3QoYXdhaXQgZGIoKS50b2tlbml6ZSgnU0VMRUNUIDEnKSkudG9FcXVhbCh7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzOiBbMCwgN10sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDFdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpdCgnU0VMRUNUICogRlJPTSByZWdpb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBkYigpLnRva2VuaXplKCdTRUxFQ1QgKiBGUk9NIHJlZ2lvbicpKS50b0VxdWFsKHtcclxuICAgICAgICAgICAgICAgIG9mZnNldHM6IFswLCA3LCA5LCAxNF0sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDMsIDQsIDBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcblxyXG5pbnRlcmZhY2UgVGFibGVOYW1lVGVzdCB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBpbnB1dDogc3RyaW5nO1xyXG4gICAgdGFibGVzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuY29uc3QgVEFCTEVOQU1FX1RFU1RTOiBUYWJsZU5hbWVUZXN0W10gPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3N0YW5kYXJkJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnZmV0Y2hfc3BlY2lmaWMnLFxyXG4gICAgICAgIGlucHV0OiAnU0VMRUNUIGNvbF9hIEZST00gbXlfdGFibGUnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbXVsdGlwbGVfdGFibGVzJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUxLCBteV90YWJsZTIsIG15X3RhYmxlMycsXHJcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlMScsICdteV90YWJsZTInLCAnbXlfdGFibGUzJ10sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdzYW1lX3RhYmxlX211bHRpcGxlX3RpbWVzJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCBjb2xfYSBGUk9NIG15X3RhYmxlLCBteV90YWJsZSBtMiwgbXlfdGFibGUgbTMnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnc3VicXVlcmllcycsXHJcbiAgICAgICAgaW5wdXQ6ICdTRUxFQ1QgKiBGUk9NIChTRUxFQ1QgKiBGUk9NIChTRUxFQ1QgKiBGUk9NIG15X3RhYmxlKSBibGEpIGJsYTMnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnam9pbicsXHJcbiAgICAgICAgaW5wdXQ6ICdTRUxFQ1QgY29sX2EgRlJPTSBteV90YWJsZSBKT0lOIG15X3RhYmxlMiBPTiAobXlfdGFibGUuY29sX2I9bXlfdGFibGUyLmNvbF9kKScsXHJcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJywgJ215X3RhYmxlMiddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnc2NhbGFyX3N1YnF1ZXJ5JyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAoU0VMRUNUIENPVU5UKCopIEZST00gbXlfdGFibGUpJyxcclxuICAgICAgICB0YWJsZXM6IFsnbXlfdGFibGUnXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3NldF9vcGVyYXRpb25zJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUgVU5JT04gQUxMIFNFTEVDVCAqIEZST00gbXlfdGFibGUyIElOVEVSU0VDVCBTRUxFQ1QgKiBGUk9NIG15X3RhYmxlMycsXHJcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJywgJ215X3RhYmxlMicsICdteV90YWJsZTMnXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3dpbmRvd19mdW5jdGlvbnMnLFxyXG4gICAgICAgIGlucHV0OiAnU0VMRUNUIHJvd19udW1iZXIoKSBPVkVSIChPUkRFUiBCWSAoU0VMRUNUIGkraiBGUk9NIG15X3RhYmxlMikpIEZST00gbXlfdGFibGUnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZScsICdteV90YWJsZTInXSxcclxuICAgIH0sXHJcbl07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRhYmxlTmFtZXMoZGI6ICgpID0+IGR1Y2tkYi5EdWNrREJCaW5kaW5ncyk6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uO1xyXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgIH0pO1xyXG4gICAgZGVzY3JpYmUoJ1RhYmxlTmFtZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIFRBQkxFTkFNRV9URVNUUykge1xyXG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlcyA9IGNvbm4uZ2V0VGFibGVOYW1lcyh0ZXN0LmlucHV0KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZXMpLnRvRXF1YWwodGVzdC50YWJsZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RUYWJsZU5hbWVzQXN5bmMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb247XHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnVGFibGVOYW1lcyBBc3luYycsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgVEFCTEVOQU1FX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVzID0gYXdhaXQgY29ubi5nZXRUYWJsZU5hbWVzKHRlc3QuaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlcykudG9FcXVhbCh0ZXN0LnRhYmxlcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vLi4vc3JjJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kdWNrZGIvZHVja2RiLXdhc20vaXNzdWVzLzMzMlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdDMzMihkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgIH0pO1xyXG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgIH0pO1xyXG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJzMzMicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVUZXh0KFxyXG4gICAgICAgICAgICAgICAgJ1Byb2R1Y3RzLmNzdicsXHJcbiAgICAgICAgICAgICAgICBgUHJvZHVjdEdyb3VwLFByb2R1Y3QsWWVhcixRdWFydGVyLFJldmVudWUsVW5pdHMsQ291bnQsUHJvZHVjdCBLZXksUmVzZWxsZXIsUHJvZHVjdCBJbmZvLFF1YXJ0ZXJBc051bWJlclxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDE4LFExLDEwMyw3LDEsMjAxOC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTgsUTEsMTAyLDQsMSwyMDE4LVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOSxRMSw5OCwxMiwxLDIwMTktUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDE4LFExLDEwNCwzLDEsMjAxOC1RMSxTYW1zdW5nLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMTksUTEsODMsNywxLDIwMTktUTEsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLFRoZWF0ZXIsMjAxOCxRMSwxNyw0LDEsMjAxOC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLFRoZWF0ZXIsMjAxOSxRMSwyMCw3LDEsMjAxOS1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLE1vdmllcywyMDE4LFExLDI1LDEyLDEsMjAxOC1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuTWVkaWEsTW92aWVzLDIwMTksUTEsMjYsMTMsMSwyMDE5LVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOCxRMiwxMDUsNSwxLDIwMTgtUTIsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDE5LFEyLDgyLDE1LDEsMjAxOS1RMixMRyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDE4LFEyLDk5LDQsMSwyMDE4LVEyLExHLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXHJcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMTksUTIsODQsMjAsMSwyMDE5LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuTWVkaWEsVGhlYXRlciwyMDE4LFEyLDE3LDQsMSwyMDE4LVEyLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxUaGVhdGVyLDIwMTksUTIsMjIsNSwxLDIwMTktUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxOCxRMiwyNSwxMiwxLDIwMTgtUTIsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxOSxRMiwyNiwxNCwxLDIwMTktUTIsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMDAsUTEsMTAzLDcsMSwyMDAwLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAwMSxRMSwxMDIsNCwxLDIwMDEtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDAyLFExLDk4LDEyLDEsMjAwMi1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAwMyxRMSwxMDQsMywxLDIwMDMtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDA0LFExLDgzLDcsMSwyMDA0LVExLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuTWVkaWEsVGhlYXRlciwyMDA1LFExLDE3LDQsMSwyMDA1LVExLEdvb2dsZSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5NZWRpYSxUaGVhdGVyLDIwMDYsUTEsMjAsNywxLDIwMDYtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5NZWRpYSxNb3ZpZXMsMjAwNyxRMSwyNSwxMiwxLDIwMDctUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5NZWRpYSxNb3ZpZXMsMjAwOCxRMSwyNiwxMywxLDIwMDgtUTEsTWljcm9zb2Z0LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMDksUTIsMTA1LDUsMSwyMDA5LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxMCxRMiw4MiwxNSwxLDIwMTAtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDExLFEyLDk5LDQsMSwyMDExLVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAxMixRMiw4NCwyMCwxLDIwMTItUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxUaGVhdGVyLDIwMTMsUTIsMTcsNCwxLDIwMTMtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxUaGVhdGVyLDIwMTQsUTIsMjIsNSwxLDIwMTQtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxNSxRMiwyNSwxMiwxLDIwMTUtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxNixRMiwyNiwxNCwxLDIwMTYtUTIsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxNyxRMSwyNiwxMywxLDIwMTctUTEsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTgsUTIsMTA1LDUsMSwyMDE4LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOSxRMiw4MiwxNSwxLDIwMTktUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDIwLFEyLDk5LDQsMSwyMDIwLVEyLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDIwLFExLDEwMyw3LDEsMjAyMC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMjAsUTIsMTAyLDQsMSwyMDIwLVEyLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAyMCxRMyw5OCwxMiwxLDIwMjAtUTMsTEcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDNcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAyMCxRNCwxMDQsMywxLDIwMjAtUTQsTEcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDRcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAyMCxRMSw4Myw3LDEsMjAyMC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLFRoZWF0ZXIsMjAyMCxRMSwxNyw0LDEsMjAyMC1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuTWVkaWEsVGhlYXRlciwyMDIwLFExLDIwLDcsMSwyMDIwLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShcIkNSRUFURSBUQUJMRSBwcm9kdWN0cyBBUyBTRUxFQ1QgKiBGUk9NICdQcm9kdWN0cy5jc3YnXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBhbGwgPSBhd2FpdCBjb25uLnF1ZXJ5KCdTRUxFQ1QgKiBGUk9NIHByb2R1Y3RzJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChhbGwuc2NoZW1hLmZpZWxkcy5sZW5ndGgpLnRvQmUoMTEpO1xyXG4gICAgICAgICAgICBleHBlY3QoYWxsLnNjaGVtYS5maWVsZHNbMF0ubmFtZSkudG9CZSgnUHJvZHVjdEdyb3VwJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gYXdhaXQgY29ubi5xdWVyeTx7XHJcbiAgICAgICAgICAgICAgICBQcm9kdWN0R3JvdXA6IGFycm93LlV0Zjg7XHJcbiAgICAgICAgICAgIH0+KCdTRUxFQ1QgcHJvZHVjdGdyb3VwIEZST00gcHJvZHVjdHMgR1JPVVAgQlkgcHJvZHVjdGdyb3VwJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChpbnNlbnNpdGl2ZS5zY2hlbWEuZmllbGRzLmxlbmd0aCkudG9CZSgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KGluc2Vuc2l0aXZlLnNjaGVtYS5maWVsZHNbMF0ubmFtZSkudG9CZSgnUHJvZHVjdEdyb3VwJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChpbnNlbnNpdGl2ZS50b0FycmF5KCkubGVuZ3RoKS50b0VxdWFsKDIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KCdEUk9QIFRBQkxFIHByb2R1Y3RzJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XHJcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy8zMzRcclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3QzMzQoYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGRlc2NyaWJlKCdHaXRIdWIgaXNzdWVzJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCczMzQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdDU1YgaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChgZGF0YS5jc3ZgLCAnMXxmb29cXG4yfGJhclxcbicpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0Q1NWRnJvbVBhdGgoJ2RhdGEuY3N2Jywge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXI6ICd8JyxcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDE6IG5ldyBhcnJvdy5JbnQzMigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wyOiBuZXcgYXJyb3cuVXRmOCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0RST1AgVEFCTEUgSUYgRVhJU1RTIGZvbycpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkuZHJvcEZpbGUoJ2RhdGEuY3N2Jyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpdCgnSlNPTiByb3cgaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChcclxuICAgICAgICAgICAgICAgICAgICAncm93cy5qc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBgW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgXCJjb2wxXCI6IDEsIFwiY29sMlwiOiBcImZvb1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBcImNvbDFcIjogMiwgXCJjb2wyXCI6IFwiYmFyXCIgfSxcclxuICAgICAgICAgICAgICAgIF1gLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydEpTT05Gcm9tUGF0aCgncm93cy5qc29uJywgeyBuYW1lOiAncm93cycgfSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KCdEUk9QIFRBQkxFIElGIEVYSVNUUyByb3dzJyk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5kcm9wRmlsZSgncm93cy5qc29uJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpdCgnSlNPTiBjb2x1bW4gaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChcclxuICAgICAgICAgICAgICAgICAgICAnY29sdW1ucy5qc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiY29sMVwiOiBbMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb2wyXCI6IFtcImZvb1wiLCBcImJhclwiXVxyXG4gICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0SlNPTkZyb21QYXRoKCdjb2x1bW5zLmpzb24nLCB7IG5hbWU6ICdjb2x1bW5zJyB9KTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0RST1AgVEFCTEUgSUYgRVhJU1RTIGNvbHVtbnMnKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLmRyb3BGaWxlKCdjb2x1bW5zLmpzb24nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGl0KCdRdWVyeSByZXN1bHQgbWF0ZXJpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnk8eyB2OiBhcnJvdy5JbnQgfT4oYFxyXG4gICAgICAgICAgICAgICAgU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwKSB0KHYpXHJcbiAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1F1ZXJ5IHJlc3VsdCBzdHJlYW1lZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIGF3YWl0IGNvbm4uc2VuZDx7IHY6IGFycm93LkludCB9PihgXHJcbiAgICAgICAgICAgICAgICBTRUxFQ1QgKiBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDApIHQodilcclxuICAgICAgICAgICAgYCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtUm93cykudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1ByZXBhcmVkIHN0YXRlbWVudCBtYXRlcmlhbGl6ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IGNvbm4ucHJlcGFyZShgU0VMRUNUIHYgKyA/IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsIDEwMDAwKSBhcyB0KHYpO2ApO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5xdWVyeSgyMzQpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1ByZXBhcmVkIHN0YXRlbWVudCBzdHJlYW1lZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgY29ubi5wcmVwYXJlKGBTRUxFQ1QgdiArID8gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7YCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIGF3YWl0IHN0bXQuc2VuZCgyMzQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bVJvd3MpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XHJcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy8zOTNcclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3QzOTMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgY29ubiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdHaXRIdWIgaXNzdWVzJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCczOTMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICBjYXN0VGltZXN0YW1wVG9EYXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhvdXRDYXN0ID0gYXdhaXQgY29ubi5xdWVyeTx7XHJcbiAgICAgICAgICAgICAgICB0czogYXJyb3cuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgVElNRVNUQU1QICcxOTkyLTAzLTIyIDAxOjAyOjAzJyBhcyB0c2ApO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0V2l0aG91dENhc3QudG9BcnJheSgpWzBdPy50cykudG9FcXVhbChuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyMiwgMSwgMiwgMykpLmdldFRpbWUoKSk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzdFRpbWVzdGFtcFRvRGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhDYXN0ID0gYXdhaXQgY29ubi5xdWVyeTx7XHJcbiAgICAgICAgICAgICAgICB0czogYXJyb3cuRGF0ZU1pbGxpc2Vjb25kO1xyXG4gICAgICAgICAgICB9PihgU0VMRUNUIFRJTUVTVEFNUCAnMTk5Mi0wMy0yMiAwMTowMjowMycgYXMgdHNgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhDYXN0LnRvQXJyYXkoKVswXT8udHMpLnRvRXF1YWwobmV3IERhdGUoRGF0ZS5VVEMoMTk5MiwgMiwgMjIsIDEsIDIsIDMpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XHJcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy80NDhcclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3Q0NDgoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgY29ubiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdHaXRIdWIgaXNzdWVzJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCc0NDgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgY3JlYXRlIHRlbXAgdGFibGUgdGVzdDQ0OChpIGludGVnZXIpYCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYGluc2VydCBpbnRvIHRlc3Q0NDggdmFsdWVzICgxKSwoMiksKDEpYCk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb25uLnF1ZXJ5KGBzZWxlY3QgKiBmcm9tIHRlc3Q0NDhgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxLCAyLCAxXSkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjb25uLnF1ZXJ5PHsgaTogYXJyb3cuTWFwXzxhcnJvdy5JbnQzMiwgYXJyb3cuVWludDY0PiB9Pihgc2VsZWN0IGhpc3RvZ3JhbShpKSBmcm9tIHRlc3Q0NDhgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gcmVzdWx0LmdldENoaWxkQXQoMCkhLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgZXhwZWN0KGFycmF5Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KGFycmF5WzBdLnRvU3RyaW5nKCkpLnRvRXF1YWwoJ3sxOiAyLCAyOiAxfScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi8uLi9zcmMnO1xyXG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2R1Y2tkYi9kdWNrZGItd2FzbS9pc3N1ZXMvNDcwXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0NDcwKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgIH0pO1xyXG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnR2l0SHViIGlzc3VlcycsICgpID0+IHtcclxuICAgICAgICBpdCgnNDcwJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBCYXNlbGluZSB3aXRob3V0IGNhc3Q6IHdlIGV4cGVjdCBhbiBlcnJvciB0byBiZSB0aHJvd24gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gdHlwZSB0aGF0IGlzIGVtaXR0ZWRcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXHJcbiAgICAgICAgICAgICAgICBxdWVyeToge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc3REdXJhdGlvblRvVGltZTY0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgSU5URVJWQUwgJzMnIE1PTlRIIEFTIGludGVydmFsYCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQxLnRvQXJyYXkoKVswXT8uaW50ZXJ2YWw/LnRvU3RyaW5nKCkpLnRvRXF1YWwoJzAsMycpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FzdCBleHBsaWNpdGx5IGVuYWJsZWQ6IFRpbWU2NCB2YWx1ZSBpcyByZXR1cm5lZFxyXG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzdER1cmF0aW9uVG9UaW1lNjQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRXaXRoQ2FzdCA9IGF3YWl0IGNvbm4ucXVlcnk8e1xyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IGFycm93LlRpbWVNaWNyb3NlY29uZDtcclxuICAgICAgICAgICAgfT4oYFNFTEVDVCBJTlRFUlZBTCAnMycgTU9OVEggQVMgaW50ZXJ2YWxgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhDYXN0LnRvQXJyYXkoKVswXT8uaW50ZXJ2YWw/LnRvU3RyaW5nKCkpLnRvRXF1YWwoJzAsMycpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FzdCBzaG91bGQgYmUgb24gYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7fSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aERlZmF1bHQgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgSU5URVJWQUwgJzMnIE1PTlRIIEFTIGludGVydmFsYCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRXaXRoRGVmYXVsdC50b0FycmF5KClbMF0/LmludGVydmFsPy50b1N0cmluZygpKS50b0VxdWFsKCcwLDMnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vLi4vc3JjJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kdWNrZGIvZHVja2RiLXdhc20vaXNzdWVzLzQ3N1xyXG4vLyBOb3RlIHRoYXQgd2hlbiBBcnJvd0pTIHN1cHBvcnRzIG5lZ2F0aXZlIGRlY2ltYWxzLCBjYXN0RGVjaW1hbFRvRG91YmxlIHNob3VsZCBwcm9iYWJseSBiZSBkZXByZWNhdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdDQ3NyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbm4pIHtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjb25uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgIH0pO1xyXG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJzQ3NycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQmFzZWxpbmUgd2l0aG91dCBjYXN0OiB3ZSBleHBlY3QgdGhlIG5lZ2F0aXZlIGRlY2ltYWwgdmFsdWVzIHRvIG5vdCB3b3JrIGFjY3VyYXRlbHlcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXHJcbiAgICAgICAgICAgICAgICBxdWVyeToge30sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhvdXRDYXN0ID0gYXdhaXQgY29ubi5xdWVyeShgU0VMRUNUICgtMS45KTo6REVDSU1BTCgyLDEpIGFzIGRlY2ltYWxgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnNjaGVtYS5maWVsZHNbMF0udHlwZS5zY2FsZSkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnNjaGVtYS5maWVsZHNbMF0udHlwZS5wcmVjaXNpb24pLnRvRXF1YWwoMik7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYXNzZXJ0aW9uIGJyZWFrcywgYXJyb3cgSlMgd2FzIGxpa2VseSB1cGRhdGVkIHRvIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnRvQXJyYXkoKVswXT8uZGVjaW1hbCA9PSAtMTkpLnRvQmUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNpbmcgY2FzdERlY2ltYWxUb0RvdWJsZSB3ZSBmb3JjZSBkZWNpbWFscyB0byBiZSBjYXN0IHRvIGRvdWJsZXMsIG5vdGUgdGhlIGluZXZpdGFibGUgaW1wcmVjaXNpb24uXHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICBjYXN0RGVjaW1hbFRvRG91YmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aENhc3QgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgIGRlY2ltYWw6IGFycm93LkZsb2F0NjQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgKC0xLjkpOjpERUNJTUFMKDIsMSkgYXMgZGVjaW1hbGApO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0V2l0aENhc3QudG9BcnJheSgpWzBdPy5kZWNpbWFsKS50b0VxdWFsKC0xLjkwMDAwMDAwMDAwMDAwMDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi8uLi9zcmMvJztcclxuaW1wb3J0IHsgdGVzdDMzMiB9IGZyb20gJy4vZ2l0aHViXzMzMi50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDMzNCB9IGZyb20gJy4vZ2l0aHViXzMzNC50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDM5MyB9IGZyb20gJy4vZ2l0aHViXzM5My50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDQ0OCB9IGZyb20gJy4vZ2l0aHViXzQ0OC50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDQ3MCB9IGZyb20gJy4vZ2l0aHViXzQ3MC50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDQ3NyB9IGZyb20gXCIuL2dpdGh1Yl80NzcudGVzdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RSZWdyZXNzaW9uQXN5bmMoYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIHRlc3QzMzIoYWRiKTtcclxuICAgIHRlc3QzMzQoYWRiKTtcclxuICAgIHRlc3QzOTMoYWRiKTtcclxuICAgIHRlc3Q0NDgoYWRiKTtcclxuICAgIHRlc3Q0NzAoYWRiKTtcclxuICAgIHRlc3Q0NzcoYWRiKTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBGbG9hdDY0LCBJbnQzMiwgVXRmOCB9IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFVERihkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ1VERicsICgpID0+IHtcclxuICAgICAgICBpdCgnc2ltcGxlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZicsIG5ldyBJbnQzMigpLCBhID0+IGEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KGpzdWRmKHY6OklOVEVHRVIpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodiknLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbMTAwMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdkb3VibGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMicsIG5ldyBGbG9hdDY0KCksIGEgPT4gYSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGYyKHY6OkRPVUJMRSkpOjpET1VCTEUgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEZsb2F0NjRBcnJheShbMTAwMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCcyIGFyZ3MnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMycsIG5ldyBJbnQzMigpLCAoYSwgYikgPT4gYSArIGIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KGpzdWRmMyh2OjpJTlRFR0VSLCB2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzIwMDAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnMyBhcmdzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjNhcmdzJywgbmV3IEludDMyKCksIChhLCBiLCBjKSA9PiBhICsgYiArIGMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KGpzdWRmM2FyZ3Modjo6SU5URUdFUiwgdjo6SU5URUdFUiwgdjo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFszMDAwMF0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJzQgYXJncycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY0YXJncycsIG5ldyBJbnQzMigpLCAoYSwgYiwgYywgZCkgPT4gYSArIGIgKyBjICsgZCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGY0YXJncyh2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQwMDAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnbm9hcmdzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjQnLCBuZXcgSW50MzIoKSwgKCkgPT4gNDIpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KCdTRUxFQ1QgbWF4KGpzdWRmNCgpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodiknKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQyXSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0KCd3aXRobnVsbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmNScsIG5ldyBJbnQzMigpLCBhID0+IChhID09IG51bGwgPyAtMTAwIDogYSkpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtaW4oanN1ZGY1KChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFstMTAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc3RyaW5ncGFyYW0nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGpzdWRmNihzOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjYnLCBuZXcgSW50MzIoKSwganN1ZGY2KTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgIFwiU0VMRUNUIG1heChqc3VkZjYoJ3N0cl8nIHx8IHYpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodilcIixcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzldKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzdHJpbmdwYXJhbW51bGxzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBqc3VkZjcoczogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmNycsIG5ldyBJbnQzMigpLCBqc3VkZjcpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgXCJTRUxFQ1QgbWF4KGpzdWRmNygoY2FzZSB3aGVuIHYgJSAyID0gMCB0aGVuICdzdHJfJyB8fCB2IGVsc2UgbnVsbCBlbmQpOjpWQVJDSEFSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpXCIsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFs5XSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnbnVsbGludHJldHVybicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY4JywgbmV3IEludDMyKCksIGEgPT4gdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAnU0VMRUNUIG1heChDT0FMRVNDRShqc3VkZjgodjo6SU5URUdFUiksIDQyKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQyXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc3RyaW5ncmV0dXJuJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjknLCBuZXcgVXRmOCgpLCBhID0+ICdIZWxsbyAnICsgYSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoTEVOR1RIKGpzdWRmOSh2OjpJTlRFR0VSKSkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxMV0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ251bGxzdHJpbmdyZXR1cm4nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMTAnLCBuZXcgVXRmOCgpLCBhID0+IChhICUgMiA9PSAwID8gJ0hlbGxvJyA6IHVuZGVmaW5lZCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgQ09VTlQoanN1ZGYxMCh2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzUwMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzdHJ1Y3QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMTEnLCBuZXcgSW50MzIoKSwgYSA9PiAoYS54ID09IG51bGwgPyAtMTAwIDogYS54KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgU0VMRUNUIG1pbihqc3VkZjExKHsneCc6IChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUiwgJ3knOiA0Mn0pKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodilgLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbLTEwMF0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3N0cnVjdG5lc3RlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGYxMicsIG5ldyBJbnQzMigpLCBhID0+IChhLngueSA9PSBudWxsID8gLTEwMCA6IGEueC55KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgU0VMRUNUIG1pbihqc3VkZjEyKHsneCc6IHsneSc6IChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUiB9LCAneic6IDQyfSkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KWAsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFstMTAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc3RydWN0bmVzdGVkbnVsbCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGYxMycsIG5ldyBJbnQzMigpLCBhID0+IChhLng/LnkgPT0gbnVsbCA/IC0xMDAgOiBhLnghLnkpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgIGBTRUxFQ1QgbWluKGpzdWRmMTMoeyd4JzogKGNhc2Ugd2hlbiB2ICUgMiA9IDAgdGhlbiB7J3knOiB2OjpJTlRFR0VSIH0gZWxzZSBudWxsIGVuZCksICd6JzogNDJ9KSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpYCxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWy0xMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiX2Jsb2NraW5nIGZyb20gJy4uL3NyYy90YXJnZXRzL2R1Y2tkYi1icm93c2VyLWJsb2NraW5nJztcclxuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy90YXJnZXRzL2R1Y2tkYic7XHJcbmltcG9ydCAqIGFzIGNoZWNrIGZyb20gJ3dhc20tZmVhdHVyZS1kZXRlY3QnO1xyXG5cclxuLy8gQ29uZmlndXJlIHRoZSB3b3JrZXJcclxuY29uc3QgRFVDS0RCX0JVTkRMRVM6IGR1Y2tkYi5EdWNrREJCdW5kbGVzID0ge1xyXG4gICAgbXZwOiB7XHJcbiAgICAgICAgbWFpbk1vZHVsZTogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItbXZwLndhc20nLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgICAgICBtYWluV29ya2VyOiBuZXcgVVJMKCcvc3RhdGljL2R1Y2tkYi1icm93c2VyLW12cC53b3JrZXIuanMnLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgIH0sXHJcbiAgICBlaDoge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IG5ldyBVUkwoJy9zdGF0aWMvZHVja2RiLWVoLndhc20nLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgICAgICBtYWluV29ya2VyOiBuZXcgVVJMKCcvc3RhdGljL2R1Y2tkYi1icm93c2VyLWVoLndvcmtlci5qcycsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmLFxyXG4gICAgfSxcclxuICAgIGNvaToge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IG5ldyBVUkwoJy9zdGF0aWMvZHVja2RiLWNvaS53YXNtJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXHJcbiAgICAgICAgbWFpbldvcmtlcjogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItYnJvd3Nlci1jb2kud29ya2VyLmpzJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXHJcbiAgICAgICAgcHRocmVhZFdvcmtlcjogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItYnJvd3Nlci1jb2kucHRocmVhZC53b3JrZXIuanMnLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgIH0sXHJcbn07XHJcbmxldCBEVUNLREJfQlVORExFOiBkdWNrZGIuRHVja0RCQnVuZGxlIHwgbnVsbCA9IG51bGw7XHJcblxyXG5kZXNjcmliZSgnd2FzbSBjaGVjaycsICgpID0+IHtcclxuICAgIGl0KCd3b3JrZXIgYW5kIHdhc20gdXJscycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIChhd2FpdCBkdWNrZGIuZ2V0UGxhdGZvcm1GZWF0dXJlcygpKS5jcm9zc09yaWdpbklzb2xhdGVkICYmXHJcbiAgICAgICAgICAgIChhd2FpdCBjaGVjay5leGNlcHRpb25zKCkpICYmXHJcbiAgICAgICAgICAgIChhd2FpdCBjaGVjay50aHJlYWRzKCkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluTW9kdWxlKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEubWFpbk1vZHVsZSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEubWFpbldvcmtlcik7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEucHRocmVhZFdvcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoYXdhaXQgY2hlY2suZXhjZXB0aW9ucygpKSAmJiAhKGF3YWl0IGNoZWNrLnRocmVhZHMoKSkpIHtcclxuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLm1haW5Nb2R1bGUpLnRvRXF1YWwoRFVDS0RCX0JVTkRMRVMuZWghLm1haW5Nb2R1bGUpO1xyXG4gICAgICAgICAgICBleHBlY3QoRFVDS0RCX0JVTkRMRSEubWFpbldvcmtlcikudG9FcXVhbChEVUNLREJfQlVORExFUy5laCEubWFpbldvcmtlcik7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShhd2FpdCBjaGVjay5leGNlcHRpb25zKCkpKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluTW9kdWxlKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLm12cCEubWFpbk1vZHVsZSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLm12cCEubWFpbldvcmtlcik7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuXHJcbi8vIExvYWRpbmcgZGVidWcgc3ltYm9scywgZXNwZWNpYWxseSBmb3IgV0FTTSB0YWtlIGluc2FuZWx5IGxvbmcgc28gd2UganVzdCBkaXNhYmxlIHRoZSB0ZXN0IHRpbWVvdXRcclxuamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwgPSA2MDAwMDtcclxuXHJcbi8vIFJlc29sdmUgYSBidWZmZXIgYnkgZmV0Y2hpbmcgZnJvbSBkaXNrXHJcbmNvbnN0IHJlc29sdmVCdWZmZXIgPSBhc3luYyAodXJsOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHJlcSA9IGF3YWl0IGZldGNoKGAvZGF0YSR7dXJsfWApO1xyXG4gICAgaWYgKCFyZXEub2spIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlcS5hcnJheUJ1ZmZlcigpKTtcclxufTtcclxuXHJcbi8vIFJlc29sdmUgdGVzdCBkYXRhXHJcbmNvbnN0IHJlc29sdmVEYXRhID0gYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHVybCkge1xyXG4gICAgICAgIGNhc2UgJy91bmkvYWxsLnppcCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL2FsbC56aXAnKTtcclxuICAgICAgICBjYXNlICcvdW5pL2Fzc2lzdGVudGVuLnBhcnF1ZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZUJ1ZmZlcignL3VuaS9hc3Npc3RlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgY2FzZSAnL3VuaS9zdHVkZW50ZW4ucGFycXVldCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgY2FzZSAnL3VuaS9ob2VyZW4ucGFycXVldCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL2hvZXJlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgY2FzZSAnL3VuaS92b3JsZXN1bmdlbi5wYXJxdWV0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy91bmkvdm9ybGVzdW5nZW4ucGFycXVldCcpO1xyXG4gICAgICAgIGNhc2UgJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0Jyk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBUZXN0IGVudmlyb25tZW50XHJcbmxldCBkYjogZHVja2RiX2Jsb2NraW5nLkR1Y2tEQkJpbmRpbmdzIHwgbnVsbCA9IG51bGw7XHJcbmxldCBhZGI6IGR1Y2tkYi5Bc3luY0R1Y2tEQiB8IG51bGwgPSBudWxsO1xyXG5sZXQgd29ya2VyOiBXb3JrZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbmJlZm9yZUFsbChhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgZHVja2RiX2Jsb2NraW5nLlZvaWRMb2dnZXIoKTtcclxuICAgIGRiID0gYXdhaXQgZHVja2RiX2Jsb2NraW5nLmNyZWF0ZUR1Y2tEQihEVUNLREJfQlVORExFUywgbG9nZ2VyLCBkdWNrZGJfYmxvY2tpbmcuQlJPV1NFUl9SVU5USU1FKTtcclxuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKF8gPT4ge30pO1xyXG5cclxuICAgIERVQ0tEQl9CVU5ETEUgPSBhd2FpdCBkdWNrZGIuc2VsZWN0QnVuZGxlKERVQ0tEQl9CVU5ETEVTKTtcclxuICAgIHdvcmtlciA9IGF3YWl0IGR1Y2tkYi5jcmVhdGVXb3JrZXIoRFVDS0RCX0JVTkRMRSEubWFpbldvcmtlciEpO1xyXG4gICAgYWRiID0gbmV3IGR1Y2tkYi5Bc3luY0R1Y2tEQihsb2dnZXIsIHdvcmtlcik7XHJcbiAgICBhd2FpdCBhZGIuaW5zdGFudGlhdGUoRFVDS0RCX0JVTkRMRSEubWFpbk1vZHVsZSwgRFVDS0RCX0JVTkRMRSEucHRocmVhZFdvcmtlcik7XHJcbn0pO1xyXG5cclxuYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKHdvcmtlcikgd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG59KTtcclxuXHJcbmltcG9ydCB7IHRlc3RBbGxUeXBlcywgdGVzdEFsbFR5cGVzQXN5bmMgfSBmcm9tICcuL2FsbF90eXBlcy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEhUVFBGUywgdGVzdEhUVFBGU0FzeW5jIH0gZnJvbSAnLi9odHRwZnNfdGVzdCc7XHJcbmltcG9ydCB7IHRlc3RCaW5kaW5ncywgdGVzdEFzeW5jQmluZGluZ3MgfSBmcm9tICcuL2JpbmRpbmdzLnRlc3QnO1xyXG5pbXBvcnQgeyB0ZXN0QmF0Y2hTdHJlYW0gfSBmcm9tICcuL2JhdGNoX3N0cmVhbS50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEFzeW5jQmF0Y2hTdHJlYW0gfSBmcm9tICcuL2JhdGNoX3N0cmVhbV9hc3luYy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEZpbGVzeXN0ZW0gfSBmcm9tICcuL2ZpbGVzeXN0ZW0udGVzdCc7XHJcbmltcG9ydCB7IHRlc3RBcnJvd0luc2VydCwgdGVzdEFycm93SW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9hcnJvdy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEpTT05JbnNlcnQsIHRlc3RKU09OSW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9qc29uLnRlc3QnO1xyXG5pbXBvcnQgeyB0ZXN0Q1NWSW5zZXJ0LCB0ZXN0Q1NWSW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9jc3YudGVzdCc7XHJcbmltcG9ydCB7IHRlc3RUb2tlbml6YXRpb24sIHRlc3RUb2tlbml6YXRpb25Bc3luYyB9IGZyb20gJy4vdG9rZW5pemVyLnRlc3QnO1xyXG5pbXBvcnQgeyB0ZXN0VGFibGVOYW1lcywgdGVzdFRhYmxlTmFtZXNBc3luYyB9IGZyb20gJy4vdGFibGVuYW1lcy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdFJlZ3Jlc3Npb25Bc3luYyB9IGZyb20gJy4vcmVncmVzc2lvbic7XHJcbmltcG9ydCB7IHRlc3RVREYgfSBmcm9tICcuL3VkZi50ZXN0JztcclxuLy9pbXBvcnQgeyB0ZXN0RVhDRUwgfSBmcm9tICcuL2V4Y2VsLnRlc3QnO1xyXG4vL2ltcG9ydCB7IHRlc3RKU09OIH0gZnJvbSAnLi9qc29uLnRlc3QnO1xyXG5cclxuY29uc3QgYmFzZVVSTCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XHJcbmNvbnN0IGRhdGFVUkwgPSBgJHtiYXNlVVJMfS9kYXRhYDtcclxuXHJcbnRlc3RIVFRQRlMoKCkgPT4gZGIhKTtcclxudGVzdEhUVFBGU0FzeW5jKCgpID0+IGFkYiEsIHJlc29sdmVEYXRhLCBkYXRhVVJMKTtcclxudGVzdFVERigoKSA9PiBkYiEpO1xyXG50ZXN0VGFibGVOYW1lcygoKSA9PiBkYiEpO1xyXG50ZXN0VGFibGVOYW1lc0FzeW5jKCgpID0+IGFkYiEpO1xyXG50ZXN0UmVncmVzc2lvbkFzeW5jKCgpID0+IGFkYiEpO1xyXG50ZXN0QWxsVHlwZXMoKCkgPT4gZGIhKTtcclxudGVzdEFsbFR5cGVzQXN5bmMoKCkgPT4gYWRiISk7XHJcbnRlc3RCaW5kaW5ncygoKSA9PiBkYiEsIGRhdGFVUkwpO1xyXG50ZXN0QXN5bmNCaW5kaW5ncygoKSA9PiBhZGIhLCBkYXRhVVJMLCBkdWNrZGIuRHVja0RCRGF0YVByb3RvY29sLkhUVFApO1xyXG50ZXN0QmF0Y2hTdHJlYW0oKCkgPT4gZGIhKTtcclxudGVzdEFzeW5jQmF0Y2hTdHJlYW0oKCkgPT4gYWRiISk7XHJcbnRlc3RGaWxlc3lzdGVtKCgpID0+IGFkYiEsIHJlc29sdmVEYXRhLCBkYXRhVVJMLCBkdWNrZGIuRHVja0RCRGF0YVByb3RvY29sLkhUVFApO1xyXG50ZXN0QXJyb3dJbnNlcnQoKCkgPT4gZGIhKTtcclxudGVzdEFycm93SW5zZXJ0QXN5bmMoKCkgPT4gYWRiISk7XHJcbnRlc3RKU09OSW5zZXJ0KCgpID0+IGRiISk7XHJcbnRlc3RKU09OSW5zZXJ0QXN5bmMoKCkgPT4gYWRiISk7XHJcbnRlc3RDU1ZJbnNlcnQoKCkgPT4gZGIhKTtcclxudGVzdENTVkluc2VydEFzeW5jKCgpID0+IGFkYiEpO1xyXG50ZXN0VG9rZW5pemF0aW9uKCgpID0+IGRiISk7XHJcbnRlc3RUb2tlbml6YXRpb25Bc3luYygoKSA9PiBhZGIhKTtcclxuLy90ZXN0RVhDRUwoKCkgPT4gZGIhKTtcclxuLy90ZXN0SlNPTigoKSA9PiBkYiEpO1xyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQVNBLE9BQUMsV0FBWTtBQUNYO0FBRUEsWUFBSSxRQUFRO0FBQ1osWUFBSSxTQUFTLE9BQU8sV0FBVztBQUMvQixZQUFJLE9BQU8sU0FBUyxTQUFTLENBQUM7QUFDOUIsWUFBSSxLQUFLLHFCQUFxQjtBQUM1QixtQkFBUztBQUFBLFFBQ1g7QUFDQSxZQUFJLGFBQWEsQ0FBQyxVQUFVLE9BQU8sU0FBUztBQUM1QyxZQUFJLFVBQVUsQ0FBQyxLQUFLLHdCQUF3QixPQUFPLFlBQVksWUFBWSxRQUFRLFlBQVksUUFBUSxTQUFTO0FBQ2hILFlBQUksU0FBUztBQUNYLGlCQUFP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QUFPLE1BQU0sSUFBTSxLQUFLLE9BQVMsTUFBTSxLQUFPLEtBQUssT0FBUyxNQUFNLEtBQU8sS0FBSztBQUM5RSxpQkFBSyxJQUFJO0FBQ1Qsa0JBQU0sS0FBTSxJQUFJLElBQUs7QUFDckIsaUJBQU0sSUFBSSxJQUFNLENBQUMsSUFBSTtBQUNyQixpQkFBSyxJQUFJLEtBQUssS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJQSxRQUFPLElBQUksQ0FBQztBQUMxQyxpQkFBSyxLQUFLO0FBQ1YsZ0JBQUksSUFBSSxNQUFNO0FBQ2QsZ0JBQUksS0FBSyxNQUFNO0FBQ2Ysa0JBQU8sTUFBTSxJQUFNLEtBQUssT0FBUyxNQUFNLEtBQU8sS0FBSyxPQUFTLE1BQU0sS0FBTyxLQUFLO0FBQzlFLGtCQUFPLE1BQU0sSUFBTSxLQUFLLE9BQVMsTUFBTSxLQUFPLEtBQUssT0FBUyxNQUFNLEtBQU8sS0FBSztBQUM5RSxpQkFBSyxJQUFJO0FBQ1Qsa0JBQU0sS0FBTSxJQUFJLElBQUs7QUFDckIsaUJBQU0sSUFBSSxJQUFNLENBQUMsSUFBSTtBQUNyQixpQkFBSyxJQUFJLEtBQUssS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJQSxRQUFPLElBQUksQ0FBQztBQUMxQyxpQkFBSyxLQUFLO0FBQ1YsZ0JBQUksSUFBSSxNQUFNO0FBQ2QsZ0JBQUksS0FBSyxNQUFNO0FBQ2Ysa0JBQU8sTUFBTSxJQUFNLEtBQUssT0FBUyxNQUFNLEtBQU8sS0FBSyxPQUFTLE1BQU0sS0FBTyxLQUFLO0FBQzlFLGtCQUFPLE1BQU0sSUFBTSxLQUFLLE9BQVMsTUFBTSxLQUFPLEtBQUssT0FBUyxNQUFNLEtBQU8sS0FBSztBQUM5RSxpQkFBSyxJQUFJO0FBQ1Qsa0JBQU0sS0FBTSxJQUFJLElBQUs7QUFDckIsaUJBQU0sSUFBSSxJQUFNLENBQUMsSUFBSTtBQUNyQixpQkFBSyxJQUFJLEtBQUssS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJQSxRQUFPLElBQUksQ0FBQztBQUMxQyxpQkFBSyxLQUFLO0FBQ1YsZ0JBQUksSUFBSSxNQUFNO0FBQ2QsZ0JBQUksS0FBSyxNQUFNO0FBQUEsVUFDakI7QUFFQSxlQUFLLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDekIsZUFBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBQ3pCLGVBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUN6QixlQUFLLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDekIsZUFBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBQ3pCLGVBQUssS0FBSyxLQUFLLEtBQUssS0FBSztBQUN6QixlQUFLLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDekIsZUFBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBQUEsUUFDM0I7QUFFQSxlQUFPLFVBQVUsTUFBTSxXQUFZO0FBQ2pDLGVBQUssU0FBUztBQUVkLGNBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxLQUFLLElBQ2xGLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSztBQUUxQixjQUFJLE1BQU0sVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDbEUsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDMUQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDekQsVUFBVyxNQUFNLElBQUssRUFBSSxJQUFJLFVBQVUsS0FBSyxFQUFJLElBQ2pELFVBQVcsTUFBTSxLQUFNLEVBQUksSUFBSSxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzFELFVBQVcsTUFBTSxLQUFNLEVBQUksSUFBSSxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzFELFVBQVcsTUFBTSxLQUFNLEVBQUksSUFBSSxVQUFXLE1BQU0sSUFBSyxFQUFJLElBQ3pELFVBQVcsTUFBTSxJQUFLLEVBQUksSUFBSSxVQUFVLEtBQUssRUFBSSxJQUNqRCxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQUksVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMxRCxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQUksVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMxRCxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQUksVUFBVyxNQUFNLElBQUssRUFBSSxJQUN6RCxVQUFXLE1BQU0sSUFBSyxFQUFJLElBQUksVUFBVSxLQUFLLEVBQUksSUFDakQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDMUQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDMUQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxJQUFLLEVBQUksSUFDekQsVUFBVyxNQUFNLElBQUssRUFBSSxJQUFJLFVBQVUsS0FBSyxFQUFJLElBQ2pELFVBQVcsTUFBTSxLQUFNLEVBQUksSUFBSSxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzFELFVBQVcsTUFBTSxLQUFNLEVBQUksSUFBSSxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQzFELFVBQVcsTUFBTSxLQUFNLEVBQUksSUFBSSxVQUFXLE1BQU0sSUFBSyxFQUFJLElBQ3pELFVBQVcsTUFBTSxJQUFLLEVBQUksSUFBSSxVQUFVLEtBQUssRUFBSSxJQUNqRCxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQUksVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMxRCxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQUksVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUMxRCxVQUFXLE1BQU0sS0FBTSxFQUFJLElBQUksVUFBVyxNQUFNLElBQUssRUFBSSxJQUN6RCxVQUFXLE1BQU0sSUFBSyxFQUFJLElBQUksVUFBVSxLQUFLLEVBQUksSUFDakQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDMUQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxLQUFNLEVBQUksSUFDMUQsVUFBVyxNQUFNLEtBQU0sRUFBSSxJQUFJLFVBQVcsTUFBTSxJ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QUUscUJBQVEsSUFBRSxHQUFFLElBQUUsR0FBRSxLQUFJO0FBQUMsa0JBQUlDLE9BQUksT0FBTyxFQUFFLENBQUMsQ0FBQztBQUFFLGtCQUFHLE1BQU1BLElBQUc7QUFBRSx1QkFBTztBQUFLLGdCQUFFLENBQUMsSUFBRUE7QUFBQSxZQUFHO0FBQUMsb0JBQU8sRUFBRSxDQUFDLElBQUUsRUFBRSxDQUFDLEtBQUcsSUFBRSxFQUFFLENBQUMsS0FBRyxLQUFHLEVBQUUsQ0FBQyxLQUFHLFFBQU07QUFBQSxVQUFDO0FBQUMsbUJBQVMsUUFBUSxLQUFJO0FBQUMsbUJBQU8sU0FBUyxHQUFHO0FBQUEsVUFBQztBQUFDLG1CQUFTLFVBQVUsS0FBSTtBQUFDLGdCQUFJO0FBQU0sZ0JBQUksR0FBRSxRQUFPO0FBQUUsZ0JBQUksYUFBVztBQUFxSyxnQkFBSSxRQUFNLENBQUM7QUFBRSxnQkFBRyxDQUFDLFdBQVcsS0FBSyxHQUFHLEdBQUU7QUFBQyxxQkFBTztBQUFBLFlBQUk7QUFBQyxnQkFBRyxRQUFNLE1BQUs7QUFBQyxxQkFBTSxDQUFDLEdBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLFlBQUM7QUFBQyxnQkFBRyxJQUFJLFdBQVcsSUFBSSxHQUFFO0FBQUMsb0JBQUksSUFBSSxRQUFRLE1BQUssSUFBSTtBQUFBLFlBQUMsT0FBSztBQUFDLG9CQUFJLElBQUksUUFBUSxNQUFLLEtBQUs7QUFBQSxZQUFDO0FBQUMsZ0JBQUcsSUFBSSxRQUFRLEdBQUcsSUFBRSxHQUFFO0FBQUMsb0JBQUksSUFBSSxRQUFRLElBQUksT0FBTyxPQUFNLEdBQUcsR0FBRSxHQUFHO0FBQUUsc0JBQU0sSUFBSSxNQUFNLEdBQUc7QUFBRSxvQkFBTSxNQUFNLFNBQU8sQ0FBQyxJQUFFLFFBQVEsTUFBTSxNQUFNLFNBQU8sQ0FBQyxDQUFDLElBQUUsUUFBUSxNQUFNLE1BQU0sU0FBTyxDQUFDLENBQUMsSUFBRTtBQUFJLG9CQUFNLE1BQU0sU0FBTyxDQUFDLElBQUUsUUFBUSxNQUFNLE1BQU0sU0FB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TUFBRyxPQUFLLENBQUMsSUFBRTtBQUFBLGNBQUUsT0FBSztBQUFDLHVCQUFPQSxNQUFHLE9BQUssQ0FBQyxJQUFFO0FBQUEsY0FBRTtBQUFDLHFCQUFPQSxNQUFHLE9BQUssQ0FBQyxJQUFFO0FBQUUscUJBQU9BO0FBQUEsWUFBRTtBQUFDLGdCQUFHLE1BQUs7QUFBQyxzQkFBTSxPQUFPLFNBQU8sQ0FBQztBQUFFLHVCQUFPLE9BQU8sT0FBSyxNQUFJLENBQUM7QUFBRSxxQkFBSyxPQUFPLE9BQUssTUFBSSxDQUFDO0FBQUUsc0JBQU0sT0FBTyxPQUFLLE9BQUssQ0FBQztBQUFBLFlBQUM7QUFBQyxnQkFBRyxRQUFNLENBQUMsT0FBTTtBQUFDLHNCQUFNLFNBQU8sSUFBRSxLQUFHO0FBQUEsWUFBQztBQUFDLGdCQUFHLENBQUMsUUFBTSxPQUFNO0FBQUMscUJBQUssVUFBUSxLQUFHLElBQUU7QUFBQSxZQUFDO0FBQUMsZ0JBQUcsVUFBUSxHQUFFO0FBQUMsc0JBQU07QUFBQSxZQUFDO0FBQUMsZ0JBQUcsU0FBTyxHQUFFO0FBQUMscUJBQUs7QUFBQSxZQUFDO0FBQUMsZ0JBQUcsQ0FBQyxRQUFNLENBQUMsU0FBUTtBQUFDLHFCQUFNO0FBQUEsWUFBRTtBQUFDLGdCQUFHLFFBQU0sRUFBRSxJQUFFLElBQUUsSUFBRSxPQUFLLElBQUUsS0FBRyxLQUFJO0FBQUMscUJBQU07QUFBQSxZQUFFO0FBQUMsZ0JBQUcsU0FBTyxLQUFHLE9BQU8sU0FBTyxDQUFDLElBQUUsS0FBRyxDQUFDLE1BQUs7QUFBQyxxQkFBTTtBQUFBLFlBQUU7QUFBQyxnQkFBRyxRQUFNLElBQUc7QUFBQyxxQkFBTTtBQUFBLFlBQUU7QUFBQyxnQkFBRyxTQUFPLEtBQUcsU0FBTyxLQUFHLFNBQU8sR0FBRTtBQUFDLHFCQUFNO0FBQUEsWUFBRTtBQUFDLGdCQUFHLFdBQVMsS0FBRyxXQUFTLEtBQUcsV0FBUyxJQUFHO0FBQUMscUJBQU07QUFBQSxZQUFFO0FBQUMsZ0JBQUcsU0FBUTtBQUFDLHdCQUFRLGFBQWEsT0FBTztBQUFFLHFCQUFLLFNBQVMsU0FBUSxFQUFFO0FBQUUsa0JBQUcsTUFBTSxJQUFJLEdBQUU7QUFBQyxvQkFBRyxRQUFNLE1BQUs7QUFBQyx5QkFBTTtBQUFBLGdCQUFFO0FBQUMsdUJBQU07QUFBQSxjQUFFO0FBQUEsWUFBQztBQUFDLGdCQUFHLENBQUMsTUFBSztBQUFDLGtCQUFHLFdBQVMsR0FBRTtBQUFDLHlCQUFPO0FBQUEsY0FBQztBQUFDLG1CQUFJLFFBQU0sT0FBSyxHQUFFO0FBQUMsb0JBQUcsV0FBUyxHQUFFO0FBQUMseUJBQUssT0FBTyxVQUFVO0FBQUEsZ0JBQUMsT0FBSztBQUFDLHlCQUFLLENBQUMsR0FBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLGdCQUFDO0FBQUEsY0FBQztBQUFDLG1CQUFHLGNBQWMsUUFBTyxNQUFLLE9BQU0sTUFBSyxNQUFLLElBQUk7QUFBRSxzQkFBUU4sU0FBTSxDQUFDLElBQUU7QUFBRyxxQkFBTztBQUFBLFlBQUM7QUFBQyxtQkFBSyxhQUFhLElBQUk7QUFBRSxtQkFBSyxVQUFVLElBQUk7QUFBRSxnQkFBRyxTQUFPLE1BQUs7QUFBQyxrQkFBRyxXQUFTLEtBQUcsV0FBUyxHQUFFO0FBQUMseUJBQU87QUFBQSxjQUFDLFdBQVMsV0FBUyxNQUFJLFFBQU0sR0FBRTtBQUFDLHVCQUFLLENBQUMsR0FBRSxHQUFFLE9BQU8sS0FBSyxHQUFFLElBQUk7QUFBRSx5QkFBTztBQUFBLGNBQUUsT0FBSztBQUFDLHVCQUFNO0FBQUEsY0FBRTtBQUFBLFlBQUMsT0FBSztBQUFDLHFCQUFLLFVBQVUsSUFBSTtBQUFFLGtCQUFHLFNBQU8sTUFBSztBQUFDLG9CQUFHLFdBQVMsS0FBRyxXQUFTLElBQUc7QUFBQywyQkFBTztBQUFBLGdCQUFFLE9BQUs7QUFBQyx5QkFBTTtBQUFBLGdCQUFFO0FBQUEsY0FBQztBQUFBLFlBQUM7QUFBQyxnQkFBRyxRQUFNLE1BQUs7QUFBQyxtQkFBRyxjQUFjLFFBQU8sTUFBSyxPQUFNLE1BQUssTUFBSyxJQUFJO0FBQUUsc0JBQVFBLFNBQU0sQ0FBQyxJQUFFO0FBQUcscUJBQU87QUFBQSxZQUFDO0FBQUMsZ0JBQUcsUUFBTSxHQUFFO0FBQUMscUJBQU07QUFBQSxZQUFFO0FBQUMsbUJBQUssSUFBSSxZQUFZLElBQUk7QUFBRSxtQkFBSyxVQUFVLElBQUk7QUFBRSxnQkFBRyxXQUFTLEdBQUU7QUFBQyx1QkFBTztBQUFBLFlBQUMsV0FBUyxXQUFTLElBQUc7QUFBQyxxQkFBSyxDQUFDLEdBQUUsR0FBRSxPQUFPLEtBQUssR0FBRSxJQUFJO0FBQUEsWUFBQztBQUFDLGlCQUFHLGNBQWMsUUFBTyxNQUFLLE9BQU0sTUFBSyxNQUFLLElBQUk7QUFBRSxvQkFBUUEsU0FBTSxDQUFDLElBQUU7QUFBRyxtQkFBTztBQUFBLFVBQUM7QUFBQyxtQkFBUyxpQkFBZ0I7QUFBQyxnQkFBRyxPQUFPLFVBQVEsWUFBVSxPQUFPLE9BQU8saUJBQWlCLEtBQUcsWUFBVztBQUFDLHFCQUFPLFVBQU0sT0FBTyxnQkFBZ0IsSUFBSTtBQUFBLFlBQUMsV0FBUyxxQkFBb0I7QUFBQyxrQkFBRztBQUFDLG9CQUFJLGdCQUFjLFVBQVEsUUFBUTtBQUFFLG9CQUFJLGlCQUFlLGNBQWMsZ0JBQWdCO0FBQUUsb0JBQUcsZ0JBQWU7QUFBQyx5QkFBTyxVQUFNLGNBQWMsZ0JBQWdCLEVBQUUsSUFBSTtBQUFBLGdCQUFDO0FBQUMsb0JBQUksY0FBWSxjQUFjLGFBQWE7QUFBRSx1QkFBTyxXQUFPLEtBQUssSUFBSSxZQUFZLEtBQUssVUFBVSxDQUFDLEdBQUU7QUFBQSxjQUFLLFNBQU8sR0FBRTtBQUFBLGNBQUM7QUFBQSxZQUFDO0FBQUMsa0JBQU0sa0JBQWtCO0FBQUEsVUFBQztBQUFDLG1CQUFTLFdBQVcsTUFBSztBQUFDLG9CQUFPLGFBQVcsZUFBZSxHQUFHLElBQUk7QUFBQSxVQUFDO0FBQUMsbUJBQVMsWUFBWSxRQUFPLE1BQUs7QUFBQyx1QkFBVyxPQUFPLFNBQVMsV0FBUyxHQUFFLFNBQU8sU0FBTyxDQUFDLENBQUM7QUFBRSxtQkFBTztBQUFBLFVBQUM7QUFBQyxtQkFBUyxhQUFhLElBQUcsT0FBTSxNQUFLLFNBQVEsTUFBSyxTQUFRLE9BQU07QUFBQyxnQkFBSSxPQUFLLGFBQWEsSUFBRyxLQUFLO0FBQUUsZ0JBQUcsS0FBSyxPQUFNO0FBQUMscUJBQU07QUFBQSxZQUFFO0FBQUMsZ0JBQUksT0FBSyxLQUFLO0FBQUssZ0JBQUksT0FBSyxLQUFLO0FBQUssZ0JBQUksYUFBVztBQUFNLGdCQUFHLFFBQU0sU0FBUTtBQUFDLGtCQUFJO0FBQU8sa0JBQUcsUUFBTSxLQUFHLEVBQUUsU0FBTyxJQUFJLFlBQVksSUFBSSxJQUFHO0FBQUMsb0JBQUcsUUFBTSxHQUFFO0FBQUMseUJBQU07QUFBQSxnQkFBRTtBQUFBLGNBQUMsT0FBSztBQUFDLHVCQUFLO0FBQUEsY0FBTTtBQUFDLGtCQUFJLDBCQUF3QixhQUFhLE1BQUssTUFBSyxPQUFPO0FBQUUsa0JBQUcsMEJBQXdCLEtBQUcsU0FBUTtBQUFDLDZCQUFXO0FBQUEsY0FBSTtBQUFBLFlBQUM7QUFBQyxnQkFBRyxRQUFNLFNBQVE7QUFBQyxxQkFBSyxLQUFHO0FBQUssa0JBQUksMEJBQXdCLGFBQWEsTUFBSyxNQUFLLE9BQU87QUFBRSxrQkFBRywwQkFBd0IsS0FBRyxTQUFRO0FBQUMsNkJBQVc7QUFBQSxjQUFJO0FBQUEsWUFBQztBQUFDLGdCQUFHLFlBQVc7QUFBQyxxQkFBTTtBQUFBLFlBQUc7QUFBQyxtQkFBTztBQUFBLFVBQUM7QUFBQyxtQkFBUyxTQUFTLE9BQU0sT0FBTTtBQUFDLGdCQUFJTyxPQUFJO0FBQUUscUJBQVEsSUFBRSxHQUFFLEtBQUcsT0FBTUEsUUFBSyxNQUFNLEdBQUcsR0FBRTtBQUFBLFlBQUM7QUFBQyxtQkFBT0E7QUFBQSxVQUFHO0FBQUMsY0FBSSxrQkFBZ0IsQ0FBQyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsRUFBRTtBQUFFLGNBQUkscUJBQW1CLENBQUMsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLElBQUcsSUFBRyxJQUFHLEVBQUU7QUFBRSxtQkFBUyxRQUFRLE1BQUssTUFBSztBQUFDLGdCQUFJLFVBQVEsSUFBSSxLQUFLLEtBQUssUUFBUSxDQUFDO0FBQUUsbUJBQU0sT0FBSyxHQUFFO0FBQUMsa0JBQUksT0FBSyxXQUFXLFFBQVEsWUFBWSxDQUFDO0FBQUUsa0JBQUksZUFBYSxRQUFRLFNBQVM7QUFBRSxrQkFBSSxzQkFBb0IsT0FBSyxrQkFBZ0Isb0JBQW9CLFlBQVk7QUFBRSxrQkFBRyxPQUFLLHFCQUFtQixRQUFRLFFBQVEsR0FBRTtBQUFDLHdCQUFNLHFCQUFtQixRQUFRLFFBQVEsSUFBRTtBQUFFLHdCQUFRLFFBQVEsQ0FBQztBQUFFLG9CQUFHLGVBQWEsSUFBRztBQUFDLDBCQUFRLFNBQVMsZUFBYSxDQUFDO0FBQUEsZ0JBQUMsT0FBSztBQUFDLDBCQUFRLFNBQVMsQ0FBQztBQUFFLDBCQUFRLFlBQVksUUFBUSxZQUFZLElBQUUsQ0FBQztBQUFBLGdCQUFDO0FBQUEsY0FBQyxPQUFLO0FBQUMsd0JBQVEsUUFBUSxRQUFRLFFBQVEsSUFBRSxJQUFJO0FBQUUsdUJBQU87QUFBQSxjQUFPO0FBQUEsWUFBQztBQUFDLG1CQUFPO0FBQUEsVUFBTztBQUFDLG1CQUFTLG1CQUFtQixTQUFRLGFBQVksUUFBTztBQUFDLGdCQUFJLE1BQUksU0FBTyxJQUFFLFNBQU8sZ0JBQWdCLE9BQU8sSUFBRTtBQUFFLGdCQUFJLFVBQVEsSUFBSSxNQUFNLEdBQUc7QUFBRSxnQkFBSSxrQkFBZ0Isa0JBQWtCLFNBQVEsU0FBUSxHQUFFLFFBQVEsTUFBTTtBQUFFLGdCQUFHO0FBQVksc0JBQVEsU0FBTztBQUFnQixtQkFBTztBQUFBLFVBQU87QUFBQyxtQkFBUyxtQkFBbUIsT0FBTSxRQUFPO0FBQUMsa0JBQU0sSUFBSSxPQUFNLFdBQVMsQ0FBQztBQUFBLFVBQUM7QUFBQyxtQkFBUyxVQUFVLEdBQUUsU0FBUSxRQUFPLElBQUc7QUFBQyxnQkFBSSxVQUFRLE9BQU8sS0FBRyxPQUFLLENBQUM7QUFBRSxnQkFBSSxPQUFLLEVBQUMsUUFBTyxPQUFPLE9BQUssQ0FBQyxHQUFFLFFBQU8sT0FBTyxLQUFHLE1BQUksQ0FBQyxHQUFFLFNBQVEsT0FBTyxLQUFHLE1BQUksQ0FBQyxHQUFFLFNBQVEsT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFFBQU8sT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFNBQVEsT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFNBQVEsT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFNBQVEsT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFVBQVMsT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFdBQVUsT0FBTyxLQUFHLE9BQUssQ0FBQyxHQUFFLFNBQVEsVUFBUSxhQUFhLE9BQU8sSUFBRSxHQUFFO0FBQUUsZ0JBQUksVUFBUSxhQUFhLE1BQU07QUFBRSxnQkFBSSxvQkFBa0IsRUFBQyxNQUFLLHdCQUF1QixNQUFLLFlBQVcsTUFBSyxZQUFXLE1BQUssTUFBSyxNQUFLLGVBQWMsTUFBSyxTQUFRLE1BQUssWUFBVyxNQUFLLFlBQVcsTUFBSyxZQUFXLE9BQU0sTUFBSyxPQUFNLE1BQUssT0FBTSxZQUFXLE9BQU0sWUFBVyxPQUFNLE1BQUssT0FBTSxNQUFLLE9BQU0sTUFBSyxPQUFNLE1BQUssT0FBTSxNQUFLLE9BQU0sTUFBSyxPQUFNLE1BQUssT0FBTSxNQUFLLE9BQU0sTUFBSyxPQUFNLE1BQUssT0FBTSxNQUFLLE9BQU0sTUFBSyxPQUFNLE1BQUssT0FBTSxNQUFLLE9BQU0sS0FBSTtBQUFFLHFCQUFRLFFBQVEsbUJBQWtCO0FBQUMsd0JBQVEsUUFBUSxRQUFRLElBQUksT0FBTyxNQUFLLEdBQUcsR0FBRSxrQkFBa0IsSUFBSSxDQUFDO0FBQUEsWUFBQztBQUFDLGdCQUFJLFdBQVMsQ0FBQyxVQUFTLFVBQVMsV0FBVSxhQUFZLFlBQVcsVUFBUyxVQUFVO0FBQUUsZ0JBQUksU0FBTyxDQUFDLFdBQVUsWUFBVyxTQUFRLFNBQVEsT0FBTSxRQUFPLFFBQU8sVUFBUyxhQUFZLFdBQVUsWUFBVyxVQUFVO0FBQUUscUJBQVMsaUJBQWlCLE9BQU0sUUFBTyxXQUFVO0FBQUMsa0JBQUksTUFBSSxPQUFPLFNBQU8sV0FBUyxNQUFNLFNBQVMsSUFBRSxTQUFPO0FBQUcscUJBQU0sSUFBSSxTQUFPLFFBQU87QUFBQyxzQkFBSSxVQUFVLENBQUMsSUFBRTtBQUFBLGNBQUc7QUFBQyxxQkFBTztBQUFBLFlBQUc7QUFBQyxxQkFBUyxhQUFhLE9BQU0sUUFBTztBQUFDLHFCQUFPLGlCQUFpQixPQUFNLFFBQU8sR0FBRztBQUFBLFlBQUM7QUFBQyxxQkFBUyxhQUFhLE9BQU0sT0FBTTtBQUFDLHVCQUFTLElBQUksT0FBTTtBQUFDLHVCQUFPLFFBQU0sSUFBRSxLQUFHLFFBQU0sSUFBRSxJQUFFO0FBQUEsY0FBQztBQUFDLGtCQUFJO0FBQVEsbUJBQUksVUFBUSxJQUFJLE1BQU0sWUFBWSxJQUFFLE1BQU0sWUFBWSxDQUFDLE9BQUssR0FBRTtBQUFDLHFCQUFJLFVBQVEsSUFBSSxNQUFNLFNBQVMsSUFBRSxNQUFNLFNBQVMsQ0FBQyxPQUFLLEdBQUU7QUFBQyw0QkFBUSxJQUFJLE1BQU0sUUFBUSxJQUFFLE1BQU0sUUFBUSxDQUFDO0FBQUEsZ0JBQUM7QUFBQSxjQUFDO0FBQUMscUJBQU87QUFBQSxZQUFPO0FBQUMscUJBQVMsc0JBQXNCLFdBQVU7QUFBQyxzQkFBTyxVQUFVLE9BQU8sR0FBRTtBQUFBLGdCQUFDLEtBQUs7QUFBRSx5QkFBTyxJQUFJLEtBQUssVUFBVSxZQUFZLElBQUUsR0FBRSxJQUFHLEVBQUU7QUFBQSxnQkFBRSxLQUFLO0FBQUUseUJBQU87QUFBQSxnQkFBVSxLQUFLO0FBQUUseUJBQU8sSUFBSSxLQUFLLFVBQVUsWUFBWSxHQUFFLEdBQUUsQ0FBQztBQUFBLGdCQUFFLEtBQUs7QUFBRSx5QkFBTyxJQUFJLEtBQUssVUFBVSxZQUFZLEdBQUUsR0FBRSxDQUFDO0FBQUEsZ0JBQUUsS0FBSztBQUFFLHlCQUFPLElBQUksS0FBSyxVQUFVLFlBQVksR0FBRSxHQUFFLENBQUM7QUFBQSxnQkFBRSxLQUFLO0FBQUUseUJBQU8sSUFBSSxLQUFLLFVBQVUsWUFBWSxJQUFFLEdBQUUsSUFBRyxFQUFFO0FBQUEsZ0JBQUUsS0FBSztBQUFFLHlCQUFPLElBQUksS0FBSyxVQUFVLFlBQVksSUFBRSxHQUFFLElBQUcsRUFBRTtBQUFBLGNBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsaUJBQWlCQyxPQUFLO0FBQUMsa0JBQUksV0FBUyxRQUFRLElBQUksS0FBS0EsTUFBSyxVQUFRLE1BQUssR0FBRSxDQUFDLEdBQUVBLE1BQUssT0FBTztBQUFFLGtCQUFJLG9CQUFrQixJQUFJLEtBQUssU0FBUyxZQUFZLEdBQUUsR0FBRSxDQUFDO0FBQUUsa0JBQUksb0JBQWtCLElBQUksS0FBSyxTQUFTLFlBQVksSUFBRSxHQUFFLEdBQUUsQ0FBQztBQUFFLGtCQUFJLHlCQUF1QixzQkFBc0IsaUJBQWlCO0FBQUUsa0JBQUkseUJBQXVCLHNCQUFzQixpQkFBaUI7QUFBRSxrQkFBRyxhQUFhLHdCQUF1QixRQUFRLEtBQUcsR0FBRTtBQUFDLG9CQUFHLGFBQWEsd0JBQXVCLFFBQVEsS0FBRyxHQUFFO0FBQUMseUJBQU8sU0FBUyxZQUFZLElBQUU7QUFBQSxnQkFBQztBQUFDLHVCQUFPLFNBQVMsWUFBWTtBQUFBLGNBQUM7QUFBQyxxQkFBTyxTQUFTLFlBQVksSUFBRTtBQUFBLFlBQUM7QUFBQyxnQkFBSSxvQkFBa0IsRUFBQyxNQUFLLFNBQVNBLE9BQUs7QUFBQyxxQkFBTyxTQUFTQSxNQUFLLE9BQU8sRUFBRSxVQUFVLEdBQUUsQ0FBQztBQUFBLFlBQUMsR0FBRSxNQUFLLFNBQVNBLE9BQUs7QUFBQyxxQkFBTyxTQUFTQSxNQUFLLE9BQU87QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMscUJBQU8sT0FBT0EsTUFBSyxNQUFNLEVBQUUsVUFBVSxHQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMscUJBQU8sT0FBT0EsTUFBSyxNQUFNO0FBQUEsWUFBQyxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLGtCQUFJLE9BQUtBLE1BQUssVUFBUTtBQUFLLHFCQUFPLGFBQWEsT0FBSyxNQUFJLEdBQUUsQ0FBQztBQUFBLFlBQUMsR0FBRSxNQUFLLFNBQVNBLE9BQUs7QUFBQyxxQkFBTyxhQUFhQSxNQUFLLFNBQVEsQ0FBQztBQUFBLFlBQUMsR0FBRSxNQUFLLFNBQVNBLE9BQUs7QUFBQyxxQkFBTyxpQkFBaUJBLE1BQUssU0FBUSxHQUFFLEdBQUc7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMscUJBQU8saUJBQWlCQSxLQUFJLEVBQUUsU0FBUyxFQUFFLFVBQVUsQ0FBQztBQUFBLFlBQUMsR0FBRSxNQUFLLFNBQVNBLE9BQUs7QUFBQyxxQkFBTyxpQkFBaUJBLEtBQUk7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMscUJBQU8sYUFBYUEsTUFBSyxTQUFRLENBQUM7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMsa0JBQUksYUFBV0EsTUFBSztBQUFRLGtCQUFHLGNBQVk7QUFBRSw2QkFBVztBQUFBLHVCQUFXLGFBQVc7QUFBRyw4QkFBWTtBQUFHLHFCQUFPLGFBQWEsWUFBVyxDQUFDO0FBQUEsWUFBQyxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLHFCQUFPLGFBQWFBLE1BQUssVUFBUSxTQUFTLFdBQVdBLE1BQUssVUFBUSxJQUFJLElBQUUsa0JBQWdCLG9CQUFtQkEsTUFBSyxTQUFPLENBQUMsR0FBRSxDQUFDO0FBQUEsWUFBQyxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLHFCQUFPLGFBQWFBLE1BQUssU0FBTyxHQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMscUJBQU8sYUFBYUEsTUFBSyxRQUFPLENBQUM7QUFBQSxZQUFDLEdBQUUsTUFBSyxXQUFVO0FBQUMscUJBQU07QUFBQSxZQUFJLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMsa0JBQUdBLE1BQUssV0FBUyxLQUFHQSxNQUFLLFVBQVEsSUFBRztBQUFDLHVCQUFNO0FBQUEsY0FBSTtBQUFDLHFCQUFNO0FBQUEsWUFBSSxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLHFCQUFPLGFBQWFBLE1BQUssUUFBTyxDQUFDO0FBQUEsWUFBQyxHQUFFLE1BQUssV0FBVTtBQUFDLHFCQUFNO0FBQUEsWUFBSSxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLHFCQUFPQSxNQUFLLFdBQVM7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMsa0JBQUksT0FBS0EsTUFBSyxVQUFRLElBQUVBLE1BQUs7QUFBUSxxQkFBTyxhQUFhLEtBQUssTUFBTSxPQUFLLENBQUMsR0FBRSxDQUFDO0FBQUEsWUFBQyxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLGtCQUFJLE1BQUksS0FBSyxPQUFPQSxNQUFLLFVBQVEsS0FBR0EsTUFBSyxVQUFRLEtBQUcsS0FBRyxDQUFDO0FBQUUsbUJBQUlBLE1BQUssVUFBUSxNQUFJQSxNQUFLLFVBQVEsS0FBRyxLQUFHLEdBQUU7QUFBQztBQUFBLGNBQUs7QUFBQyxrQkFBRyxDQUFDLEtBQUk7QUFBQyxzQkFBSTtBQUFHLG9CQUFJLFNBQU9BLE1BQUssVUFBUSxJQUFFQSxNQUFLLFVBQVEsS0FBRztBQUFFLG9CQUFHLFNBQU8sS0FBRyxTQUFPLEtBQUcsV0FBV0EsTUFBSyxVQUFRLE1BQUksQ0FBQyxHQUFFO0FBQUM7QUFBQSxnQkFBSztBQUFBLGNBQUMsV0FBUyxPQUFLLElBQUc7QUFBQyxvQkFBSSxRQUFNQSxNQUFLLFVBQVEsTUFBSUEsTUFBSyxXQUFTO0FBQUUsb0JBQUcsUUFBTSxNQUFJLFFBQU0sS0FBRyxDQUFDLFdBQVdBLE1BQUssT0FBTztBQUFHLHdCQUFJO0FBQUEsY0FBQztBQUFDLHFCQUFPLGFBQWEsS0FBSSxDQUFDO0FBQUEsWUFBQyxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLHFCQUFPQSxNQUFLO0FBQUEsWUFBTyxHQUFFLE1BQUssU0FBU0EsT0FBSztBQUFDLGtCQUFJLE9BQUtBLE1BQUssVUFBUSxLQUFHQSxNQUFLLFVBQVEsS0FBRztBQUFFLHFCQUFPLGFBQWEsS0FBSyxNQUFNLE9BQUssQ0FBQyxHQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMsc0JBQU9BLE1BQUssVUFBUSxNQUFNLFNBQVMsRUFBRSxVQUFVLENBQUM7QUFBQSxZQUFDLEdBQUUsTUFBSyxTQUFTQSxPQUFLO0FBQUMscUJBQU9BLE1BQUssVUFBUTtBQUFBLFlBQUksR0FBRSxNQUFLLFNBQVNBLE9BQUs7QUFBQyxrQkFBSSxNQUFJQSxNQUFLO0FBQVUsa0JBQUksUUFBTSxPQUFLO0FBQUUsb0JBQUksS0FBSyxJQUFJLEdBQUcsSUFBRTtBQUFHLG9CQUFJLE1BQUksS0FBRyxNQUFJLE1BQUk7QUFBRyxzQkFBTyxRQUFNLE1BQUksT0FBSyxPQUFPLFNBQU8sR0FBRyxFQUFFLE1BQU0sRUFBRTtBQUFBLFlBQUMsR0FBRSxNQUFLLFNBQVNBLE9BQUs7QUFBQyxxQkFBT0EsTUFBSztBQUFBLFlBQU8sR0FBRSxNQUFLLFdBQVU7QUFBQyxxQkFBTTtBQUFBLFlBQUcsRUFBQztBQUFFLHNCQUFRLFFBQVEsUUFBUSxPQUFNLE1BQU07QUFBRSxxQkFBUSxRQUFRLG1CQUFrQjtBQUFDLGtCQUFHLFFBQVEsU0FBUyxJQUFJLEdBQUU7QUFBQywwQkFBUSxRQUFRLFFBQVEsSUFBSSxPQUFPLE1BQUssR0FBRyxHQUFFLGtCQUFrQixJQUFJLEVBQUUsSUFBSSxDQUFDO0FBQUEsY0FBQztBQUFBLFlBQUM7QUFBQyxzQkFBUSxRQUFRLFFBQVEsU0FBUSxHQUFHO0FBQUUsZ0JBQUksUUFBTSxtQkFBbUIsU0FBUSxLQUFLO0FBQUUsZ0JBQUcsTUFBTSxTQUFPLFNBQVE7QUFBQyxxQkFBTztBQUFBLFlBQUM7QUFBQywrQkFBbUIsT0FBTSxDQUFDO0FBQUUsbUJBQU8sTUFBTSxTQUFPO0FBQUEsVUFBQztBQUFDLG1CQUFTLFlBQVksR0FBRSxTQUFRLFFBQU8sSUFBRyxLQUFJO0FBQUMsbUJBQU8sVUFBVSxHQUFFLFNBQVEsUUFBTyxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLGlCQUFnQjtBQUFDLGdCQUFJLGlDQUFpQztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMscUJBQW9CO0FBQUMsZ0JBQUkscUNBQXFDO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxnQkFBZTtBQUFDLGdCQUFJLGdDQUFnQztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMseUJBQXdCO0FBQUMsZ0JBQUkseUNBQXlDO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxtQkFBa0I7QUFBQyxnQkFBSSxtQ0FBbUM7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLG9CQUFtQjtBQUFDLGdCQUFJLG9DQUFvQztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMsMkJBQTBCO0FBQUMsZ0JBQUksMkNBQTJDO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxxQkFBb0I7QUFBQyxnQkFBSSxxQ0FBcUM7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLGtCQUFpQjtBQUFDLGdCQUFJLGtDQUFrQztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMscUJBQW9CO0FBQUMsZ0JBQUkscUNBQXFDO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxZQUFXO0FBQUMsZ0JBQUksNEJBQTRCO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyx1QkFBc0I7QUFBQyxnQkFBSSx1Q0FBdUM7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLHlCQUF3QjtBQUFDLGdCQUFJLHlDQUF5QztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMsMkJBQTBCO0FBQUMsZ0JBQUksMkNBQTJDO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxvQkFBbUI7QUFBQyxnQkFBSSxvQ0FBb0M7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLG9CQUFtQjtBQUFDLGdCQUFJLG9DQUFvQztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMsbUJBQWtCO0FBQUMsZ0JBQUksbUNBQW1DO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxpQkFBZ0I7QUFBQyxnQkFBSSxpQ0FBaUM7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLFdBQVU7QUFBQyxnQkFBSSwyQkFBMkI7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLFlBQVc7QUFBQyxnQkFBSSw0QkFBNEI7QUFBRSxrQkFBTSxFQUFFO0FBQUEsVUFBQztBQUFDLG1CQUFTLHNCQUFxQjtBQUFDLGdCQUFJLHNDQUFzQztBQUFFLGtCQUFNLEVBQUU7QUFBQSxVQUFDO0FBQUMsbUJBQVMsc0JBQXFCO0FBQUMsZ0JBQUksc0NBQXNDO0FBQUUsa0JBQU0sRUFBRTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxXQUFXLE1BQUs7QUFBQyx5QkFBVztBQUFLLGdCQUFHLENBQUMsaUJBQWlCLEdBQUU7QUFBQyxrQkFBRyxPQUFPLFFBQVE7QUFBRSx1QkFBTyxRQUFRLEVBQUUsSUFBSTtBQUFFLHNCQUFNO0FBQUEsWUFBSTtBQUFDLGtCQUFNLE1BQUssSUFBSSxXQUFXLElBQUksQ0FBQztBQUFBLFVBQUM7QUFBQyxtQkFBUyxPQUFPLFFBQU8sVUFBUztBQUFDLHlCQUFXO0FBQU8sdUJBQVcsTUFBTTtBQUFBLFVBQUM7QUFBQyxtQkFBUyxnQkFBZ0IsR0FBRTtBQUFDLGdCQUFHLGFBQWEsY0FBWSxLQUFHLFVBQVM7QUFBQyxxQkFBTztBQUFBLFlBQVU7QUFBQyxrQkFBTSxHQUFFLENBQUM7QUFBQSxVQUFDO0FBQUMsbUJBQVMsU0FBUyxPQUFNO0FBQUMsZ0JBQUksT0FBSyxPQUFPLE1BQUksS0FBSztBQUFFLG1CQUFPO0FBQUEsVUFBSTtBQUFDLG1CQUFTLG9CQUFvQixLQUFJO0FBQUMsZ0JBQUksT0FBSyxnQkFBZ0IsR0FBRyxJQUFFO0FBQUUsZ0JBQUksTUFBSSxXQUFXLElBQUk7QUFBRSx5QkFBYSxLQUFJLEtBQUksSUFBSTtBQUFFLG1CQUFPO0FBQUEsVUFBRztBQUFDLG1CQUFTLE1BQU0sT0FBTSxZQUFXLFVBQVMsTUFBSyxNQUFLO0FBQUMsZ0JBQUksTUFBSSxFQUFDLFVBQVMsU0FBSztBQUFDLGtCQUFJQyxPQUFJO0FBQUUsa0JBQUcsUUFBTSxRQUFNLFFBQU0sVUFBVyxRQUFNLEdBQUU7QUFBQyxnQkFBQUEsT0FBSSxvQkFBb0IsR0FBRztBQUFBLGNBQUM7QUFBQyxxQkFBT0E7QUFBQSxZQUFHLEdBQUUsU0FBUSxTQUFLO0FBQUMsa0JBQUlBLE9BQUksV0FBVyxJQUFJLE1BQU07QUFBRSxpQ0FBbUIsS0FBSUEsSUFBRztBQUFFLHFCQUFPQTtBQUFBLFlBQUcsRUFBQztBQUFFLHFCQUFTLG1CQUFtQkEsTUFBSTtBQUFDLGtCQUFHLGVBQWEsVUFBUztBQUFDLHVCQUFPLGFBQWFBLElBQUc7QUFBQSxjQUFDO0FBQUMsa0JBQUcsZUFBYTtBQUFVLHVCQUFPLFFBQVFBLElBQUc7QUFBRSxxQkFBT0E7QUFBQSxZQUFHO0FBQUMsZ0JBQUksT0FBSyxTQUFTLEtBQUs7QUFBRSxnQkFBSSxRQUFNLENBQUM7QUFBRSxnQkFBSSxRQUFNO0FBQUUsZ0JBQUcsTUFBSztBQUFDLHVCQUFRLElBQUUsR0FBRSxJQUFFLEtBQUssUUFBTyxLQUFJO0FBQUMsb0JBQUksWUFBVSxJQUFJLFNBQVMsQ0FBQyxDQUFDO0FBQUUsb0JBQUcsV0FBVTtBQUFDLHNCQUFHLFVBQVE7QUFBRSw0QkFBTSxVQUFVO0FBQUUsd0JBQU0sQ0FBQyxJQUFFLFVBQVUsS0FBSyxDQUFDLENBQUM7QUFBQSxnQkFBQyxPQUFLO0FBQUMsd0JBQU0sQ0FBQyxJQUFFLEtBQUssQ0FBQztBQUFBLGdCQUFDO0FBQUEsY0FBQztBQUFBLFlBQUM7QUFBQyxnQkFBSSxNQUFJLEtBQUssTUFBTSxNQUFLLEtBQUs7QUFBRSxxQkFBUyxPQUFPQSxNQUFJO0FBQUMsa0JBQUcsVUFBUTtBQUFFLDZCQUFhLEtBQUs7QUFBRSxxQkFBTyxtQkFBbUJBLElBQUc7QUFBQSxZQUFDO0FBQUMsa0JBQUksT0FBTyxHQUFHO0FBQUUsbUJBQU87QUFBQSxVQUFHO0FBQUMsY0FBSSxjQUFZLEVBQUMsS0FBSSxnQkFBZSxLQUFJLG1CQUFrQixLQUFJLFlBQVcsS0FBSSxrQkFBaUIsS0FBSSxtQkFBa0IsS0FBSSxpQkFBZ0IsS0FBSSxtQkFBa0IsS0FBSSw4QkFBNkIsS0FBSSx3QkFBdUIsS0FBSSxrQkFBaUIsS0FBSSxpQkFBZ0IsTUFBSyxVQUFTLE1BQUssdUJBQXNCLE1BQUssaUJBQWdCLE1BQUssb0JBQW1CLE1BQUssc0JBQXFCLEtBQUksb0JBQW1CLE1BQUssb0JBQW1CLEtBQUksd0JBQXVCLE1BQUssdUJBQXNCLE1BQUssd0JBQXVCLE1BQUssdUJBQXNCLEtBQUksa0JBQWlCLE1BQUssb0JBQW1CLE1BQUssb0JBQW1CLE1BQUssdUJBQXNCLEtBQUksbUJBQWtCLE1BQUsscUJBQW9CLE1BQUsscUJBQW9CLEtBQUksa0JBQWlCLE1BQUssbUJBQWtCLEtBQUksbUJBQWtCLE1BQUssbUJBQWtCLEtBQUkscUJBQW9CLEtBQUksbUNBQWtDLE1BQUssZ0JBQWUsTUFBSyxZQUFXLEtBQUksUUFBTyxNQUFLLFNBQVEsTUFBSyxpQ0FBZ0MsTUFBSyxpQ0FBZ0MsTUFBSyxxQ0FBb0MsTUFBSyxpQ0FBZ0MsS0FBSSwyQkFBMEIsTUFBSyw0QkFBMkIsS0FBSSw0Q0FBMkMsTUFBSywwQkFBeUIsTUFBSywwQkFBeUIsS0FBSSwwQkFBeUIsTUFBSyw4QkFBNkIsS0FBSSwyQkFBMEIsTUFBSywwQ0FBeUMsTUFBSyxxQkFBb0IsS0FBSSxtQ0FBa0MsTUFBSyw2QkFBNEIsS0FBSSxzQkFBcUIsS0FBSSwwQkFBeUIsS0FBSSxxQkFBb0IsTUFBSyx3QkFBdUIsTUFBSyx5QkFBd0IsTUFBSyxjQUFhLE1BQUssb0JBQW1CLEtBQUksV0FBVSxNQUFLLGdCQUFlLEtBQUksV0FBVSxLQUFJLFlBQVcsS0FBSSxVQUFTLEtBQUksVUFBUyxNQUFLLFVBQVMsS0FBSSxXQUFVLEtBQUksY0FBYSxNQUFLLGFBQVksTUFBSyxjQUFhLE1BQUssYUFBWSxLQUFJLGdCQUFlLEtBQUksb0JBQW1CLEtBQUksZUFBYyxLQUFJLHdCQUF1QixLQUFJLGtCQUFpQixNQUFLLG1CQUFrQixLQUFJLDBCQUF5QixLQUFJLG9CQUFtQixNQUFLLGlCQUFnQixNQUFLLG9CQUFtQixLQUFJLFdBQVUsS0FBSSxzQkFBcUIsS0FBSSx3QkFBdUIsS0FBSSwwQkFBeUIsS0FBSSxtQkFBa0IsS0FBSSxtQkFBa0IsS0FBSSxrQkFBaUIsS0FBSSxnQkFBZSxLQUFJLFVBQVMsS0FBSSxXQUFVLEtBQUkscUJBQW9CLEtBQUksb0JBQW1CO0FBQUUsY0FBSSxNQUFJLFdBQVc7QUFBRSxjQUFJLHFCQUFtQixXQUFVO0FBQUMsb0JBQU8scUJBQW1CLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLFFBQU0sT0FBTyxPQUFPLElBQUUsV0FBVTtBQUFDLG9CQUFPLFFBQU0sT0FBTyxPQUFPLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksK0JBQTZCLE9BQU8sOEJBQThCLElBQUUsV0FBVTtBQUFDLG9CQUFPLCtCQUE2QixPQUFPLDhCQUE4QixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLDZCQUEyQixPQUFPLDRCQUE0QixJQUFFLFdBQVU7QUFBQyxvQkFBTyw2QkFBMkIsT0FBTyw0QkFBNEIsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSx3QkFBc0IsT0FBTyx1QkFBdUIsSUFBRSxXQUFVO0FBQUMsb0JBQU8sd0JBQXNCLE9BQU8sdUJBQXVCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksb0JBQWtCLE9BQU8sbUJBQW1CLElBQUUsV0FBVTtBQUFDLG9CQUFPLG9CQUFrQixPQUFPLG1CQUFtQixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLHNCQUFvQixPQUFPLHFCQUFxQixJQUFFLFdBQVU7QUFBQyxvQkFBTyxzQkFBb0IsT0FBTyxxQkFBcUIsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSx5QkFBdUIsT0FBTyx3QkFBd0IsSUFBRSxXQUFVO0FBQUMsb0JBQU8seUJBQXVCLE9BQU8sd0JBQXdCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksMEJBQXdCLE9BQU8seUJBQXlCLElBQUUsV0FBVTtBQUFDLG9CQUFPLDBCQUF3QixPQUFPLHlCQUF5QixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLHlCQUF1QixPQUFPLHdCQUF3QixJQUFFLFdBQVU7QUFBQyxvQkFBTyx5QkFBdUIsT0FBTyx3QkFBd0IsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxtQkFBaUIsT0FBTyxrQkFBa0IsSUFBRSxXQUFVO0FBQUMsb0JBQU8sbUJBQWlCLE9BQU8sa0JBQWtCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksbUNBQWlDLE9BQU8sa0NBQWtDLElBQUUsV0FBVTtBQUFDLG9CQUFPLG1DQUFpQyxPQUFPLGtDQUFrQyxJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLGlDQUErQixPQUFPLGdDQUFnQyxJQUFFLFdBQVU7QUFBQyxvQkFBTyxpQ0FBK0IsT0FBTyxnQ0FBZ0MsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxnQ0FBOEIsT0FBTywrQkFBK0IsSUFBRSxXQUFVO0FBQUMsb0JBQU8sZ0NBQThCLE9BQU8sK0JBQStCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksMkJBQXlCLE9BQU8sMEJBQTBCLElBQUUsV0FBVTtBQUFDLG9CQUFPLDJCQUF5QixPQUFPLDBCQUEwQixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLDRCQUEwQixPQUFPLDJCQUEyQixJQUFFLFdBQVU7QUFBQyxvQkFBTyw0QkFBMEIsT0FBTywyQkFBMkIsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxpQ0FBK0IsT0FBTyxnQ0FBZ0MsSUFBRSxXQUFVO0FBQUMsb0JBQU8saUNBQStCLE9BQU8sZ0NBQWdDLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUkscUNBQW1DLE9BQU8sb0NBQW9DLElBQUUsV0FBVTtBQUFDLG9CQUFPLHFDQUFtQyxPQUFPLG9DQUFvQyxJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLHVDQUFxQyxPQUFPLHNDQUFzQyxJQUFFLFdBQVU7QUFBQyxvQkFBTyx1Q0FBcUMsT0FBTyxzQ0FBc0MsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxtQ0FBaUMsT0FBTyxrQ0FBa0MsSUFBRSxXQUFVO0FBQUMsb0JBQU8sbUNBQWlDLE9BQU8sa0NBQWtDLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksc0NBQW9DLE9BQU8scUNBQXFDLElBQUUsV0FBVTtBQUFDLG9CQUFPLHNDQUFvQyxPQUFPLHFDQUFxQyxJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLGtDQUFnQyxPQUFPLGlDQUFpQyxJQUFFLFdBQVU7QUFBQyxvQkFBTyxrQ0FBZ0MsT0FBTyxpQ0FBaUMsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxnQ0FBOEIsT0FBTywrQkFBK0IsSUFBRSxXQUFVO0FBQUMsb0JBQU8sZ0NBQThCLE9BQU8sK0JBQStCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksMEJBQXdCLE9BQU8seUJBQXlCLElBQUUsV0FBVTtBQUFDLG9CQUFPLDBCQUF3QixPQUFPLHlCQUF5QixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLGdDQUE4QixPQUFPLCtCQUErQixJQUFFLFdBQVU7QUFBQyxvQkFBTyxnQ0FBOEIsT0FBTywrQkFBK0IsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSx1QkFBcUIsT0FBTyxzQkFBc0IsSUFBRSxXQUFVO0FBQUMsb0JBQU8sdUJBQXFCLE9BQU8sc0JBQXNCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksZ0NBQThCLE9BQU8sK0JBQStCLElBQUUsV0FBVTtBQUFDLG9CQUFPLGdDQUE4QixPQUFPLCtCQUErQixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLDhCQUE0QixPQUFPLDZCQUE2QixJQUFFLFdBQVU7QUFBQyxvQkFBTyw4QkFBNEIsT0FBTyw2QkFBNkIsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSw2QkFBMkIsT0FBTyw0QkFBNEIsSUFBRSxXQUFVO0FBQUMsb0JBQU8sNkJBQTJCLE9BQU8sNEJBQTRCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksMkJBQXlCLE9BQU8sMEJBQTBCLElBQUUsV0FBVTtBQUFDLG9CQUFPLDJCQUF5QixPQUFPLDBCQUEwQixJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLDRCQUEwQixPQUFPLDJCQUEyQixJQUFFLFdBQVU7QUFBQyxvQkFBTyw0QkFBMEIsT0FBTywyQkFBMkIsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSx3QkFBc0IsT0FBTyx1QkFBdUIsSUFBRSxXQUFVO0FBQUMsb0JBQU8sd0JBQXNCLE9BQU8sdUJBQXVCLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksa0NBQWdDLE9BQU8saUNBQWlDLElBQUUsV0FBVTtBQUFDLG9CQUFPLGtDQUFnQyxPQUFPLGlDQUFpQyxJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLGlDQUErQixPQUFPLGdDQUFnQyxJQUFFLFdBQVU7QUFBQyxvQkFBTyxpQ0FBK0IsT0FBTyxnQ0FBZ0MsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxtQ0FBaUMsT0FBTyxrQ0FBa0MsSUFBRSxXQUFVO0FBQUMsb0JBQU8sbUNBQWlDLE9BQU8sa0NBQWtDLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksa0NBQWdDLE9BQU8saUNBQWlDLElBQUUsV0FBVTtBQUFDLG9CQUFPLGtDQUFnQyxPQUFPLGlDQUFpQyxJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLDZCQUEyQixPQUFPLDRCQUE0QixJQUFFLFdBQVU7QUFBQyxvQkFBTyw2QkFBMkIsT0FBTyw0QkFBNEIsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSwyQ0FBeUMsT0FBTywwQ0FBMEMsSUFBRSxXQUFVO0FBQUMsb0JBQU8sMkNBQXlDLE9BQU8sMENBQTBDLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksbUNBQWlDLE9BQU8sa0NBQWtDLElBQUUsV0FBVTtBQUFDLG9CQUFPLG1DQUFpQyxPQUFPLGtDQUFrQyxJQUFFLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLG9DQUFrQyxPQUFPLG1DQUFtQyxJQUFFLFdBQVU7QUFBQyxvQkFBTyxvQ0FBa0MsT0FBTyxtQ0FBbUMsSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxvQkFBa0IsV0FBVTtBQUFDLG9CQUFPLG9CQUFrQixPQUFPLEtBQUssRUFBRSxrQkFBa0IsR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLFNBQU8sV0FBVTtBQUFDLG9CQUFPLFNBQU8sT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksU0FBTyxXQUFVO0FBQUMsb0JBQU8sU0FBTyxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxTQUFPLFdBQVU7QUFBQyxvQkFBTyxTQUFPLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLFVBQVEsT0FBTyxTQUFTLElBQUUsV0FBVTtBQUFDLG9CQUFPLFVBQVEsT0FBTyxTQUFTLElBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksUUFBTSxPQUFPLE9BQU8sSUFBRSxXQUFVO0FBQUMsb0JBQU8sUUFBTSxPQUFPLE9BQU8sSUFBRSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxVQUFRLFdBQVU7QUFBQyxvQkFBTyxVQUFRLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxjQUFJLFlBQVUsV0FBVTtBQUFDLG9CQUFPLFlBQVUsT0FBTyxLQUFLLEVBQUUsSUFBSSxHQUFHLE1BQU0sTUFBSyxTQUFTO0FBQUEsVUFBQztBQUFFLGNBQUksZUFBYSxXQUFVO0FBQUMsb0JBQU8sZUFBYSxPQUFPLEtBQUssRUFBRSxJQUFJLEdBQUcsTUFBTSxNQUFLLFNBQVM7QUFBQSxVQUFDO0FBQUUsY0FBSSxhQUFXLFdBQVU7QUFBQyxvQkFBTyxhQUFXLE9BQU8sS0FBSyxFQUFFLElBQUksR0FBRyxNQUFNLE1BQUssU0FBUztBQUFBLFVBQUM7QUFBRSxpQkFBTyxZQUFZLElBQUU7QUFBVyxpQkFBTyxXQUFXLElBQUU7QUFBVSxpQkFBTyxjQUFjLElBQUU7QUFBYSxpQkFBTyxPQUFPLElBQUU7QUFBTSxjQUFJO0FBQVUsa0NBQXNCLFNBQVMsWUFBVztBQUFDLGdCQUFHLENBQUM7QUFBVSxrQkFBSTtBQUFFLGdCQUFHLENBQUM7QUFBVSxzQ0FBc0I7QUFBQSxVQUFTO0FBQUUsbUJBQVMsV0FBVTtBQUFDLGdCQUFJLGdCQUFjO0FBQU0sZ0JBQUksT0FBSztBQUFFLGdCQUFJLE9BQUs7QUFBRSxnQkFBRztBQUFDLGtCQUFJLE1BQUksY0FBYyxNQUFLLElBQUk7QUFBRSxxQkFBTyxLQUFJLElBQUk7QUFBRSxxQkFBTztBQUFBLFlBQUcsU0FBTyxHQUFFO0FBQUMscUJBQU8sZ0JBQWdCLENBQUM7QUFBQSxZQUFDO0FBQUEsVUFBQztBQUFDLG1CQUFTLE1BQUs7QUFBQyxnQkFBRyxrQkFBZ0IsR0FBRTtBQUFDO0FBQUEsWUFBTTtBQUFDLG1CQUFPO0FBQUUsZ0JBQUcsa0JBQWdCLEdBQUU7QUFBQztBQUFBLFlBQU07QUFBQyxxQkFBUyxRQUFPO0FBQUMsa0JBQUc7QUFBVTtBQUFPLDBCQUFVO0FBQUsscUJBQU8sV0FBVyxJQUFFO0FBQUssa0JBQUc7QUFBTTtBQUFPLDBCQUFZO0FBQUUsc0JBQVE7QUFBRSxrQ0FBb0IsTUFBTTtBQUFFLGtCQUFHLE9BQU8sc0JBQXNCO0FBQUUsdUJBQU8sc0JBQXNCLEVBQUU7QUFBRSxrQkFBRztBQUFhLHlCQUFTO0FBQUUsc0JBQVE7QUFBQSxZQUFDO0FBQUMsZ0JBQUcsT0FBTyxXQUFXLEdBQUU7QUFBQyxxQkFBTyxXQUFXLEVBQUUsWUFBWTtBQUFFLHlCQUFXLFdBQVU7QUFBQywyQkFBVyxXQUFVO0FBQUMseUJBQU8sV0FBVyxFQUFFLEVBQUU7QUFBQSxnQkFBQyxHQUFFLENBQUM7QUFBRSxzQkFBTTtBQUFBLGNBQUMsR0FBRSxDQUFDO0FBQUEsWUFBQyxPQUFLO0FBQUMsb0JBQU07QUFBQSxZQUFDO0FBQUEsVUFBQztBQUFDLGNBQUcsT0FBTyxTQUFTLEdBQUU7QUFBQyxnQkFBRyxPQUFPLE9BQU8sU0FBUyxLQUFHO0FBQVcscUJBQU8sU0FBUyxJQUFFLENBQUMsT0FBTyxTQUFTLENBQUM7QUFBRSxtQkFBTSxPQUFPLFNBQVMsRUFBRSxTQUFPLEdBQUU7QUFBQyxxQkFBTyxTQUFTLEVBQUUsSUFBSSxFQUFFO0FBQUEsWUFBQztBQUFBLFVBQUM7QUFBQyxjQUFJLGVBQWE7QUFBSyxjQUFHLE9BQU8sY0FBYztBQUFFLDJCQUFhO0FBQU0sY0FBSTtBQUc1NG1ELGlCQUFPaEIsUUFBTztBQUFBLFFBQ2hCO0FBQUEsTUFHQSxHQUFHO0FBQ0gsVUFBSSxPQUFPRixhQUFZLFlBQVksT0FBT0MsWUFBVztBQUNuRCxRQUFBQSxRQUFPLFVBQVVDO0FBQUEsZUFDVixPQUFPLFdBQVcsY0FBYyxPQUFPLEtBQUs7QUFDbkQsZUFBTyxDQUFDLEdBQUcsV0FBVztBQUFFLGlCQUFPQTtBQUFBLFFBQVEsQ0FBQztBQUFBLGVBQ2pDLE9BQU9GLGFBQVk7QUFDMUIsUUFBQUEsU0FBUSxRQUFRLElBQUlFO0FBQUE7QUFBQTs7O0FDcEJ0QjtBQUFBLG1EQUFBaUIsVUFBQUMsU0FBQTtBQWVBLE1BQUFBLFFBQU8sVUFBVTtBQUFBO0FBQUE7OztBQzJCVixXQUFTLE9BQU8sR0FBRyxHQUFHO0FBQzNCLFFBQUksSUFBSSxDQUFDO0FBQ1QsYUFBUyxLQUFLO0FBQUcsVUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLEdBQUcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUk7QUFDOUUsVUFBRSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ2QsUUFBSSxLQUFLLFFBQVEsT0FBTyxPQUFPLDBCQUEwQjtBQUNyRCxlQUFTLElBQUksR0FBRyxJQUFJLE9BQU8sc0JBQXNCLENBQUMsR0FBRyxJQUFJLEVBQUUsUUFBUSxLQUFLO0FBQ3BFLFlBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLFVBQVUscUJBQXFCLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztBQUN6RSxZQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUFBLE1BQ3hCO0FBQ0osV0FBTztBQUFBLEVBQ1Q7QUE4RE8sV0FBUyxVQUFVLFNBQVMsWUFBWSxHQUFHLFdBQVc7QUFDM0QsYUFBUyxNQUFNLE9BQU87QUFBRSxhQUFPLGlCQUFpQixJQUFJLFFBQVEsSUFBSSxFQUFFLFNBQVUsU0FBUztBQUFFLGdCQUFRLEtBQUs7QUFBQSxNQUFHLENBQUM7QUFBQSxJQUFHO0FBQzNHLFdBQU8sS0FBSyxNQUFNLElBQUksVUFBVSxTQUFVLFNBQVMsUUFBUTtBQUN2RCxlQUFTLFVBQVUsT0FBTztBQUFFLFlBQUk7QUFBRSxlQUFLLFVBQVUsS0FBSyxLQUFLLENBQUM7QUFBQSxRQUFHLFNBQVMsR0FBRztBQUFFLGlCQUFPLENBQUM7QUFBQSxRQUFHO0FBQUEsTUFBRTtBQUMxRixlQUFTLFNBQVMsT0FBTztBQUFFLFlBQUk7QUFBRSxlQUFLLFVBQVUsT0FBTyxFQUFFLEtBQUssQ0FBQztBQUFBLFFBQUcsU0FBUyxHQUFHO0FBQUUsaUJBQU8sQ0FBQztBQUFBLFFBQUc7QUFBQSxNQUFFO0FBQzdGLGVBQVMsS0FBSyxRQUFRO0FBQUUsZUFBTyxPQUFPLFFBQVEsT0FBTyxLQUFLLElBQUksTUFBTSxPQUFPLEtBQUssRUFBRSxLQUFLLFdBQVcsUUFBUTtBQUFBLE1BQUc7QUFDN0csWUFBTSxZQUFZLFVBQVUsTUFBTSxTQUFTLGNBQWMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsSUFDeEUsQ0FBQztBQUFBLEVBQ0g7QUE4Q08sV0FBUyxTQUFTLEdBQUc7QUFDMUIsUUFBSSxJQUFJLE9BQU8sV0FBVyxjQUFjLE9BQU8sVUFBVSxJQUFJLEtBQUssRUFBRSxDQUFDLEdBQUcsSUFBSTtBQUM1RSxRQUFJO0FBQUcsYUFBTyxFQUFFLEtBQUssQ0FBQztBQUN0QixRQUFJLEtBQUssT0FBTyxFQUFFLFdBQVc7QUFBVSxhQUFPO0FBQUEsUUFDMUMsTUFBTSxXQUFZO0FBQ2QsY0FBSSxLQUFLLEtBQUssRUFBRTtBQUFRLGdCQUFJO0FBQzVCLGlCQUFPLEVBQUUsT0FBTyxLQUFLLEVBQUUsR0FBRyxHQUFHLE1BQU0sQ0FBQyxFQUFFO0FBQUEsUUFDMUM7QUFBQSxNQUNKO0FBQ0EsVUFBTSxJQUFJLFVBQVUsSUFBSSw0QkFBNEIsaUNBQWlDO0FBQUEsRUFDdkY7QUE2Q08sV0FBUyxRQUFRLEdBQUc7QUFDekIsV0FBTyxnQkFBZ0IsV0FBVyxLQUFLLElBQUksR0FBRyxRQUFRLElBQUksUUFBUSxDQUFDO0FBQUEsRUFDckU7QUFFTyxXQUFTLGlCQUFpQixTQUFTLFlBQVksV0FBVztBQUMvRCxRQUFJLENBQUMsT0FBTztBQUFlLFlBQU0sSUFBSSxVQUFVLHNDQUFzQztBQUNyRixRQUFJLElBQUksVUFBVSxNQUFNLFNBQVMsY0FBYyxDQUFDLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQztBQUM1RCxXQUFPLElBQUksQ0FBQyxHQUFHLEtBQUssTUFBTSxHQUFHLEtBQUssT0FBTyxHQUFHLEtBQUssUUFBUSxHQUFHLEVBQUUsT0FBTyxhQUFhLElBQUksV0FBWTtBQUFFLGFBQU87QUFBQSxJQUFNLEdBQUc7QUFDcEgsYUFBUyxLQUFLLEdBQUc7QUFBRSxVQUFJLEVBQUUsQ0FBQztBQUFHLFVBQUUsQ0FBQyxJQUFJLFNBQVUsR0FBRztBQUFFLGlCQUFPLElBQUksUUFBUSxTQUFVLEdBQUcsR0FBRztBQUFFLGNBQUUsS0FBSyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssT0FBTyxHQUFHLENBQUM7QUFBQSxVQUFHLENBQUM7QUFBQSxRQUFHO0FBQUEsSUFBRztBQUN6SSxhQUFTLE9BQU8sR0FBRyxHQUFHO0FBQUUsVUFBSTtBQUFFLGFBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQUEsTUFBRyxTQUFTLEdBQUc7QUFBRSxlQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO0FBQUEsTUFBRztBQUFBLElBQUU7QUFDakYsYUFBUyxLQUFLLEdBQUc7QUFBRSxRQUFFLGlCQUFpQixVQUFVLFFBQVEsUUFBUSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEtBQUssU0FBUyxNQUFNLElBQUksT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztBQUFBLElBQUc7QUFDdkgsYUFBUyxRQUFRLE9BQU87QUFBRSxhQUFPLFFBQVEsS0FBSztBQUFBLElBQUc7QUFDakQsYUFBUyxPQUFPLE9BQU87QUFBRSxhQUFPLFNBQVMsS0FBSztBQUFBLElBQUc7QUFDakQsYUFBUyxPQUFPLEdBQUcsR0FBRztBQUFFLFVBQUksRUFBRSxDQUFDLEdBQUcsRUFBRSxNQUFNLEdBQUcsRUFBRTtBQUFRLGVBQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUFBLElBQUc7QUFBQSxFQUNuRjtBQUVPLFdBQVMsaUJBQWlCLEdBQUc7QUFDbEMsUUFBSSxHQUFHO0FBQ1AsV0FBTyxJQUFJLENBQUMsR0FBRyxLQUFLLE1BQU0sR0FBRyxLQUFLLFNBQVMsU0FBVSxHQUFHO0FBQUUsWUFBTTtBQUFBLElBQUcsQ0FBQyxHQUFHLEtBQUssUUFBUSxHQUFHLEVBQUUsT0FBTyxRQUFRLElBQUksV0FBWTtBQUFFLGFBQU87QUFBQSxJQUFNLEdBQUc7QUFDMUksYUFBUyxLQUFLLEdBQUcsR0FBRztBQUFFLFFBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLFNBQVUsR0FBRztBQUFFLGdCQUFRLElBQUksQ0FBQyxLQUFLLEVBQUUsT0FBTyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLE1BQU0sTUFBTSxJQUFJLElBQUksRUFBRSxDQUFDLElBQUk7QUFBQSxNQUFHLElBQUk7QUFBQSxJQUFHO0FBQUEsRUFDdkk7QUFFTyxXQUFTLGNBQWMsR0FBRztBQUMvQixRQUFJLENBQUMsT0FBTztBQUFlLFlBQU0sSUFBSSxVQUFVLHNDQUFzQztBQUNyRixRQUFJLElBQUksRUFBRSxPQUFPLGFBQWEsR0FBRztBQUNqQyxXQUFPLElBQUksRUFBRSxLQUFLLENBQUMsS0FBSyxJQUFJLE9BQU8sYUFBYSxhQUFhLFNBQVMsQ0FBQyxJQUFJLEVBQUUsT0FBTyxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxLQUFLLE1BQU0sR0FBRyxLQUFLLE9BQU8sR0FBRyxLQUFLLFFBQVEsR0FBRyxFQUFFLE9BQU8sYUFBYSxJQUFJLFdBQVk7QUFBRSxhQUFPO0FBQUEsSUFBTSxHQUFHO0FBQzlNLGFBQVMsS0FBSyxHQUFHO0FBQUUsUUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssU0FBVSxHQUFHO0FBQUUsZUFBTyxJQUFJLFFBQVEsU0FBVSxTQUFTLFFBQVE7QUFBRSxjQUFJLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxPQUFPLFNBQVMsUUFBUSxFQUFFLE1BQU0sRUFBRSxLQUFLO0FBQUEsUUFBRyxDQUFDO0FBQUEsTUFBRztBQUFBLElBQUc7QUFDL0osYUFBUyxPQUFPLFNBQVMsUUFBUSxHQUFHLEdBQUc7QUFBRSxjQUFRLFFBQVEsQ0FBQyxFQUFFLEtBQUssU0FBU0MsSUFBRztBQUFFLGdCQUFRLEVBQUUsT0FBT0EsSUFBRyxNQUFNLEVBQUUsQ0FBQztBQUFBLE1BQUcsR0FBRyxNQUFNO0FBQUEsSUFBRztBQUFBLEVBQzdIOzs7QUMzUEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaUJBLE1BQU0sVUFBVSxJQUFJLFlBQVksT0FBTztBQUVoQyxNQUFNLGFBQWEsQ0FBQyxXQUEwQixRQUFRLE9BQU8sTUFBTTtBQUUxRSxNQUFNLFVBQVUsSUFBSSxZQUFXO0FBRXhCLE1BQU0sYUFBYSxDQUFDLFVBQW1CLFFBQVEsT0FBTyxLQUFLOzs7QUNzQmxFLE1BQU0sQ0FBQyxtQkFBbUIsc0JBQXNCLEtBQUssTUFBSztBQUN0RCxVQUFNLGdDQUFnQyxNQUFLO0FBQUcsWUFBTSxJQUFJLE1BQU0sb0RBQW9EO0lBQUc7SUFDckgsTUFBTSx5QkFBd0I7TUFDMUIsV0FBVyxvQkFBaUI7QUFBSyxlQUFPO01BQUc7TUFDM0MsT0FBTyxLQUFFO0FBQUssY0FBTSw4QkFBNkI7TUFBSTtNQUNyRCxPQUFPLE9BQUk7QUFBSyxjQUFNLDhCQUE2QjtNQUFJO01BQ3ZELGNBQUE7QUFBZ0IsY0FBTSw4QkFBNkI7TUFBSTs7QUFFM0QsV0FBTyxPQUFPLGtCQUFrQixjQUFjLENBQUMsZUFBZSxJQUFJLElBQUksQ0FBTSwwQkFBMEIsS0FBSztFQUMvRyxHQUFFO0FBR0YsTUFBTSxDQUFDLG9CQUFvQix1QkFBdUIsS0FBSyxNQUFLO0FBQ3hELFVBQU0saUNBQWlDLE1BQUs7QUFBRyxZQUFNLElBQUksTUFBTSxxREFBcUQ7SUFBRztJQUN2SCxNQUFNLDBCQUF5QjtNQUMzQixXQUFXLG9CQUFpQjtBQUFLLGVBQU87TUFBRztNQUMzQyxPQUFPLEtBQUU7QUFBSyxjQUFNLCtCQUE4QjtNQUFJO01BQ3RELE9BQU8sT0FBSTtBQUFLLGNBQU0sK0JBQThCO01BQUk7TUFDeEQsY0FBQTtBQUFnQixjQUFNLCtCQUE4QjtNQUFJOztBQUU1RCxXQUFPLE9BQU8sbUJBQW1CLGNBQWMsQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQU0sMkJBQTJCLEtBQUs7RUFDbEgsR0FBRTtBQUthLE1BQU0sV0FBVyxDQUFDLE1BQVcsT0FBTyxNQUFNO0FBQzFDLE1BQU0sWUFBWSxDQUFDLE1BQVcsT0FBTyxNQUFNO0FBQzNDLE1BQU0sYUFBYSxDQUFDLE1BQVcsT0FBTyxNQUFNO0FBR3BELE1BQU0sV0FBVyxDQUFDLE1BQXdCLEtBQUssUUFBUSxPQUFPLENBQUMsTUFBTTtBQUdyRSxNQUFNLFlBQVksQ0FBVSxNQUErQjtBQUM5RCxXQUFPLFNBQVMsQ0FBQyxLQUFLLFdBQVcsRUFBRSxJQUFJO0VBQzNDO0FBUU8sTUFBTSxhQUFhLENBQVUsTUFBNEI7QUFDNUQsV0FBTyxTQUFTLENBQUMsS0FBSyxXQUFXLEVBQUUsT0FBTyxRQUFRLENBQUM7RUFDdkQ7QUFHTyxNQUFNLGtCQUFrQixDQUFVLE1BQWlDO0FBQ3RFLFdBQU8sU0FBUyxDQUFDLEtBQUssV0FBVyxFQUFFLE9BQU8sYUFBYSxDQUFDO0VBQzVEO0FBR08sTUFBTSxjQUFjLENBQUMsTUFBOEI7QUFDdEQsV0FBTyxTQUFTLENBQUMsS0FBSyxTQUFTLEVBQUUsUUFBUSxDQUFDO0VBQzlDO0FBUU8sTUFBTSxtQkFBbUIsQ0FBVSxNQUFrQztBQUN4RSxXQUFPLFNBQVMsQ0FBQyxLQUFNLFVBQVUsS0FBTyxXQUFXO0VBQ3ZEO0FBWU8sTUFBTSxlQUFlLENBQUMsTUFBMkI7QUFDcEQsV0FBTyxTQUFTLENBQUMsS0FBSyxXQUFXLEVBQUUsTUFBTSxDQUFDLEtBQUssU0FBUyxFQUFFLElBQUksQ0FBQztFQUNuRTtBQVFPLE1BQU0sa0JBQWtCLENBQUMsTUFBeUI7QUFDckQsV0FBTyxTQUFTLENBQUMsS0FBSyxvQkFBb0IsRUFBRSxNQUFNLENBQUM7RUFDdkQ7QUFFQSxNQUFNLG9CQUFvQixDQUFVLE1BQXFDLG1CQUFtQixLQUFLLG9CQUFvQjtBQUc5RyxNQUFNLHNCQUFzQixDQUFVLE1BQWtDO0FBQzNFLFdBQU8sU0FBUyxDQUFDLEtBQ2IsV0FBVyxFQUFFLE9BQU8sQ0FBQyxLQUNyQixXQUFXLEVBQUUsV0FBVyxDQUFDLEtBQ3pCLENBQUMsa0JBQWtCLENBQUM7RUFDNUI7QUFHTyxNQUFNLHNCQUFzQixDQUFVLE1BQWtDO0FBQzNFLFdBQU8sU0FBUyxDQUFDLEtBQ2IsV0FBVyxFQUFFLFFBQVEsQ0FBQyxLQUN0QixXQUFXLEVBQUUsV0FBVyxDQUFDLEtBQ3pCLENBQUMsa0JBQWtCLENBQUM7RUFDNUI7QUFHTyxNQUFNLHVCQUF1QixDQUFDLE1BQXNDO0FBQ3ZFLFdBQU8sU0FBUyxDQUFDLEtBQ2IsV0FBVyxFQUFFLEtBQUssQ0FBQyxLQUNuQixXQUFXLEVBQUUsT0FBTyxDQUFDLEtBQ3JCLFVBQVUsRUFBRSxVQUFVLENBQUMsS0FDdkIsQ0FBQyxrQkFBa0IsQ0FBQztFQUM1QjtBQUdPLE1BQU0sdUJBQXVCLENBQUMsTUFBc0M7QUFDdkUsV0FBTyxTQUFTLENBQUMsS0FDYixXQUFXLEVBQUUsTUFBTSxDQUFDLEtBQ3BCLFdBQVcsRUFBRSxNQUFNLENBQUMsS0FDcEIsVUFBVSxFQUFFLFVBQVUsQ0FBQyxLQUN2QixDQUFDLGtCQUFrQixDQUFDO0VBQzVCO0FBR08sTUFBTSwwQkFBMEIsQ0FBQyxNQUFpRDtBQUNyRixXQUFPLFNBQVMsQ0FBQyxLQUNiLFdBQVcsRUFBRSxPQUFPLENBQUMsS0FDckIsV0FBVyxFQUFFLE9BQU8sQ0FBQyxLQUNyQixXQUFXLEVBQUUsVUFBVSxDQUFDLEtBQ3hCLFdBQVcsRUFBRSxhQUFhLENBQUMsS0FDM0IsV0FBVyxFQUFFLFVBQVUsQ0FBQyxLQUN4QixXQUFXLEVBQUUscUJBQXFCLENBQUMsS0FDbkMsV0FBVyxFQUFFLFlBQVksQ0FBQztFQUNsQzs7O0FGaEtBLE1BQU0saUJBQWtCLE9BQU8sc0JBQXNCLGNBQWMsb0JBQW9CO0FBR3ZGLFdBQVMsNkJBQTZCLFFBQW9CO0FBQ3RELFVBQU0sU0FBUyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQTtBQUN6QyxRQUFJLFNBQWlCLFNBQWlCLE1BQWM7QUFDcEQsYUFBUyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLE9BQU8sUUFBUSxFQUFFLElBQUksS0FBSTtBQUN0RCxVQUFJLE9BQU8sQ0FBQztBQUNaLFVBQUksT0FBTyxDQUFDO0FBRVosVUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsWUFBWTtBQUNsRSxjQUFNLE9BQU8sRUFBRSxDQUFDLElBQUk7QUFDcEI7O0FBRUosT0FBQyxFQUFFLFlBQVksU0FBUyxZQUFZLEtBQUksSUFBSztBQUM3QyxPQUFDLEVBQUUsWUFBWSxTQUFTLFlBQVksS0FBSSxJQUFLO0FBRTdDLFVBQUssVUFBVSxPQUFRLFdBQVksVUFBVSxPQUFRLFNBQVM7QUFDMUQsY0FBTSxPQUFPLEVBQUUsQ0FBQyxJQUFJO0FBQ3BCOztBQUVKLGFBQU8sQ0FBQyxJQUFJLElBQUksV0FBVyxFQUFFLFFBQVEsU0FBUyxVQUFVLFVBQVUsSUFBSTs7QUFFMUUsV0FBTztFQUNYO0FBR00sV0FBVSxPQUF5RSxRQUFpQixRQUFpQixtQkFBbUIsR0FBRyxtQkFBbUIsT0FBTyxZQUFVO0FBQ2pMLFVBQU0sbUJBQW1CLE9BQU87QUFDaEMsVUFBTSxNQUFNLElBQUksV0FBVyxPQUFPLFFBQVEsT0FBTyxZQUFZLGdCQUFnQjtBQUM3RSxVQUFNLE1BQU0sSUFBSSxXQUFXLE9BQU8sUUFBUSxPQUFPLFlBQVksS0FBSyxJQUFJLGtCQUFrQixnQkFBZ0IsQ0FBQztBQUN6RyxRQUFJLElBQUksS0FBSyxnQkFBZ0I7QUFDN0IsV0FBTztFQUNYO0FBR00sV0FBVSxnQkFBZ0IsUUFBc0IsTUFBb0I7QUFJdEUsVUFBTSxTQUFTLDZCQUE2QixNQUFNO0FBQ2xELFVBQU0sYUFBYSxPQUFPLE9BQU8sQ0FBQyxHQUFHLE1BQU0sSUFBSSxFQUFFLFlBQVksQ0FBQztBQUM5RCxRQUFJLFFBQW9CLFFBQW9CO0FBQzVDLFFBQUksU0FBUyxHQUFHLFFBQVE7QUFDeEIsVUFBTSxTQUFTLEtBQUssSUFBSSxRQUFRLE9BQU8sbUJBQW1CLFVBQVU7QUFDcEUsZUFBVyxJQUFJLE9BQU8sUUFBUSxFQUFFLFFBQVEsS0FBSTtBQUN4QyxlQUFTLE9BQU8sS0FBSztBQUNyQixlQUFTLE9BQU8sU0FBUyxHQUFHLEtBQUssSUFBSSxPQUFPLFFBQVEsU0FBUyxNQUFNLENBQUM7QUFDcEUsVUFBSSxVQUFXLFNBQVMsT0FBTyxRQUFTO0FBQ3BDLFlBQUksT0FBTyxTQUFTLE9BQU8sUUFBUTtBQUMvQixpQkFBTyxLQUFLLElBQUksT0FBTyxTQUFTLE9BQU8sTUFBTTttQkFDdEMsT0FBTyxXQUFXLE9BQU8sUUFBUTtBQUFFOztBQUM5QyxpQkFBUyxPQUFPLFFBQVEsUUFBUSxNQUFNLElBQUssU0FBUztBQUNwRDs7QUFFSixhQUFPLFdBQVcsU0FBUyxJQUFJLFdBQVcsTUFBTSxJQUFJLFFBQVEsTUFBTTtBQUNsRSxnQkFBVSxPQUFPOztBQUVyQixXQUFPLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxHQUFHLE9BQU8sTUFBTSxLQUFLLEdBQUcsY0FBYyxTQUFTLE9BQU8sYUFBYSxFQUFFO0VBQzNHO0FBUU0sV0FBVSxrQkFFZCxxQkFBMEIsT0FBMkI7QUFFbkQsUUFBSSxRQUFhLGlCQUFpQixLQUFLLElBQUksTUFBTSxRQUFRO0FBRXpELFFBQUksaUJBQWlCLHFCQUFxQjtBQUN0QyxVQUFJLHdCQUF3QixZQUFZO0FBR3BDLGVBQU8sSUFBSSxvQkFBb0IsTUFBTSxRQUFRLE1BQU0sWUFBWSxNQUFNLFVBQVU7O0FBRW5GLGFBQU87O0FBRVgsUUFBSSxDQUFDLE9BQU87QUFBRSxhQUFPLElBQUksb0JBQW9CLENBQUM7O0FBQzlDLFFBQUksT0FBTyxVQUFVLFVBQVU7QUFBRSxjQUFRLFdBQVcsS0FBSzs7QUFDekQsUUFBSSxpQkFBaUIsYUFBYTtBQUFFLGFBQU8sSUFBSSxvQkFBb0IsS0FBSzs7QUFDeEUsUUFBSSxpQkFBaUIsZ0JBQWdCO0FBQUUsYUFBTyxJQUFJLG9CQUFvQixLQUFLOztBQUMzRSxRQUFJLHdCQUF3QixLQUFLLEdBQUc7QUFBRSxhQUFPLGtCQUFrQixxQkFBcUIsTUFBTSxNQUFLLENBQUU7O0FBQ2pHLFdBQU8sQ0FBQyxZQUFZLE9BQU8sS0FBSyxJQUFJLG9CQUFvQixLQUFLLEtBQUssSUFBSyxNQUFNLGNBQWMsSUFBSSxJQUFJLG9CQUFvQixDQUFDLElBQ2xILElBQUksb0JBQW9CLE1BQU0sUUFBUSxNQUFNLFlBQVksTUFBTSxhQUFhLG9CQUFvQixpQkFBaUI7RUFDMUg7QUFFc0IsTUFBTSxjQUFjLENBQUMsVUFBZ0Msa0JBQWtCLFdBQVcsS0FBSztBQUN2RixNQUFNLGVBQWUsQ0FBQyxVQUFnQyxrQkFBa0IsWUFBWSxLQUFLO0FBQ3pGLE1BQU0sZUFBZSxDQUFDLFVBQWdDLGtCQUFrQixZQUFZLEtBQUs7QUFDekYsTUFBTSxrQkFBa0IsQ0FBQyxVQUFnQyxrQkFBa0IsbUJBQWUsS0FBSztBQUMvRixNQUFNLGVBQWUsQ0FBQyxVQUFnQyxrQkFBa0IsWUFBWSxLQUFLO0FBQ3pGLE1BQU0sZ0JBQWdCLENBQUMsVUFBZ0Msa0JBQWtCLGFBQWEsS0FBSztBQUMzRixNQUFNLGdCQUFnQixDQUFDLFVBQWdDLGtCQUFrQixhQUFhLEtBQUs7QUFDM0YsTUFBTSxtQkFBbUIsQ0FBQyxVQUFnQyxrQkFBa0Isb0JBQWdCLEtBQUs7QUFDakcsTUFBTSxpQkFBaUIsQ0FBQyxVQUFnQyxrQkFBa0IsY0FBYyxLQUFLO0FBQzdGLE1BQU0saUJBQWlCLENBQUMsVUFBZ0Msa0JBQWtCLGNBQWMsS0FBSztBQUM3RixNQUFNLHNCQUFzQixDQUFDLFVBQWdDLGtCQUFrQixtQkFBbUIsS0FBSztBQU03SCxNQUFNLE9BQU8sQ0FBK0MsYUFBZTtBQUFHLGFBQVMsS0FBSTtBQUFJLFdBQU87RUFBVTtBQUcxRyxZQUFXLDBCQUFnRCxXQUFxQyxRQUFvQztBQUN0SSxVQUFNLE9BQU8sV0FBYSxHQUFJO0FBQUksWUFBTTtJQUFHO0FBQzNDLFVBQU0sVUFDRCxPQUFPLFdBQVcsV0FBWSxLQUFLLE1BQU0sSUFDbkMsWUFBWSxPQUFPLE1BQU0sSUFBSyxLQUFLLE1BQU0sSUFDckMsa0JBQWtCLGNBQWUsS0FBSyxNQUFNLElBQ3hDLGtCQUFrQixpQkFBa0IsS0FBSyxNQUFNLElBQzVDLENBQUMsV0FBaUMsTUFBTSxJQUFJLEtBQUssTUFBTSxJQUFJO0FBRWpGLFdBQU8sS0FBTSxXQUFXQyxLQUEyRDtBQUMvRSxVQUFJLElBQThCO0FBQ2xDLFNBQUc7QUFDQyxZQUFJQSxJQUFHLEtBQUssTUFBTSxrQkFBa0IsV0FBVyxDQUFDLENBQUM7ZUFDNUMsQ0FBQyxFQUFFO0lBQ2hCLEVBQUcsUUFBUSxPQUFPLFFBQVEsRUFBQyxDQUFFLENBQUM7QUFDOUIsV0FBTyxJQUFJLFVBQVM7RUFDeEI7QUFFc0IsTUFBTSxzQkFBc0IsQ0FBQyxVQUF3QywwQkFBMEIsV0FBVyxLQUFLO0FBQy9HLE1BQU0sdUJBQXVCLENBQUMsVUFBd0MsMEJBQTBCLFlBQVksS0FBSztBQUNqSCxNQUFNLHVCQUF1QixDQUFDLFVBQXdDLDBCQUEwQixZQUFZLEtBQUs7QUFDakgsTUFBTSx1QkFBdUIsQ0FBQyxVQUF3QywwQkFBMEIsWUFBWSxLQUFLO0FBQ2pILE1BQU0sd0JBQXdCLENBQUMsVUFBd0MsMEJBQTBCLGFBQWEsS0FBSztBQUNuSCxNQUFNLHdCQUF3QixDQUFDLFVBQXdDLDBCQUEwQixhQUFhLEtBQUs7QUFDbkgsTUFBTSx5QkFBeUIsQ0FBQyxVQUF3QywwQkFBMEIsY0FBYyxLQUFLO0FBQ3JILE1BQU0seUJBQXlCLENBQUMsVUFBd0MsMEJBQTBCLGNBQWMsS0FBSztBQUNySCxNQUFNLDhCQUE4QixDQUFDLFVBQXdDLDBCQUEwQixtQkFBbUIsS0FBSztBQU0vSSxXQUFpQiwrQkFBcUQsV0FBcUMsUUFBeUM7O0FBR3RKLFVBQUksVUFBZ0MsTUFBTSxHQUFHO0FBQ3pDLGVBQUEsTUFBQSxRQUFPLE1BQUEsUUFBQSxPQUFPLGlCQUFBLGNBQUEsK0JBQStCLFdBQVcsTUFBQSxRQUFNLE1BQU0sQ0FBQSxDQUFDLENBQUEsQ0FBQSxDQUFBOztBQUd6RSxZQUFNLE9BQU8sU0FBbUIsR0FBSTtBQUFBLGVBQUEsaUJBQUEsTUFBQSxXQUFBLGFBQUE7QUFBSSxnQkFBQSxNQUFBLFFBQU0sTUFBQSxRQUFNLENBQUMsQ0FBQTtRQUFFLENBQUM7TUFBQTtBQUN4RCxZQUFNLE9BQU8sU0FBMENDLFNBQVM7O0FBQzVELGdCQUFBLFFBQUEsT0FBTyxpQkFBQSxjQUFBLEtBQU0sV0FBV0QsS0FBaUI7QUFDckMsZ0JBQUksSUFBOEI7QUFDbEMsZUFBRztBQUNDLGtCQUFJQSxJQUFHLEtBQUssTUFBTSxNQUFDLFFBQUQsTUFBQyxTQUFBLFNBQUQsRUFBRyxLQUFLO3FCQUNyQixDQUFDLEVBQUU7VUFDaEIsRUFBR0MsUUFBTyxPQUFPLFFBQVEsRUFBQyxDQUFFLENBQUMsQ0FBQyxDQUFBLENBQUE7UUFDbEMsQ0FBQzs7QUFFRCxZQUFNLFVBQ0QsT0FBTyxXQUFXLFdBQVksS0FBSyxNQUFNLElBQ25DLFlBQVksT0FBTyxNQUFNLElBQUssS0FBSyxNQUFNLElBQ3JDLGtCQUFrQixjQUFlLEtBQUssTUFBTSxJQUN4QyxrQkFBa0IsaUJBQWtCLEtBQUssTUFBTSxJQUM1QyxXQUFpQyxNQUFNLElBQUksS0FBSyxNQUFNLElBQ2xELENBQUMsZ0JBQXNDLE1BQU0sSUFBSSxLQUFLLE1BQU0sSUFDeEQ7QUFFOUIsWUFBQTs7UUFBQSxPQUFPLGlCQUFBLGNBQUEsS0FBTSxTQUFpQkQsS0FBZ0U7O0FBQzFGLGdCQUFJLElBQThCO0FBQ2xDLGVBQUc7QUFDQyxrQkFBSSxNQUFBLFFBQU1BLElBQUcsS0FBSyxNQUFBLE1BQUEsUUFBTSxrQkFBa0IsV0FBVyxDQUFDLENBQUMsQ0FBQSxDQUFDO3FCQUNuRCxDQUFDLEVBQUU7VUFDaEIsQ0FBQztVQUFFLFFBQVEsT0FBTyxhQUFhLEVBQUMsQ0FBRSxDQUFDLENBQUMsQ0FBQTtNQUFBO0FBQ3BDLGFBQUEsTUFBQSxRQUFPLElBQUksVUFBUyxDQUFFO0lBQzFCLENBQUM7O0FBRXFCLE1BQU0sMkJBQTJCLENBQUMsVUFBNkMsK0JBQStCLFdBQVcsS0FBSztBQUM5SCxNQUFNLDRCQUE0QixDQUFDLFVBQTZDLCtCQUErQixZQUFZLEtBQUs7QUFDaEksTUFBTSw0QkFBNEIsQ0FBQyxVQUE2QywrQkFBK0IsWUFBWSxLQUFLO0FBQ2hJLE1BQU0sNEJBQTRCLENBQUMsVUFBNkMsK0JBQStCLFlBQVksS0FBSztBQUNoSSxNQUFNLDZCQUE2QixDQUFDLFVBQTZDLCtCQUErQixhQUFhLEtBQUs7QUFDbEksTUFBTSw2QkFBNkIsQ0FBQyxVQUE2QywrQkFBK0IsYUFBYSxLQUFLO0FBQ2xJLE1BQU0sOEJBQThCLENBQUMsVUFBNkMsK0JBQStCLGNBQWMsS0FBSztBQUNwSSxNQUFNLDhCQUE4QixDQUFDLFVBQTZDLCtCQUErQixjQUFjLEtBQUs7QUFDcEksTUFBTSxtQ0FBbUMsQ0FBQyxVQUE2QywrQkFBK0IsbUJBQW1CLEtBQUs7QUFHOUosV0FBVSxtQkFBbUIsUUFBZ0IsUUFBZ0IsY0FBd0I7QUFHdkYsUUFBSSxXQUFXLEdBQUc7QUFDZCxxQkFBZSxhQUFhLE1BQU0sR0FBRyxTQUFTLENBQUM7QUFDL0MsZUFBUyxJQUFJLElBQUksRUFBRSxLQUFLLFVBQVM7QUFDN0IscUJBQWEsQ0FBQyxLQUFLOzs7QUFHM0IsV0FBTztFQUNYO0FBR00sV0FBVSxpQkFBMkMsR0FBTSxHQUFJO0FBQ2pFLFFBQUksSUFBSTtBQUNSLFVBQU0sSUFBSSxFQUFFO0FBQ1osUUFBSSxNQUFNLEVBQUUsUUFBUTtBQUFFLGFBQU87O0FBQzdCLFFBQUksSUFBSSxHQUFHO0FBQ1AsU0FBRztBQUFFLFlBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUc7QUFBRSxpQkFBTzs7ZUFBa0IsRUFBRSxJQUFJOztBQUU3RCxXQUFPO0VBQ1g7OztBR3hNQSxNQUFBLG1CQUFlO0lBQ1gsYUFBNkMsUUFBdUI7QUFDaEUsYUFBT0UsTUFBSyxhQUFnQixNQUFNLENBQUM7SUFDdkM7SUFDQSxrQkFBa0QsUUFBeUM7QUFDdkYsYUFBT0EsTUFBSyxrQkFBcUIsTUFBTSxDQUFDO0lBQzVDO0lBQ0EsY0FBOEMsUUFBeUI7QUFDbkUsYUFBT0EsTUFBSyxjQUFpQixNQUFNLENBQUM7SUFDeEM7SUFDQSxlQUFlLFFBQTZCO0FBQ3hDLGFBQU9BLE1BQUssZUFBZSxNQUFNLENBQUM7SUFDdEM7O0lBRUEsWUFBZSxRQUF3QyxTQUFrQztBQUNyRixZQUFNLElBQUksTUFBTSxpREFBaUQ7SUFDckU7O0lBRUEsYUFBZ0IsUUFBd0MsU0FBMEM7QUFDOUYsWUFBTSxJQUFJLE1BQU0sa0RBQWtEO0lBQ3RFOztBQUlKLE1BQU1BLFFBQU8sQ0FBMkQsYUFBZTtBQUFHLGFBQVMsS0FBSTtBQUFJLFdBQU87RUFBVTtBQUc1SCxZQUFVLGFBQTZDLFFBQXVCO0FBRTFFLFFBQUksTUFBMkIsUUFBUTtBQUN2QyxRQUFJLFVBQXdCLENBQUEsR0FBSTtBQUNoQyxRQUFJLEtBQXNCLE1BQWMsZUFBZTtBQUV2RCxhQUFTLFlBQVM7QUFDZCxVQUFJLFFBQVEsUUFBUTtBQUNoQixlQUFPLGdCQUFnQixTQUFTLElBQUksRUFBRSxDQUFDOztBQUUzQyxPQUFDLFFBQVEsU0FBUyxZQUFZLElBQUksZ0JBQWdCLFNBQVMsSUFBSTtBQUMvRCxhQUFPO0lBQ1g7QUFHQSxLQUFDLEVBQUUsS0FBSyxLQUFJLElBQUssTUFBVztBQUc1QixVQUFNQyxNQUFLLHFCQUFxQixNQUFNLEVBQUUsT0FBTyxRQUFRLEVBQUM7QUFFeEQsUUFBSTtBQUNBLFNBQUc7QUFFQyxTQUFDLEVBQUUsTUFBTSxPQUFPLE9BQU0sSUFBSyxPQUFPLE1BQU0sT0FBTyxZQUFZLElBQ3ZEQSxJQUFHLEtBQUksSUFBS0EsSUFBRyxLQUFLLE9BQU8sWUFBWTtBQUUzQyxZQUFJLENBQUMsUUFBUSxPQUFPLGFBQWEsR0FBRztBQUNoQyxrQkFBUSxLQUFLLE1BQU07QUFDbkIsMEJBQWdCLE9BQU87O0FBRzNCLFlBQUksUUFBUSxRQUFRLGNBQWM7QUFDOUIsYUFBRztBQUNDLGFBQUMsRUFBRSxLQUFLLEtBQUksSUFBSyxNQUFNLFVBQVM7bUJBQzNCLE9BQU87O2VBRWYsQ0FBQzthQUNMLEdBQUc7QUFDUixPQUFDLFFBQVEsU0FBVSxPQUFPQSxJQUFHLFVBQVUsY0FBZ0JBLElBQUcsTUFBTSxDQUFDOztBQUVqRSxNQUFDLFVBQVUsU0FBVyxPQUFPQSxJQUFHLFdBQVcsY0FBZ0JBLElBQUcsT0FBTyxJQUFLOztBQUU5RSxXQUFPO0VBQ1g7QUFHQSxXQUFnQixrQkFBa0QsUUFBeUM7O0FBRXZHLFVBQUksTUFBMkIsUUFBUTtBQUN2QyxVQUFJLFVBQXdCLENBQUEsR0FBSTtBQUNoQyxVQUFJLEtBQXNCLE1BQWMsZUFBZTtBQUV2RCxlQUFTLFlBQVM7QUFDZCxZQUFJLFFBQVEsUUFBUTtBQUNoQixpQkFBTyxnQkFBZ0IsU0FBUyxJQUFJLEVBQUUsQ0FBQzs7QUFFM0MsU0FBQyxRQUFRLFNBQVMsWUFBWSxJQUFJLGdCQUFnQixTQUFTLElBQUk7QUFDL0QsZUFBTztNQUNYO0FBR0EsT0FBQyxFQUFFLEtBQUssS0FBSSxJQUFNLE1BQUEsTUFBQSxRQUFXLElBQUk7QUFHakMsWUFBTUEsTUFBSywwQkFBMEIsTUFBTSxFQUFFLE9BQU8sYUFBYSxFQUFDO0FBRWxFLFVBQUk7QUFDQSxXQUFHO0FBRUMsV0FBQyxFQUFFLE1BQU0sT0FBTyxPQUFNLElBQUssT0FBTyxNQUFNLE9BQU8sWUFBWSxJQUNyRCxNQUFBLFFBQU1BLElBQUcsS0FBSSxDQUFFLElBQ2YsTUFBQSxRQUFNQSxJQUFHLEtBQUssT0FBTyxZQUFZLENBQUM7QUFFeEMsY0FBSSxDQUFDLFFBQVEsT0FBTyxhQUFhLEdBQUc7QUFDaEMsb0JBQVEsS0FBSyxNQUFNO0FBQ25CLDRCQUFnQixPQUFPOztBQUczQixjQUFJLFFBQVEsUUFBUSxjQUFjO0FBQzlCLGVBQUc7QUFDQyxlQUFDLEVBQUUsS0FBSyxLQUFJLElBQUssTUFBQSxNQUFBLFFBQU0sVUFBUyxDQUFFO3FCQUM3QixPQUFPOztpQkFFZixDQUFDO2VBQ0wsR0FBRztBQUNSLFNBQUMsUUFBUSxTQUFVLE9BQU9BLElBQUcsVUFBVSxlQUFnQixNQUFBLFFBQU1BLElBQUcsTUFBTSxDQUFDLENBQUM7O0FBRXhFLFFBQUMsVUFBVSxTQUFXLE9BQU9BLElBQUcsV0FBVyxlQUFnQixNQUFBLFFBQU1BLElBQUcsT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUM7O0FBRWpHLGFBQUEsTUFBQSxRQUFPLElBQUk7SUFDZixDQUFDOztBQU1ELFdBQWdCLGNBQThDLFFBQXlCOztBQUVuRixVQUFJLE9BQU8sT0FBTyxRQUFRO0FBQzFCLFVBQUksVUFBd0IsQ0FBQSxHQUFJO0FBQ2hDLFVBQUksS0FBc0IsTUFBYyxlQUFlO0FBRXZELGVBQVMsWUFBUztBQUNkLFlBQUksUUFBUSxRQUFRO0FBQ2hCLGlCQUFPLGdCQUFnQixTQUFTLElBQUksRUFBRSxDQUFDOztBQUUzQyxTQUFDLFFBQVEsU0FBUyxZQUFZLElBQUksZ0JBQWdCLFNBQVMsSUFBSTtBQUMvRCxlQUFPO01BQ1g7QUFHQSxPQUFDLEVBQUUsS0FBSyxLQUFJLElBQUssTUFBQSxNQUFBLFFBQVcsSUFBSTtBQUdoQyxZQUFNQSxNQUFLLElBQUksbUJBQW1CLE1BQU07QUFFeEMsVUFBSTtBQUNBLFdBQUc7QUFFQyxXQUFDLEVBQUUsTUFBTSxPQUFPLE9BQU0sSUFBSyxPQUFPLE1BQU0sT0FBTyxZQUFZLElBQ3JELE1BQUEsUUFBTUEsSUFBRyxNQUFNLEVBQUMsQ0FBRSxJQUNsQixNQUFBLFFBQU1BLElBQUcsTUFBTSxFQUFFLE9BQU8sWUFBWSxDQUFDO0FBRTNDLGNBQUksQ0FBQyxRQUFRLE9BQU8sYUFBYSxHQUFHO0FBQ2hDLG9CQUFRLEtBQUssYUFBYSxNQUFNLENBQUM7QUFDakMsNEJBQWdCLE9BQU87O0FBRzNCLGNBQUksUUFBUSxRQUFRLGNBQWM7QUFDOUIsZUFBRztBQUNDLGVBQUMsRUFBRSxLQUFLLEtBQUksSUFBSyxNQUFBLE1BQUEsUUFBTSxVQUFTLENBQUU7cUJBQzdCLE9BQU87O2lCQUVmLENBQUM7ZUFDTCxHQUFHO0FBQ1IsU0FBQyxRQUFRLFVBQVUsTUFBQSxRQUFNQSxJQUFHLFFBQVEsRUFBRSxDQUFDLENBQUM7O0FBRXhDLFFBQUMsVUFBVSxRQUFVLE1BQUEsUUFBTUEsSUFBRyxRQUFRLEVBQUMsQ0FBRSxJQUNuQyxPQUFPLFFBQVEsS0FBS0EsSUFBRyxZQUFXOztBQUU1QyxhQUFBLE1BQUEsUUFBTyxJQUFJO0lBQ2YsQ0FBQzs7QUFHRCxNQUFNLHFCQUFOLE1BQXdCO0lBSXBCLFlBQW9CLFFBQXlCO0FBQXpCLFdBQUEsU0FBQTtBQUZaLFdBQUEsU0FBZ0Q7QUFHcEQsV0FBSyxTQUFTLEtBQUssT0FBTyxXQUFXLEVBQUM7QUFNdEMsV0FBSyxPQUFPLFFBQVEsRUFBRSxNQUFNLE1BQUs7TUFBRyxDQUFDO0lBQ3pDO0lBRUEsSUFBSSxTQUFNO0FBQ04sYUFBTyxLQUFLLFNBQVMsS0FBSyxPQUFPLFFBQVEsRUFBRSxNQUFNLE1BQUs7TUFBRyxDQUFDLElBQUksUUFBUSxRQUFPO0lBQ2pGO0lBRUEsY0FBVztBQUNQLFVBQUksS0FBSyxRQUFRO0FBQ2IsYUFBSyxPQUFPLFlBQVc7O0FBRTNCLFdBQUssU0FBUztJQUNsQjtJQUVNLE9BQU8sUUFBWTs7QUFDckIsY0FBTSxFQUFFLFFBQVEsT0FBTSxJQUFLO0FBQzNCLG1CQUFXLE1BQU0sT0FBTyxRQUFRLEVBQUUsTUFBTSxFQUFFLE1BQU0sTUFBSztRQUFHLENBQUM7QUFDekQsbUJBQVcsT0FBTyxRQUFRLEtBQUssS0FBSyxZQUFXO01BQ25ELENBQUM7O0lBRUssS0FBSyxNQUFhOztBQUNwQixZQUFJLFNBQVMsR0FBRztBQUNaLGlCQUFPLEVBQUUsTUFBTSxLQUFLLFVBQVUsTUFBTSxPQUFPLElBQUksV0FBVyxDQUFDLEVBQUM7O0FBRWhFLGNBQU0sU0FBUyxNQUFNLEtBQUssT0FBUSxLQUFJO0FBQ3RDLFNBQUMsT0FBTyxTQUFTLE9BQU8sUUFBUSxhQUFhLE1BQU07QUFDbkQsZUFBTztNQUNYLENBQUM7OztBQVFMLE1BQU0sVUFBVSxDQUFtQixRQUErQixVQUFZO0FBQzFFLFVBQU0sVUFBVSxDQUFDLE1BQVcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzlDLFFBQUk7QUFDSixXQUFPLENBQUMsT0FBTyxTQUFTLElBQUksUUFDeEIsQ0FBQyxPQUFPLFVBQVUsTUFBTSxPQUFPLE1BQU0sRUFBRSxPQUFPLE9BQU8sQ0FBQyxDQUN6RDtFQUNMO0FBR0EsV0FBZ0IsZUFBZSxRQUE2Qjs7QUFFeEQsWUFBTSxTQUFrQixDQUFBO0FBQ3hCLFVBQUksUUFBbUI7QUFDdkIsVUFBSSxPQUFPLE9BQU8sTUFBb0I7QUFDdEMsVUFBSSxLQUFzQixNQUFjLGVBQWU7QUFDdkQsVUFBSSxVQUF3QixDQUFBLEdBQUk7QUFFaEMsZUFBUyxZQUFTO0FBQ2QsWUFBSSxRQUFRLFFBQVE7QUFDaEIsaUJBQU8sZ0JBQWdCLFNBQVMsSUFBSSxFQUFFLENBQUM7O0FBRTNDLFNBQUMsUUFBUSxTQUFTLFlBQVksSUFBSSxnQkFBZ0IsU0FBUyxJQUFJO0FBQy9ELGVBQU87TUFDWDtBQUlBLE9BQUMsRUFBRSxLQUFLLEtBQUksSUFBSyxNQUFBLE1BQUEsUUFBVyxJQUFJO0FBR2hDLFVBQUssT0FBZSxPQUFPLEdBQUc7QUFDMUIsY0FBQSxNQUFBLFFBQU0sSUFBSSxXQUFXLENBQUMsQ0FBQztBQUN2QixlQUFBLE1BQUEsUUFBTyxJQUFJOztBQUdmLFVBQUk7QUFFQSxlQUFPLENBQUMsSUFBSSxRQUFRLFFBQVEsS0FBSztBQUNqQyxlQUFPLENBQUMsSUFBSSxRQUFRLFFBQVEsT0FBTztBQUVuQyxXQUFHO0FBQ0MsaUJBQU8sQ0FBQyxJQUFJLFFBQVEsUUFBUSxVQUFVO0FBR3RDLFdBQUMsT0FBTyxHQUFHLElBQUksTUFBQSxRQUFNLFFBQVEsS0FBSyxPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUcxRCxjQUFJLFVBQVUsU0FBUztBQUFFOztBQUN6QixjQUFJLEVBQUUsT0FBTyxVQUFVLFFBQVE7QUFFM0IsZ0JBQUksQ0FBQyxPQUFPLFNBQVMsT0FBTyxZQUFZLEdBQUc7QUFDdkMsdUJBQVMsYUFBYSxPQUFPLE1BQU0sRUFBQyxDQUFFO21CQUNuQztBQUNILHVCQUFTLGFBQWEsT0FBTyxNQUFNLEVBQUUsT0FBTyxZQUFZLENBQUM7QUFLekQsa0JBQUssT0FBc0IsYUFBYyxPQUFPLGNBQWU7QUFDM0QseUJBQVMsYUFBYSxPQUFPLE1BQU0sRUFBQyxDQUFFOzs7QUFJOUMsZ0JBQUssT0FBc0IsYUFBYSxHQUFHO0FBQ3ZDLHNCQUFRLEtBQUssTUFBb0I7QUFDakMsOEJBQWlCLE9BQXNCOzs7QUFJL0MsY0FBSSxRQUFRLFFBQVEsY0FBYztBQUM5QixlQUFHO0FBQ0MsZUFBQyxFQUFFLEtBQUssS0FBSSxJQUFLLE1BQUEsTUFBQSxRQUFNLFVBQVMsQ0FBRTtxQkFDN0IsT0FBTzs7aUJBRWYsQ0FBQzs7QUFFVixjQUFBLFFBQU0sUUFBUSxRQUFRLFVBQVUsVUFBVSxNQUFNLElBQUksQ0FBQzs7QUFHekQsYUFBQSxNQUFBLFFBQU8sSUFBSTtBQUVYLGVBQVMsUUFBdUNDLFNBQWlCQyxNQUFPO0FBQ3BFLGlCQUFTLFVBQWU7QUFDeEIsZUFBTyxJQUFJLFFBQWMsQ0FBQyxTQUFTLFdBQVU7QUFDekMscUJBQVcsQ0FBQyxLQUFLLEVBQUUsS0FBS0QsU0FBUTtBQUM1QixtQkFBTyxLQUFLLEVBQUUsS0FBSyxFQUFFOztBQUV6QixjQUFJO0FBSUEsa0JBQU0sVUFBVyxPQUFlLFNBQVM7QUFDekMsdUJBQVcsUUFBUSxLQUFLLFFBQVFDLElBQUc7QUFDbkMsWUFBQUEsT0FBTTttQkFDRCxHQUFHO0FBQUUsWUFBQUEsT0FBTSxLQUFVQTs7QUFDMUIsWUFBQUEsUUFBTyxPQUFPLE9BQU9BLElBQUcsSUFBSSxRQUFPOztRQUUzQyxDQUFDO01BQ0w7SUFDSixDQUFDOzs7O0FDMVRELE1BQVk7QUFBWixHQUFBLFNBQVlDLGtCQUFlO0FBSXZCLElBQUFBLGlCQUFBQSxpQkFBQSxJQUFBLElBQUEsQ0FBQSxJQUFBO0FBS0EsSUFBQUEsaUJBQUFBLGlCQUFBLElBQUEsSUFBQSxDQUFBLElBQUE7QUFLQSxJQUFBQSxpQkFBQUEsaUJBQUEsSUFBQSxJQUFBLENBQUEsSUFBQTtBQUtBLElBQUFBLGlCQUFBQSxpQkFBQSxJQUFBLElBQUEsQ0FBQSxJQUFBO0FBV0EsSUFBQUEsaUJBQUFBLGlCQUFBLElBQUEsSUFBQSxDQUFBLElBQUE7RUFDSixHQS9CWSxvQkFBQSxrQkFBZSxDQUFBLEVBQUE7QUFvQzNCLE1BQVk7QUFBWixHQUFBLFNBQVlDLFlBQVM7QUFDakIsSUFBQUEsV0FBQUEsV0FBQSxRQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsV0FBQUEsV0FBQSxPQUFBLElBQUEsQ0FBQSxJQUFBO0VBQ0osR0FIWSxjQUFBLFlBQVMsQ0FBQSxFQUFBO0FBUXJCLE1BQVk7QUFBWixHQUFBLFNBQVlDLFlBQVM7QUFDakIsSUFBQUEsV0FBQUEsV0FBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsV0FBQUEsV0FBQSxRQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsV0FBQUEsV0FBQSxRQUFBLElBQUEsQ0FBQSxJQUFBO0VBQ0osR0FKWSxjQUFBLFlBQVMsQ0FBQSxFQUFBO0FBU3JCLE1BQVk7QUFBWixHQUFBLFNBQVlDLFdBQVE7QUFDaEIsSUFBQUEsVUFBQUEsVUFBQSxLQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsVUFBQUEsVUFBQSxhQUFBLElBQUEsQ0FBQSxJQUFBO0VBQ0osR0FIWSxhQUFBLFdBQVEsQ0FBQSxFQUFBO0FBUXBCLE1BQVk7QUFBWixHQUFBLFNBQVlDLFdBQVE7QUFDaEIsSUFBQUEsVUFBQUEsVUFBQSxRQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsVUFBQUEsVUFBQSxhQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsVUFBQUEsVUFBQSxhQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsVUFBQUEsVUFBQSxZQUFBLElBQUEsQ0FBQSxJQUFBO0VBQ0osR0FMWSxhQUFBLFdBQVEsQ0FBQSxFQUFBO0FBVXBCLE1BQVk7QUFBWixHQUFBLFNBQVlDLGVBQVk7QUFDcEIsSUFBQUEsY0FBQUEsY0FBQSxZQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsY0FBQUEsY0FBQSxVQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsY0FBQUEsY0FBQSxnQkFBQSxJQUFBLENBQUEsSUFBQTtFQUNKLEdBSlksaUJBQUEsZUFBWSxDQUFBLEVBQUE7QUFrQnhCLE1BQVk7QUFBWixHQUFBLFNBQVlDLGdCQUFhO0FBQ3JCLElBQUFBLGVBQUFBLGVBQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLGVBQUFBLGVBQUEsUUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLGVBQUFBLGVBQUEsaUJBQUEsSUFBQSxDQUFBLElBQUE7QUFDQSxJQUFBQSxlQUFBQSxlQUFBLGFBQUEsSUFBQSxDQUFBLElBQUE7QUFDQSxJQUFBQSxlQUFBQSxlQUFBLFFBQUEsSUFBQSxDQUFBLElBQUE7QUFDQSxJQUFBQSxlQUFBQSxlQUFBLGNBQUEsSUFBQSxDQUFBLElBQUE7RUFDSixHQVBZLGtCQUFBLGdCQUFhLENBQUEsRUFBQTtBQW1DekIsTUFBWTtBQUFaLEdBQUEsU0FBWUMsT0FBSTtBQUNaLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsS0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsT0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsUUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsU0FBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLENBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsV0FBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsVUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsTUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsUUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsT0FBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsaUJBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGVBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLEtBQUEsSUFBQSxFQUFBLElBQUE7QUFFQSxJQUFBQSxNQUFBQSxNQUFBLFlBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLE1BQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLE9BQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLE9BQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLE9BQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLE9BQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFFBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFFBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFFBQUEsSUFBQSxFQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFNBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFNBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFNBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFNBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGlCQUFBLElBQUEsR0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxpQkFBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsc0JBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLHNCQUFBLElBQUEsR0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxxQkFBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsWUFBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsaUJBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGlCQUFBLElBQUEsR0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxnQkFBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsWUFBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsYUFBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsaUJBQUEsSUFBQSxHQUFBLElBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLG1CQUFBLElBQUEsR0FBQSxJQUFBO0VBQ0osR0E5Q1ksU0FBQSxPQUFJLENBQUEsRUFB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QUM3Qjs7OztBQ05BLE1BQVlDO0FBQVosR0FBQSxTQUFZQSxPQUFJO0FBQ2QsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxLQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxlQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxRQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxTQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxXQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxVQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxNQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxTQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxPQUFBLElBQUEsRUFBQSxJQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxpQkFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsZUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsS0FBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsVUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsYUFBQSxJQUFBLEVBQUEsSUFBQTtBQUNBLElBQUFBLE1BQUFBLE1B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SSxHQUFHLE1BQU0sS0FBSyxTQUFTLElBQUksRUFBQyxDQUFFO0lBQ2xLO0lBQ08scUJBQXFELE1BQVMsRUFBRSxRQUFRLFVBQVMsSUFBSyxLQUFLLGNBQWEsR0FBRTtBQUM3RyxhQUFPLFNBQVMsRUFBRSxNQUFNLFFBQVEsV0FBVyxZQUFZLEtBQUssZUFBZSxNQUFNLFNBQVMsR0FBRyxNQUFNLEtBQUssU0FBUyxJQUFJLEVBQUMsQ0FBRTtJQUM1SDtJQUNPLFVBQWdDLE1BQVMsRUFBRSxRQUFRLFVBQVMsSUFBSyxLQUFLLGNBQWEsR0FBRTtBQUN4RixhQUFPLFNBQVMsRUFBRSxNQUFNLFFBQVEsV0FBVyxZQUFZLEtBQUssZUFBZSxNQUFNLFNBQVMsR0FBRyxNQUFNLEtBQUssU0FBUyxJQUFJLEVBQUMsQ0FBRTtJQUM1SDtJQUNPLGVBQXlDLE1BQVMsRUFBRSxRQUFRLFVBQVMsSUFBSyxLQUFLLGNBQWEsR0FBRTtBQUNqRyxhQUFPLFNBQVMsRUFBRSxNQUFNLFFBQVEsV0FBVyxZQUFZLEtBQUssZUFBZSxNQUFNLFNBQVMsR0FBRyxNQUFNLEtBQUssU0FBUyxJQUFJLEVBQUMsQ0FBRTtJQUM1SDtJQUNPLFVBQStCLE1BQVMsRUFBRSxRQUFRLFVBQVMsSUFBSyxLQUFLLGNBQWEsR0FBRTtBQUN2RixhQUFPLFNBQVMsRUFBRSxNQUFNLFFBQVEsV0FBVyxZQUFZLEtBQUssZUFBZSxNQUFNLFNBQVMsR0FBRyxNQUFNLEtBQUssU0FBUyxJQUFJLEVBQUMsQ0FBRTtJQUM1SDtJQUNPLGFBQXFDLE1BQVMsRUFBRSxRQUFRLFVBQVMsSUFBSyxLQUFLLGNBQWEsR0FBRTtBQUM3RixhQUFPLFNBQVMsRUFBRSxNQUFNLFFBQVEsV0FBVyxZQUFZLEtBQUssZUFBZSxNQUFNLFNBQVMsR0FBRyxNQUFNLEtBQUssU0FBUyxJQUFJLEVBQUMsQ0FBRTtJQUM1SDtJQUNPLFVBQStCLE1BQVMsRUFBRSxRQUFRLFVBQVMsSUFBSyxLQUFLLGNBQWEsR0FBRTtBQUN2RixhQUFPLFNBQVMsRUFBRSxNQUFNLFFBQVEsV0FBVyxZQUFZ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b0IsTUFBTSxHQUFJO0FBQzlCLHNCQUFvQixNQUFNLEdBQUk7QUFDOUIsZUFBYSxNQUFNLEVBQUc7QUFDdEIsb0JBQWtCLE1BQU0sR0FBSTtBQUM1QixlQUFhLE1BQU0sSUFBSyxPQUFPO0FBQy9CLG9CQUFrQixNQUFNLEtBQU0scUJBQXVDO0FBQ3JFLGtCQUFnQixNQUFNLEVBQUc7QUFDekIsdUJBQXFCLE1BQU0sR0FBSTtBQUMvQixpQkFBZSxNQUFNLEtBQU0sYUFBYSxxQkFBdUM7QUFDL0Usa0JBQWdCLE1BQU0sRUFBRztBQUN6Qix1QkFBcUIsTUFBTSxHQUFJO0FBQy9CLGlCQUFlLE1BQU0sRUFBRztBQUN4QixzQkFBb0IsTUFBTSxHQUFJO0FBQzlCLGdCQUFjLE1BQU0sRUFBRztBQUN2QixxQkFBbUIsTUFBTSxHQUFJO0FBQzdCLG1CQUFpQixNQUFNLEVBQUc7QUFDMUIsd0JBQXNCLE1BQU0sR0FBSTsiLAogICJuYW1lcyI6IFsiaXMyMjQiLCAibWV0aG9kIiwgImJsb2NrcyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJEdWNrREIiLCAiZXJyIiwgImdldEJpbmFyeSIsICJpbnN0YW5jZSIsICJmZCIsICJ0bXAiLCAiTW9kdWxlIiwgIm91dCIsICJmYW1pbHkiLCAidHlwZSIsICJwcm90byIsICJhZGRyIiwgInBvcnQiLCAiYWkiLCAic3VtIiwgImRhdGUiLCAicmV0IiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkR1Y2tEQiIsICJlcnIiLCAiZ2V0QmluYXJ5IiwgImluc3RhbmNlIiwgImZkIiwgInRtcCIsICJNb2R1bGUiLCAib3V0IiwgImZhbWlseSIsICJ0eXBlIiwgInByb3RvIiwgImFkZHIiLCAicG9ydCIsICJhaSIsICJzdW0iLCAiZGF0ZSIsICJyZXQiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAidiIsICJpdCIsICJzb3VyY2UiLCAicHVtcCIsICJpdCIsICJldmVudHMiLCAiZXJyIiwgIk1ldGFkYXRhVmVyc2lvbiIsICJVbmlvbk1vZGUiLCAiUHJlY2lzaW9uIiwgIkRhdGVVbml0IiwgIlRpbWVVbml0IiwgIkludGVydmFsVW5pdCIsICJNZXNzYWdlSGVhZGVyIiwgIlR5cGUiLCAiQnVmZmVyVHlwZSIsICJ4IiwgIl9hIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgIl9hIiwgImluc3RhbmNlIiwgImdldEJvb2wiLCAic2V0Qm9vbCIsICJzdW0iLCAiYnl0ZUxlbmd0aCIsICJudWxsQml0bWFwIiwgImxlbmd0aCIsICJnZXRCb29sIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgIl9hIiwgIl9iIiwgIl9kIiwgIl9jIiwgImluc3RhbmNlIiwgImJlZ2luIiwgImVuZCIsICJuZXdEYXRhIiwgIl9hIiwgInNpemUiLCAiX2EiLCAiX2IiLCAiX2MiLCAiX2QiLCAiRW5jb2RpbmciLCAiQnVpbGRlciIsICJNZXRhZGF0YVZlcnNpb24iLCAiRW5kaWFubmVzcyIsICJEaWN0aW9uYXJ5S2luZCIsICJCaW5hcnkiLCAiQm9vbCIsICJEYXRlVW5pdCIsICJEYXRlIiwgIkRhdGVVbml0IiwgIkRlY2ltYWwiLCAiVGltZVVuaXQiLCAiRml4ZWRTaXplQmluYXJ5IiwgIkZpeGVkU2l6ZUxpc3QiLCAiUHJlY2lzaW9uIiwgIlByZWNpc2lvbiIsICJJbnRlcnZhbFVuaXQiLCAiSW50ZXJ2YWxVbml0IiwgIkxpc3QiLCAiTWFwIiwgIk51bGwiLCAiVGltZVVuaXQiLCAiVGltZVVuaXQiLCAiVW5pb25Nb2RlIiwgIlVuaW9uTW9kZSIsICJVdGY4IiwgIlR5cGUiLCAiVHlwZSIsICJNZXRhZGF0YVZlcnNpb24iLCAiU2NoZW1hIiwgIkZpZWxkIiwgIkJ1aWxkZXIiLCAiQnl0ZUJ1ZmZlciIsICJTY2hlbWEiLCAiZGIiLCAiX2QiLCAiX2UiLCAiX2YiLCAiX2EiLCAiX2MiLCAiSW50NjQiLCAiVWludDY0IiwgInN1bSIsICJGaWVsZCIsICJJbnQ2NCIsICJGaWVsZCIsICJGaWVsZCIsICJGaWVsZCIsICJGaWVsZCIsICJGaWVsZCIsICJpbnN0YW5jZSIsICJpbnN0YW5jZSIsICJpbnN0YW5jZSIsICJ0eXBlIiwgIkZpZWxkIiwgIl9hIiwgIlNjaGVtYSIsICJzY2hlbWEiLCAiRmllbGQiLCAiYmF0Y2hlcyIsICJfYyIsICJfYiIsICJpbnN0YW5jZSIsICJkYXRhIiwgImluZGljZXMiLCAib2xkVG9OZXciLCAiX2EiLCAiU2NoZW1hIiwgIkZpZWxkIiwgImluc3RhbmNlIiwgIl9iIiwgIl9hIiwgIkJvZHlDb21wcmVzc2lvbk1ldGhvZCIsICJDb21wcmVzc2lvblR5cGUiLCAibWV0aG9kIiwgIkJ1ZmZlciIsICJSZWNvcmRCYXRjaCIsICJCdWZmZXIiLCAiUmVjb3JkQmF0Y2giLCAiTWVzc2FnZUhlYWRlciIsICJNZXRhZGF0YVZlcnNpb24iLCAiTWVzc2FnZUhlYWRlciIsICJOdWxsIiwgIkJpbmFyeSIsICJCb29sIiwgIlV0ZjgiLCAiRGVjaW1hbCIsICJEYXRlIiwgIkxpc3QiLCAiRml4ZWRTaXplQmluYXJ5IiwgIkZpeGVkU2l6ZUxpc3QiLCAiTWFwIiwgImluc3RhbmNlIiwgIlNjaGVtYSIsICJSZWNvcmRCYXRjaCIsICJEaWN0aW9uYXJ5QmF0Y2giLCAiRmllbGQiLCAiRmllbGROb2RlIiwgInN1bSIsICJCdWlsZGVyIiwgIkJ5dGVCdWZmZXIiLCAiTWVzc2FnZSIsICJTY2hlbWEiLCAiUmVjb3JkQmF0Y2giLCAiRGljdGlvbmFyeUJhdGNoIiwgIkZpZWxkTm9kZSIsICJGaWVsZCIsICJUeXBlIiwgIkRlY2ltYWwiLCAiRGF0ZSIsICJGaXhlZFNpemVCaW5hcnkiLCAiRml4ZWRTaXplTGlzdCIsICJNYXAiLCAiaW5zdGFuY2UiLCAiQnVmZmVyIiwgIk1lc3NhZ2UiLCAiX2EiLCAiX2QiLCAiX2UiLCAiX2YiLCAiX2MiLCAic2VsZiIsICJGaWVsZE5vZGUiLCAiTWVzc2FnZSIsICJSZWNvcmRCYXRjaCIsICJEaWN0aW9uYXJ5QmF0Y2giLCAiX2EiLCAiX2IiLCAiX2QiLCAiaXQiLCAiX2EiLCAicmVhZGVyIiwgInRtcCIsICJkZWNvZGVyIiwgImY2NCIsICJibG9ja3MiLCAiVEVYVF9FTkNPREVSIiwgIndvcmtlciIsICJURVhUX0VOQ09ERVIiLCAiZSIsICJtZXRob2QiLCAieGhyIiwgInJlc3VsdCIsICJyZXNwb25zZSIsICJEdWNrREJXYXNtIiwgIkR1Y2tEQiIsICJEdWNrREJXYXNtIiwgIkR1Y2tEQiIsICJkYiIsICJURVhUX0VOQ09ERVIiLCAid29ya2VyIiwgIl9wIiwgIldvcmtlciIsICJkYiIsICJtb2R1bGUiLCAiYWRiIiwgInJlc29sdmVEYXRhIiwgImRiIiwgImJhc2VVUkwiLCAiYWRiIiwgImRiIiwgInRlc3RSb3dzIiwgImRiIiwgImRlY29kZXIiLCAiZGIiLCAicmVzb2x2ZURhdGEiLCAiU2NoZW1hIiwgIkZpZWxkIiwgImRiIiwgImVuY29kZXIiLCAiZGIiLCAiZGVzY3JpYmVCcm93c2VyIiwgImVuY29kZXIiLCAiVEVTVF9GSUxFIiwgImRiIiwgImRiIiwgImRiIiwgImRiIiwgImFkYiIsICJkYiIsICJkYiIsICJkYiIsICJkYiIsICJhZGIiLCAiZGIiXQp9Cg==
