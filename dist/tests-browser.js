"use strict";
var duckdb = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "../../node_modules/tslib/tslib.js"(exports2, module2) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __classPrivateFieldIn2;
      var __createBinding2;
      (function(factory) {
        var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports3) {
            factory(createExporter(root2, createExporter(exports3)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root2, createExporter(module2.exports)));
        } else {
          factory(createExporter(root2));
        }
        function createExporter(exports3, previous) {
          if (exports3 !== root2) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports3, "__esModule", { value: true });
            } else {
              exports3.__esModule = true;
            }
          }
          return function(id, v) {
            return exports3[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends2 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest2 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding2(o, m, p);
        };
        __createBinding2 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values2 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read2(arguments[i]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray2 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await2 = function(v) {
          return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues2 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding2(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn2 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
      });
    }
  });

  // ../../node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "../../node_modules/js-sha256/src/sha256.js"(exports, module) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createOutputMethod(type, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createHmacOutputMethod(type, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // ../../node_modules/web-worker/cjs/browser.js
  var require_browser = __commonJS({
    "../../node_modules/web-worker/cjs/browser.js"(exports2, module2) {
      module2.exports = Worker;
    }
  });

  // ../../node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // ../../node_modules/apache-arrow/util/buffer.mjs
  var buffer_exports = {};
  __export(buffer_exports, {
    compareArrayLike: () => compareArrayLike,
    joinUint8Arrays: () => joinUint8Arrays,
    memcpy: () => memcpy,
    rebaseValueOffsets: () => rebaseValueOffsets,
    toArrayBufferView: () => toArrayBufferView,
    toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
    toArrayBufferViewIterator: () => toArrayBufferViewIterator,
    toBigInt64Array: () => toBigInt64Array,
    toBigUint64Array: () => toBigUint64Array,
    toFloat32Array: () => toFloat32Array,
    toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
    toFloat32ArrayIterator: () => toFloat32ArrayIterator,
    toFloat64Array: () => toFloat64Array,
    toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
    toFloat64ArrayIterator: () => toFloat64ArrayIterator,
    toInt16Array: () => toInt16Array,
    toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
    toInt16ArrayIterator: () => toInt16ArrayIterator,
    toInt32Array: () => toInt32Array,
    toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
    toInt32ArrayIterator: () => toInt32ArrayIterator,
    toInt8Array: () => toInt8Array,
    toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
    toInt8ArrayIterator: () => toInt8ArrayIterator,
    toUint16Array: () => toUint16Array,
    toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
    toUint16ArrayIterator: () => toUint16ArrayIterator,
    toUint32Array: () => toUint32Array,
    toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
    toUint32ArrayIterator: () => toUint32ArrayIterator,
    toUint8Array: () => toUint8Array,
    toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
    toUint8ArrayIterator: () => toUint8ArrayIterator,
    toUint8ClampedArray: () => toUint8ClampedArray,
    toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
    toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
  });

  // ../../node_modules/apache-arrow/util/utf8.mjs
  var decoder = new TextDecoder("utf-8");
  var decodeUtf8 = (buffer) => decoder.decode(buffer);
  var encoder = new TextEncoder();
  var encodeUtf8 = (value) => encoder.encode(value);

  // ../../node_modules/apache-arrow/util/compat.mjs
  var [BigIntCtor, BigIntAvailable] = (() => {
    const BigIntUnavailableError = () => {
      throw new Error("BigInt is not available in this environment");
    };
    function BigIntUnavailable() {
      throw BigIntUnavailableError();
    }
    BigIntUnavailable.asIntN = () => {
      throw BigIntUnavailableError();
    };
    BigIntUnavailable.asUintN = () => {
      throw BigIntUnavailableError();
    };
    return typeof BigInt !== "undefined" ? [BigInt, true] : [BigIntUnavailable, false];
  })();
  var [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {
    const BigInt64ArrayUnavailableError = () => {
      throw new Error("BigInt64Array is not available in this environment");
    };
    class BigInt64ArrayUnavailable {
      static get BYTES_PER_ELEMENT() {
        return 8;
      }
      static of() {
        throw BigInt64ArrayUnavailableError();
      }
      static from() {
        throw BigInt64ArrayUnavailableError();
      }
      constructor() {
        throw BigInt64ArrayUnavailableError();
      }
    }
    return typeof BigInt64Array !== "undefined" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];
  })();
  var [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {
    const BigUint64ArrayUnavailableError = () => {
      throw new Error("BigUint64Array is not available in this environment");
    };
    class BigUint64ArrayUnavailable {
      static get BYTES_PER_ELEMENT() {
        return 8;
      }
      static of() {
        throw BigUint64ArrayUnavailableError();
      }
      static from() {
        throw BigUint64ArrayUnavailableError();
      }
      constructor() {
        throw BigUint64ArrayUnavailableError();
      }
    }
    return typeof BigUint64Array !== "undefined" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
  })();
  var isNumber = (x) => typeof x === "number";
  var isBoolean = (x) => typeof x === "boolean";
  var isFunction = (x) => typeof x === "function";
  var isObject = (x) => x != null && Object(x) === x;
  var isPromise = (x) => {
    return isObject(x) && isFunction(x.then);
  };
  var isIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.iterator]);
  };
  var isAsyncIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.asyncIterator]);
  };
  var isArrowJSON = (x) => {
    return isObject(x) && isObject(x["schema"]);
  };
  var isIteratorResult = (x) => {
    return isObject(x) && "done" in x && "value" in x;
  };
  var isFileHandle = (x) => {
    return isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
  };
  var isFetchResponse = (x) => {
    return isObject(x) && isReadableDOMStream(x["body"]);
  };
  var isReadableInterop = (x) => "_getDOMStream" in x && "_getNodeStream" in x;
  var isWritableDOMStream = (x) => {
    return isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !isReadableInterop(x);
  };
  var isReadableDOMStream = (x) => {
    return isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !isReadableInterop(x);
  };
  var isWritableNodeStream = (x) => {
    return isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !isReadableInterop(x);
  };
  var isReadableNodeStream = (x) => {
    return isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !isReadableInterop(x);
  };
  var isFlatbuffersByteBuffer = (x) => {
    return isObject(x) && isFunction(x["clear"]) && isFunction(x["bytes"]) && isFunction(x["position"]) && isFunction(x["setPosition"]) && isFunction(x["capacity"]) && isFunction(x["getBufferIdentifier"]) && isFunction(x["createLong"]);
  };

  // ../../node_modules/apache-arrow/util/buffer.mjs
  var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
  function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n; ) {
      x = result[j];
      y = chunks[i];
      if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
        y && (result[++j] = y);
        continue;
      }
      ({ byteOffset: xOffset, byteLength: xLen } = x);
      ({ byteOffset: yOffset, byteLength: yLen } = y);
      if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
        y && (result[++j] = y);
        continue;
      }
      result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
  }
  function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
  }
  function joinUint8Arrays(chunks, size) {
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n; ) {
      source = result[index];
      sliced = source.subarray(0, Math.min(source.length, length - offset));
      if (length <= offset + sliced.length) {
        if (sliced.length < source.length) {
          result[index] = source.subarray(sliced.length);
        } else if (sliced.length === source.length) {
          index++;
        }
        buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
        break;
      }
      memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
      offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
  }
  function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
      if (ArrayBufferViewCtor === Uint8Array) {
        return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
      }
      return value;
    }
    if (!value) {
      return new ArrayBufferViewCtor(0);
    }
    if (typeof value === "string") {
      value = encodeUtf8(value);
    }
    if (value instanceof ArrayBuffer) {
      return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
      return new ArrayBufferViewCtor(value);
    }
    if (isFlatbuffersByteBuffer(value)) {
      return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
  }
  var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
  var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
  var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
  var toBigInt64Array = (input) => toArrayBufferView(BigInt64ArrayCtor, input);
  var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
  var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
  var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
  var toBigUint64Array = (input) => toArrayBufferView(BigUint64ArrayCtor, input);
  var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
  var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
  var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
  var pump = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) {
      yield x;
    };
    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable(source) ? wrap(source) : source;
    yield* pump(function* (it2) {
      let r = null;
      do {
        r = it2.next(yield toArrayBufferView(ArrayCtor, r));
      } while (!r.done);
    }(buffers[Symbol.iterator]()));
    return new ArrayCtor();
  }
  var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
  var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
  var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
  var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
  var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
  var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
  var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
  var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
  var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
  function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
      if (isPromise(source)) {
        return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
      }
      const wrap = function(x) {
        return __asyncGenerator(this, arguments, function* () {
          yield yield __await(yield __await(x));
        });
      };
      const emit = function(source2) {
        return __asyncGenerator(this, arguments, function* () {
          yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it2) {
            let r = null;
            do {
              r = it2.next(yield r === null || r === void 0 ? void 0 : r.value);
            } while (!r.done);
          }(source2[Symbol.iterator]())))));
        });
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;
      yield __await(
        yield* __asyncDelegator(__asyncValues(pump(function(it2) {
          return __asyncGenerator(this, arguments, function* () {
            let r = null;
            do {
              r = yield __await(it2.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
            } while (!r.done);
          });
        }(buffers[Symbol.asyncIterator]()))))
      );
      return yield __await(new ArrayCtor());
    });
  }
  var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
  var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
  var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
  var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
  var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
  var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
  var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
  var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
  var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
  function rebaseValueOffsets(offset, length, valueOffsets) {
    if (offset !== 0) {
      valueOffsets = valueOffsets.slice(0, length + 1);
      for (let i = -1; ++i <= length; ) {
        valueOffsets[i] += offset;
      }
    }
    return valueOffsets;
  }
  function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
      return false;
    }
    if (n > 0) {
      do {
        if (a[i] !== b[i]) {
          return false;
        }
      } while (++i < n);
    }
    return true;
  }

  // ../../node_modules/apache-arrow/io/adapters.mjs
  var adapters_default = {
    fromIterable(source) {
      return pump2(fromIterable(source));
    },
    fromAsyncIterable(source) {
      return pump2(fromAsyncIterable(source));
    },
    fromDOMStream(source) {
      return pump2(fromDOMStream(source));
    },
    fromNodeStream(stream) {
      return pump2(fromNodeStream(stream));
    },
    toDOMStream(source, options) {
      throw new Error(`"toDOMStream" not available in this environment`);
    },
    toNodeStream(source, options) {
      throw new Error(`"toNodeStream" not available in this environment`);
    }
  };
  var pump2 = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield null);
    const it2 = toUint8ArrayIterator(source)[Symbol.iterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it2.next() : it2.next(size - bufferLength));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield byteRange());
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it2.throw === "function" && it2.throw(e);
    } finally {
      threw === false && typeof it2.return === "function" && it2.return(null);
    }
    return null;
  }
  function fromAsyncIterable(source) {
    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2.next()) : yield __await(it2.next(size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it2.throw === "function" && (yield __await(it2.throw(e)));
      } finally {
        threw === false && typeof it2.return === "function" && (yield __await(it2.return(new Uint8Array(0))));
      }
      return yield __await(null);
    });
  }
  function fromDOMStream(source) {
    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
      let done = false, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = new AdaptiveByteReader(source);
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2["read"]()) : yield __await(it2["read"](size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(toUint8Array(buffer));
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && (yield __await(it2["cancel"](e)));
      } finally {
        threw === false ? yield __await(it2["cancel"]()) : source["locked"] && it2.releaseLock();
      }
      return yield __await(null);
    });
  }
  var AdaptiveByteReader = class {
    constructor(source) {
      this.source = source;
      this.reader = null;
      this.reader = this.source["getReader"]();
      this.reader["closed"].catch(() => {
      });
    }
    get closed() {
      return this.reader ? this.reader["closed"].catch(() => {
      }) : Promise.resolve();
    }
    releaseLock() {
      if (this.reader) {
        this.reader.releaseLock();
      }
      this.reader = null;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        const { reader, source } = this;
        reader && (yield reader["cancel"](reason).catch(() => {
        }));
        source && (source["locked"] && this.releaseLock());
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        if (size === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = yield this.reader.read();
        !result.done && (result.value = toUint8Array(result));
        return result;
      });
    }
  };
  var onEvent = (stream, event) => {
    const handler = (_) => resolve([event, _]);
    let resolve;
    return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
  };
  function fromNodeStream(stream) {
    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
      const events = [];
      let event = "error";
      let done = false, err = null;
      let cmd, size, bufferLength = 0;
      let buffers = [], buffer;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      if (stream["isTTY"]) {
        yield yield __await(new Uint8Array(0));
        return yield __await(null);
      }
      try {
        events[0] = onEvent(stream, "end");
        events[1] = onEvent(stream, "error");
        do {
          events[2] = onEvent(stream, "readable");
          [event, err] = yield __await(Promise.race(events.map((x) => x[2])));
          if (event === "error") {
            break;
          }
          if (!(done = event === "end")) {
            if (!Number.isFinite(size - bufferLength)) {
              buffer = toUint8Array(stream["read"]());
            } else {
              buffer = toUint8Array(stream["read"](size - bufferLength));
              if (buffer.byteLength < size - bufferLength) {
                buffer = toUint8Array(stream["read"]());
              }
            }
            if (buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } finally {
        yield __await(cleanup(events, event === "error" ? err : null));
      }
      return yield __await(null);
      function cleanup(events2, err2) {
        buffer = buffers = null;
        return new Promise((resolve, reject) => {
          for (const [evt, fn] of events2) {
            stream["off"](evt, fn);
          }
          try {
            const destroy = stream["destroy"];
            destroy && destroy.call(stream, err2);
            err2 = void 0;
          } catch (e) {
            err2 = e || err2;
          } finally {
            err2 != null ? reject(err2) : resolve();
          }
        });
      }
    });
  }

  // ../../node_modules/apache-arrow/enum.mjs
  var MetadataVersion;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion || (MetadataVersion = {}));
  var UnionMode;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode || (UnionMode = {}));
  var Precision;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision || (Precision = {}));
  var DateUnit;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit || (DateUnit = {}));
  var TimeUnit;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit || (TimeUnit = {}));
  var IntervalUnit;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit || (IntervalUnit = {}));
  var MessageHeader;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader || (MessageHeader = {}));
  var Type;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["Float"] = 3] = "Float";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct"] = 13] = "Struct";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Dictionary"] = -1] = "Dictionary";
    Type3[Type3["Int8"] = -2] = "Int8";
    Type3[Type3["Int16"] = -3] = "Int16";
    Type3[Type3["Int32"] = -4] = "Int32";
    Type3[Type3["Int64"] = -5] = "Int64";
    Type3[Type3["Uint8"] = -6] = "Uint8";
    Type3[Type3["Uint16"] = -7] = "Uint16";
    Type3[Type3["Uint32"] = -8] = "Uint32";
    Type3[Type3["Uint64"] = -9] = "Uint64";
    Type3[Type3["Float16"] = -10] = "Float16";
    Type3[Type3["Float32"] = -11] = "Float32";
    Type3[Type3["Float64"] = -12] = "Float64";
    Type3[Type3["DateDay"] = -13] = "DateDay";
    Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
    Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
    Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
    Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
    Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
    Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  })(Type || (Type = {}));
  var BufferType;
  (function(BufferType2) {
    BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
    BufferType2[BufferType2["DATA"] = 1] = "DATA";
    BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
    BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
  })(BufferType || (BufferType = {}));

  // ../../node_modules/apache-arrow/util/vector.mjs
  var vector_exports = {};
  __export(vector_exports, {
    clampIndex: () => clampIndex,
    clampRange: () => clampRange,
    createElementComparator: () => createElementComparator
  });

  // ../../node_modules/apache-arrow/util/pretty.mjs
  var undf = void 0;
  function valueToString(x) {
    if (x === null) {
      return "null";
    }
    if (x === undf) {
      return "undefined";
    }
    switch (typeof x) {
      case "number":
        return `${x}`;
      case "bigint":
        return `${x}`;
      case "string":
        return `"${x}"`;
    }
    if (typeof x[Symbol.toPrimitive] === "function") {
      return x[Symbol.toPrimitive]("string");
    }
    if (ArrayBuffer.isView(x)) {
      if (x instanceof BigInt64ArrayCtor || x instanceof BigUint64ArrayCtor) {
        return `[${[...x].map((x2) => valueToString(x2))}]`;
      }
      return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
  }

  // ../../node_modules/apache-arrow/util/bn.mjs
  var bn_exports = {};
  __export(bn_exports, {
    BN: () => BN,
    bignumToBigInt: () => bignumToBigInt,
    bignumToString: () => bignumToString,
    isArrowBigNumSymbol: () => isArrowBigNumSymbol
  });
  var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
  function BigNum(x, ...xs) {
    if (xs.length === 0) {
      return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
  }
  BigNum.prototype[isArrowBigNumSymbol] = true;
  BigNum.prototype.toJSON = function() {
    return `"${bignumToString(this)}"`;
  };
  BigNum.prototype.valueOf = function() {
    return bignumToNumber(this);
  };
  BigNum.prototype.toString = function() {
    return bignumToString(this);
  };
  BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
    switch (hint) {
      case "number":
        return bignumToNumber(this);
      case "string":
        return bignumToString(this);
      case "default":
        return bignumToBigInt(this);
    }
    return bignumToString(this);
  };
  function SignedBigNum(...args) {
    return BigNum.apply(this, args);
  }
  function UnsignedBigNum(...args) {
    return BigNum.apply(this, args);
  }
  function DecimalBigNum(...args) {
    return BigNum.apply(this, args);
  }
  Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
  Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64ArrayCtor });
  Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64ArrayCtor });
  Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64ArrayCtor });
  function bignumToNumber(bn) {
    const { buffer, byteOffset, length, "signed": signed } = bn;
    const words = new BigUint64ArrayCtor(buffer, byteOffset, length);
    const negative = signed && words[words.length - 1] & BigInt(1) << BigInt(63);
    let number = negative ? BigInt(1) : BigInt(0);
    let i = BigInt(0);
    if (!negative) {
      for (const word of words) {
        number += word * (BigInt(1) << BigInt(32) * i++);
      }
    } else {
      for (const word of words) {
        number += ~word * (BigInt(1) << BigInt(32) * i++);
      }
      number *= BigInt(-1);
    }
    return number;
  }
  var bignumToString;
  var bignumToBigInt;
  if (!BigIntAvailable) {
    bignumToString = decimalToString;
    bignumToBigInt = bignumToString;
  } else {
    bignumToBigInt = (a) => a.byteLength === 8 ? new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0] : decimalToString(a);
    bignumToString = (a) => a.byteLength === 8 ? `${new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a);
  }
  function decimalToString(a) {
    let digits = "";
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
      for (base64[0] = base32[i = 0]; i < n; ) {
        base32[i++] = base64[1] = base64[0] / 10;
        base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
      }
      base32[i] = base64[1] = base64[0] / 10;
      base64[0] = base64[0] - base64[1] * 10;
      digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
  }
  var BN = class {
    static new(num, isSigned) {
      switch (isSigned) {
        case true:
          return new SignedBigNum(num);
        case false:
          return new UnsignedBigNum(num);
      }
      switch (num.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case BigInt64ArrayCtor:
          return new SignedBigNum(num);
      }
      if (num.byteLength === 16) {
        return new DecimalBigNum(num);
      }
      return new UnsignedBigNum(num);
    }
    static signed(num) {
      return new SignedBigNum(num);
    }
    static unsigned(num) {
      return new UnsignedBigNum(num);
    }
    static decimal(num) {
      return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
      return BN.new(num, isSigned);
    }
  };

  // ../../node_modules/apache-arrow/type.mjs
  var _a;
  var _b;
  var _c;
  var _d;
  var _e;
  var _f;
  var _g;
  var _h;
  var _j;
  var _k;
  var _l;
  var _m;
  var _o;
  var _p;
  var _q;
  var _r;
  var _s;
  var _t;
  var _u;
  var DataType = class {
    static isNull(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Null;
    }
    static isInt(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Int;
    }
    static isFloat(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Float;
    }
    static isBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Binary;
    }
    static isUtf8(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Utf8;
    }
    static isBool(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Bool;
    }
    static isDecimal(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Decimal;
    }
    static isDate(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Date;
    }
    static isTime(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Time;
    }
    static isTimestamp(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Timestamp;
    }
    static isInterval(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Interval;
    }
    static isList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.List;
    }
    static isStruct(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Struct;
    }
    static isUnion(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Union;
    }
    static isFixedSizeBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeBinary;
    }
    static isFixedSizeList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeList;
    }
    static isMap(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Map;
    }
    static isDictionary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Dictionary;
    }
    static isDenseUnion(x) {
      return DataType.isUnion(x) && x.mode === UnionMode.Dense;
    }
    static isSparseUnion(x) {
      return DataType.isUnion(x) && x.mode === UnionMode.Sparse;
    }
    get typeId() {
      return Type.NONE;
    }
  };
  _a = Symbol.toStringTag;
  DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    return proto[Symbol.toStringTag] = "DataType";
  })(DataType.prototype);
  var Null = class extends DataType {
    toString() {
      return `Null`;
    }
    get typeId() {
      return Type.Null;
    }
  };
  _b = Symbol.toStringTag;
  Null[_b] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null.prototype);
  var Int_ = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 8:
          return this.isSigned ? Int8Array : Uint8Array;
        case 16:
          return this.isSigned ? Int16Array : Uint16Array;
        case 32:
          return this.isSigned ? Int32Array : Uint32Array;
        case 64:
          return this.isSigned ? BigInt64ArrayCtor : BigUint64ArrayCtor;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
    }
  };
  _c = Symbol.toStringTag;
  Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Int";
  })(Int_.prototype);
  var Int8 = class extends Int_ {
    constructor() {
      super(true, 8);
    }
    get ArrayType() {
      return Int8Array;
    }
  };
  var Int16 = class extends Int_ {
    constructor() {
      super(true, 16);
    }
    get ArrayType() {
      return Int16Array;
    }
  };
  var Int32 = class extends Int_ {
    constructor() {
      super(true, 32);
    }
    get ArrayType() {
      return Int32Array;
    }
  };
  var Int64 = class extends Int_ {
    constructor() {
      super(true, 64);
    }
    get ArrayType() {
      return BigInt64ArrayCtor;
    }
  };
  var Uint8 = class extends Int_ {
    constructor() {
      super(false, 8);
    }
    get ArrayType() {
      return Uint8Array;
    }
  };
  var Uint16 = class extends Int_ {
    constructor() {
      super(false, 16);
    }
    get ArrayType() {
      return Uint16Array;
    }
  };
  var Uint32 = class extends Int_ {
    constructor() {
      super(false, 32);
    }
    get ArrayType() {
      return Uint32Array;
    }
  };
  var Uint64 = class extends Int_ {
    constructor() {
      super(false, 64);
    }
    get ArrayType() {
      return BigUint64ArrayCtor;
    }
  };
  Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
  Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
  Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
  Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64ArrayCtor });
  Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
  Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
  Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64ArrayCtor });
  var Float = class extends DataType {
    constructor(precision) {
      super();
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get ArrayType() {
      switch (this.precision) {
        case Precision.HALF:
          return Uint16Array;
        case Precision.SINGLE:
          return Float32Array;
        case Precision.DOUBLE:
          return Float64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `Float${this.precision << 5 || 16}`;
    }
  };
  _d = Symbol.toStringTag;
  Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = "Float";
  })(Float.prototype);
  var Float16 = class extends Float {
    constructor() {
      super(Precision.HALF);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
  Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return `Binary`;
    }
  };
  _e = Symbol.toStringTag;
  Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Binary";
  })(Binary.prototype);
  var Utf8 = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Utf8;
    }
    toString() {
      return `Utf8`;
    }
  };
  _f = Symbol.toStringTag;
  Utf8[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Utf8";
  })(Utf8.prototype);
  var Bool = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Bool;
    }
    toString() {
      return `Bool`;
    }
  };
  _g = Symbol.toStringTag;
  Bool[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Bool";
  })(Bool.prototype);
  var Decimal = class extends DataType {
    constructor(scale, precision, bitWidth = 128) {
      super();
      this.scale = scale;
      this.precision = precision;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Decimal;
    }
    toString() {
      return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
    }
  };
  _h = Symbol.toStringTag;
  Decimal[_h] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = "Decimal";
  })(Decimal.prototype);
  var Date_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    toString() {
      return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
  };
  _j = Symbol.toStringTag;
  Date_[_j] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Date";
  })(Date_.prototype);
  var DateDay = class extends Date_ {
    constructor() {
      super(DateUnit.DAY);
    }
  };
  var DateMillisecond = class extends Date_ {
    constructor() {
      super(DateUnit.MILLISECOND);
    }
  };
  var Time_ = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 32:
          return Int32Array;
        case 64:
          return BigInt64ArrayCtor;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  };
  _k = Symbol.toStringTag;
  Time_[_k] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Time";
  })(Time_.prototype);
  var Timestamp_ = class extends DataType {
    constructor(unit, timezone) {
      super();
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    toString() {
      return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
    }
  };
  _l = Symbol.toStringTag;
  Timestamp_[_l] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Timestamp";
  })(Timestamp_.prototype);
  var TimestampSecond = class extends Timestamp_ {
    constructor(timezone) {
      super(TimeUnit.SECOND, timezone);
    }
  };
  var Interval_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    toString() {
      return `Interval<${IntervalUnit[this.unit]}>`;
    }
  };
  _m = Symbol.toStringTag;
  Interval_[_m] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Interval";
  })(Interval_.prototype);
  var List = class extends DataType {
    constructor(child) {
      super();
      this.children = [child];
    }
    get typeId() {
      return Type.List;
    }
    toString() {
      return `List<${this.valueType}>`;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
  };
  _o = Symbol.toStringTag;
  List[_o] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "List";
  })(List.prototype);
  var Struct = class extends DataType {
    constructor(children) {
      super();
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _p = Symbol.toStringTag;
  Struct[_p] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "Struct";
  })(Struct.prototype);
  var Union_ = class extends DataType {
    constructor(mode, typeIds, children) {
      super();
      this.mode = mode;
      this.children = children;
      this.typeIds = typeIds = Int32Array.from(typeIds);
      this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
    }
    get typeId() {
      return Type.Union;
    }
    toString() {
      return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
  };
  _q = Symbol.toStringTag;
  Union_[_q] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = "Union";
  })(Union_.prototype);
  var FixedSizeBinary = class extends DataType {
    constructor(byteWidth) {
      super();
      this.byteWidth = byteWidth;
    }
    get typeId() {
      return Type.FixedSizeBinary;
    }
    toString() {
      return `FixedSizeBinary[${this.byteWidth}]`;
    }
  };
  _r = Symbol.toStringTag;
  FixedSizeBinary[_r] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "FixedSizeBinary";
  })(FixedSizeBinary.prototype);
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
    toString() {
      return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
  };
  _s = Symbol.toStringTag;
  FixedSizeList[_s] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = "FixedSizeList";
  })(FixedSizeList.prototype);
  var Map_ = class extends DataType {
    constructor(child, keysSorted = false) {
      super();
      this.children = [child];
      this.keysSorted = keysSorted;
    }
    get typeId() {
      return Type.Map;
    }
    get keyType() {
      return this.children[0].type.children[0].type;
    }
    get valueType() {
      return this.children[0].type.children[1].type;
    }
    get childType() {
      return this.children[0].type;
    }
    toString() {
      return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _t = Symbol.toStringTag;
  Map_[_t] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = "Map_";
  })(Map_.prototype);
  var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
  var Dictionary = class extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
      super();
      this.indices = indices;
      this.dictionary = dictionary;
      this.isOrdered = isOrdered || false;
      this.id = id == null ? getId() : typeof id === "number" ? id : id.low;
    }
    get typeId() {
      return Type.Dictionary;
    }
    get children() {
      return this.dictionary.children;
    }
    get valueType() {
      return this.dictionary;
    }
    get ArrayType() {
      return this.dictionary.ArrayType;
    }
    toString() {
      return `Dictionary<${this.indices}, ${this.dictionary}>`;
    }
  };
  _u = Symbol.toStringTag;
  Dictionary[_u] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = "Dictionary";
  })(Dictionary.prototype);
  function strideForType(type) {
    const t = type;
    switch (type.typeId) {
      case Type.Decimal:
        return type.bitWidth / 32;
      case Type.Timestamp:
        return 2;
      case Type.Date:
        return 1 + t.unit;
      case Type.Interval:
        return 1 + t.unit;
      case Type.FixedSizeList:
        return t.listSize;
      case Type.FixedSizeBinary:
        return t.byteWidth;
      default:
        return 1;
    }
  }

  // ../../node_modules/apache-arrow/visitor.mjs
  var Visitor = class {
    visitMany(nodes, ...args) {
      return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
    }
    visit(...args) {
      return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
      return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
      return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) {
      return null;
    }
    visitBool(_node, ..._args) {
      return null;
    }
    visitInt(_node, ..._args) {
      return null;
    }
    visitFloat(_node, ..._args) {
      return null;
    }
    visitUtf8(_node, ..._args) {
      return null;
    }
    visitBinary(_node, ..._args) {
      return null;
    }
    visitFixedSizeBinary(_node, ..._args) {
      return null;
    }
    visitDate(_node, ..._args) {
      return null;
    }
    visitTimestamp(_node, ..._args) {
      return null;
    }
    visitTime(_node, ..._args) {
      return null;
    }
    visitDecimal(_node, ..._args) {
      return null;
    }
    visitList(_node, ..._args) {
      return null;
    }
    visitStruct(_node, ..._args) {
      return null;
    }
    visitUnion(_node, ..._args) {
      return null;
    }
    visitDictionary(_node, ..._args) {
      return null;
    }
    visitInterval(_node, ..._args) {
      return null;
    }
    visitFixedSizeList(_node, ..._args) {
      return null;
    }
    visitMap(_node, ..._args) {
      return null;
    }
  };
  function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === "number") {
      return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === "string" && node in Type) {
      return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);
    }
    if (node && node instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);
  }
  function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
      case Type.Null:
        fn = visitor.visitNull;
        break;
      case Type.Bool:
        fn = visitor.visitBool;
        break;
      case Type.Int:
        fn = visitor.visitInt;
        break;
      case Type.Int8:
        fn = visitor.visitInt8 || visitor.visitInt;
        break;
      case Type.Int16:
        fn = visitor.visitInt16 || visitor.visitInt;
        break;
      case Type.Int32:
        fn = visitor.visitInt32 || visitor.visitInt;
        break;
      case Type.Int64:
        fn = visitor.visitInt64 || visitor.visitInt;
        break;
      case Type.Uint8:
        fn = visitor.visitUint8 || visitor.visitInt;
        break;
      case Type.Uint16:
        fn = visitor.visitUint16 || visitor.visitInt;
        break;
      case Type.Uint32:
        fn = visitor.visitUint32 || visitor.visitInt;
        break;
      case Type.Uint64:
        fn = visitor.visitUint64 || visitor.visitInt;
        break;
      case Type.Float:
        fn = visitor.visitFloat;
        break;
      case Type.Float16:
        fn = visitor.visitFloat16 || visitor.visitFloat;
        break;
      case Type.Float32:
        fn = visitor.visitFloat32 || visitor.visitFloat;
        break;
      case Type.Float64:
        fn = visitor.visitFloat64 || visitor.visitFloat;
        break;
      case Type.Utf8:
        fn = visitor.visitUtf8;
        break;
      case Type.Binary:
        fn = visitor.visitBinary;
        break;
      case Type.FixedSizeBinary:
        fn = visitor.visitFixedSizeBinary;
        break;
      case Type.Date:
        fn = visitor.visitDate;
        break;
      case Type.DateDay:
        fn = visitor.visitDateDay || visitor.visitDate;
        break;
      case Type.DateMillisecond:
        fn = visitor.visitDateMillisecond || visitor.visitDate;
        break;
      case Type.Timestamp:
        fn = visitor.visitTimestamp;
        break;
      case Type.TimestampSecond:
        fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMillisecond:
        fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMicrosecond:
        fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
        break;
      case Type.TimestampNanosecond:
        fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
        break;
      case Type.Time:
        fn = visitor.visitTime;
        break;
      case Type.TimeSecond:
        fn = visitor.visitTimeSecond || visitor.visitTime;
        break;
      case Type.TimeMillisecond:
        fn = visitor.visitTimeMillisecond || visitor.visitTime;
        break;
      case Type.TimeMicrosecond:
        fn = visitor.visitTimeMicrosecond || visitor.visitTime;
        break;
      case Type.TimeNanosecond:
        fn = visitor.visitTimeNanosecond || visitor.visitTime;
        break;
      case Type.Decimal:
        fn = visitor.visitDecimal;
        break;
      case Type.List:
        fn = visitor.visitList;
        break;
      case Type.Struct:
        fn = visitor.visitStruct;
        break;
      case Type.Union:
        fn = visitor.visitUnion;
        break;
      case Type.DenseUnion:
        fn = visitor.visitDenseUnion || visitor.visitUnion;
        break;
      case Type.SparseUnion:
        fn = visitor.visitSparseUnion || visitor.visitUnion;
        break;
      case Type.Dictionary:
        fn = visitor.visitDictionary;
        break;
      case Type.Interval:
        fn = visitor.visitInterval;
        break;
      case Type.IntervalDayTime:
        fn = visitor.visitIntervalDayTime || visitor.visitInterval;
        break;
      case Type.IntervalYearMonth:
        fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
        break;
      case Type.FixedSizeList:
        fn = visitor.visitFixedSizeList;
        break;
      case Type.Map:
        fn = visitor.visitMap;
        break;
    }
    if (typeof fn === "function")
      return fn;
    if (!throwIfNotFound)
      return () => null;
    throw new Error(`Unrecognized type '${Type[dtype]}'`);
  }
  function inferDType(type) {
    switch (type.typeId) {
      case Type.Null:
        return Type.Null;
      case Type.Int: {
        const { bitWidth, isSigned } = type;
        switch (bitWidth) {
          case 8:
            return isSigned ? Type.Int8 : Type.Uint8;
          case 16:
            return isSigned ? Type.Int16 : Type.Uint16;
          case 32:
            return isSigned ? Type.Int32 : Type.Uint32;
          case 64:
            return isSigned ? Type.Int64 : Type.Uint64;
        }
        return Type.Int;
      }
      case Type.Float:
        switch (type.precision) {
          case Precision.HALF:
            return Type.Float16;
          case Precision.SINGLE:
            return Type.Float32;
          case Precision.DOUBLE:
            return Type.Float64;
        }
        return Type.Float;
      case Type.Binary:
        return Type.Binary;
      case Type.Utf8:
        return Type.Utf8;
      case Type.Bool:
        return Type.Bool;
      case Type.Decimal:
        return Type.Decimal;
      case Type.Time:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimeSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimeMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimeMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimeNanosecond;
        }
        return Type.Time;
      case Type.Timestamp:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimestampSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimestampMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimestampMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimestampNanosecond;
        }
        return Type.Timestamp;
      case Type.Date:
        switch (type.unit) {
          case DateUnit.DAY:
            return Type.DateDay;
          case DateUnit.MILLISECOND:
            return Type.DateMillisecond;
        }
        return Type.Date;
      case Type.Interval:
        switch (type.unit) {
          case IntervalUnit.DAY_TIME:
            return Type.IntervalDayTime;
          case IntervalUnit.YEAR_MONTH:
            return Type.IntervalYearMonth;
        }
        return Type.Interval;
      case Type.Map:
        return Type.Map;
      case Type.List:
        return Type.List;
      case Type.Struct:
        return Type.Struct;
      case Type.Union:
        switch (type.mode) {
          case UnionMode.Dense:
            return Type.DenseUnion;
          case UnionMode.Sparse:
            return Type.SparseUnion;
        }
        return Type.Union;
      case Type.FixedSizeBinary:
        return Type.FixedSizeBinary;
      case Type.FixedSizeList:
        return Type.FixedSizeList;
      case Type.Dictionary:
        return Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${Type[type.typeId]}'`);
  }
  Visitor.prototype.visitInt8 = null;
  Visitor.prototype.visitInt16 = null;
  Visitor.prototype.visitInt32 = null;
  Visitor.prototype.visitInt64 = null;
  Visitor.prototype.visitUint8 = null;
  Visitor.prototype.visitUint16 = null;
  Visitor.prototype.visitUint32 = null;
  Visitor.prototype.visitUint64 = null;
  Visitor.prototype.visitFloat16 = null;
  Visitor.prototype.visitFloat32 = null;
  Visitor.prototype.visitFloat64 = null;
  Visitor.prototype.visitDateDay = null;
  Visitor.prototype.visitDateMillisecond = null;
  Visitor.prototype.visitTimestampSecond = null;
  Visitor.prototype.visitTimestampMillisecond = null;
  Visitor.prototype.visitTimestampMicrosecond = null;
  Visitor.prototype.visitTimestampNanosecond = null;
  Visitor.prototype.visitTimeSecond = null;
  Visitor.prototype.visitTimeMillisecond = null;
  Visitor.prototype.visitTimeMicrosecond = null;
  Visitor.prototype.visitTimeNanosecond = null;
  Visitor.prototype.visitDenseUnion = null;
  Visitor.prototype.visitSparseUnion = null;
  Visitor.prototype.visitIntervalDayTime = null;
  Visitor.prototype.visitIntervalYearMonth = null;

  // ../../node_modules/apache-arrow/util/math.mjs
  var math_exports = {};
  __export(math_exports, {
    float64ToUint16: () => float64ToUint16,
    uint16ToFloat64: () => uint16ToFloat64
  });
  var f64 = new Float64Array(1);
  var u32 = new Uint32Array(f64.buffer);
  function uint16ToFloat64(h) {
    const expo = (h & 31744) >> 10;
    const sigf = (h & 1023) / 1024;
    const sign = Math.pow(-1, (h & 32768) >> 15);
    switch (expo) {
      case 31:
        return sign * (sigf ? Number.NaN : 1 / 0);
      case 0:
        return sign * (sigf ? 6103515625e-14 * sigf : 0);
    }
    return sign * Math.pow(2, expo - 15) * (1 + sigf);
  }
  function float64ToUint16(d) {
    if (d !== d) {
      return 32256;
    }
    f64[0] = d;
    const sign = (u32[1] & 2147483648) >> 16 & 65535;
    let expo = u32[1] & 2146435072, sigf = 0;
    if (expo >= 1089470464) {
      if (u32[0] > 0) {
        expo = 31744;
      } else {
        expo = (expo & 2080374784) >> 16;
        sigf = (u32[1] & 1048575) >> 10;
      }
    } else if (expo <= 1056964608) {
      sigf = 1048576 + (u32[1] & 1048575);
      sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
      expo = 0;
    } else {
      expo = expo - 1056964608 >> 10;
      sigf = (u32[1] & 1048575) + 512 >> 10;
    }
    return sign | expo | sigf & 65535;
  }

  // ../../node_modules/apache-arrow/visitor/set.mjs
  var SetVisitor = class extends Visitor {
  };
  function wrapSet(fn) {
    return (data, _1, _2) => {
      if (data.setValid(_1, _2 != null)) {
        return fn(data, _1, _2);
      }
    };
  }
  var setEpochMsToDays = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs / 864e5);
  };
  var setEpochMsToMillisecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs % 4294967296);
    data[index + 1] = Math.trunc(epochMs / 4294967296);
  };
  var setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs * 1e3 % 4294967296);
    data[index + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
  };
  var setEpochMsToNanosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs * 1e6 % 4294967296);
    data[index + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
  };
  var setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      values.set(value.subarray(0, y - x), x);
    }
  };
  var setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
  };
  var setInt = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat16 = ({ values }, index, value) => {
    values[index] = float64ToUint16(value);
  };
  var setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
      case Precision.HALF:
        return setFloat16(data, index, value);
      case Precision.SINGLE:
      case Precision.DOUBLE:
        return setFloat(data, index, value);
    }
  };
  var setDateDay = ({ values }, index, value) => {
    setEpochMsToDays(values, index, value.valueOf());
  };
  var setDateMillisecond = ({ values }, index, value) => {
    setEpochMsToMillisecondsLong(values, index * 2, value.valueOf());
  };
  var setFixedSizeBinary = ({ stride, values }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);
  var setUtf8 = ({ values, valueOffsets }, index, value) => {
    setVariableWidthBytes(values, valueOffsets, index, encodeUtf8(value));
  };
  var setDate = (data, index, value) => {
    data.type.unit === DateUnit.DAY ? setDateDay(data, index, value) : setDateMillisecond(data, index, value);
  };
  var setTimestampSecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value / 1e3);
  var setTimestampMillisecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value);
  var setTimestampMicrosecond = ({ values }, index, value) => setEpochMsToMicrosecondsLong(values, index * 2, value);
  var setTimestampNanosecond = ({ values }, index, value) => setEpochMsToNanosecondsLong(values, index * 2, value);
  var setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimestampSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimestampMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimestampMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimestampNanosecond(data, index, value);
    }
  };
  var setTimeSecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMillisecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMicrosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeNanosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTime = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimeSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimeMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimeMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimeNanosecond(data, index, value);
    }
  };
  var setDecimal = ({ values, stride }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setList = (data, index, value) => {
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = instance.getVisitFn(values);
    if (Array.isArray(value)) {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value[++idx]);
      }
    } else {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value.get(++idx));
      }
    }
  };
  var setMap = (data, index, value) => {
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
      set(values, idx, val);
      if (++idx >= end)
        break;
    }
  };
  var _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
  var _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
  var _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
  var _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
  var setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
  };
  var setUnion = (data, index, value) => {
    data.type.mode === UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
  };
  var setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, data.valueOffsets[index], value);
  };
  var setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, index, value);
  };
  var setDictionary = (data, index, value) => {
    var _a5;
    (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index], value);
  };
  var setIntervalValue = (data, index, value) => {
    data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index, value) : setIntervalYearMonth(data, index, value);
  };
  var setIntervalDayTime = ({ values }, index, value) => {
    values.set(value.subarray(0, 2), 2 * index);
  };
  var setIntervalYearMonth = ({ values }, index, value) => {
    values[index] = value[0] * 12 + value[1] % 12;
  };
  var setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set = instance.getVisitFn(child);
    if (Array.isArray(value)) {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value[idx]);
      }
    } else {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value.get(idx));
      }
    }
  };
  SetVisitor.prototype.visitBool = wrapSet(setBool);
  SetVisitor.prototype.visitInt = wrapSet(setInt);
  SetVisitor.prototype.visitInt8 = wrapSet(setInt);
  SetVisitor.prototype.visitInt16 = wrapSet(setInt);
  SetVisitor.prototype.visitInt32 = wrapSet(setInt);
  SetVisitor.prototype.visitInt64 = wrapSet(setInt);
  SetVisitor.prototype.visitUint8 = wrapSet(setInt);
  SetVisitor.prototype.visitUint16 = wrapSet(setInt);
  SetVisitor.prototype.visitUint32 = wrapSet(setInt);
  SetVisitor.prototype.visitUint64 = wrapSet(setInt);
  SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
  SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
  SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
  SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
  SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
  SetVisitor.prototype.visitBinary = wrapSet(setBinary);
  SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
  SetVisitor.prototype.visitDate = wrapSet(setDate);
  SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
  SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
  SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
  SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
  SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
  SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
  SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
  SetVisitor.prototype.visitTime = wrapSet(setTime);
  SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
  SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
  SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
  SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
  SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
  SetVisitor.prototype.visitList = wrapSet(setList);
  SetVisitor.prototype.visitStruct = wrapSet(setStruct);
  SetVisitor.prototype.visitUnion = wrapSet(setUnion);
  SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
  SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
  SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
  SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
  SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
  SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
  SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
  SetVisitor.prototype.visitMap = wrapSet(setMap);
  var instance = new SetVisitor();

  // ../../node_modules/apache-arrow/row/struct.mjs
  var kParent = Symbol.for("parent");
  var kRowIndex = Symbol.for("rowIndex");
  var StructRow = class {
    constructor(parent, rowIndex) {
      this[kParent] = parent;
      this[kRowIndex] = rowIndex;
      return new Proxy(this, new StructRowProxyHandler());
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const i = this[kRowIndex];
      const parent = this[kParent];
      const keys = parent.type.children;
      const json = {};
      for (let j = -1, n = keys.length; ++j < n; ) {
        json[keys[j].name] = instance2.visit(parent.children[j], i);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
    [Symbol.iterator]() {
      return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
  };
  var StructRowIterator = class {
    constructor(data, rowIndex) {
      this.childIndex = 0;
      this.children = data.children;
      this.rowIndex = rowIndex;
      this.childFields = data.type.children;
      this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i = this.childIndex;
      if (i < this.numChildren) {
        this.childIndex = i + 1;
        return {
          done: false,
          value: [
            this.childFields[i].name,
            instance2.visit(this.children[i], this.rowIndex)
          ]
        };
      }
      return { done: true, value: null };
    }
  };
  Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
  });
  var StructRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
      return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;
    }
    getOwnPropertyDescriptor(row, key) {
      if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        instance.visit(row[kParent].children[idx], row[kRowIndex], val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key) || typeof key === "symbol") {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };

  // ../../node_modules/apache-arrow/visitor/get.mjs
  var GetVisitor = class extends Visitor {
  };
  function wrapGet(fn) {
    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
  }
  var epochDaysToMs = (data, index) => 864e5 * data[index];
  var epochMillisecondsLongToMs = (data, index) => 4294967296 * data[index + 1] + (data[index] >>> 0);
  var epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e3) + (data[index] >>> 0) / 1e3;
  var epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e6) + (data[index] >>> 0) / 1e6;
  var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
  var epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
  var epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
  var getNull = (_data, _index) => null;
  var getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
      return null;
    }
    const x = valueOffsets[index];
    const y = valueOffsets[index + 1];
    return values.subarray(x, y);
  };
  var getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << idx % 8) !== 0;
  };
  var getDateDay = ({ values }, index) => epochDaysToDate(values, index);
  var getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
  var getNumeric = ({ stride, values }, index) => values[stride * index];
  var getFloat16 = ({ stride, values }, index) => uint16ToFloat64(values[stride * index]);
  var getBigInts = ({ values }, index) => values[index];
  var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
  var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
  var getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? decodeUtf8(bytes) : null;
  };
  var getInt = ({ values }, index) => values[index];
  var getFloat = ({ type, values }, index) => type.precision !== Precision.HALF ? values[index] : uint16ToFloat64(values[index]);
  var getDate = (data, index) => data.type.unit === DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
  var getTimestampSecond = ({ values }, index) => 1e3 * epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
  var getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
  var getTimestamp = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimestampSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimestampMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimestampMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimestampNanosecond(data, index);
    }
  };
  var getTimeSecond = ({ values }, index) => values[index];
  var getTimeMillisecond = ({ values }, index) => values[index];
  var getTimeMicrosecond = ({ values }, index) => values[index];
  var getTimeNanosecond = ({ values }, index) => values[index];
  var getTime = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimeSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimeMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimeMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimeNanosecond(data, index);
    }
  };
  var getDecimal = ({ values, stride }, index) => BN.decimal(values.subarray(stride * index, stride * (index + 1)));
  var getList = (data, index) => {
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new Vector([slice]);
  };
  var getMap = (data, index) => {
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new MapRow(child.slice(begin, end - begin));
  };
  var getStruct = (data, index) => {
    return new StructRow(data, index);
  };
  var getUnion = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
  };
  var getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, data.valueOffsets[index]);
  };
  var getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, index);
  };
  var getDictionary = (data, index) => {
    var _a5;
    return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index]);
  };
  var getInterval = (data, index) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
  var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
  var getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12);
    int32s[1] = Math.trunc(interval % 12);
    return int32s;
  };
  var getFixedSizeList = (data, index) => {
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new Vector([slice]);
  };
  GetVisitor.prototype.visitNull = wrapGet(getNull);
  GetVisitor.prototype.visitBool = wrapGet(getBool);
  GetVisitor.prototype.visitInt = wrapGet(getInt);
  GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitFloat = wrapGet(getFloat);
  GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
  GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
  GetVisitor.prototype.visitBinary = wrapGet(getBinary);
  GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
  GetVisitor.prototype.visitDate = wrapGet(getDate);
  GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
  GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
  GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
  GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
  GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
  GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
  GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
  GetVisitor.prototype.visitTime = wrapGet(getTime);
  GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
  GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
  GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
  GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
  GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
  GetVisitor.prototype.visitList = wrapGet(getList);
  GetVisitor.prototype.visitStruct = wrapGet(getStruct);
  GetVisitor.prototype.visitUnion = wrapGet(getUnion);
  GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
  GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
  GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
  GetVisitor.prototype.visitInterval = wrapGet(getInterval);
  GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
  GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
  GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
  GetVisitor.prototype.visitMap = wrapGet(getMap);
  var instance2 = new GetVisitor();

  // ../../node_modules/apache-arrow/row/map.mjs
  var kKeys = Symbol.for("keys");
  var kVals = Symbol.for("vals");
  var MapRow = class {
    constructor(slice) {
      this[kKeys] = new Vector([slice.children[0]]).memoize();
      this[kVals] = slice.children[1];
      return new Proxy(this, new MapRowProxyHandler());
    }
    [Symbol.iterator]() {
      return new MapRowIterator(this[kKeys], this[kVals]);
    }
    get size() {
      return this[kKeys].length;
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const keys = this[kKeys];
      const vals = this[kVals];
      const json = {};
      for (let i = -1, n = keys.length; ++i < n; ) {
        json[keys.get(i)] = instance2.visit(vals, i);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  };
  var MapRowIterator = class {
    constructor(keys, vals) {
      this.keys = keys;
      this.vals = vals;
      this.keyIndex = 0;
      this.numKeys = keys.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i = this.keyIndex;
      if (i === this.numKeys) {
        return { done: true, value: null };
      }
      this.keyIndex++;
      return {
        done: false,
        value: [
          this.keys.get(i),
          instance2.visit(this.vals, i)
        ]
      };
    }
  };
  var MapRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kKeys].toArray().map(String);
    }
    has(row, key) {
      return row[kKeys].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        const val = instance2.visit(Reflect.get(row, kVals), idx);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        instance.visit(Reflect.get(row, kVals), idx, val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key)) {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };
  Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [kVals]: { writable: true, enumerable: false, configurable: false, value: null }
  });

  // ../../node_modules/apache-arrow/util/vector.mjs
  function clampIndex(source, index, then) {
    const length = source.length;
    const adjust = index > -1 ? index : length + index % length;
    return then ? then(source, adjust) : adjust;
  }
  var tmp;
  function clampRange(source, begin, end, then) {
    const { length: len = 0 } = source;
    let lhs = typeof begin !== "number" ? 0 : begin;
    let rhs = typeof end !== "number" ? len : end;
    lhs < 0 && (lhs = (lhs % len + len) % len);
    rhs < 0 && (rhs = (rhs % len + len) % len);
    rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
    rhs > len && (rhs = len);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
  }
  var isNaNFast = (value) => value !== value;
  function createElementComparator(search) {
    const typeofSearch = typeof search;
    if (typeofSearch !== "object" || search === null) {
      if (isNaNFast(search)) {
        return isNaNFast;
      }
      return (value) => value === search;
    }
    if (search instanceof Date) {
      const valueOfSearch = search.valueOf();
      return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
    }
    if (ArrayBuffer.isView(search)) {
      return (value) => value ? compareArrayLike(search, value) : false;
    }
    if (search instanceof Map) {
      return createMapComparator(search);
    }
    if (Array.isArray(search)) {
      return createArrayLikeComparator(search);
    }
    if (search instanceof Vector) {
      return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
  }
  function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs[i]);
    }
    return createSubElementsComparator(comparators);
  }
  function createMapComparator(lhs) {
    let i = -1;
    const comparators = [];
    for (const v of lhs.values())
      comparators[++i] = createElementComparator(v);
    return createSubElementsComparator(comparators);
  }
  function createVectorComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs.get(i));
    }
    return createSubElementsComparator(comparators);
  }
  function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    if (!allowEmpty && keys.length === 0) {
      return () => false;
    }
    const comparators = [];
    for (let i = -1, n = keys.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs[keys[i]]);
    }
    return createSubElementsComparator(comparators, keys);
  }
  function createSubElementsComparator(comparators, keys) {
    return (rhs) => {
      if (!rhs || typeof rhs !== "object") {
        return false;
      }
      switch (rhs.constructor) {
        case Array:
          return compareArray(comparators, rhs);
        case Map:
          return compareObject(comparators, rhs, rhs.keys());
        case MapRow:
        case StructRow:
        case Object:
        case void 0:
          return compareObject(comparators, rhs, keys || Object.keys(rhs));
      }
      return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
    };
  }
  function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
      return false;
    }
    for (let i = -1; ++i < n; ) {
      if (!comparators[i](arr[i])) {
        return false;
      }
    }
    return true;
  }
  function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
      return false;
    }
    for (let i = -1; ++i < n; ) {
      if (!comparators[i](vec.get(i))) {
        return false;
      }
    }
    return true;
  }
  function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
      if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
        break;
      }
    }
    if (i === n && lKey.done && rKey.done && rVal.done) {
      return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
  }

  // ../../node_modules/apache-arrow/util/bit.mjs
  var bit_exports = {};
  __export(bit_exports, {
    BitIterator: () => BitIterator,
    getBit: () => getBit,
    getBool: () => getBool2,
    packBools: () => packBools,
    popcnt_array: () => popcnt_array,
    popcnt_bit_range: () => popcnt_bit_range,
    popcnt_uint32: () => popcnt_uint32,
    setBool: () => setBool2,
    truncateBitmap: () => truncateBitmap
  });
  function getBool2(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
  }
  function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
  }
  function setBool2(bytes, index, value) {
    return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
  }
  function truncateBitmap(offset, length, bitmap) {
    const alignedSize = bitmap.byteLength + 7 & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
      const bytes = new Uint8Array(alignedSize);
      bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : packBools(new BitIterator(bitmap, offset, length, null, getBool2)).subarray(0, alignedSize));
      return bytes;
    }
    return bitmap;
  }
  function packBools(values) {
    const xs = [];
    let i = 0, bit = 0, byte = 0;
    for (const value of values) {
      value && (byte |= 1 << bit);
      if (++bit === 8) {
        xs[i++] = byte;
        byte = bit = 0;
      }
    }
    if (i === 0 || bit > 0) {
      xs[i++] = byte;
    }
    const b = new Uint8Array(xs.length + 7 & ~7);
    b.set(xs);
    return b;
  }
  var BitIterator = class {
    constructor(bytes, begin, length, context, get) {
      this.bytes = bytes;
      this.length = length;
      this.context = context;
      this.get = get;
      this.bit = begin % 8;
      this.byteIndex = begin >> 3;
      this.byte = bytes[this.byteIndex++];
      this.index = 0;
    }
    next() {
      if (this.index < this.length) {
        if (this.bit === 8) {
          this.bit = 0;
          this.byte = this.bytes[this.byteIndex++];
        }
        return {
          value: this.get(this.context, this.index++, this.byte, this.bit++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
      return 0;
    }
    if (rhs - lhs < 8) {
      let sum2 = 0;
      for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
        sum2 += bit;
      }
      return sum2;
    }
    const rhsInside = rhs >> 3 << 3;
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return popcnt_bit_range(data, lhs, lhsInside) + popcnt_bit_range(data, rhsInside, rhs) + popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3);
  }
  function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len - pos >= 4) {
      cnt += popcnt_uint32(view.getUint32(pos));
      pos += 4;
    }
    while (len - pos >= 2) {
      cnt += popcnt_uint32(view.getUint16(pos));
      pos += 2;
    }
    while (len - pos >= 1) {
      cnt += popcnt_uint32(view.getUint8(pos));
      pos += 1;
    }
    return cnt;
  }
  function popcnt_uint32(uint32) {
    let i = Math.trunc(uint32);
    i = i - (i >>> 1 & 1431655765);
    i = (i & 858993459) + (i >>> 2 & 858993459);
    return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
  }

  // ../../node_modules/apache-arrow/data.mjs
  var kUnknownNullCount = -1;
  var Data = class {
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
      this.type = type;
      this.children = children;
      this.dictionary = dictionary;
      this.offset = Math.floor(Math.max(offset || 0, 0));
      this.length = Math.floor(Math.max(length || 0, 0));
      this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
      let buffer;
      if (buffers instanceof Data) {
        this.stride = buffers.stride;
        this.values = buffers.values;
        this.typeIds = buffers.typeIds;
        this.nullBitmap = buffers.nullBitmap;
        this.valueOffsets = buffers.valueOffsets;
      } else {
        this.stride = strideForType(type);
        if (buffers) {
          (buffer = buffers[0]) && (this.valueOffsets = buffer);
          (buffer = buffers[1]) && (this.values = buffer);
          (buffer = buffers[2]) && (this.nullBitmap = buffer);
          (buffer = buffers[3]) && (this.typeIds = buffer);
        }
      }
      this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    get typeId() {
      return this.type.typeId;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get buffers() {
      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get byteLength() {
      let byteLength = 0;
      const { valueOffsets, values, nullBitmap, typeIds } = this;
      valueOffsets && (byteLength += valueOffsets.byteLength);
      values && (byteLength += values.byteLength);
      nullBitmap && (byteLength += nullBitmap.byteLength);
      typeIds && (byteLength += typeIds.byteLength);
      return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
    }
    get nullCount() {
      let nullCount = this._nullCount;
      let nullBitmap;
      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
        this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
      }
      return nullCount;
    }
    getValid(index) {
      if (this.nullable && this.nullCount > 0) {
        const pos = this.offset + index;
        const val = this.nullBitmap[pos >> 3];
        return (val & 1 << pos % 8) !== 0;
      }
      return true;
    }
    setValid(index, value) {
      if (!this.nullable) {
        return value;
      }
      if (!this.nullBitmap || this.nullBitmap.byteLength <= index >> 3) {
        const { nullBitmap: nullBitmap2 } = this._changeLengthAndBackfillNullBitmap(this.length);
        Object.assign(this, { nullBitmap: nullBitmap2, _nullCount: 0 });
      }
      const { nullBitmap, offset } = this;
      const pos = offset + index >> 3;
      const bit = (offset + index) % 8;
      const val = nullBitmap[pos] >> bit & 1;
      value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);
      return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
      return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
      const { stride, typeId, children } = this;
      const nullCount = +(this._nullCount === 0) - 1;
      const childStride = typeId === 16 ? stride : 1;
      const buffers = this._sliceBuffers(offset, length, stride, typeId);
      return this.clone(
        this.type,
        this.offset + offset,
        length,
        nullCount,
        buffers,
        children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset, childStride * length)
      );
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
      if (this.typeId === Type.Null) {
        return this.clone(this.type, 0, newLength, 0);
      }
      const { length, nullCount } = this;
      const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
      bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
      if (nullCount > 0) {
        bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);
      }
      const buffers = this.buffers;
      buffers[BufferType.VALIDITY] = bitmap;
      return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
      let arr;
      const { buffers } = this;
      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));
      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
      return buffers;
    }
    _sliceChildren(children, offset, length) {
      return children.map((child) => child.slice(offset, length));
    }
  };
  Data.prototype.children = Object.freeze([]);
  var MakeDataVisitor = class extends Visitor {
    visit(props) {
      return this.getVisitFn(props["type"]).call(this, props);
    }
    visitNull(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length = 0 } = props;
      return new Data(type, offset, length, 0);
    }
    visitBool(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitInt(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitFloat(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitUtf8(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitDate(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitTimestamp(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitTime(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitDecimal(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
    visitStruct(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { length = children.reduce((len, { length: length2 }) => Math.max(len, length2), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], children);
    }
    visitUnion(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
      const { ["length"]: length = typeIds.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      if (DataType.isSparseUnion(type)) {
        return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap, typeIds], children);
      }
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children);
    }
    visitDictionary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.indices.ArrayType, props["data"]);
      const { ["dictionary"]: dictionary = new Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { ["length"]: length = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], [child]);
    }
    visitMap(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
  };
  function makeData(props) {
    return new MakeDataVisitor().visit(props);
  }

  // ../../node_modules/apache-arrow/util/chunk.mjs
  var ChunkedIterator = class {
    constructor(numChunks = 0, getChunkIterator) {
      this.numChunks = numChunks;
      this.getChunkIterator = getChunkIterator;
      this.chunkIndex = 0;
      this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
      while (this.chunkIndex < this.numChunks) {
        const next = this.chunkIterator.next();
        if (!next.done) {
          return next;
        }
        if (++this.chunkIndex < this.numChunks) {
          this.chunkIterator = this.getChunkIterator(this.chunkIndex);
        }
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
  }
  function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index) => {
      offsets[index + 1] = offsets[index] + chunk.length;
      return offsets;
    }, new Uint32Array(chunks.length + 1));
  }
  function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for (let i = -1, n = chunks.length; ++i < n; ) {
      const chunk = chunks[i];
      const offset = offsets[i];
      const { length } = chunk;
      if (offset >= end) {
        break;
      }
      if (begin >= offset + length) {
        continue;
      }
      if (offset >= begin && offset + length <= end) {
        slices.push(chunk);
        continue;
      }
      const from = Math.max(0, begin - offset);
      const to = Math.min(end - offset, length);
      slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
      slices.push(chunks[0].slice(0, 0));
    }
    return slices;
  }
  function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
      if (lhs >= rhs - 1) {
        return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
      }
      mid = lhs + Math.trunc((rhs - lhs) * 0.5);
      idx < offsets[mid] ? rhs = mid : lhs = mid;
    } while (lhs < rhs);
  }
  function isChunkedValid(data, index) {
    return data.getValid(index);
  }
  function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i, j) {
      return fn(chunks[i], j);
    }
    return function(index) {
      const data = this.data;
      return binarySearch(data, this._offsets, index, chunkedFn);
    };
  }
  function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i, j) {
      return fn(chunks[i], j, _2);
    }
    return function(index, value) {
      const data = this.data;
      _2 = value;
      const result = binarySearch(data, this._offsets, index, chunkedFn);
      _2 = void 0;
      return result;
    };
  }
  function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
      let begin = fromIndex, index = 0, total = 0;
      for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {
        const chunk = data[i];
        if (~(index = indexOf(chunk, _1, begin))) {
          return total + index;
        }
        begin = 0;
        total += chunk.length;
      }
      return -1;
    }
    return function(element, offset) {
      _1 = element;
      const data = this.data;
      const result = typeof offset !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
      _1 = void 0;
      return result;
    };
  }

  // ../../node_modules/apache-arrow/visitor/indexof.mjs
  var IndexOfVisitor = class extends Visitor {
  };
  function nullIndexOf(data, searchElement) {
    return searchElement === null && data.length > 0 ? 0 : -1;
  }
  function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
      return -1;
    }
    let i = 0;
    for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {
      if (!isValid) {
        return i;
      }
      ++i;
    }
    return -1;
  }
  function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === void 0) {
      return -1;
    }
    if (searchElement === null) {
      return indexOfNull(data, fromIndex);
    }
    const get = instance2.getVisitFn(data);
    const compare = createElementComparator(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
      if (compare(get(data, i))) {
        return i;
      }
    }
    return -1;
  }
  function indexOfUnion(data, searchElement, fromIndex) {
    const get = instance2.getVisitFn(data);
    const compare = createElementComparator(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
      if (compare(get(data, i))) {
        return i;
      }
    }
    return -1;
  }
  IndexOfVisitor.prototype.visitNull = nullIndexOf;
  IndexOfVisitor.prototype.visitBool = indexOfValue;
  IndexOfVisitor.prototype.visitInt = indexOfValue;
  IndexOfVisitor.prototype.visitInt8 = indexOfValue;
  IndexOfVisitor.prototype.visitInt16 = indexOfValue;
  IndexOfVisitor.prototype.visitInt32 = indexOfValue;
  IndexOfVisitor.prototype.visitInt64 = indexOfValue;
  IndexOfVisitor.prototype.visitUint8 = indexOfValue;
  IndexOfVisitor.prototype.visitUint16 = indexOfValue;
  IndexOfVisitor.prototype.visitUint32 = indexOfValue;
  IndexOfVisitor.prototype.visitUint64 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat = indexOfValue;
  IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
  IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
  IndexOfVisitor.prototype.visitBinary = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
  IndexOfVisitor.prototype.visitDate = indexOfValue;
  IndexOfVisitor.prototype.visitDateDay = indexOfValue;
  IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTime = indexOfValue;
  IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDecimal = indexOfValue;
  IndexOfVisitor.prototype.visitList = indexOfValue;
  IndexOfVisitor.prototype.visitStruct = indexOfValue;
  IndexOfVisitor.prototype.visitUnion = indexOfValue;
  IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitDictionary = indexOfValue;
  IndexOfVisitor.prototype.visitInterval = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
  IndexOfVisitor.prototype.visitMap = indexOfValue;
  var instance3 = new IndexOfVisitor();

  // ../../node_modules/apache-arrow/visitor/iterator.mjs
  var IteratorVisitor = class extends Visitor {
  };
  function vectorIterator(vector) {
    const { type } = vector;
    if (vector.nullCount === 0 && vector.stride === 1 && (type.typeId === Type.Timestamp || type instanceof Int_ && type.bitWidth !== 64 || type instanceof Time_ && type.bitWidth !== 64 || type instanceof Float && type.precision !== Precision.HALF)) {
      return new ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        return data.values.subarray(0, data.length)[Symbol.iterator]();
      });
    }
    let offset = 0;
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data = vector.data[chunkIndex];
      const length = data.length;
      const inner = vector.slice(offset, offset + length);
      offset += length;
      return new VectorIterator(inner);
    });
  }
  var VectorIterator = class {
    constructor(vector) {
      this.vector = vector;
      this.index = 0;
    }
    next() {
      if (this.index < this.vector.length) {
        return {
          value: this.vector.get(this.index++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  IteratorVisitor.prototype.visitNull = vectorIterator;
  IteratorVisitor.prototype.visitBool = vectorIterator;
  IteratorVisitor.prototype.visitInt = vectorIterator;
  IteratorVisitor.prototype.visitInt8 = vectorIterator;
  IteratorVisitor.prototype.visitInt16 = vectorIterator;
  IteratorVisitor.prototype.visitInt32 = vectorIterator;
  IteratorVisitor.prototype.visitInt64 = vectorIterator;
  IteratorVisitor.prototype.visitUint8 = vectorIterator;
  IteratorVisitor.prototype.visitUint16 = vectorIterator;
  IteratorVisitor.prototype.visitUint32 = vectorIterator;
  IteratorVisitor.prototype.visitUint64 = vectorIterator;
  IteratorVisitor.prototype.visitFloat = vectorIterator;
  IteratorVisitor.prototype.visitFloat16 = vectorIterator;
  IteratorVisitor.prototype.visitFloat32 = vectorIterator;
  IteratorVisitor.prototype.visitFloat64 = vectorIterator;
  IteratorVisitor.prototype.visitUtf8 = vectorIterator;
  IteratorVisitor.prototype.visitBinary = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
  IteratorVisitor.prototype.visitDate = vectorIterator;
  IteratorVisitor.prototype.visitDateDay = vectorIterator;
  IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestamp = vectorIterator;
  IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitTime = vectorIterator;
  IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitDecimal = vectorIterator;
  IteratorVisitor.prototype.visitList = vectorIterator;
  IteratorVisitor.prototype.visitStruct = vectorIterator;
  IteratorVisitor.prototype.visitUnion = vectorIterator;
  IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
  IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
  IteratorVisitor.prototype.visitDictionary = vectorIterator;
  IteratorVisitor.prototype.visitInterval = vectorIterator;
  IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
  IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
  IteratorVisitor.prototype.visitMap = vectorIterator;
  var instance4 = new IteratorVisitor();

  // ../../node_modules/apache-arrow/visitor/bytelength.mjs
  var sum = (x, y) => x + y;
  var GetByteLengthVisitor = class extends Visitor {
    visitNull(____, _) {
      return 0;
    }
    visitInt(data, _) {
      return data.type.bitWidth / 8;
    }
    visitFloat(data, _) {
      return data.type.ArrayType.BYTES_PER_ELEMENT;
    }
    visitBool(____, _) {
      return 1 / 8;
    }
    visitDecimal(data, _) {
      return data.type.bitWidth / 8;
    }
    visitDate(data, _) {
      return (data.type.unit + 1) * 4;
    }
    visitTime(data, _) {
      return data.type.bitWidth / 8;
    }
    visitTimestamp(data, _) {
      return data.type.unit === TimeUnit.SECOND ? 4 : 8;
    }
    visitInterval(data, _) {
      return (data.type.unit + 1) * 4;
    }
    visitStruct(data, i) {
      return data.children.reduce((total, child) => total + instance5.visit(child, i), 0);
    }
    visitFixedSizeBinary(data, _) {
      return data.type.byteWidth;
    }
    visitMap(data, i) {
      return 8 + data.children.reduce((total, child) => total + instance5.visit(child, i), 0);
    }
    visitDictionary(data, i) {
      var _a5;
      return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);
    }
  };
  var getUtf8ByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getBinaryByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getListByteLength = ({ valueOffsets, stride, children }, index) => {
    const child = children[0];
    const { [index * stride]: start } = valueOffsets;
    const { [index * stride + 1]: end } = valueOffsets;
    const visit = instance5.getVisitFn(child.type);
    const slice = child.slice(start, end - start);
    let size = 8;
    for (let idx = -1, len = end - start; ++idx < len; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getFixedSizeListByteLength = ({ stride, children }, index) => {
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    const visit = instance5.getVisitFn(child.type);
    let size = 0;
    for (let idx = -1, len = slice.length; ++idx < len; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getUnionByteLength = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index) : getSparseUnionByteLength(data, index);
  };
  var getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
    const childIndex = type.typeIdToChildIndex[typeIds[index]];
    return 8 + instance5.visit(children[childIndex], valueOffsets[index]);
  };
  var getSparseUnionByteLength = ({ children }, index) => {
    return 4 + instance5.visitMany(children, children.map(() => index)).reduce(sum, 0);
  };
  GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
  GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
  GetByteLengthVisitor.prototype.visitList = getListByteLength;
  GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
  GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
  GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
  GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
  var instance5 = new GetByteLengthVisitor();

  // ../../node_modules/apache-arrow/vector.mjs
  var _a2;
  var visitorsByTypeId = {};
  var vectorPrototypesByTypeId = {};
  var Vector = class {
    constructor(input) {
      var _b2, _c2, _d2;
      const data = input[0] instanceof Vector ? input.flatMap((x) => x.data) : input;
      if (data.length === 0 || data.some((x) => !(x instanceof Data))) {
        throw new TypeError("Vector constructor expects an Array of Data instances.");
      }
      const type = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
      switch (data.length) {
        case 0:
          this._offsets = [0];
          break;
        case 1: {
          const { get, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
          const unchunkedData = data[0];
          this.isValid = (index) => isChunkedValid(unchunkedData, index);
          this.get = (index) => get(unchunkedData, index);
          this.set = (index, value) => set(unchunkedData, index, value);
          this.indexOf = (index) => indexOf(unchunkedData, index);
          this.getByteLength = (index) => byteLength(unchunkedData, index);
          this._offsets = [0, unchunkedData.length];
          break;
        }
        default:
          Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
          this._offsets = computeChunkOffsets(data);
          break;
      }
      this.data = data;
      this.type = type;
      this.stride = strideForType(type);
      this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
      this.length = this._offsets[this._offsets.length - 1];
    }
    get byteLength() {
      if (this._byteLength === -1) {
        this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
      }
      return this._byteLength;
    }
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get [Symbol.toStringTag]() {
      return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    get VectorName() {
      return `${Type[this.type.typeId]}Vector`;
    }
    isValid(index) {
      return false;
    }
    get(index) {
      return null;
    }
    set(index, value) {
      return;
    }
    indexOf(element, offset) {
      return -1;
    }
    includes(element, offset) {
      return this.indexOf(element, offset) > 0;
    }
    getByteLength(index) {
      return 0;
    }
    [Symbol.iterator]() {
      return instance4.visit(this);
    }
    concat(...others) {
      return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    slice(begin, end) {
      return new Vector(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));
    }
    toJSON() {
      return [...this];
    }
    toArray() {
      const { type, data, length, stride, ArrayType } = this;
      switch (type.typeId) {
        case Type.Int:
        case Type.Float:
        case Type.Decimal:
        case Type.Time:
        case Type.Timestamp:
          switch (data.length) {
            case 0:
              return new ArrayType();
            case 1:
              return data[0].values.subarray(0, length * stride);
            default:
              return data.reduce((memo, { values, length: chunk_length }) => {
                memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                memo.offset += chunk_length * stride;
                return memo;
              }, { array: new ArrayType(length * stride), offset: 0 }).array;
          }
      }
      return [...this];
    }
    toString() {
      return `[${[...this].join(",")}]`;
    }
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.numChildren) {
        return new Vector(this.data.map(({ children }) => children[index]));
      }
      return null;
    }
    get isMemoized() {
      if (DataType.isDictionary(this.type)) {
        return this.data[0].dictionary.isMemoized;
      }
      return false;
    }
    memoize() {
      if (DataType.isDictionary(this.type)) {
        const dictionary = new MemoizedVector(this.data[0].dictionary);
        const newData = this.data.map((data) => {
          const cloned = data.clone();
          cloned.dictionary = dictionary;
          return cloned;
        });
        return new Vector(newData);
      }
      return new MemoizedVector(this);
    }
    unmemoize() {
      if (DataType.isDictionary(this.type) && this.isMemoized) {
        const dictionary = this.data[0].dictionary.unmemoize();
        const newData = this.data.map((data) => {
          const newData2 = data.clone();
          newData2.dictionary = dictionary;
          return newData2;
        });
        return new Vector(newData);
      }
      return this;
    }
  };
  _a2 = Symbol.toStringTag;
  Vector[_a2] = ((proto) => {
    proto.type = DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._nullCount = -1;
    proto._byteLength = -1;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === "number" && T !== Type.NONE);
    for (const typeId of typeIds) {
      const get = instance2.getVisitFnByTypeId(typeId);
      const set = instance.getVisitFnByTypeId(typeId);
      const indexOf = instance3.getVisitFnByTypeId(typeId);
      const byteLength = instance5.getVisitFnByTypeId(typeId);
      visitorsByTypeId[typeId] = { get, set, indexOf, byteLength };
      vectorPrototypesByTypeId[typeId] = Object.create(proto, {
        ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
        ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
        ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
        ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },
        ["getByteLength"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }
      });
    }
    return "Vector";
  })(Vector.prototype);
  var MemoizedVector = class extends Vector {
    constructor(vector) {
      super(vector.data);
      const get = this.get;
      const set = this.set;
      const slice = this.slice;
      const cache = new Array(this.length);
      Object.defineProperty(this, "get", {
        value(index) {
          const cachedValue = cache[index];
          if (cachedValue !== void 0) {
            return cachedValue;
          }
          const value = get.call(this, index);
          cache[index] = value;
          return value;
        }
      });
      Object.defineProperty(this, "set", {
        value(index, value) {
          set.call(this, index, value);
          cache[index] = value;
        }
      });
      Object.defineProperty(this, "slice", {
        value: (begin, end) => new MemoizedVector(slice.call(this, begin, end))
      });
      Object.defineProperty(this, "isMemoized", { value: true });
      Object.defineProperty(this, "unmemoize", {
        value: () => new Vector(this.data)
      });
      Object.defineProperty(this, "memoize", {
        value: () => this
      });
    }
  };
  function makeVector(init) {
    if (init) {
      if (init instanceof Data) {
        return new Vector([init]);
      }
      if (init instanceof Vector) {
        return new Vector(init.data);
      }
      if (init.type instanceof DataType) {
        return new Vector([makeData(init)]);
      }
      if (Array.isArray(init)) {
        return new Vector(init.flatMap((v) => unwrapInputs(v)));
      }
      if (ArrayBuffer.isView(init)) {
        if (init instanceof DataView) {
          init = new Uint8Array(init.buffer);
        }
        const props = { offset: 0, length: init.length, nullCount: 0, data: init };
        if (init instanceof Int8Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int8() }))]);
        }
        if (init instanceof Int16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int16() }))]);
        }
        if (init instanceof Int32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int32() }))]);
        }
        if (init instanceof BigInt64ArrayCtor) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int64() }))]);
        }
        if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint8() }))]);
        }
        if (init instanceof Uint16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint16() }))]);
        }
        if (init instanceof Uint32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint32() }))]);
        }
        if (init instanceof BigUint64ArrayCtor) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint64() }))]);
        }
        if (init instanceof Float32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float32() }))]);
        }
        if (init instanceof Float64Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float64() }))]);
        }
        throw new Error("Unrecognized input");
      }
    }
    throw new Error("Unrecognized input");
  }
  function unwrapInputs(x) {
    return x instanceof Data ? [x] : x instanceof Vector ? x.data : makeVector(x).data;
  }

  // ../../node_modules/apache-arrow/builder/valid.mjs
  function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
      return function isValid(value) {
        return true;
      };
    }
    let fnBody = "";
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
      fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
    }
    if (nullValues.length !== noNaNs.length) {
      fnBody = `if (x !== x) return false;
${fnBody}`;
    }
    return new Function(`x`, `${fnBody}
return true;`);
  }
  function valueToCase(x) {
    if (typeof x !== "bigint") {
      return valueToString(x);
    } else if (BigIntAvailable) {
      return `${valueToString(x)}n`;
    }
    return `"${valueToString(x)}"`;
  }

  // ../../node_modules/apache-arrow/builder/buffer.mjs
  var roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;
  var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
  var BufferBuilder = class {
    constructor(buffer, stride = 1) {
      this.buffer = buffer;
      this.stride = stride;
      this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
      this.ArrayType = buffer.constructor;
      this._resize(this.length = Math.ceil(buffer.length / stride));
    }
    get byteLength() {
      return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() {
      return this.buffer.length / this.stride;
    }
    get reservedByteLength() {
      return this.buffer.byteLength;
    }
    set(index, value) {
      return this;
    }
    append(value) {
      return this.set(this.length, value);
    }
    reserve(extra) {
      if (extra > 0) {
        this.length += extra;
        const stride = this.stride;
        const length = this.length * stride;
        const reserved = this.buffer.length;
        if (length >= reserved) {
          this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
        }
      }
      return this;
    }
    flush(length = this.length) {
      length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
      const array = sliceOrExtendArray(this.buffer, length);
      this.clear();
      return array;
    }
    clear() {
      this.length = 0;
      this._resize(0);
      return this;
    }
    _resize(newLength) {
      return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);
    }
  };
  BufferBuilder.prototype.offset = 0;
  var DataBufferBuilder = class extends BufferBuilder {
    last() {
      return this.get(this.length - 1);
    }
    get(index) {
      return this.buffer[index];
    }
    set(index, value) {
      this.reserve(index - this.length + 1);
      this.buffer[index * this.stride] = value;
      return this;
    }
  };
  var BitmapBufferBuilder = class extends DataBufferBuilder {
    constructor(data = new Uint8Array(0)) {
      super(data, 1 / 8);
      this.numValid = 0;
    }
    get numInvalid() {
      return this.length - this.numValid;
    }
    get(idx) {
      return this.buffer[idx >> 3] >> idx % 8 & 1;
    }
    set(idx, val) {
      const { buffer } = this.reserve(idx - this.length + 1);
      const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
      val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
      return this;
    }
    clear() {
      this.numValid = 0;
      return super.clear();
    }
  };
  var OffsetsBufferBuilder = class extends DataBufferBuilder {
    constructor(data = new Int32Array(1)) {
      super(data, 1);
    }
    append(value) {
      return this.set(this.length - 1, value);
    }
    set(index, value) {
      const offset = this.length - 1;
      const buffer = this.reserve(index - offset + 1).buffer;
      if (offset < index++) {
        buffer.fill(buffer[offset], offset, index);
      }
      buffer[index] = buffer[index - 1] + value;
      return this;
    }
    flush(length = this.length - 1) {
      if (length > this.length) {
        this.set(length - 1, 0);
      }
      return super.flush(length + 1);
    }
  };

  // ../../node_modules/apache-arrow/builder.mjs
  var Builder = class {
    constructor({ "type": type, "nullValues": nulls }) {
      this.length = 0;
      this.finished = false;
      this.type = type;
      this.children = [];
      this.nullValues = nulls;
      this.stride = strideForType(type);
      this._nulls = new BitmapBufferBuilder();
      if (nulls && nulls.length > 0) {
        this._isValid = createIsValidFunction(nulls);
      }
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(options) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    toVector() {
      return new Vector([this.flush()]);
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get nullCount() {
      return this._nulls.numInvalid;
    }
    get numChildren() {
      return this.children.length;
    }
    get byteLength() {
      let size = 0;
      const { _offsets, _values, _nulls, _typeIds, children } = this;
      _offsets && (size += _offsets.byteLength);
      _values && (size += _values.byteLength);
      _nulls && (size += _nulls.byteLength);
      _typeIds && (size += _typeIds.byteLength);
      return children.reduce((size2, child) => size2 + child.byteLength, size);
    }
    get reservedLength() {
      return this._nulls.reservedLength;
    }
    get reservedByteLength() {
      let size = 0;
      this._offsets && (size += this._offsets.reservedByteLength);
      this._values && (size += this._values.reservedByteLength);
      this._nulls && (size += this._nulls.reservedByteLength);
      this._typeIds && (size += this._typeIds.reservedByteLength);
      return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
    }
    get valueOffsets() {
      return this._offsets ? this._offsets.buffer : null;
    }
    get values() {
      return this._values ? this._values.buffer : null;
    }
    get nullBitmap() {
      return this._nulls ? this._nulls.buffer : null;
    }
    get typeIds() {
      return this._typeIds ? this._typeIds.buffer : null;
    }
    append(value) {
      return this.set(this.length, value);
    }
    isValid(value) {
      return this._isValid(value);
    }
    set(index, value) {
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value);
      }
      return this;
    }
    setValue(index, value) {
      this._setValue(this, index, value);
    }
    setValid(index, valid) {
      this.length = this._nulls.set(index, +valid).length;
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    getChildAt(index) {
      return this.children[index] || null;
    }
    flush() {
      let data;
      let typeIds;
      let nullBitmap;
      let valueOffsets;
      const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
      if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
        valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
      } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
        data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
      } else {
        data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
      }
      if (nullCount > 0) {
        nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
      }
      const children = this.children.map((child) => child.flush());
      this.clear();
      return makeData({
        type,
        length,
        nullCount,
        children,
        "child": children[0],
        data,
        typeIds,
        nullBitmap,
        valueOffsets
      });
    }
    finish() {
      this.finished = true;
      for (const child of this.children)
        child.finish();
      return this;
    }
    clear() {
      var _a5, _b2, _c2, _d2;
      this.length = 0;
      (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();
      (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();
      (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();
      (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();
      for (const child of this.children)
        child.clear();
      return this;
    }
  };
  Builder.prototype.length = 1;
  Builder.prototype.stride = 1;
  Builder.prototype.children = null;
  Builder.prototype.finished = false;
  Builder.prototype.nullValues = null;
  Builder.prototype._isValid = () => true;
  var FixedWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);
    }
    setValue(index, value) {
      const values = this._values;
      values.reserve(index - values.length + 1);
      return super.setValue(index, value);
    }
  };
  var VariableWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._pendingLength = 0;
      this._offsets = new OffsetsBufferBuilder();
    }
    setValue(index, value) {
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.length);
      this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
      pending.set(index, value);
    }
    setValid(index, isValid) {
      if (!super.setValid(index, isValid)) {
        (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
        return false;
      }
      return true;
    }
    clear() {
      this._pendingLength = 0;
      this._pending = void 0;
      return super.clear();
    }
    flush() {
      this._flush();
      return super.flush();
    }
    finish() {
      this._flush();
      return super.finish();
    }
    _flush() {
      const pending = this._pending;
      const pendingLength = this._pendingLength;
      this._pendingLength = 0;
      this._pending = void 0;
      if (pending && pending.size > 0) {
        this._flushPending(pending, pendingLength);
      }
      return this;
    }
  };

  // ../../node_modules/apache-arrow/fb/block.mjs
  var Block = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    metaDataLength() {
      return this.bb.readInt32(this.bb_pos + 8);
    }
    bodyLength() {
      return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
      return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
      builder.prep(8, 24);
      builder.writeInt64(bodyLength);
      builder.pad(4);
      builder.writeInt32(metaDataLength);
      builder.writeInt64(offset);
      return builder.offset();
    }
  };

  // ../../node_modules/flatbuffers/mjs/constants.js
  var SIZEOF_SHORT = 2;
  var SIZEOF_INT = 4;
  var FILE_IDENTIFIER_LENGTH = 4;
  var SIZE_PREFIX_LENGTH = 4;

  // ../../node_modules/flatbuffers/mjs/utils.js
  var int32 = new Int32Array(2);
  var float32 = new Float32Array(int32.buffer);
  var float64 = new Float64Array(int32.buffer);
  var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

  // ../../node_modules/flatbuffers/mjs/long.js
  var Long = class {
    constructor(low, high) {
      this.low = low | 0;
      this.high = high | 0;
    }
    static create(low, high) {
      return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);
    }
    toFloat64() {
      return (this.low >>> 0) + this.high * 4294967296;
    }
    equals(other) {
      return this.low == other.low && this.high == other.high;
    }
  };
  Long.ZERO = new Long(0, 0);

  // ../../node_modules/flatbuffers/mjs/encoding.js
  var Encoding;
  (function(Encoding2) {
    Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
  })(Encoding || (Encoding = {}));

  // ../../node_modules/flatbuffers/mjs/byte-buffer.js
  var ByteBuffer = class {
    constructor(bytes_) {
      this.bytes_ = bytes_;
      this.position_ = 0;
    }
    static allocate(byte_size) {
      return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
      this.position_ = 0;
    }
    bytes() {
      return this.bytes_;
    }
    position() {
      return this.position_;
    }
    setPosition(position) {
      this.position_ = position;
    }
    capacity() {
      return this.bytes_.length;
    }
    readInt8(offset) {
      return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
      return this.bytes_[offset];
    }
    readInt16(offset) {
      return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
      return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
      return new Long(this.readInt32(offset), this.readInt32(offset + 4));
    }
    readUint64(offset) {
      return new Long(this.readUint32(offset), this.readUint32(offset + 4));
    }
    readFloat32(offset) {
      int32[0] = this.readInt32(offset);
      return float32[0];
    }
    readFloat64(offset) {
      int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
      int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return float64[0];
    }
    writeInt8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    }
    writeUint64(offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    }
    writeFloat32(offset, value) {
      float32[0] = value;
      this.writeInt32(offset, int32[0]);
    }
    writeFloat64(offset, value) {
      float64[0] = value;
      this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    }
    getBufferIdentifier() {
      if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
      }
      let result = "";
      for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
      }
      return result;
    }
    __offset(bb_pos, vtable_offset) {
      const vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    __union(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    }
    __string(offset, opt_encoding) {
      offset += this.readInt32(offset);
      const length = this.readInt32(offset);
      let result = "";
      let i = 0;
      offset += SIZEOF_INT;
      if (opt_encoding === Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }
      while (i < length) {
        let codePoint;
        const a = this.readUint8(offset + i++);
        if (a < 192) {
          codePoint = a;
        } else {
          const b = this.readUint8(offset + i++);
          if (a < 224) {
            codePoint = (a & 31) << 6 | b & 63;
          } else {
            const c = this.readUint8(offset + i++);
            if (a < 240) {
              codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
            } else {
              const d = this.readUint8(offset + i++);
              codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
            }
          }
        }
        if (codePoint < 65536) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 65536;
          result += String.fromCharCode((codePoint >> 10) + 55296, (codePoint & (1 << 10) - 1) + 56320);
        }
      }
      return result;
    }
    __union_with_string(o, offset) {
      if (typeof o === "string") {
        return this.__string(offset);
      }
      return this.__union(o, offset);
    }
    __indirect(offset) {
      return offset + this.readInt32(offset);
    }
    __vector(offset) {
      return offset + this.readInt32(offset) + SIZEOF_INT;
    }
    __vector_len(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
      if (ident.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    }
    createLong(low, high) {
      return Long.create(low, high);
    }
    createScalarList(listAccessor, listLength) {
      const ret = [];
      for (let i = 0; i < listLength; ++i) {
        if (listAccessor(i) !== null) {
          ret.push(listAccessor(i));
        }
      }
      return ret;
    }
    createObjList(listAccessor, listLength) {
      const ret = [];
      for (let i = 0; i < listLength; ++i) {
        const val = listAccessor(i);
        if (val !== null) {
          ret.push(val.unpack());
        }
      }
      return ret;
    }
  };

  // ../../node_modules/flatbuffers/mjs/builder.js
  var Builder2 = class {
    constructor(opt_initial_size) {
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
      let initial_size;
      if (!opt_initial_size) {
        initial_size = 1024;
      } else {
        initial_size = opt_initial_size;
      }
      this.bb = ByteBuffer.allocate(initial_size);
      this.space = initial_size;
    }
    clear() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
    }
    forceDefaults(forceDefaults) {
      this.force_defaults = forceDefaults;
    }
    dataBuffer() {
      return this.bb;
    }
    asUint8Array() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    prep(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        const old_buf_size = this.bb.capacity();
        this.bb = Builder2.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    }
    pad(byte_size) {
      for (let i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    }
    writeInt8(value) {
      this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
      this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
      this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
      this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    }
    addInt8(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    }
    addInt16(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    }
    addInt32(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    }
    addInt64(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    }
    addFloat32(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    }
    addFloat64(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    }
    addFieldInt16(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    }
    addFieldInt32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    }
    addFieldInt64(voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    }
    addFieldFloat32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    }
    addFieldFloat64(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    }
    addFieldOffset(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    }
    addFieldStruct(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    }
    nested(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    }
    notNested() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    }
    slot(voffset) {
      if (this.vtable !== null)
        this.vtable[voffset] = this.offset();
    }
    offset() {
      return this.bb.capacity() - this.space;
    }
    static growByteBuffer(bb) {
      const old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      const new_buf_size = old_buf_size << 1;
      const nbb = ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    }
    addOffset(offset) {
      this.prep(SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + SIZEOF_INT);
    }
    startObject(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (let i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    }
    endObject() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      const vtableloc = this.offset();
      let i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      const trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      const standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
      this.addInt16(len);
      let existing_vtable = 0;
      const vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          const vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    }
    finish(root_table, opt_file_identifier, opt_size_prefix) {
      const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        const file_identifier = opt_file_identifier;
        this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
        }
        for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    }
    finishSizePrefixed(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    }
    requiredField(table, field) {
      const table_start = this.bb.capacity() - table;
      const vtable_start = table_start - this.bb.readInt32(table_start);
      const ok = this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    }
    startVector(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    }
    endVector() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    }
    createSharedString(s) {
      if (!s) {
        return 0;
      }
      if (!this.string_maps) {
        this.string_maps = /* @__PURE__ */ new Map();
      }
      if (this.string_maps.has(s)) {
        return this.string_maps.get(s);
      }
      const offset = this.createString(s);
      this.string_maps.set(s, offset);
      return offset;
    }
    createString(s) {
      if (!s) {
        return 0;
      }
      let utf8;
      if (s instanceof Uint8Array) {
        utf8 = s;
      } else {
        utf8 = [];
        let i = 0;
        while (i < s.length) {
          let codePoint;
          const a = s.charCodeAt(i++);
          if (a < 55296 || a >= 56320) {
            codePoint = a;
          } else {
            const b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
          }
          if (codePoint < 128) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 2048) {
              utf8.push(codePoint >> 6 & 31 | 192);
            } else {
              if (codePoint < 65536) {
                utf8.push(codePoint >> 12 & 15 | 224);
              } else {
                utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);
              }
              utf8.push(codePoint >> 6 & 63 | 128);
            }
            utf8.push(codePoint & 63 | 128);
          }
        }
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    }
    createLong(low, high) {
      return Long.create(low, high);
    }
    createObjectOffset(obj) {
      if (obj === null) {
        return 0;
      }
      if (typeof obj === "string") {
        return this.createString(obj);
      } else {
        return obj.pack(this);
      }
    }
    createObjectOffsetList(list) {
      const ret = [];
      for (let i = 0; i < list.length; ++i) {
        const val = list[i];
        if (val !== null) {
          ret.push(this.createObjectOffset(val));
        } else {
          throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
        }
      }
      return ret;
    }
    createStructOffsetList(list, startFunc) {
      startFunc(this, list.length);
      this.createObjectOffsetList(list);
      return this.endVector();
    }
  };

  // ../../node_modules/apache-arrow/fb/key-value.mjs
  var KeyValue = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsKeyValue(bb, obj) {
      return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
      builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
      builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
      builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
      KeyValue.startKeyValue(builder);
      KeyValue.addKey(builder, keyOffset);
      KeyValue.addValue(builder, valueOffset);
      return KeyValue.endKeyValue(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/metadata-version.mjs
  var MetadataVersion2;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion2 || (MetadataVersion2 = {}));

  // ../../node_modules/apache-arrow/fb/endianness.mjs
  var Endianness;
  (function(Endianness2) {
    Endianness2[Endianness2["Little"] = 0] = "Little";
    Endianness2[Endianness2["Big"] = 1] = "Big";
  })(Endianness || (Endianness = {}));

  // ../../node_modules/apache-arrow/fb/dictionary-kind.mjs
  var DictionaryKind;
  (function(DictionaryKind2) {
    DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
  })(DictionaryKind || (DictionaryKind = {}));

  // ../../node_modules/apache-arrow/fb/int.mjs
  var Int = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsInt(bb, obj) {
      return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
      builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
      builder.addFieldInt8(1, +isSigned, 0);
    }
    static endInt(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
      Int.startInt(builder);
      Int.addBitWidth(builder, bitWidth);
      Int.addIsSigned(builder, isSigned);
      return Int.endInt(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/dictionary-encoding.mjs
  var DictionaryEncoding = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
      return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    indexType(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isOrdered() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
      builder.startObject(4);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, builder.createLong(0, 0));
    }
    static addIndexType(builder, indexTypeOffset) {
      builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
      builder.addFieldInt8(2, +isOrdered, 0);
    }
    static addDictionaryKind(builder, dictionaryKind) {
      builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/binary.mjs
  var Binary2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBinary(bb, obj) {
      return (obj || new Binary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Binary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
      builder.startObject(0);
    }
    static endBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBinary(builder) {
      Binary2.startBinary(builder);
      return Binary2.endBinary(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/bool.mjs
  var Bool2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBool(bb, obj) {
      return (obj || new Bool2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Bool2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
      builder.startObject(0);
    }
    static endBool(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBool(builder) {
      Bool2.startBool(builder);
      return Bool2.endBool(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/date-unit.mjs
  var DateUnit2;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit2 || (DateUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/date.mjs
  var Date2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDate(bb, obj) {
      return (obj || new Date2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Date2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit2.MILLISECOND;
    }
    static startDate(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, DateUnit2.MILLISECOND);
    }
    static endDate(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDate(builder, unit) {
      Date2.startDate(builder);
      Date2.addUnit(builder, unit);
      return Date2.endDate(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/decimal.mjs
  var Decimal2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDecimal(bb, obj) {
      return (obj || new Decimal2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Decimal2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    scale() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
      builder.startObject(3);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
      builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
      Decimal2.startDecimal(builder);
      Decimal2.addPrecision(builder, precision);
      Decimal2.addScale(builder, scale);
      Decimal2.addBitWidth(builder, bitWidth);
      return Decimal2.endDecimal(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/time-unit.mjs
  var TimeUnit2;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit2 || (TimeUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/fixed-size-binary.mjs
  var FixedSizeBinary2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
      return (obj || new FixedSizeBinary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FixedSizeBinary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    byteWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
      builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
      builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
      FixedSizeBinary2.startFixedSizeBinary(builder);
      FixedSizeBinary2.addByteWidth(builder, byteWidth);
      return FixedSizeBinary2.endFixedSizeBinary(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/fixed-size-list.mjs
  var FixedSizeList2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
      return (obj || new FixedSizeList2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FixedSizeList2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    listSize() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
      builder.startObject(1);
    }
    static addListSize(builder, listSize) {
      builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeList(builder, listSize) {
      FixedSizeList2.startFixedSizeList(builder);
      FixedSizeList2.addListSize(builder, listSize);
      return FixedSizeList2.endFixedSizeList(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/precision.mjs
  var Precision2;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision2 || (Precision2 = {}));

  // ../../node_modules/apache-arrow/fb/floating-point.mjs
  var FloatingPoint = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
      return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision2.HALF;
    }
    static startFloatingPoint(builder) {
      builder.startObject(1);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt16(0, precision, Precision2.HALF);
    }
    static endFloatingPoint(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFloatingPoint(builder, precision) {
      FloatingPoint.startFloatingPoint(builder);
      FloatingPoint.addPrecision(builder, precision);
      return FloatingPoint.endFloatingPoint(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/interval-unit.mjs
  var IntervalUnit2;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit2 || (IntervalUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/interval.mjs
  var Interval = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsInterval(bb, obj) {
      return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit2.YEAR_MONTH;
    }
    static startInterval(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, IntervalUnit2.YEAR_MONTH);
    }
    static endInterval(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInterval(builder, unit) {
      Interval.startInterval(builder);
      Interval.addUnit(builder, unit);
      return Interval.endInterval(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/list.mjs
  var List2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsList(bb, obj) {
      return (obj || new List2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new List2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
      builder.startObject(0);
    }
    static endList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createList(builder) {
      List2.startList(builder);
      return List2.endList(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/map.mjs
  var Map2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsMap(bb, obj) {
      return (obj || new Map2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Map2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    keysSorted() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
      builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
      builder.addFieldInt8(0, +keysSorted, 0);
    }
    static endMap(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createMap(builder, keysSorted) {
      Map2.startMap(builder);
      Map2.addKeysSorted(builder, keysSorted);
      return Map2.endMap(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/null.mjs
  var Null2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsNull(bb, obj) {
      return (obj || new Null2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Null2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
      builder.startObject(0);
    }
    static endNull(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createNull(builder) {
      Null2.startNull(builder);
      return Null2.endNull(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/struct_.mjs
  var Struct_ = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsStruct_(bb, obj) {
      return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
      builder.startObject(0);
    }
    static endStruct_(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createStruct_(builder) {
      Struct_.startStruct_(builder);
      return Struct_.endStruct_(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/time.mjs
  var Time = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsTime(bb, obj) {
      return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.MILLISECOND;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTime(builder, unit, bitWidth) {
      Time.startTime(builder);
      Time.addUnit(builder, unit);
      Time.addBitWidth(builder, bitWidth);
      return Time.endTime(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/timestamp.mjs
  var Timestamp = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsTimestamp(bb, obj) {
      return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.SECOND;
    }
    timezone(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
      builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
      Timestamp.startTimestamp(builder);
      Timestamp.addUnit(builder, unit);
      Timestamp.addTimezone(builder, timezoneOffset);
      return Timestamp.endTimestamp(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/union-mode.mjs
  var UnionMode2;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode2 || (UnionMode2 = {}));

  // ../../node_modules/apache-arrow/fb/union.mjs
  var Union = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsUnion(bb, obj) {
      return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode2.Sparse;
    }
    typeIds(index) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
      builder.startObject(2);
    }
    static addMode(builder, mode) {
      builder.addFieldInt16(0, mode, UnionMode2.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
      builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt32(data[i]);
      }
      return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
      Union.startUnion(builder);
      Union.addMode(builder, mode);
      Union.addTypeIds(builder, typeIdsOffset);
      return Union.endUnion(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/utf8.mjs
  var Utf82 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsUtf8(bb, obj) {
      return (obj || new Utf82()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Utf82()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
      builder.startObject(0);
    }
    static endUtf8(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUtf8(builder) {
      Utf82.startUtf8(builder);
      return Utf82.endUtf8(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/type.mjs
  var Type2;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct_"] = 13] = "Struct_";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Duration"] = 18] = "Duration";
    Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
    Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
    Type3[Type3["LargeList"] = 21] = "LargeList";
  })(Type2 || (Type2 = {}));

  // ../../node_modules/apache-arrow/fb/field.mjs
  var Field = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsField(bb, obj) {
      return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    nullable() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : Type2.NONE;
    }
    type(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    dictionary(obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    children(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
      builder.startObject(7);
    }
    static addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
      builder.addFieldInt8(1, +nullable, 0);
    }
    static addTypeType(builder, typeType) {
      builder.addFieldInt8(2, typeType, Type2.NONE);
    }
    static addType(builder, typeOffset) {
      builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
      builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
      builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/schema.mjs
  var Schema = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsSchema(bb, obj) {
      return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    endianness() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;
    }
    fields(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    features(index) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
    }
    featuresLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
      builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
      builder.addFieldInt16(0, endianness, Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
      builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
      builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt64(data[i]);
      }
      return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishSchemaBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
      Schema.startSchema(builder);
      Schema.addEndianness(builder, endianness);
      Schema.addFields(builder, fieldsOffset);
      Schema.addCustomMetadata(builder, customMetadataOffset);
      Schema.addFeatures(builder, featuresOffset);
      return Schema.endSchema(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/footer.mjs
  var Footer = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFooter(bb, obj) {
      return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    schema(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addSchema(builder, schemaOffset) {
      builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
      builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
      builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishFooterBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
  };

  // ../../node_modules/apache-arrow/schema.mjs
  var Schema2 = class {
    constructor(fields = [], metadata, dictionaries) {
      this.fields = fields || [];
      this.metadata = metadata || /* @__PURE__ */ new Map();
      if (!dictionaries) {
        dictionaries = generateDictionaryMap(fields);
      }
      this.dictionaries = dictionaries;
    }
    get [Symbol.toStringTag]() {
      return "Schema";
    }
    get names() {
      return this.fields.map((f) => f.name);
    }
    toString() {
      return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
    }
    select(fieldNames) {
      const names = new Set(fieldNames);
      const fields = this.fields.filter((f) => names.has(f.name));
      return new Schema2(fields, this.metadata);
    }
    selectAt(fieldIndices) {
      const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
      return new Schema2(fields, this.metadata);
    }
    assign(...args) {
      const other = args[0] instanceof Schema2 ? args[0] : Array.isArray(args[0]) ? new Schema2(args[0]) : new Schema2(args);
      const curFields = [...this.fields];
      const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
      const newFields = other.fields.filter((f2) => {
        const i = curFields.findIndex((f) => f.name === f2.name);
        return ~i ? (curFields[i] = f2.clone({
          metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
        })) && false : true;
      });
      const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
      return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
  };
  Schema2.prototype.fields = null;
  Schema2.prototype.metadata = null;
  Schema2.prototype.dictionaries = null;
  var Field2 = class {
    constructor(name, type, nullable = false, metadata) {
      this.name = name;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata || /* @__PURE__ */ new Map();
    }
    static new(...args) {
      let [name, type, nullable, metadata] = args;
      if (args[0] && typeof args[0] === "object") {
        ({ name } = args[0]);
        type === void 0 && (type = args[0].type);
        nullable === void 0 && (nullable = args[0].nullable);
        metadata === void 0 && (metadata = args[0].metadata);
      }
      return new Field2(`${name}`, type, nullable, metadata);
    }
    get typeId() {
      return this.type.typeId;
    }
    get [Symbol.toStringTag]() {
      return "Field";
    }
    toString() {
      return `${this.name}: ${this.type}`;
    }
    clone(...args) {
      let [name, type, nullable, metadata] = args;
      !args[0] || typeof args[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
      return Field2.new(name, type, nullable, metadata);
    }
  };
  Field2.prototype.type = null;
  Field2.prototype.name = null;
  Field2.prototype.nullable = null;
  Field2.prototype.metadata = null;
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }
  function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const field = fields[i];
      const type = field.type;
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          dictionaries.set(type.id, type.dictionary);
        } else if (dictionaries.get(type.id) !== type.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        generateDictionaryMap(type.children, dictionaries);
      }
    }
    return dictionaries;
  }

  // ../../node_modules/apache-arrow/ipc/metadata/file.mjs
  var Long2 = Long;
  var Builder3 = Builder2;
  var ByteBuffer2 = ByteBuffer;
  var Footer_ = class {
    constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {
      this.schema = schema;
      this.version = version;
      recordBatches && (this._recordBatches = recordBatches);
      dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    static decode(buf) {
      buf = new ByteBuffer2(toUint8Array(buf));
      const footer = Footer.getRootAsFooter(buf);
      const schema = Schema2.decode(footer.schema());
      return new OffHeapFooter(schema, footer);
    }
    static encode(footer) {
      const b = new Builder3();
      const schemaOffset = Schema2.encode(b, footer.schema);
      Footer.startRecordBatchesVector(b, footer.numRecordBatches);
      for (const rb of [...footer.recordBatches()].slice().reverse()) {
        FileBlock.encode(b, rb);
      }
      const recordBatchesOffset = b.endVector();
      Footer.startDictionariesVector(b, footer.numDictionaries);
      for (const db2 of [...footer.dictionaryBatches()].slice().reverse()) {
        FileBlock.encode(b, db2);
      }
      const dictionaryBatchesOffset = b.endVector();
      Footer.startFooter(b);
      Footer.addSchema(b, schemaOffset);
      Footer.addVersion(b, MetadataVersion.V4);
      Footer.addRecordBatches(b, recordBatchesOffset);
      Footer.addDictionaries(b, dictionaryBatchesOffset);
      Footer.finishFooterBuffer(b, Footer.endFooter(b));
      return b.asUint8Array();
    }
    get numRecordBatches() {
      return this._recordBatches.length;
    }
    get numDictionaries() {
      return this._dictionaryBatches.length;
    }
    *recordBatches() {
      for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
        if (block = this.getRecordBatch(i)) {
          yield block;
        }
      }
    }
    *dictionaryBatches() {
      for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
        if (block = this.getDictionaryBatch(i)) {
          yield block;
        }
      }
    }
    getRecordBatch(index) {
      return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
      return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
    }
  };
  var OffHeapFooter = class extends Footer_ {
    constructor(schema, _footer) {
      super(schema, _footer.version());
      this._footer = _footer;
    }
    get numRecordBatches() {
      return this._footer.recordBatchesLength();
    }
    get numDictionaries() {
      return this._footer.dictionariesLength();
    }
    getRecordBatch(index) {
      if (index >= 0 && index < this.numRecordBatches) {
        const fileBlock = this._footer.recordBatches(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
    getDictionaryBatch(index) {
      if (index >= 0 && index < this.numDictionaries) {
        const fileBlock = this._footer.dictionaries(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
  };
  var FileBlock = class {
    constructor(metaDataLength, bodyLength, offset) {
      this.metaDataLength = metaDataLength;
      this.offset = typeof offset === "number" ? offset : offset.low;
      this.bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
    }
    static decode(block) {
      return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    static encode(b, fileBlock) {
      const { metaDataLength } = fileBlock;
      const offset = new Long2(fileBlock.offset, 0);
      const bodyLength = new Long2(fileBlock.bodyLength, 0);
      return Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
  };

  // ../../node_modules/apache-arrow/io/interfaces.mjs
  var ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
  var ArrowJSON = class {
    constructor(_json) {
      this._json = _json;
    }
    get schema() {
      return this._json["schema"];
    }
    get batches() {
      return this._json["batches"] || [];
    }
    get dictionaries() {
      return this._json["dictionaries"] || [];
    }
  };
  var ReadableInterop = class {
    tee() {
      return this._getDOMStream().tee();
    }
    pipe(writable, options) {
      return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) {
      return this._getDOMStream().pipeTo(writable, options);
    }
    pipeThrough(duplex, options) {
      return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
      return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
      return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
  };
  var AsyncQueue = class extends ReadableInterop {
    constructor() {
      super();
      this._values = [];
      this.resolvers = [];
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() {
      return this._closedPromise;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    write(value) {
      if (this._ensureOpen()) {
        this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
      }
    }
    abort(value) {
      if (this._closedPromiseResolve) {
        this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
      }
    }
    close() {
      if (this._closedPromiseResolve) {
        const { resolvers } = this;
        while (resolvers.length > 0) {
          resolvers.shift().resolve(ITERATOR_DONE);
        }
        this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    toDOMStream(options) {
      return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    toNodeStream(options) {
      return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    throw(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.abort(_);
        return ITERATOR_DONE;
      });
    }
    return(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return ITERATOR_DONE;
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(..._args) {
      if (this._values.length > 0) {
        return Promise.resolve({ done: false, value: this._values.shift() });
      } else if (this._error) {
        return Promise.reject({ done: true, value: this._error.error });
      } else if (!this._closedPromiseResolve) {
        return Promise.resolve(ITERATOR_DONE);
      } else {
        return new Promise((resolve, reject) => {
          this.resolvers.push({ resolve, reject });
        });
      }
    }
    _ensureOpen() {
      if (this._closedPromiseResolve) {
        return true;
      }
      throw new Error(`AsyncQueue is closed`);
    }
  };

  // ../../node_modules/apache-arrow/io/stream.mjs
  var AsyncByteQueue = class extends AsyncQueue {
    write(value) {
      if ((value = toUint8Array(value)).byteLength > 0) {
        return super.write(value);
      }
    }
    toString(sync = false) {
      return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
    }
    toUint8Array(sync = false) {
      return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
        var e_1, _a5;
        const buffers = [];
        let byteLength = 0;
        try {
          for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {
            const chunk = _c2.value;
            buffers.push(chunk);
            byteLength += chunk.byteLength;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a5 = _b2.return))
              yield _a5.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return joinUint8Arrays(buffers, byteLength)[0];
      }))();
    }
  };
  var ByteStream = class {
    constructor(source) {
      if (source) {
        this.source = new ByteStreamSource(adapters_default.fromIterable(source));
      }
    }
    [Symbol.iterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var AsyncByteStream = class {
    constructor(source) {
      if (source instanceof AsyncByteStream) {
        this.source = source.source;
      } else if (source instanceof AsyncByteQueue) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isReadableNodeStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
      } else if (isReadableDOMStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
      } else if (isFetchResponse(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
      } else if (isIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
      } else if (isPromise(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isAsyncIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    get closed() {
      return this.source.closed;
    }
    cancel(reason) {
      return this.source.cancel(reason);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var ByteStreamSource = class {
    constructor(source) {
      this.source = source;
    }
    cancel(reason) {
      this.return(reason);
    }
    peek(size) {
      return this.next(size, "peek").value;
    }
    read(size) {
      return this.next(size, "read").value;
    }
    next(size, cmd = "read") {
      return this.source.next({ cmd, size });
    }
    throw(value) {
      return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
    }
    return(value) {
      return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
    }
  };
  var AsyncByteStreamSource = class {
    constructor(source) {
      this.source = source;
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    get closed() {
      return this._closedPromise;
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(size, cmd = "read") {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.next({ cmd, size });
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
  };

  // ../../node_modules/apache-arrow/io/file.mjs
  var RandomAccessFile = class extends ByteStream {
    constructor(buffer, byteLength) {
      super();
      this.position = 0;
      this.buffer = toUint8Array(buffer);
      this.size = typeof byteLength === "undefined" ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
      const { buffer, byteOffset } = this.readAt(position, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
      this.position = Math.min(position, this.size);
      return position < this.size;
    }
    read(nBytes) {
      const { buffer, size, position } = this;
      if (buffer && position < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        this.position = Math.min(size, position + Math.min(size - position, nBytes));
        return buffer.subarray(position, this.position);
      }
      return null;
    }
    readAt(position, nBytes) {
      const buf = this.buffer;
      const end = Math.min(this.size, position + nBytes);
      return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() {
      this.buffer && (this.buffer = null);
    }
    throw(value) {
      this.close();
      return { done: true, value };
    }
    return(value) {
      this.close();
      return { done: true, value };
    }
  };
  var AsyncRandomAccessFile = class extends AsyncByteStream {
    constructor(file, byteLength) {
      super();
      this.position = 0;
      this._handle = file;
      if (typeof byteLength === "number") {
        this.size = byteLength;
      } else {
        this._pending = (() => __awaiter(this, void 0, void 0, function* () {
          this.size = (yield file.stat()).size;
          delete this._pending;
        }))();
      }
    }
    readInt32(position) {
      return __awaiter(this, void 0, void 0, function* () {
        const { buffer, byteOffset } = yield this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      });
    }
    seek(position) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        this.position = Math.min(position, this.size);
        return position < this.size;
      });
    }
    read(nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size, position } = this;
        if (file && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Number.POSITIVE_INFINITY;
          }
          let pos = position, offset = 0, bytesRead = 0;
          const end = Math.min(size, pos + Math.min(size - pos, nBytes));
          const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
          while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
            ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
          }
          return buffer;
        }
        return null;
      });
    }
    readAt(position, nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size } = this;
        if (file && position + nBytes < size) {
          const end = Math.min(size, position + nBytes);
          const buffer = new Uint8Array(end - position);
          return (yield file.read(buffer, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const f = this._handle;
        this._handle = null;
        f && (yield f.close());
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
  };

  // ../../node_modules/apache-arrow/util/int.mjs
  var int_exports = {};
  __export(int_exports, {
    BaseInt64: () => BaseInt64,
    Int128: () => Int128,
    Int64: () => Int642,
    Uint64: () => Uint642
  });
  var carryBit16 = 1 << 16;
  function intAsHex(value) {
    if (value < 0) {
      value = 4294967295 + value + 1;
    }
    return `0x${value.toString(16)}`;
  }
  var kInt32DecimalDigits = 8;
  var kPowersOfTen = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8
  ];
  var BaseInt64 = class {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return this.buffer[1];
    }
    low() {
      return this.buffer[0];
    }
    _times(other) {
      const L = new Uint32Array([
        this.buffer[1] >>> 16,
        this.buffer[1] & 65535,
        this.buffer[0] >>> 16,
        this.buffer[0] & 65535
      ]);
      const R = new Uint32Array([
        other.buffer[1] >>> 16,
        other.buffer[1] & 65535,
        other.buffer[0] >>> 16,
        other.buffer[0] & 65535
      ]);
      let product = L[3] * R[3];
      this.buffer[0] = product & 65535;
      let sum2 = product >>> 16;
      product = L[2] * R[3];
      sum2 += product;
      product = L[3] * R[2] >>> 0;
      sum2 += product;
      this.buffer[0] += sum2 << 16;
      this.buffer[1] = sum2 >>> 0 < product ? carryBit16 : 0;
      this.buffer[1] += sum2 >>> 16;
      this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
      this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
      return this;
    }
    _plus(other) {
      const sum2 = this.buffer[0] + other.buffer[0] >>> 0;
      this.buffer[1] += other.buffer[1];
      if (sum2 < this.buffer[0] >>> 0) {
        ++this.buffer[1];
      }
      this.buffer[0] = sum2;
    }
    lessThan(other) {
      return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
    }
    equals(other) {
      return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
      return other.lessThan(this);
    }
    hex() {
      return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
  };
  var Uint642 = class extends BaseInt64 {
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    static from(val, out_buffer = new Uint32Array(2)) {
      return Uint642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return Uint642.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const length = str.length;
      const out = new Uint642(out_buffer);
      for (let posn = 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new Uint642(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return out;
    }
    static convertArray(values) {
      const data = new Uint32Array(values.length * 2);
      for (let i = -1, n = values.length; ++i < n; ) {
        Uint642.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
      }
      return data;
    }
    static multiply(left, right) {
      const rtrn = new Uint642(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    static add(left, right) {
      const rtrn = new Uint642(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int642 = class extends BaseInt64 {
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      return this;
    }
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    lessThan(other) {
      const this_high = this.buffer[1] << 0;
      const other_high = other.buffer[1] << 0;
      return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
    }
    static from(val, out_buffer = new Uint32Array(2)) {
      return Int642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return Int642.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out = new Int642(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new Int642(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return negate ? out.negate() : out;
    }
    static convertArray(values) {
      const data = new Uint32Array(values.length * 2);
      for (let i = -1, n = values.length; ++i < n; ) {
        Int642.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
      }
      return data;
    }
    static multiply(left, right) {
      const rtrn = new Int642(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    static add(left, right) {
      const rtrn = new Int642(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int128 = class {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      this.buffer[2] = ~this.buffer[2];
      this.buffer[3] = ~this.buffer[3];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      if (this.buffer[1] == 0) {
        ++this.buffer[2];
      }
      if (this.buffer[2] == 0) {
        ++this.buffer[3];
      }
      return this;
    }
    times(other) {
      const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
      const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
      const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
      const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
      const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
      const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
      const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
      const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
      let product = Uint642.multiply(L3, R3);
      this.buffer[0] = product.low();
      const sum2 = new Uint642(new Uint32Array([product.high(), 0]));
      product = Uint642.multiply(L2, R3);
      sum2.plus(product);
      product = Uint642.multiply(L3, R2);
      sum2.plus(product);
      this.buffer[1] = sum2.low();
      this.buffer[3] = sum2.lessThan(product) ? 1 : 0;
      this.buffer[2] = sum2.high();
      const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
      this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
      return this;
    }
    plus(other) {
      const sums = new Uint32Array(4);
      sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
      sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
      sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
      sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
      if (sums[0] < this.buffer[0] >>> 0) {
        ++sums[1];
      }
      if (sums[1] < this.buffer[1] >>> 0) {
        ++sums[2];
      }
      if (sums[2] < this.buffer[2] >>> 0) {
        ++sums[3];
      }
      this.buffer[3] = sums[3];
      this.buffer[2] = sums[2];
      this.buffer[1] = sums[1];
      this.buffer[0] = sums[0];
      return this;
    }
    hex() {
      return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    static multiply(left, right) {
      const rtrn = new Int128(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    static add(left, right) {
      const rtrn = new Int128(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
    static from(val, out_buffer = new Uint32Array(4)) {
      return Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
      return Int128.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(4)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out = new Int128(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
        const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return negate ? out.negate() : out;
    }
    static convertArray(values) {
      const data = new Uint32Array(values.length * 4);
      for (let i = -1, n = values.length; ++i < n; ) {
        Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
      }
      return data;
    }
  };

  // ../../node_modules/apache-arrow/visitor/vectorloader.mjs
  var VectorLoader = class extends Visitor {
    constructor(bytes, nodes, buffers, dictionaries) {
      super();
      this.nodesIndex = -1;
      this.buffersIndex = -1;
      this.bytes = bytes;
      this.nodes = nodes;
      this.buffers = buffers;
      this.dictionaries = dictionaries;
    }
    visit(node) {
      return super.visit(node instanceof Field2 ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
      return makeData({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type) {
      return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type) : this.visitDenseUnion(type);
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), "child": this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    nextFieldNode() {
      return this.nodes[++this.nodesIndex];
    }
    nextBufferRange() {
      return this.buffers[++this.buffersIndex];
    }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
      return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) {
      return this.readData(type, buffer);
    }
    readTypeIds(type, buffer) {
      return this.readData(type, buffer);
    }
    readData(_type, { length, offset } = this.nextBufferRange()) {
      return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
      return this.dictionaries.get(type.id);
    }
  };
  var JSONVectorLoader = class extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries) {
      super(new Uint8Array(0), nodes, buffers, dictionaries);
      this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
      return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
      const { sources } = this;
      if (DataType.isTimestamp(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDecimal(type)) {
        return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));
      } else if (DataType.isBinary(type) || DataType.isFixedSizeBinary(type)) {
        return binaryDataFromJSON(sources[offset]);
      } else if (DataType.isBool(type)) {
        return packBools(sources[offset]);
      } else if (DataType.isUtf8(type)) {
        return encodeUtf8(sources[offset].join(""));
      }
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
    }
  };
  function binaryDataFromJSON(values) {
    const joined = values.join("");
    const data = new Uint8Array(joined.length / 2);
    for (let i = 0; i < joined.length; i += 2) {
      data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
  }

  // ../../node_modules/apache-arrow/builder/binary.mjs
  var BinaryBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, toUint8Array(value));
    }
    _flushPending(pending, pendingLength) {
      const offsets = this._offsets;
      const data = this._values.reserve(pendingLength).buffer;
      let offset = 0;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          const length = value.length;
          data.set(value, offset);
          offsets.set(index, length);
          offset += length;
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/bool.mjs
  var BoolBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._values = new BitmapBufferBuilder();
    }
    setValue(index, value) {
      this._values.set(index, +value);
    }
  };

  // ../../node_modules/apache-arrow/builder/date.mjs
  var DateBuilder = class extends FixedWidthBuilder {
  };
  DateBuilder.prototype._setValue = setDate;
  var DateDayBuilder = class extends DateBuilder {
  };
  DateDayBuilder.prototype._setValue = setDateDay;
  var DateMillisecondBuilder = class extends DateBuilder {
  };
  DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

  // ../../node_modules/apache-arrow/builder/decimal.mjs
  var DecimalBuilder = class extends FixedWidthBuilder {
  };
  DecimalBuilder.prototype._setValue = setDecimal;

  // ../../node_modules/apache-arrow/builder/dictionary.mjs
  var DictionaryBuilder = class extends Builder {
    constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
      super({ type: new Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
      this._nulls = null;
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      this.indices = makeBuilder({ "type": this.type.indices, "nullValues": nulls });
      this.dictionary = makeBuilder({ "type": this.type.dictionary, "nullValues": null });
      if (typeof hashFn === "function") {
        this.valueToKey = hashFn;
      }
    }
    get values() {
      return this.indices.values;
    }
    get nullCount() {
      return this.indices.nullCount;
    }
    get nullBitmap() {
      return this.indices.nullBitmap;
    }
    get byteLength() {
      return this.indices.byteLength + this.dictionary.byteLength;
    }
    get reservedLength() {
      return this.indices.reservedLength + this.dictionary.reservedLength;
    }
    get reservedByteLength() {
      return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
    }
    isValid(value) {
      return this.indices.isValid(value);
    }
    setValid(index, valid) {
      const indices = this.indices;
      valid = indices.setValid(index, valid);
      this.length = indices.length;
      return valid;
    }
    setValue(index, value) {
      const keysToIndices = this._keysToIndices;
      const key = this.valueToKey(value);
      let idx = keysToIndices[key];
      if (idx === void 0) {
        keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
      }
      return this.indices.setValue(index, idx);
    }
    flush() {
      const type = this.type;
      const prev = this._dictionary;
      const curr = this.dictionary.toVector();
      const data = this.indices.flush().clone(type);
      data.dictionary = prev ? prev.concat(curr) : curr;
      this.finished || (this._dictionaryOffset += curr.length);
      this._dictionary = data.dictionary;
      this.clear();
      return data;
    }
    finish() {
      this.indices.finish();
      this.dictionary.finish();
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      return super.finish();
    }
    clear() {
      this.indices.clear();
      this.dictionary.clear();
      return super.clear();
    }
    valueToKey(val) {
      return typeof val === "string" ? val : `${val}`;
    }
  };

  // ../../node_modules/apache-arrow/builder/fixedsizebinary.mjs
  var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {
  };
  FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

  // ../../node_modules/apache-arrow/builder/fixedsizelist.mjs
  var FixedSizeListBuilder = class extends Builder {
    setValue(index, value) {
      const [child] = this.children;
      const start = index * this.stride;
      for (let i = -1, n = value.length; ++i < n; ) {
        child.set(start + i, value[i]);
      }
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("FixedSizeListBuilder can only have one child.");
      }
      const childIndex = this.children.push(child);
      this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));
      return childIndex;
    }
  };

  // ../../node_modules/apache-arrow/builder/float.mjs
  var FloatBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Float16Builder = class extends FloatBuilder {
    setValue(index, value) {
      super.setValue(index, float64ToUint16(value));
    }
  };
  var Float32Builder = class extends FloatBuilder {
  };
  var Float64Builder = class extends FloatBuilder {
  };

  // ../../node_modules/apache-arrow/builder/interval.mjs
  var IntervalBuilder = class extends FixedWidthBuilder {
  };
  IntervalBuilder.prototype._setValue = setIntervalValue;
  var IntervalDayTimeBuilder = class extends IntervalBuilder {
  };
  IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
  var IntervalYearMonthBuilder = class extends IntervalBuilder {
  };
  IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

  // ../../node_modules/apache-arrow/builder/int.mjs
  var IntBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Int8Builder = class extends IntBuilder {
  };
  var Int16Builder = class extends IntBuilder {
  };
  var Int32Builder = class extends IntBuilder {
  };
  var Int64Builder = class extends IntBuilder {
  };
  var Uint8Builder = class extends IntBuilder {
  };
  var Uint16Builder = class extends IntBuilder {
  };
  var Uint32Builder = class extends IntBuilder {
  };
  var Uint64Builder = class extends IntBuilder {
  };

  // ../../node_modules/apache-arrow/builder/list.mjs
  var ListBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._offsets = new OffsetsBufferBuilder();
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new List(new Field2(name, child.type, true));
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (typeof value === "undefined") {
          offsets.set(index, 0);
        } else {
          const n = value.length;
          const start = offsets.set(index, n).buffer[index];
          for (let i = -1; ++i < n; ) {
            child.set(start + i, value[i]);
          }
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/map.mjs
  var MapBuilder = class extends VariableWidthBuilder {
    set(index, value) {
      return super.set(index, value);
    }
    setValue(index, value) {
      const row = value instanceof Map ? value : new Map(Object.entries(value));
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.size);
      this._pendingLength += row.size;
      pending.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
          for (const val of value.entries()) {
            child.set(idx, val);
            if (++idx >= end)
              break;
          }
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/null.mjs
  var NullBuilder = class extends Builder {
    setValue(index, value) {
    }
    setValid(index, valid) {
      this.length = Math.max(index + 1, this.length);
      return valid;
    }
  };

  // ../../node_modules/apache-arrow/builder/struct.mjs
  var StructBuilder = class extends Builder {
    setValue(index, value) {
      const { children, type } = this;
      switch (Array.isArray(value) || value.constructor) {
        case true:
          return type.children.forEach((_, i) => children[i].set(index, value[i]));
        case Map:
          return type.children.forEach((f, i) => children[i].set(index, value.get(f.name)));
        default:
          return type.children.forEach((f, i) => children[i].set(index, value[f.name]));
      }
    }
    setValid(index, valid) {
      if (!super.setValid(index, valid)) {
        this.children.forEach((child) => child.setValid(index, valid));
      }
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      const childIndex = this.children.push(child);
      this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);
      return childIndex;
    }
  };

  // ../../node_modules/apache-arrow/builder/timestamp.mjs
  var TimestampBuilder = class extends FixedWidthBuilder {
  };
  TimestampBuilder.prototype._setValue = setTimestamp;
  var TimestampSecondBuilder = class extends TimestampBuilder {
  };
  TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
  var TimestampMillisecondBuilder = class extends TimestampBuilder {
  };
  TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
  var TimestampMicrosecondBuilder = class extends TimestampBuilder {
  };
  TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
  var TimestampNanosecondBuilder = class extends TimestampBuilder {
  };
  TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

  // ../../node_modules/apache-arrow/builder/time.mjs
  var TimeBuilder = class extends FixedWidthBuilder {
  };
  TimeBuilder.prototype._setValue = setTime;
  var TimeSecondBuilder = class extends TimeBuilder {
  };
  TimeSecondBuilder.prototype._setValue = setTimeSecond;
  var TimeMillisecondBuilder = class extends TimeBuilder {
  };
  TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
  var TimeMicrosecondBuilder = class extends TimeBuilder {
  };
  TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
  var TimeNanosecondBuilder = class extends TimeBuilder {
  };
  TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

  // ../../node_modules/apache-arrow/builder/union.mjs
  var UnionBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);
      if (typeof options["valueToChildTypeId"] === "function") {
        this._valueToChildTypeId = options["valueToChildTypeId"];
      }
    }
    get typeIdToChildIndex() {
      return this.type.typeIdToChildIndex;
    }
    append(value, childTypeId) {
      return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
      if (childTypeId === void 0) {
        childTypeId = this._valueToChildTypeId(this, value, index);
      }
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value, childTypeId);
      }
      return this;
    }
    setValue(index, value, childTypeId) {
      this._typeIds.set(index, childTypeId);
      const childIndex = this.type.typeIdToChildIndex[childTypeId];
      const child = this.children[childIndex];
      child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
      const childTypeId = this.children.push(child);
      const { type: { children, mode, typeIds } } = this;
      const fields = [...children, new Field2(name, child.type)];
      this.type = new Union_(mode, [...typeIds, childTypeId], fields);
      return childTypeId;
    }
    _valueToChildTypeId(builder, value, offset) {
      throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
  };
  var SparseUnionBuilder = class extends UnionBuilder {
  };
  var DenseUnionBuilder = class extends UnionBuilder {
    constructor(options) {
      super(options);
      this._offsets = new DataBufferBuilder(new Int32Array(0));
    }
    setValue(index, value, childTypeId) {
      const id = this._typeIds.set(index, childTypeId).buffer[index];
      const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
      const denseIndex = this._offsets.set(index, child.length).buffer[index];
      child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
  };

  // ../../node_modules/apache-arrow/builder/utf8.mjs
  var Utf8Builder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, encodeUtf8(value));
    }
    _flushPending(pending, pendingLength) {
    }
  };
  Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

  // ../../node_modules/apache-arrow/visitor/builderctor.mjs
  var GetBuilderCtor = class extends Visitor {
    visitNull() {
      return NullBuilder;
    }
    visitBool() {
      return BoolBuilder;
    }
    visitInt() {
      return IntBuilder;
    }
    visitInt8() {
      return Int8Builder;
    }
    visitInt16() {
      return Int16Builder;
    }
    visitInt32() {
      return Int32Builder;
    }
    visitInt64() {
      return Int64Builder;
    }
    visitUint8() {
      return Uint8Builder;
    }
    visitUint16() {
      return Uint16Builder;
    }
    visitUint32() {
      return Uint32Builder;
    }
    visitUint64() {
      return Uint64Builder;
    }
    visitFloat() {
      return FloatBuilder;
    }
    visitFloat16() {
      return Float16Builder;
    }
    visitFloat32() {
      return Float32Builder;
    }
    visitFloat64() {
      return Float64Builder;
    }
    visitUtf8() {
      return Utf8Builder;
    }
    visitBinary() {
      return BinaryBuilder;
    }
    visitFixedSizeBinary() {
      return FixedSizeBinaryBuilder;
    }
    visitDate() {
      return DateBuilder;
    }
    visitDateDay() {
      return DateDayBuilder;
    }
    visitDateMillisecond() {
      return DateMillisecondBuilder;
    }
    visitTimestamp() {
      return TimestampBuilder;
    }
    visitTimestampSecond() {
      return TimestampSecondBuilder;
    }
    visitTimestampMillisecond() {
      return TimestampMillisecondBuilder;
    }
    visitTimestampMicrosecond() {
      return TimestampMicrosecondBuilder;
    }
    visitTimestampNanosecond() {
      return TimestampNanosecondBuilder;
    }
    visitTime() {
      return TimeBuilder;
    }
    visitTimeSecond() {
      return TimeSecondBuilder;
    }
    visitTimeMillisecond() {
      return TimeMillisecondBuilder;
    }
    visitTimeMicrosecond() {
      return TimeMicrosecondBuilder;
    }
    visitTimeNanosecond() {
      return TimeNanosecondBuilder;
    }
    visitDecimal() {
      return DecimalBuilder;
    }
    visitList() {
      return ListBuilder;
    }
    visitStruct() {
      return StructBuilder;
    }
    visitUnion() {
      return UnionBuilder;
    }
    visitDenseUnion() {
      return DenseUnionBuilder;
    }
    visitSparseUnion() {
      return SparseUnionBuilder;
    }
    visitDictionary() {
      return DictionaryBuilder;
    }
    visitInterval() {
      return IntervalBuilder;
    }
    visitIntervalDayTime() {
      return IntervalDayTimeBuilder;
    }
    visitIntervalYearMonth() {
      return IntervalYearMonthBuilder;
    }
    visitFixedSizeList() {
      return FixedSizeListBuilder;
    }
    visitMap() {
      return MapBuilder;
    }
  };
  var instance6 = new GetBuilderCtor();

  // ../../node_modules/apache-arrow/visitor/typecomparator.mjs
  var TypeComparator = class extends Visitor {
    compareSchemas(schema, other) {
      return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
    }
    compareManyFields(fields, others) {
      return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));
    }
    compareFields(field, other) {
      return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
    }
  };
  function compareConstructor(type, other) {
    return other instanceof type.constructor;
  }
  function compareAny(type, other) {
    return type === other || compareConstructor(type, other);
  }
  function compareInt(type, other) {
    return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
  }
  function compareFloat(type, other) {
    return type === other || compareConstructor(type, other) && type.precision === other.precision;
  }
  function compareFixedSizeBinary(type, other) {
    return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
  }
  function compareDate(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareTimestamp(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
  }
  function compareTime(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
  }
  function compareList(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareStruct(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareUnion(type, other) {
    return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && instance7.compareManyFields(type.children, other.children);
  }
  function compareDictionary(type, other) {
    return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance7.visit(type.indices, other.indices) && instance7.visit(type.dictionary, other.dictionary);
  }
  function compareInterval(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareFixedSizeList(type, other) {
    return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareMap(type, other) {
    return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  TypeComparator.prototype.visitNull = compareAny;
  TypeComparator.prototype.visitBool = compareAny;
  TypeComparator.prototype.visitInt = compareInt;
  TypeComparator.prototype.visitInt8 = compareInt;
  TypeComparator.prototype.visitInt16 = compareInt;
  TypeComparator.prototype.visitInt32 = compareInt;
  TypeComparator.prototype.visitInt64 = compareInt;
  TypeComparator.prototype.visitUint8 = compareInt;
  TypeComparator.prototype.visitUint16 = compareInt;
  TypeComparator.prototype.visitUint32 = compareInt;
  TypeComparator.prototype.visitUint64 = compareInt;
  TypeComparator.prototype.visitFloat = compareFloat;
  TypeComparator.prototype.visitFloat16 = compareFloat;
  TypeComparator.prototype.visitFloat32 = compareFloat;
  TypeComparator.prototype.visitFloat64 = compareFloat;
  TypeComparator.prototype.visitUtf8 = compareAny;
  TypeComparator.prototype.visitBinary = compareAny;
  TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
  TypeComparator.prototype.visitDate = compareDate;
  TypeComparator.prototype.visitDateDay = compareDate;
  TypeComparator.prototype.visitDateMillisecond = compareDate;
  TypeComparator.prototype.visitTimestamp = compareTimestamp;
  TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
  TypeComparator.prototype.visitTime = compareTime;
  TypeComparator.prototype.visitTimeSecond = compareTime;
  TypeComparator.prototype.visitTimeMillisecond = compareTime;
  TypeComparator.prototype.visitTimeMicrosecond = compareTime;
  TypeComparator.prototype.visitTimeNanosecond = compareTime;
  TypeComparator.prototype.visitDecimal = compareAny;
  TypeComparator.prototype.visitList = compareList;
  TypeComparator.prototype.visitStruct = compareStruct;
  TypeComparator.prototype.visitUnion = compareUnion;
  TypeComparator.prototype.visitDenseUnion = compareUnion;
  TypeComparator.prototype.visitSparseUnion = compareUnion;
  TypeComparator.prototype.visitDictionary = compareDictionary;
  TypeComparator.prototype.visitInterval = compareInterval;
  TypeComparator.prototype.visitIntervalDayTime = compareInterval;
  TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
  TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
  TypeComparator.prototype.visitMap = compareMap;
  var instance7 = new TypeComparator();
  function compareSchemas(schema, other) {
    return instance7.compareSchemas(schema, other);
  }
  function compareFields(field, other) {
    return instance7.compareFields(field, other);
  }
  function compareTypes(type, other) {
    return instance7.visit(type, other);
  }

  // ../../node_modules/apache-arrow/factories.mjs
  function makeBuilder(options) {
    const type = options.type;
    const builder = new (instance6.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
      const children = options["children"] || [];
      const defaultOptions = { "nullValues": options["nullValues"] };
      const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : ({ name }) => children[name] || defaultOptions;
      for (const [index, field] of type.children.entries()) {
        const { type: type2 } = field;
        const opts = getChildOptions(field, index);
        builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type2 })));
      }
    }
    return builder;
  }
  function vectorFromArray(init, type) {
    if (init instanceof Data || init instanceof Vector || init.type instanceof DataType || ArrayBuffer.isView(init)) {
      return makeVector(init);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (DataType.isDictionary(vector.type)) {
      return vector.memoize();
    }
    return vector;
  }
  function inferType(value) {
    if (value.length === 0) {
      return new Null();
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
      if (val == null) {
        ++nullsCount;
        continue;
      }
      switch (typeof val) {
        case "bigint":
          ++bigintsCount;
          continue;
        case "boolean":
          ++booleansCount;
          continue;
        case "number":
          ++numbersCount;
          continue;
        case "string":
          ++stringsCount;
          continue;
        case "object":
          if (Array.isArray(val)) {
            ++arraysCount;
          } else if (Object.prototype.toString.call(val) === "[object Date]") {
            ++datesCount;
          } else {
            ++objectsCount;
          }
          continue;
      }
      throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected");
    }
    if (numbersCount + nullsCount === value.length) {
      return new Float64();
    } else if (stringsCount + nullsCount === value.length) {
      return new Dictionary(new Utf8(), new Int32());
    } else if (bigintsCount + nullsCount === value.length) {
      return new Int64();
    } else if (booleansCount + nullsCount === value.length) {
      return new Bool();
    } else if (datesCount + nullsCount === value.length) {
      return new DateMillisecond();
    } else if (arraysCount + nullsCount === value.length) {
      const array = value;
      const childType = inferType(array[array.findIndex((ary) => ary != null)]);
      if (array.every((ary) => ary == null || compareTypes(childType, inferType(ary)))) {
        return new List(new Field2("", childType, true));
      }
    } else if (objectsCount + nullsCount === value.length) {
      const fields = /* @__PURE__ */ new Map();
      for (const row of value) {
        for (const key of Object.keys(row)) {
          if (!fields.has(key) && row[key] != null) {
            fields.set(key, new Field2(key, inferType([row[key]]), true));
          }
        }
      }
      return new Struct([...fields.values()]);
    }
    throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected");
  }
  function builderThroughIterable(options) {
    const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
    const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
    return function* (source) {
      let numChunks = 0;
      const builder = makeBuilder(options);
      for (const value of source) {
        if (builder.append(value)[sizeProperty] >= highWaterMark) {
          ++numChunks && (yield builder.toVector());
        }
      }
      if (builder.finish().length > 0 || numChunks === 0) {
        yield builder.toVector();
      }
    };
  }

  // ../../node_modules/apache-arrow/util/recordbatch.mjs
  function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
  }
  function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i = -1;
    const numColumns = cols.length;
    let child, children = [];
    while (memo.numBatches-- > 0) {
      for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
        children[i] = child = cols[i].shift();
        batchLength = Math.min(batchLength, child ? child.length : batchLength);
      }
      if (Number.isFinite(batchLength)) {
        children = distributeChildren(fields, batchLength, children, cols, memo);
        if (batchLength > 0) {
          batches[numBatches++] = makeData({
            type: new Struct(fields),
            length: batchLength,
            nullCount: 0,
            children: children.slice()
          });
        }
      }
    }
    return [
      schema = schema.assign(fields),
      batches.map((data) => new RecordBatch(schema, data))
    ];
  }
  function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a5;
    const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
    for (let i = -1, n = columns.length; ++i < n; ) {
      const child = children[i];
      const length = child === null || child === void 0 ? void 0 : child.length;
      if (length >= batchLength) {
        if (length === batchLength) {
          children[i] = child;
        } else {
          children[i] = child.slice(0, batchLength);
          memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
        }
      } else {
        const field = fields[i];
        fields[i] = field.clone({ nullable: true });
        children[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
          type: field.type,
          length: batchLength,
          nullCount: batchLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return children;
  }

  // ../../node_modules/apache-arrow/table.mjs
  var _a3;
  var Table = class {
    constructor(...args) {
      var _b2, _c2;
      if (args.length === 0) {
        this.batches = [];
        this.schema = new Schema2([]);
        this._offsets = [0];
        return this;
      }
      let schema;
      let offsets;
      if (args[0] instanceof Schema2) {
        schema = args.shift();
      }
      if (args[args.length - 1] instanceof Uint32Array) {
        offsets = args.pop();
      }
      const unwrap = (x) => {
        if (x) {
          if (x instanceof RecordBatch) {
            return [x];
          } else if (x instanceof Table) {
            return x.batches;
          } else if (x instanceof Data) {
            if (x.type instanceof Struct) {
              return [new RecordBatch(new Schema2(x.type.children), x)];
            }
          } else if (Array.isArray(x)) {
            return x.flatMap((v) => unwrap(v));
          } else if (typeof x[Symbol.iterator] === "function") {
            return [...x].flatMap((v) => unwrap(v));
          } else if (typeof x === "object") {
            const keys = Object.keys(x);
            const vecs = keys.map((k) => new Vector([x[k]]));
            const schema2 = new Schema2(keys.map((k, i) => new Field2(String(k), vecs[i].type)));
            const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);
            return batches2.length === 0 ? [new RecordBatch(x)] : batches2;
          }
        }
        return [];
      };
      const batches = args.flatMap((v) => unwrap(v));
      schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);
      if (!(schema instanceof Schema2)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      for (const batch of batches) {
        if (!(batch instanceof RecordBatch)) {
          throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
        }
        if (!compareSchemas(schema, batch.schema)) {
          throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
        }
      }
      this.schema = schema;
      this.batches = batches;
      this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);
    }
    get data() {
      return this.batches.map(({ data }) => data);
    }
    get numCols() {
      return this.schema.fields.length;
    }
    get numRows() {
      return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    isValid(index) {
      return false;
    }
    get(index) {
      return null;
    }
    set(index, value) {
      return;
    }
    indexOf(element, offset) {
      return -1;
    }
    getByteLength(index) {
      return 0;
    }
    [Symbol.iterator]() {
      if (this.batches.length > 0) {
        return instance4.visit(new Vector(this.data));
      }
      return new Array(0)[Symbol.iterator]();
    }
    toArray() {
      return [...this];
    }
    toString() {
      return `[
  ${this.toArray().join(",\n  ")}
]`;
    }
    concat(...others) {
      const schema = this.schema;
      const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
      return new Table(schema, data.map((data2) => new RecordBatch(schema, data2)));
    }
    slice(begin, end) {
      const schema = this.schema;
      [begin, end] = clampRange({ length: this.numRows }, begin, end);
      const data = sliceChunks(this.data, this._offsets, begin, end);
      return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));
    }
    getChild(name) {
      return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        const data = this.data.map((data2) => data2.children[index]);
        if (data.length === 0) {
          const { type } = this.schema.fields[index];
          const empty = makeData({ type, length: 0, nullCount: 0 });
          data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
        }
        return new Vector(data);
      }
      return null;
    }
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let batches = [...this.batches];
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const field = fields[index].clone({ type: child.type });
        const children = this.schema.fields.map((_, i) => this.getChildAt(i));
        [fields[index], children[index]] = [field, child];
        [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);
      }
      return new Table(schema, batches);
    }
    select(columnNames) {
      const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
      return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const data = this.batches.map((batch) => batch.selectAt(columnIndices));
      return new Table(schema, data);
    }
    assign(other) {
      const fields = this.schema.fields;
      const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
        const [indices2, oldToNew2] = memo;
        const i = fields.findIndex((f) => f.name === f2.name);
        ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
        return memo;
      }, [[], []]);
      const schema = this.schema.assign(other.schema);
      const columns = [
        ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),
        ...indices.map((i) => other.getChildAt(i))
      ].filter(Boolean);
      return new Table(...distributeVectorsIntoRecordBatches(schema, columns));
    }
  };
  _a3 = Symbol.toStringTag;
  Table[_a3] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto["isValid"] = wrapChunkedCall1(isChunkedValid);
    proto["get"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));
    proto["set"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));
    proto["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));
    proto["getByteLength"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));
    return "Table";
  })(Table.prototype);

  // ../../node_modules/apache-arrow/recordbatch.mjs
  var _a4;
  var RecordBatch = class {
    constructor(...args) {
      switch (args.length) {
        case 2: {
          [this.schema] = args;
          if (!(this.schema instanceof Schema2)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [
            ,
            this.data = makeData({
              nullCount: 0,
              type: new Struct(this.schema.fields),
              children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
            })
          ] = args;
          if (!(this.data instanceof Data)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
          break;
        }
        case 1: {
          const [obj] = args;
          const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
            memo.children[i] = obj[name];
            memo.length = Math.max(memo.length, obj[name].length);
            memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });
            return memo;
          }, {
            length: 0,
            fields: new Array(),
            children: new Array()
          });
          const schema = new Schema2(fields);
          const data = makeData({ type: new Struct(fields), length, children, nullCount: 0 });
          [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
          break;
        }
        default:
          throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
      }
    }
    get dictionaries() {
      return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    get numCols() {
      return this.schema.fields.length;
    }
    get numRows() {
      return this.data.length;
    }
    get nullCount() {
      return this.data.nullCount;
    }
    isValid(index) {
      return this.data.getValid(index);
    }
    get(index) {
      return instance2.visit(this.data, index);
    }
    set(index, value) {
      return instance.visit(this.data, index, value);
    }
    indexOf(element, offset) {
      return instance3.visit(this.data, element, offset);
    }
    getByteLength(index) {
      return instance5.visit(this.data, index);
    }
    [Symbol.iterator]() {
      return instance4.visit(new Vector([this.data]));
    }
    toArray() {
      return [...this];
    }
    concat(...others) {
      return new Table(this.schema, [this, ...others]);
    }
    slice(begin, end) {
      const [slice] = new Vector([this.data]).slice(begin, end).data;
      return new RecordBatch(this.schema, slice);
    }
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        return new Vector([this.data.children[index]]);
      }
      return null;
    }
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let data = this.data;
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const children = data.children.slice();
        const field = fields[index].clone({ type: child.type });
        [fields[index], children[index]] = [field, child.data[0]];
        schema = new Schema2(fields, new Map(this.schema.metadata));
        data = makeData({ type: new Struct(fields), children });
      }
      return new RecordBatch(schema, data);
    }
    select(columnNames) {
      const schema = this.schema.select(columnNames);
      const type = new Struct(schema.fields);
      const children = [];
      for (const name of columnNames) {
        const index = this.schema.fields.findIndex((f) => f.name === name);
        if (~index) {
          children[index] = this.data.children[index];
        }
      }
      return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));
    }
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
      const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });
      return new RecordBatch(schema, subset);
    }
  };
  _a4 = Symbol.toStringTag;
  RecordBatch[_a4] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return "RecordBatch";
  })(RecordBatch.prototype);
  function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b2;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
      const chunk = chunks[idx];
      if (!chunk || chunk.length !== maxLength) {
        fields[idx] = field.clone({ nullable: true });
        children[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
          type: field.type,
          length: maxLength,
          nullCount: maxLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return [
      schema.assign(fields),
      makeData({ type: new Struct(fields), length: maxLength, children })
    ];
  }
  function collectDictionaries(fields, children, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const field = fields[i];
      const type = field.type;
      const data = children[i];
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          if (data.dictionary) {
            dictionaries.set(type.id, data.dictionary);
          }
        } else if (dictionaries.get(type.id) !== data.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        collectDictionaries(type.children, data.children, dictionaries);
      }
    }
    return dictionaries;
  }
  var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
    constructor(schema) {
      const children = schema.fields.map((f) => makeData({ type: f.type }));
      const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children });
      super(schema, data);
    }
  };

  // ../../node_modules/apache-arrow/fb/body-compression-method.mjs
  var BodyCompressionMethod;
  (function(BodyCompressionMethod2) {
    BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
  })(BodyCompressionMethod || (BodyCompressionMethod = {}));

  // ../../node_modules/apache-arrow/fb/compression-type.mjs
  var CompressionType;
  (function(CompressionType2) {
    CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
  })(CompressionType || (CompressionType = {}));

  // ../../node_modules/apache-arrow/fb/body-compression.mjs
  var BodyCompression = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBodyCompression(bb, obj) {
      return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    codec() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;
    }
    method() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
      builder.startObject(2);
    }
    static addCodec(builder, codec) {
      builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method2) {
      builder.addFieldInt8(1, method2, BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBodyCompression(builder, codec, method2) {
      BodyCompression.startBodyCompression(builder);
      BodyCompression.addCodec(builder, codec);
      BodyCompression.addMethod(builder, method2);
      return BodyCompression.endBodyCompression(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/buffer.mjs
  var Buffer2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    length() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createBuffer(builder, offset, length) {
      builder.prep(8, 16);
      builder.writeInt64(length);
      builder.writeInt64(offset);
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/fb/field-node.mjs
  var FieldNode = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    length() {
      return this.bb.readInt64(this.bb_pos);
    }
    nullCount() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createFieldNode(builder, length, null_count) {
      builder.prep(8, 16);
      builder.writeInt64(null_count);
      builder.writeInt64(length);
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/fb/record-batch.mjs
  var RecordBatch2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsRecordBatch(bb, obj) {
      return (obj || new RecordBatch2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new RecordBatch2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    length() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    nodes(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buffers(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    compression(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
      builder.startObject(4);
    }
    static addLength(builder, length) {
      builder.addFieldInt64(0, length, builder.createLong(0, 0));
    }
    static addNodes(builder, nodesOffset) {
      builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
      builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
      builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/dictionary-batch.mjs
  var DictionaryBatch = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
      return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    data(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isDelta() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
      builder.startObject(3);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, builder.createLong(0, 0));
    }
    static addData(builder, dataOffset) {
      builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
      builder.addFieldInt8(2, +isDelta, 0);
    }
    static endDictionaryBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/message-header.mjs
  var MessageHeader2;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader2 || (MessageHeader2 = {}));

  // ../../node_modules/apache-arrow/fb/message.mjs
  var Message = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsMessage(bb, obj) {
      return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    headerType() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader2.NONE;
    }
    header(obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addHeaderType(builder, headerType) {
      builder.addFieldInt8(1, headerType, MessageHeader2.NONE);
    }
    static addHeader(builder, headerOffset) {
      builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
      builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishMessageBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
      Message.startMessage(builder);
      Message.addVersion(builder, version);
      Message.addHeaderType(builder, headerType);
      Message.addHeader(builder, headerOffset);
      Message.addBodyLength(builder, bodyLength);
      Message.addCustomMetadata(builder, customMetadataOffset);
      return Message.endMessage(builder);
    }
  };

  // ../../node_modules/apache-arrow/visitor/typeassembler.mjs
  var Long3 = Long;
  var TypeAssembler = class extends Visitor {
    visit(node, builder) {
      return node == null || builder == null ? void 0 : super.visit(node, builder);
    }
    visitNull(_node, b) {
      Null2.startNull(b);
      return Null2.endNull(b);
    }
    visitInt(node, b) {
      Int.startInt(b);
      Int.addBitWidth(b, node.bitWidth);
      Int.addIsSigned(b, node.isSigned);
      return Int.endInt(b);
    }
    visitFloat(node, b) {
      FloatingPoint.startFloatingPoint(b);
      FloatingPoint.addPrecision(b, node.precision);
      return FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
      Binary2.startBinary(b);
      return Binary2.endBinary(b);
    }
    visitBool(_node, b) {
      Bool2.startBool(b);
      return Bool2.endBool(b);
    }
    visitUtf8(_node, b) {
      Utf82.startUtf8(b);
      return Utf82.endUtf8(b);
    }
    visitDecimal(node, b) {
      Decimal2.startDecimal(b);
      Decimal2.addScale(b, node.scale);
      Decimal2.addPrecision(b, node.precision);
      Decimal2.addBitWidth(b, node.bitWidth);
      return Decimal2.endDecimal(b);
    }
    visitDate(node, b) {
      Date2.startDate(b);
      Date2.addUnit(b, node.unit);
      return Date2.endDate(b);
    }
    visitTime(node, b) {
      Time.startTime(b);
      Time.addUnit(b, node.unit);
      Time.addBitWidth(b, node.bitWidth);
      return Time.endTime(b);
    }
    visitTimestamp(node, b) {
      const timezone = node.timezone && b.createString(node.timezone) || void 0;
      Timestamp.startTimestamp(b);
      Timestamp.addUnit(b, node.unit);
      if (timezone !== void 0) {
        Timestamp.addTimezone(b, timezone);
      }
      return Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
      Interval.startInterval(b);
      Interval.addUnit(b, node.unit);
      return Interval.endInterval(b);
    }
    visitList(_node, b) {
      List2.startList(b);
      return List2.endList(b);
    }
    visitStruct(_node, b) {
      Struct_.startStruct_(b);
      return Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
      Union.startTypeIdsVector(b, node.typeIds.length);
      const typeIds = Union.createTypeIdsVector(b, node.typeIds);
      Union.startUnion(b);
      Union.addMode(b, node.mode);
      Union.addTypeIds(b, typeIds);
      return Union.endUnion(b);
    }
    visitDictionary(node, b) {
      const indexType = this.visit(node.indices, b);
      DictionaryEncoding.startDictionaryEncoding(b);
      DictionaryEncoding.addId(b, new Long3(node.id, 0));
      DictionaryEncoding.addIsOrdered(b, node.isOrdered);
      if (indexType !== void 0) {
        DictionaryEncoding.addIndexType(b, indexType);
      }
      return DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
      FixedSizeBinary2.startFixedSizeBinary(b);
      FixedSizeBinary2.addByteWidth(b, node.byteWidth);
      return FixedSizeBinary2.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
      FixedSizeList2.startFixedSizeList(b);
      FixedSizeList2.addListSize(b, node.listSize);
      return FixedSizeList2.endFixedSizeList(b);
    }
    visitMap(node, b) {
      Map2.startMap(b);
      Map2.addKeysSorted(b, node.keysSorted);
      return Map2.endMap(b);
    }
  };
  var instance8 = new TypeAssembler();

  // ../../node_modules/apache-arrow/ipc/metadata/json.mjs
  function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["customMetadata"]), dictionaries);
  }
  function recordBatchFromJSON(b) {
    return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
  }
  function dictionaryBatchFromJSON(b) {
    return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
  }
  function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
      ...fieldNodes,
      new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
      ...fieldNodesFromJSON(column["children"])
    ], []);
  }
  function buffersFromJSON(xs, buffers = []) {
    for (let i = -1, n = (xs || []).length; ++i < n; ) {
      const column = xs[i];
      column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
      column["TYPE"] && buffers.push(new BufferRegion(buffers.length, column["TYPE"].length));
      column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
      column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
      buffers = buffersFromJSON(column["children"], buffers);
    }
    return buffers;
  }
  function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum2, val) => sum2 + +(val === 0), 0);
  }
  function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    if (!dictionaries || !(dictMeta = _field["dictionary"])) {
      type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
      field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    } else if (!dictionaries.has(id = dictMeta["id"])) {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    } else {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    }
    return field || null;
  }
  function customMetadataFromJSON(_metadata) {
    return new Map(Object.entries(_metadata || {}));
  }
  function indexTypeFromJSON(_type) {
    return new Int_(_type["isSigned"], _type["bitWidth"]);
  }
  function typeFromJSON(f, children) {
    const typeId = f["type"]["name"];
    switch (typeId) {
      case "NONE":
        return new Null();
      case "null":
        return new Null();
      case "binary":
        return new Binary();
      case "utf8":
        return new Utf8();
      case "bool":
        return new Bool();
      case "list":
        return new List((children || [])[0]);
      case "struct":
        return new Struct(children || []);
      case "struct_":
        return new Struct(children || []);
    }
    switch (typeId) {
      case "int": {
        const t = f["type"];
        return new Int_(t["isSigned"], t["bitWidth"]);
      }
      case "floatingpoint": {
        const t = f["type"];
        return new Float(Precision[t["precision"]]);
      }
      case "decimal": {
        const t = f["type"];
        return new Decimal(t["scale"], t["precision"], t["bitWidth"]);
      }
      case "date": {
        const t = f["type"];
        return new Date_(DateUnit[t["unit"]]);
      }
      case "time": {
        const t = f["type"];
        return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
      }
      case "timestamp": {
        const t = f["type"];
        return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
      }
      case "interval": {
        const t = f["type"];
        return new Interval_(IntervalUnit[t["unit"]]);
      }
      case "union": {
        const t = f["type"];
        return new Union_(UnionMode[t["mode"]], t["typeIds"] || [], children || []);
      }
      case "fixedsizebinary": {
        const t = f["type"];
        return new FixedSizeBinary(t["byteWidth"]);
      }
      case "fixedsizelist": {
        const t = f["type"];
        return new FixedSizeList(t["listSize"], (children || [])[0]);
      }
      case "map": {
        const t = f["type"];
        return new Map_((children || [])[0], t["keysSorted"]);
      }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
  }

  // ../../node_modules/apache-arrow/ipc/metadata/message.mjs
  var Long4 = Long;
  var Builder4 = Builder2;
  var ByteBuffer3 = ByteBuffer;
  var Message2 = class {
    constructor(bodyLength, version, headerType, header) {
      this._version = version;
      this._headerType = headerType;
      this.body = new Uint8Array(0);
      header && (this._createHeader = () => header);
      this._bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
    }
    static fromJSON(msg, headerType) {
      const message = new Message2(0, MetadataVersion.V4, headerType);
      message._createHeader = messageHeaderFromJSON(msg, headerType);
      return message;
    }
    static decode(buf) {
      buf = new ByteBuffer3(toUint8Array(buf));
      const _message = Message.getRootAsMessage(buf);
      const bodyLength = _message.bodyLength();
      const version = _message.version();
      const headerType = _message.headerType();
      const message = new Message2(bodyLength, version, headerType);
      message._createHeader = decodeMessageHeader(_message, headerType);
      return message;
    }
    static encode(message) {
      const b = new Builder4();
      let headerOffset = -1;
      if (message.isSchema()) {
        headerOffset = Schema2.encode(b, message.header());
      } else if (message.isRecordBatch()) {
        headerOffset = RecordBatch3.encode(b, message.header());
      } else if (message.isDictionaryBatch()) {
        headerOffset = DictionaryBatch2.encode(b, message.header());
      }
      Message.startMessage(b);
      Message.addVersion(b, MetadataVersion.V4);
      Message.addHeader(b, headerOffset);
      Message.addHeaderType(b, message.headerType);
      Message.addBodyLength(b, new Long4(message.bodyLength, 0));
      Message.finishMessageBuffer(b, Message.endMessage(b));
      return b.asUint8Array();
    }
    static from(header, bodyLength = 0) {
      if (header instanceof Schema2) {
        return new Message2(0, MetadataVersion.V4, MessageHeader.Schema, header);
      }
      if (header instanceof RecordBatch3) {
        return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.RecordBatch, header);
      }
      if (header instanceof DictionaryBatch2) {
        return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.DictionaryBatch, header);
      }
      throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() {
      return this.headerType;
    }
    get version() {
      return this._version;
    }
    get headerType() {
      return this._headerType;
    }
    get bodyLength() {
      return this._bodyLength;
    }
    header() {
      return this._createHeader();
    }
    isSchema() {
      return this.headerType === MessageHeader.Schema;
    }
    isRecordBatch() {
      return this.headerType === MessageHeader.RecordBatch;
    }
    isDictionaryBatch() {
      return this.headerType === MessageHeader.DictionaryBatch;
    }
  };
  var RecordBatch3 = class {
    constructor(length, nodes, buffers) {
      this._nodes = nodes;
      this._buffers = buffers;
      this._length = typeof length === "number" ? length : length.low;
    }
    get nodes() {
      return this._nodes;
    }
    get length() {
      return this._length;
    }
    get buffers() {
      return this._buffers;
    }
  };
  var DictionaryBatch2 = class {
    constructor(data, id, isDelta = false) {
      this._data = data;
      this._isDelta = isDelta;
      this._id = typeof id === "number" ? id : id.low;
    }
    get id() {
      return this._id;
    }
    get data() {
      return this._data;
    }
    get isDelta() {
      return this._isDelta;
    }
    get length() {
      return this.data.length;
    }
    get nodes() {
      return this.data.nodes;
    }
    get buffers() {
      return this.data.buffers;
    }
  };
  var BufferRegion = class {
    constructor(offset, length) {
      this.offset = typeof offset === "number" ? offset : offset.low;
      this.length = typeof length === "number" ? length : length.low;
    }
  };
  var FieldNode2 = class {
    constructor(length, nullCount) {
      this.length = typeof length === "number" ? length : length.low;
      this.nullCount = typeof nullCount === "number" ? nullCount : nullCount.low;
    }
  };
  function messageHeaderFromJSON(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.fromJSON(message);
        case MessageHeader.RecordBatch:
          return RecordBatch3.fromJSON(message);
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.fromJSON(message);
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  function decodeMessageHeader(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.decode(message.header(new Schema()));
        case MessageHeader.RecordBatch:
          return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  Field2["encode"] = encodeField;
  Field2["decode"] = decodeField;
  Field2["fromJSON"] = fieldFromJSON;
  Schema2["encode"] = encodeSchema;
  Schema2["decode"] = decodeSchema;
  Schema2["fromJSON"] = schemaFromJSON;
  RecordBatch3["encode"] = encodeRecordBatch;
  RecordBatch3["decode"] = decodeRecordBatch;
  RecordBatch3["fromJSON"] = recordBatchFromJSON;
  DictionaryBatch2["encode"] = encodeDictionaryBatch;
  DictionaryBatch2["decode"] = decodeDictionaryBatch;
  DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
  FieldNode2["encode"] = encodeFieldNode;
  FieldNode2["decode"] = decodeFieldNode;
  BufferRegion["encode"] = encodeBufferRegion;
  BufferRegion["decode"] = decodeBufferRegion;
  function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries);
  }
  function decodeRecordBatch(batch, version = MetadataVersion.V4) {
    if (batch.compression() !== null) {
      throw new Error("Record batch compression not implemented");
    }
    return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
  }
  function decodeDictionaryBatch(batch, version = MetadataVersion.V4) {
    return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
  }
  function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
  }
  function decodeFieldNode(f) {
    return new FieldNode2(f.length(), f.nullCount());
  }
  function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {
      if (f = batch.nodes(i)) {
        nodes[++j] = FieldNode2.decode(f);
      }
    }
    return nodes;
  }
  function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {
      if (b = batch.buffers(i)) {
        if (version < MetadataVersion.V4) {
          b.bb_pos += 8 * (i + 1);
        }
        bufferRegions[++j] = BufferRegion.decode(b);
      }
    }
    return bufferRegions;
  }
  function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {
      if (f = schema.fields(i)) {
        fields[++j] = Field2.decode(f, dictionaries);
      }
    }
    return fields;
  }
  function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n; ) {
      if (f = field.children(i)) {
        children[++j] = Field2.decode(f, dictionaries);
      }
    }
    return children;
  }
  function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    if (!dictionaries || !(dictMeta = f.dictionary())) {
      type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
      field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    } else if (!dictionaries.has(id = dictMeta.id().low)) {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    } else {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
  }
  function decodeCustomMetadata(parent) {
    const data = /* @__PURE__ */ new Map();
    if (parent) {
      for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {
        if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
          data.set(key, entry.value());
        }
      }
    }
    return data;
  }
  function decodeIndexType(_type) {
    return new Int_(_type.isSigned(), _type.bitWidth());
  }
  function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
      case Type2["NONE"]:
        return new Null();
      case Type2["Null"]:
        return new Null();
      case Type2["Binary"]:
        return new Binary();
      case Type2["Utf8"]:
        return new Utf8();
      case Type2["Bool"]:
        return new Bool();
      case Type2["List"]:
        return new List((children || [])[0]);
      case Type2["Struct_"]:
        return new Struct(children || []);
    }
    switch (typeId) {
      case Type2["Int"]: {
        const t = f.type(new Int());
        return new Int_(t.isSigned(), t.bitWidth());
      }
      case Type2["FloatingPoint"]: {
        const t = f.type(new FloatingPoint());
        return new Float(t.precision());
      }
      case Type2["Decimal"]: {
        const t = f.type(new Decimal2());
        return new Decimal(t.scale(), t.precision(), t.bitWidth());
      }
      case Type2["Date"]: {
        const t = f.type(new Date2());
        return new Date_(t.unit());
      }
      case Type2["Time"]: {
        const t = f.type(new Time());
        return new Time_(t.unit(), t.bitWidth());
      }
      case Type2["Timestamp"]: {
        const t = f.type(new Timestamp());
        return new Timestamp_(t.unit(), t.timezone());
      }
      case Type2["Interval"]: {
        const t = f.type(new Interval());
        return new Interval_(t.unit());
      }
      case Type2["Union"]: {
        const t = f.type(new Union());
        return new Union_(t.mode(), t.typeIdsArray() || [], children || []);
      }
      case Type2["FixedSizeBinary"]: {
        const t = f.type(new FixedSizeBinary2());
        return new FixedSizeBinary(t.byteWidth());
      }
      case Type2["FixedSizeList"]: {
        const t = f.type(new FixedSizeList2());
        return new FixedSizeList(t.listSize(), (children || [])[0]);
      }
      case Type2["Map"]: {
        const t = f.type(new Map2());
        return new Map_((children || [])[0], t.keysSorted());
      }
    }
    throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
  }
  function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
    Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    Schema.startSchema(b);
    Schema.addFields(b, fieldsVectorOffset);
    Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
    if (metadataOffset !== -1) {
      Schema.addCustomMetadata(b, metadataOffset);
    }
    return Schema.endSchema(b);
  }
  function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!DataType.isDictionary(type)) {
      typeOffset = instance8.visit(type, b);
    } else {
      typeId = type.dictionary.typeId;
      dictionaryOffset = instance8.visit(type, b);
      typeOffset = instance8.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
    const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    if (field.name) {
      nameOffset = b.createString(field.name);
    }
    Field.startField(b);
    Field.addType(b, typeOffset);
    Field.addTypeType(b, typeId);
    Field.addChildren(b, childrenVectorOffset);
    Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
      Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
      Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
      Field.addCustomMetadata(b, metadataOffset);
    }
    return Field.endField(b);
  }
  function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    RecordBatch2.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
      FieldNode2.encode(b, n);
    const nodesVectorOffset = b.endVector();
    RecordBatch2.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
      BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    RecordBatch2.startRecordBatch(b);
    RecordBatch2.addLength(b, new Long4(recordBatch.length, 0));
    RecordBatch2.addNodes(b, nodesVectorOffset);
    RecordBatch2.addBuffers(b, buffersVectorOffset);
    return RecordBatch2.endRecordBatch(b);
  }
  function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
    DictionaryBatch.startDictionaryBatch(b);
    DictionaryBatch.addId(b, new Long4(dictionaryBatch.id, 0));
    DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    DictionaryBatch.addData(b, dataOffset);
    return DictionaryBatch.endDictionaryBatch(b);
  }
  function encodeFieldNode(b, node) {
    return FieldNode.createFieldNode(b, new Long4(node.length, 0), new Long4(node.nullCount, 0));
  }
  function encodeBufferRegion(b, node) {
    return Buffer2.createBuffer(b, new Long4(node.offset, 0), new Long4(node.length, 0));
  }
  var platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true);
    return new Int16Array(buffer)[0] === 256;
  })();

  // ../../node_modules/apache-arrow/ipc/message.mjs
  var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
  var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
  var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
  var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
  var MessageReader = class {
    constructor(source) {
      this.source = source instanceof ByteStream ? source : new ByteStream(source);
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let r;
      if ((r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readMessageBody(bodyLength) {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
    readMetadataLength() {
      const buf = this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    }
    readMetadata(metadataLength) {
      const buf = this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    }
  };
  var AsyncMessageReader = class {
    constructor(source, byteLength) {
      this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if ((r = yield this.readMetadata(r.value)).done) {
          return ITERATOR_DONE;
        }
        return r;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.throw(value);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.return(value);
      });
    }
    readMessage(type) {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      });
    }
    readMessageBody(bodyLength) {
      return __awaiter(this, void 0, void 0, function* () {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = toUint8Array(yield this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
      });
    }
    readSchema(throwIfNull = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const type = MessageHeader.Schema;
        const message = yield this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      });
    }
    readMetadataLength() {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
      });
    }
    readMetadata(metadataLength) {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(metadataLength);
        if (!buf) {
          return ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: Message2.decode(buf) };
      });
    }
  };
  var JSONMessageReader = class extends MessageReader {
    constructor(source) {
      super(new Uint8Array(0));
      this._schema = false;
      this._body = [];
      this._batchIndex = 0;
      this._dictionaryIndex = 0;
      this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
    }
    next() {
      const { _json } = this;
      if (!this._schema) {
        this._schema = true;
        const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
        return { done: false, value: message };
      }
      if (this._dictionaryIndex < _json.dictionaries.length) {
        const batch = _json.dictionaries[this._dictionaryIndex++];
        this._body = batch["data"]["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
        return { done: false, value: message };
      }
      if (this._batchIndex < _json.batches.length) {
        const batch = _json.batches[this._batchIndex++];
        this._body = batch["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
        return { done: false, value: message };
      }
      this._body = [];
      return ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
      return flattenDataSources(this._body);
      function flattenDataSources(xs) {
        return (xs || []).reduce((buffers, column) => [
          ...buffers,
          ...column["VALIDITY"] && [column["VALIDITY"]] || [],
          ...column["TYPE"] && [column["TYPE"]] || [],
          ...column["OFFSET"] && [column["OFFSET"]] || [],
          ...column["DATA"] && [column["DATA"]] || [],
          ...flattenDataSources(column["children"])
        ], []);
      }
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readSchema() {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (!message || !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
  };
  var PADDING = 4;
  var MAGIC_STR = "ARROW1";
  var MAGIC = new Uint8Array(MAGIC_STR.length);
  for (let i = 0; i < MAGIC_STR.length; i += 1) {
    MAGIC[i] = MAGIC_STR.codePointAt(i);
  }
  function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = MAGIC.length; ++i < n; ) {
      if (MAGIC[i] !== buffer[index + i]) {
        return false;
      }
    }
    return true;
  }
  var magicLength = MAGIC.length;
  var magicAndPadding = magicLength + PADDING;
  var magicX2AndPadding = magicLength * 2 + PADDING;

  // ../../node_modules/apache-arrow/ipc/reader.mjs
  var RecordBatchReader = class extends ReadableInterop {
    constructor(impl) {
      super();
      this._impl = impl;
    }
    get closed() {
      return this._impl.closed;
    }
    get schema() {
      return this._impl.schema;
    }
    get autoDestroy() {
      return this._impl.autoDestroy;
    }
    get dictionaries() {
      return this._impl.dictionaries;
    }
    get numDictionaries() {
      return this._impl.numDictionaries;
    }
    get numRecordBatches() {
      return this._impl.numRecordBatches;
    }
    get footer() {
      return this._impl.isFile() ? this._impl.footer : null;
    }
    isSync() {
      return this._impl.isSync();
    }
    isAsync() {
      return this._impl.isAsync();
    }
    isFile() {
      return this._impl.isFile();
    }
    isStream() {
      return this._impl.isStream();
    }
    next() {
      return this._impl.next();
    }
    throw(value) {
      return this._impl.throw(value);
    }
    return(value) {
      return this._impl.return(value);
    }
    cancel() {
      return this._impl.cancel();
    }
    reset(schema) {
      this._impl.reset(schema);
      this._DOMStream = void 0;
      this._nodeStream = void 0;
      return this;
    }
    open(options) {
      const opening = this._impl.open(options);
      return isPromise(opening) ? opening.then(() => this) : this;
    }
    readRecordBatch(index) {
      return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
      return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
    }
    toNodeStream() {
      return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    static from(source) {
      if (source instanceof RecordBatchReader) {
        return source;
      } else if (isArrowJSON(source)) {
        return fromArrowJSON(source);
      } else if (isFileHandle(source)) {
        return fromFileHandle(source);
      } else if (isPromise(source)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
          return yield RecordBatchReader.from(yield source);
        }))();
      } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
        return fromAsyncByteStream(new AsyncByteStream(source));
      }
      return fromByteStream(new ByteStream(source));
    }
    static readAll(source) {
      if (source instanceof RecordBatchReader) {
        return source.isSync() ? readAllSync(source) : readAllAsync(source);
      } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {
        return readAllSync(source);
      }
      return readAllAsync(source);
    }
  };
  var RecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      return [...this];
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return __asyncGenerator(this, arguments, function* _a5() {
        yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
      });
    }
  };
  var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      var e_1, _a5;
      return __awaiter(this, void 0, void 0, function* () {
        const batches = new Array();
        try {
          for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {
            const batch = _c2.value;
            batches.push(batch);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a5 = _b2.return))
              yield _a5.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return batches;
      });
    }
    [Symbol.iterator]() {
      throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
  };
  var RecordBatchFileReader = class extends RecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var RecordBatchReaderImpl = class {
    constructor(dictionaries = /* @__PURE__ */ new Map()) {
      this.closed = false;
      this.autoDestroy = true;
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.dictionaries = dictionaries;
    }
    get numDictionaries() {
      return this._dictionaryIndex;
    }
    get numRecordBatches() {
      return this._recordBatchIndex;
    }
    isSync() {
      return false;
    }
    isAsync() {
      return false;
    }
    isFile() {
      return false;
    }
    isStream() {
      return false;
    }
    reset(schema) {
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.schema = schema;
      this.dictionaries = /* @__PURE__ */ new Map();
      return this;
    }
    _loadRecordBatch(header, body) {
      const children = this._loadVectors(header, body, this.schema.fields);
      const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children });
      return new RecordBatch(this.schema, data);
    }
    _loadDictionaryBatch(header, body) {
      const { id, isDelta } = header;
      const { dictionaries, schema } = this;
      const dictionary = dictionaries.get(id);
      if (isDelta || !dictionary) {
        const type = schema.dictionaries.get(id);
        const data = this._loadVectors(header.data, body, [type]);
        return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();
      }
      return dictionary.memoize();
    }
    _loadVectors(header, body, types) {
      return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
    }
  };
  var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
    }
    isSync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.iterator]() {
      return this;
    }
    cancel() {
      if (!this.closed && (this.closed = true)) {
        this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    }
    open(options) {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = this._reader.readSchema()))) {
          this.cancel();
        }
      }
      return this;
    }
    throw(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    }
    return(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    }
    next() {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return this.return();
    }
    _readNextMessageAndValidate(type) {
      return this._reader.readMessage(type);
    }
  };
  var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = new AsyncMessageReader(this._handle = source);
    }
    isAsync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && (this.closed = true)) {
          yield this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      });
    }
    open(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
            yield this.cancel();
          }
        }
        return this;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.throw(value);
        }
        return ITERATOR_DONE;
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.return(value);
        }
        return ITERATOR_DONE;
      });
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = yield this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            yield this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return yield this.return();
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this._reader.readMessage(type);
      });
    }
  };
  var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
    }
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    isSync() {
      return true;
    }
    isFile() {
      return true;
    }
    open(options) {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && this._readDictionaryBatch(this._dictionaryIndex++);
        }
      }
      return super.open(options);
    }
    readRecordBatch(index) {
      var _a5;
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    }
    _readDictionaryBatch(index) {
      var _a5;
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    }
    _readFooter() {
      const { _handle } = this;
      const offset = _handle.size - magicAndPadding;
      const length = _handle.readInt32(offset);
      const buffer = _handle.readAt(offset - length, length);
      return Footer_.decode(buffer);
    }
    _readNextMessageAndValidate(type) {
      var _a5;
      if (!this._footer) {
        this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);
        if (block && this._handle.seek(block.offset)) {
          return this._reader.readMessage(type);
        }
      }
      return null;
    }
  };
  var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
    constructor(source, ...rest) {
      const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
      const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
      super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);
    }
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    isFile() {
      return true;
    }
    isAsync() {
      return true;
    }
    open(options) {
      const _super = Object.create(null, {
        open: { get: () => super.open }
      });
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = yield this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
          }
        }
        return yield _super.open.call(this, options);
      });
    }
    readRecordBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          yield this.open();
        }
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
          if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      });
    }
    _readDictionaryBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
          if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      });
    }
    _readFooter() {
      return __awaiter(this, void 0, void 0, function* () {
        const { _handle } = this;
        _handle._pending && (yield _handle._pending);
        const offset = _handle.size - magicAndPadding;
        const length = yield _handle.readInt32(offset);
        const buffer = yield _handle.readAt(offset - length, length);
        return Footer_.decode(buffer);
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this._footer) {
          yield this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && (yield this._handle.seek(block.offset))) {
            return yield this._reader.readMessage(type);
          }
        }
        return null;
      });
    }
  };
  var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source, dictionaries);
    }
    _loadVectors(header, body, types) {
      return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
    }
  };
  function shouldAutoDestroy(self2, options) {
    return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
  }
  function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
      if (!reader.open({ autoDestroy: false }).closed) {
        do {
          yield reader;
        } while (!reader.reset().open().closed);
      }
    } finally {
      reader.cancel();
    }
  }
  function readAllAsync(source) {
    return __asyncGenerator(this, arguments, function* readAllAsync_1() {
      const reader = yield __await(RecordBatchReader.from(source));
      try {
        if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
          do {
            yield yield __await(reader);
          } while (!(yield __await(reader.reset().open())).closed);
        }
      } finally {
        yield __await(reader.cancel());
      }
    });
  }
  function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
  }
  function fromByteStream(source) {
    const bytes = source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {
    }()));
  }
  function fromAsyncByteStream(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const bytes = yield source.peek(magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
        return __asyncGenerator(this, arguments, function* () {
        });
      }()));
    });
  }
  function fromFileHandle(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const { size } = yield source.stat();
      const file = new AsyncRandomAccessFile(source, size);
      if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
        return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
      }
      return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
  }

  // ../../node_modules/apache-arrow/visitor/vectorassembler.mjs
  var VectorAssembler = class extends Visitor {
    constructor() {
      super();
      this._byteLength = 0;
      this._nodes = [];
      this._buffers = [];
      this._bufferRegions = [];
    }
    static assemble(...args) {
      const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);
      const assembler = new VectorAssembler();
      assembler.visitMany(unwrap(args));
      return assembler;
    }
    visit(data) {
      if (data instanceof Vector) {
        this.visitMany(data.data);
        return this;
      }
      const { type } = data;
      if (!DataType.isDictionary(type)) {
        const { length, nullCount } = data;
        if (length > 2147483647) {
          throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
        }
        if (!DataType.isNull(type)) {
          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length, data.nullBitmap));
        }
        this.nodes.push(new FieldNode2(length, nullCount));
      }
      return super.visit(data);
    }
    visitNull(_null) {
      return this;
    }
    visitDictionary(data) {
      return this.visit(data.clone(data.type.indices));
    }
    get nodes() {
      return this._nodes;
    }
    get buffers() {
      return this._buffers;
    }
    get byteLength() {
      return this._byteLength;
    }
    get bufferRegions() {
      return this._bufferRegions;
    }
  };
  function addBuffer(values) {
    const byteLength = values.byteLength + 7 & ~7;
    this.buffers.push(values);
    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
  }
  function assembleUnion(data) {
    const { type, length, typeIds, valueOffsets } = data;
    addBuffer.call(this, typeIds);
    if (type.mode === UnionMode.Sparse) {
      return assembleNestedVector.call(this, data);
    } else if (type.mode === UnionMode.Dense) {
      if (data.offset <= 0) {
        addBuffer.call(this, valueOffsets);
        return assembleNestedVector.call(this, data);
      } else {
        const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
        const childLengths = new Int32Array(maxChildTypeId + 1);
        const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
        const shiftedOffsets = new Int32Array(length);
        const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
        for (let typeId, shift, index = -1; ++index < length; ) {
          if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
            shift = childOffsets[typeId] = unshiftedOffsets[typeId];
          }
          shiftedOffsets[index] = unshiftedOffsets[index] - shift;
          ++childLengths[typeId];
        }
        addBuffer.call(this, shiftedOffsets);
        for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren; ) {
          if (child = data.children[childIndex]) {
            const typeId = type.typeIds[childIndex];
            const childLength = Math.min(length, childLengths[typeId]);
            this.visit(child.slice(childOffsets[typeId], childLength));
          }
        }
      }
    }
    return this;
  }
  function assembleBoolVector(data) {
    let values;
    if (data.nullCount >= data.length) {
      return addBuffer.call(this, new Uint8Array(0));
    } else if ((values = data.values) instanceof Uint8Array) {
      return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));
    }
    return addBuffer.call(this, packBools(data.values));
  }
  function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
  }
  function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets));
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength));
    return this;
  }
  function assembleListVector(data) {
    const { length, valueOffsets } = data;
    if (valueOffsets) {
      addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
    }
    return this.visit(data.children[0]);
  }
  function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
  }
  VectorAssembler.prototype.visitBool = assembleBoolVector;
  VectorAssembler.prototype.visitInt = assembleFlatVector;
  VectorAssembler.prototype.visitFloat = assembleFlatVector;
  VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
  VectorAssembler.prototype.visitBinary = assembleFlatListVector;
  VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
  VectorAssembler.prototype.visitDate = assembleFlatVector;
  VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
  VectorAssembler.prototype.visitTime = assembleFlatVector;
  VectorAssembler.prototype.visitDecimal = assembleFlatVector;
  VectorAssembler.prototype.visitList = assembleListVector;
  VectorAssembler.prototype.visitStruct = assembleNestedVector;
  VectorAssembler.prototype.visitUnion = assembleUnion;
  VectorAssembler.prototype.visitInterval = assembleFlatVector;
  VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
  VectorAssembler.prototype.visitMap = assembleListVector;

  // ../../node_modules/apache-arrow/ipc/writer.mjs
  var RecordBatchWriter = class extends ReadableInterop {
    constructor(options) {
      super();
      this._position = 0;
      this._started = false;
      this._sink = new AsyncByteQueue();
      this._schema = null;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
      this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
      this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    toString(sync = false) {
      return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
      return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
      if (isPromise(input)) {
        return input.then((x) => this.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(this, input);
      }
      return writeAll(this, input);
    }
    get closed() {
      return this._sink.closed;
    }
    [Symbol.asyncIterator]() {
      return this._sink[Symbol.asyncIterator]();
    }
    toDOMStream(options) {
      return this._sink.toDOMStream(options);
    }
    toNodeStream(options) {
      return this._sink.toNodeStream(options);
    }
    close() {
      return this.reset()._sink.close();
    }
    abort(reason) {
      return this.reset()._sink.abort(reason);
    }
    finish() {
      this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
      return this;
    }
    reset(sink = this._sink, schema = null) {
      if (sink === this._sink || sink instanceof AsyncByteQueue) {
        this._sink = sink;
      } else {
        this._sink = new AsyncByteQueue();
        if (sink && isWritableDOMStream(sink)) {
          this.toDOMStream({ type: "bytes" }).pipeTo(sink);
        } else if (sink && isWritableNodeStream(sink)) {
          this.toNodeStream({ objectMode: false }).pipe(sink);
        }
      }
      if (this._started && this._schema) {
        this._writeFooter(this._schema);
      }
      this._started = false;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      if (!schema || !compareSchemas(schema, this._schema)) {
        if (schema == null) {
          this._position = 0;
          this._schema = null;
        } else {
          this._started = true;
          this._schema = schema;
          this._writeSchema(schema);
        }
      }
      return this;
    }
    write(payload) {
      let schema = null;
      if (!this._sink) {
        throw new Error(`RecordBatchWriter is closed`);
      } else if (payload == null) {
        return this.finish() && void 0;
      } else if (payload instanceof Table && !(schema = payload.schema)) {
        return this.finish() && void 0;
      } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {
        return this.finish() && void 0;
      }
      if (schema && !compareSchemas(schema, this._schema)) {
        if (this._started && this._autoDestroy) {
          return this.close();
        }
        this.reset(this._sink, schema);
      }
      if (payload instanceof RecordBatch) {
        if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
          this._writeRecordBatch(payload);
        }
      } else if (payload instanceof Table) {
        this.writeAll(payload.batches);
      } else if (isIterable(payload)) {
        this.writeAll(payload);
      }
    }
    _writeMessage(message, alignment = 8) {
      const a = alignment - 1;
      const buffer = Message2.encode(message);
      const flatbufferSize = buffer.byteLength;
      const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
      const alignedSize = flatbufferSize + prefixSize + a & ~a;
      const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
      if (message.headerType === MessageHeader.RecordBatch) {
        this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      } else if (message.headerType === MessageHeader.DictionaryBatch) {
        this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      }
      if (!this._writeLegacyIpcFormat) {
        this._write(Int32Array.of(-1));
      }
      this._write(Int32Array.of(alignedSize - prefixSize));
      if (flatbufferSize > 0) {
        this._write(buffer);
      }
      return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
      if (this._started) {
        const buffer = toUint8Array(chunk);
        if (buffer && buffer.byteLength > 0) {
          this._sink.write(buffer);
          this._position += buffer.byteLength;
        }
      }
      return this;
    }
    _writeSchema(schema) {
      return this._writeMessage(Message2.from(schema));
    }
    _writeFooter(schema) {
      return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
      return this._write(MAGIC);
    }
    _writePadding(nBytes) {
      return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
      const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
      const message = Message2.from(recordBatch, byteLength);
      return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
      this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector([dictionary]));
      const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);
      const dictionaryBatch = new DictionaryBatch2(recordBatch, id, isDelta);
      const message = Message2.from(dictionaryBatch, byteLength);
      return this._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
      let buffer;
      let size, padding;
      for (let i = -1, n = buffers.length; ++i < n; ) {
        if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
          this._write(buffer);
          if ((padding = (size + 7 & ~7) - size) > 0) {
            this._writePadding(padding);
          }
        }
      }
      return this;
    }
    _writeDictionaries(batch) {
      for (let [id, dictionary] of batch.dictionaries) {
        let offset = this._dictionaryDeltaOffsets.get(id) || 0;
        if (offset === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset)).length > 0) {
          for (const data of dictionary.data) {
            this._writeDictionaryBatch(data, id, offset > 0);
            offset += data.length;
          }
        }
      }
      return this;
    }
  };
  var RecordBatchStreamWriter = class extends RecordBatchWriter {
    static writeAll(input, options) {
      const writer = new RecordBatchStreamWriter(options);
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
  };
  var RecordBatchFileWriter = class extends RecordBatchWriter {
    static writeAll(input) {
      const writer = new RecordBatchFileWriter();
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
    constructor() {
      super();
      this._autoDestroy = true;
    }
    _writeSchema(schema) {
      return this._writeMagic()._writePadding(2);
    }
    _writeFooter(schema) {
      const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));
      return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
    }
  };
  function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof Table) {
      chunks = input.batches;
      writer.reset(void 0, input.schema);
    }
    for (const batch of chunks) {
      writer.write(batch);
    }
    return writer.finish();
  }
  function writeAllAsync(writer, batches) {
    var batches_1, batches_1_1;
    var e_1, _a5;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        for (batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), !batches_1_1.done; ) {
          const batch = batches_1_1.value;
          writer.write(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (batches_1_1 && !batches_1_1.done && (_a5 = batches_1.return))
            yield _a5.call(batches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return writer.finish();
    });
  }

  // ../../node_modules/apache-arrow/io/whatwg/iterable.mjs
  function toDOMStream(source, options) {
    if (isAsyncIterable(source)) {
      return asyncIterableAsReadableDOMStream(source, options);
    }
    if (isIterable(source)) {
      return iterableAsReadableDOMStream(source, options);
    }
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
  }
  function iterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        next(controller, it2 || (it2 = source[Symbol.iterator]()));
      },
      pull(controller) {
        it2 ? next(controller, it2) : controller.close();
      },
      cancel() {
        ((it2 === null || it2 === void 0 ? void 0 : it2.return) && it2.return() || true) && (it2 = null);
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = it3.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    }
  }
  function asyncIterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, it2 || (it2 = source[Symbol.asyncIterator]()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          it2 ? yield next(controller, it2) : controller.close();
        });
      },
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          ((it2 === null || it2 === void 0 ? void 0 : it2.return) && (yield it2.return()) || true) && (it2 = null);
        });
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = yield it3.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/io/whatwg/builder.mjs
  function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
  }
  var BuilderTransform = class {
    constructor(options) {
      this._numChunks = 0;
      this._finished = false;
      this._bufferedSize = 0;
      const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
      this._controller = null;
      this._builder = makeBuilder(builderOptions);
      this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
      const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
      const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
      this["readable"] = new ReadableStream({
        ["cancel"]: () => {
          this._builder.clear();
        },
        ["pull"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        },
        ["start"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        }
      }, {
        "highWaterMark": readableHighWaterMark,
        "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
      });
      this["writable"] = new WritableStream({
        ["abort"]: () => {
          this._builder.clear();
        },
        ["write"]: () => {
          this._maybeFlush(this._builder, this._controller);
        },
        ["close"]: () => {
          this._maybeFlush(this._builder.finish(), this._controller);
        }
      }, {
        "highWaterMark": writableHighWaterMark,
        "size": (value) => this._writeValueAndReturnChunkSize(value)
      });
    }
    _writeValueAndReturnChunkSize(value) {
      const bufferedSize = this._bufferedSize;
      this._bufferedSize = this._getSize(this._builder.append(value));
      return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
      if (controller == null) {
        return;
      }
      if (this._bufferedSize >= controller.desiredSize) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (builder.finished) {
        if (builder.length > 0 || this._numChunks === 0) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (!this._finished && (this._finished = true)) {
          this._enqueue(controller, null);
        }
      }
    }
    _enqueue(controller, chunk) {
      this._bufferedSize = 0;
      this._controller = null;
      chunk == null ? controller.close() : controller.enqueue(chunk);
    }
  };
  var chunkLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;
  };
  var chunkByteLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;
  };

  // ../../node_modules/apache-arrow/io/whatwg/reader.mjs
  function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield queue.close();
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, reader || (reader = yield open()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          reader ? yield next(controller, reader) : controller.close();
        });
      }
    });
    return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
    function open() {
      return __awaiter(this, void 0, void 0, function* () {
        return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
      });
    }
    function next(controller, reader2) {
      return __awaiter(this, void 0, void 0, function* () {
        let size = controller.desiredSize;
        let r = null;
        while (!(r = yield reader2.next()).done) {
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/io/whatwg/writer.mjs
  function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new AsyncByteStream(writer);
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield reader.cancel();
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      }
    }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf = null;
        let size = controller.desiredSize;
        while (buf = yield reader.read(size || null)) {
          controller.enqueue(buf);
          if (size != null && (size -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/ipc/serialization.mjs
  function tableToIPC(table, type = "stream") {
    return (type === "stream" ? RecordBatchStreamWriter : RecordBatchFileWriter).writeAll(table).toUint8Array(true);
  }

  // ../../node_modules/apache-arrow/Arrow.mjs
  var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {
    compareSchemas,
    compareFields,
    compareTypes
  });

  // ../../node_modules/apache-arrow/Arrow.dom.mjs
  adapters_default.toDOMStream = toDOMStream;
  Builder["throughDOM"] = builderThroughDOMStream;
  RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

  // src/bindings/connection.ts
  var DuckDBConnection = class {
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    close() {
      this._bindings.disconnect(this._conn);
    }
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    query(text) {
      const buffer = this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    async send(text) {
      let header = this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await new Promise((resolve, reject) => {
          try {
            resolve(this._bindings.pollPendingQuery(this._conn));
          } catch (e) {
            reject(e);
          }
        });
      }
      const iter = new ResultStreamIterator(this._bindings, this._conn, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
    cancelSent() {
      return this._bindings.cancelPendingQuery(this._conn);
    }
    getTableNames(query) {
      return this._bindings.getTableNames(this._conn, query);
    }
    prepare(text) {
      const stmt = this._bindings.createPrepared(this._conn, text);
      return new PreparedStatement(this._bindings, this._conn, stmt);
    }
    createScalarFunction(name, returns, func) {
      this._bindings.createScalarFunction(this._conn, name, returns, func);
    }
    insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      this.insertArrowFromIPCStream(buffer, options);
    }
    insertArrowFromIPCStream(buffer, options) {
      this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    insertCSVFromPath(path, options) {
      this._bindings.insertCSVFromPath(this._conn, path, options);
    }
    insertJSONFromPath(path, options) {
      this._bindings.insertJSONFromPath(this._conn, path, options);
    }
  };
  var ResultStreamIterator = class {
    constructor(bindings, conn, header) {
      this.bindings = bindings;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
    }
    next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      const bufferI8 = this.bindings.fetchQueryResults(this.conn);
      this._depleted = bufferI8.length == 0;
      return {
        done: this._depleted,
        value: bufferI8
      };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  var PreparedStatement = class {
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    close() {
      this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    query(...params) {
      const buffer = this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    send(...params) {
      const header = this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new ResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/bindings/udf_runtime.ts
  var TEXT_ENCODER = new TextEncoder();
  var TEXT_DECODER = new TextDecoder("utf-8");
  function storeError(mod, response, message) {
    const msgBuffer = TEXT_ENCODER.encode(message);
    const heapAddr = mod._malloc(msgBuffer.byteLength);
    const heapArray = mod.HEAPU8.subarray(heapAddr, heapAddr + msgBuffer.byteLength);
    heapArray.set(msgBuffer);
    mod.HEAPF64[(response >> 3) + 0] = 1;
    mod.HEAPF64[(response >> 3) + 1] = heapAddr;
    mod.HEAPF64[(response >> 3) + 2] = heapArray.byteLength;
  }
  function getTypeSize(ptype) {
    switch (ptype) {
      case "UINT8":
      case "INT8":
        return 1;
      case "INT32":
      case "FLOAT":
        return 4;
      case "INT64":
      case "UINT64":
      case "DOUBLE":
      case "VARCHAR":
        return 8;
      default:
        return 0;
    }
  }
  function ptrToArray(mod, ptr, ptype, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n * getTypeSize(ptype));
    switch (ptype) {
      case "UINT8":
        return new Uint8Array(heap.buffer, heap.byteOffset, n);
      case "INT8":
        return new Int8Array(heap.buffer, heap.byteOffset, n);
      case "INT32":
        return new Int32Array(heap.buffer, heap.byteOffset, n);
      case "FLOAT":
        return new Float32Array(heap.buffer, heap.byteOffset, n);
      case "DOUBLE":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      case "VARCHAR":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      default:
        return new Array(0);
    }
  }
  function ptrToUint8Array(mod, ptr, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n);
    return new Uint8Array(heap.buffer, heap.byteOffset, n);
  }
  function ptrToFloat64Array(mod, ptr, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n * 8);
    return new Float64Array(heap.buffer, heap.byteOffset, n);
  }
  function callScalarUDF(runtime, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) {
    try {
      const udf = runtime._udfFunctions.get(funcId);
      if (!udf) {
        storeError(mod, response, "Unknown UDF with id: " + funcId);
        return;
      }
      const rawDesc = TEXT_DECODER.decode(mod.HEAPU8.subarray(descPtr, descPtr + descSize));
      const desc = JSON.parse(rawDesc);
      const ptrs = ptrToFloat64Array(mod, ptrsPtr, ptrsSize / 8);
      const buildResolver = (arg) => {
        let validity = null;
        if (arg.validityBuffer !== void 0) {
          validity = ptrToUint8Array(mod, ptrs[arg.validityBuffer], desc.rows);
        }
        switch (arg.physicalType) {
          case "VARCHAR": {
            if (arg.dataBuffer === null || arg.dataBuffer === void 0) {
              throw new Error("malformed data view, expected data buffer for VARCHAR argument");
            }
            if (arg.lengthBuffer === null || arg.lengthBuffer === void 0) {
              throw new Error("malformed data view, expected data length buffer for VARCHAR argument");
            }
            const raw = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            const strings = [];
            const stringLengths = ptrToFloat64Array(mod, ptrs[arg.lengthBuffer], desc.rows);
            for (let j = 0; j < desc.rows; ++j) {
              if (validity != null && !validity[j]) {
                strings.push(null);
                continue;
              }
              const subarray = mod.HEAPU8.subarray(
                raw[j],
                raw[j] + stringLengths[j]
              );
              const str = TEXT_DECODER.decode(subarray);
              strings.push(str);
            }
            return (row) => strings[row];
          }
          case "STRUCT": {
            const tmp2 = {};
            const children = [];
            for (let j = 0; j < (arg.children?.length || 0); ++j) {
              const attr = arg.children[j];
              const child = buildResolver(attr);
              children.push((row) => {
                tmp2[attr.name] = child(row);
              });
            }
            if (validity != null) {
              return (row) => {
                if (!validity[row]) {
                  return null;
                }
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            } else {
              return (row) => {
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            }
          }
          default: {
            if (arg.dataBuffer === void 0) {
              throw new Error(
                "malformed data view, expected data buffer for argument of type: " + arg.physicalType
              );
            }
            const data = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            if (validity != null) {
              return (row) => !validity[row] ? null : data[row];
            } else {
              return (row) => data[row];
            }
          }
        }
      };
      const argResolvers = [];
      for (let i = 0; i < desc.args.length; ++i) {
        argResolvers.push(buildResolver(desc.args[i]));
      }
      const resultDataLen = desc.rows * getTypeSize(desc.ret.physicalType);
      const resultDataPtr = mod._malloc(resultDataLen);
      const resultData = ptrToArray(mod, resultDataPtr, desc.ret.physicalType, desc.rows);
      const resultValidityPtr = mod._malloc(desc.rows);
      const resultValidity = ptrToUint8Array(mod, resultValidityPtr, desc.rows);
      if (resultData.length == 0 || resultValidity.length == 0) {
        storeError(mod, response, "Can't create physical arrays for result");
        return;
      }
      let rawResultData = resultData;
      if (desc.ret.physicalType == "VARCHAR") {
        rawResultData = new Array(desc.rows);
      }
      const args = [];
      for (let i = 0; i < desc.args.length; ++i) {
        args.push(null);
      }
      for (let i = 0; i < desc.rows; ++i) {
        for (let j = 0; j < desc.args.length; ++j) {
          args[j] = argResolvers[j](i);
        }
        const res = udf.func(...args);
        rawResultData[i] = res;
        resultValidity[i] = res === void 0 || res === null ? 0 : 1;
      }
      let resultLengthsPtr = 0;
      switch (desc.ret.physicalType) {
        case "VARCHAR": {
          const resultDataUTF8 = new Array(0);
          resultLengthsPtr = mod._malloc(desc.rows * getTypeSize("DOUBLE"));
          const resultLengths = ptrToFloat64Array(mod, resultLengthsPtr, desc.rows);
          let totalLength = 0;
          for (let row = 0; row < desc.rows; ++row) {
            const utf8 = TEXT_ENCODER.encode(rawResultData[row] || "");
            resultDataUTF8.push(utf8);
            resultLengths[row] = utf8.length;
            totalLength += utf8.length;
          }
          const resultStringPtr = mod._malloc(totalLength);
          const resultStringBuf = mod.HEAPU8.subarray(resultStringPtr, resultStringPtr + totalLength);
          let writerOffset = 0;
          for (let row = 0; row < desc.rows; ++row) {
            resultData[row] = writerOffset;
            const resultUTF8 = resultDataUTF8[row];
            const writer = resultStringBuf.subarray(writerOffset, writerOffset + resultUTF8.length);
            writer.set(resultUTF8);
            writerOffset += resultUTF8.length;
          }
        }
      }
      const retLen = 3 * 8;
      const retPtr = mod._malloc(retLen);
      const retBuffer = ptrToFloat64Array(mod, retPtr, 3);
      retBuffer[0] = resultDataPtr;
      retBuffer[1] = resultValidityPtr;
      retBuffer[2] = resultLengthsPtr;
      mod.HEAPF64[(response >> 3) + 0] = 0;
      mod.HEAPF64[(response >> 3) + 1] = retPtr;
      mod.HEAPF64[(response >> 3) + 2] = 0;
    } catch (e) {
      storeError(mod, response, e.toString());
    }
  }

  // src/bindings/runtime.ts
  function TextDecoderWrapper() {
    const decoder3 = new TextDecoder();
    return (data) => {
      if (typeof SharedArrayBuffer !== "undefined" && data.buffer instanceof SharedArrayBuffer) {
        data = new Uint8Array(data);
      }
      return decoder3.decode(data);
    };
  }
  var decodeText = TextDecoderWrapper();
  function failWith(mod, msg) {
    console.error(`FAIL WITH: ${msg}`);
    mod.ccall("duckdb_web_fail_with", null, ["string"], [msg]);
  }
  function copyBuffer(mod, begin, length) {
    const buffer = mod.HEAPU8.subarray(begin, begin + length);
    const copy = new Uint8Array(new ArrayBuffer(buffer.byteLength));
    copy.set(buffer);
    return copy;
  }
  function readString(mod, begin, length) {
    return decodeText(mod.HEAPU8.subarray(begin, begin + length));
  }
  function callSRet(mod, funcName, argTypes, args) {
    const stackPointer = mod.stackSave();
    const response = mod.stackAlloc(3 * 8);
    argTypes.unshift("number");
    args.unshift(response);
    mod.ccall(funcName, null, argTypes, args);
    const status = mod.HEAPF64[(response >> 3) + 0];
    const data = mod.HEAPF64[(response >> 3) + 1];
    const dataSize = mod.HEAPF64[(response >> 3) + 2];
    mod.stackRestore(stackPointer);
    return [status, data, dataSize];
  }
  function dropResponseBuffers(mod) {
    mod.ccall("duckdb_web_clear_response", null, [], []);
  }

  // src/bindings/file_stats.ts
  var FileStatistics = class {
    constructor(u8array) {
      const f642 = new Float64Array(u8array.buffer, u8array.byteOffset, u8array.byteLength / 8);
      const blocks2 = new Uint8Array(new ArrayBuffer(u8array.byteLength));
      blocks2.set(u8array.subarray(7 * 8));
      this.totalFileReadsCold = f642[0];
      this.totalFileReadsAhead = f642[1];
      this.totalFileReadsCached = f642[2];
      this.totalFileWrites = f642[3];
      this.totalPageAccesses = f642[4];
      this.totalPageLoads = f642[5];
      this.blockSize = f642[6];
      this.blockStats = blocks2;
    }
    getBlockStats(index, out) {
      out = out || {
        file_reads_cold: 0,
        file_reads_ahead: 0,
        file_reads_cached: 0,
        file_writes: 0,
        page_accesses: 0,
        page_loads: 0
      };
      out.file_writes = this.blockStats[index * 3 + 0] & 15;
      out.file_reads_cold = this.blockStats[index * 3 + 0] >> 4;
      out.file_reads_ahead = this.blockStats[index * 3 + 1] & 15;
      out.file_reads_cached = this.blockStats[index * 3 + 1] >> 4;
      out.page_accesses = this.blockStats[index * 3 + 1] & 15;
      out.page_loads = this.blockStats[index * 3 + 1] >> 4;
      return out;
    }
  };

  // src/json_typedef.ts
  function arrowToSQLType(type) {
    switch (type.typeId) {
      case Type.Binary:
        return { sqlType: "binary" };
      case Type.Bool:
        return { sqlType: "bool" };
      case Type.Date:
        return { sqlType: "date" };
      case Type.DateDay:
        return { sqlType: "date32[d]" };
      case Type.DateMillisecond:
        return { sqlType: "date64[ms]" };
      case Type.Decimal: {
        const dec = type;
        return { sqlType: "decimal", precision: dec.precision, scale: dec.scale };
      }
      case Type.Float:
        return { sqlType: "float" };
      case Type.Float16:
        return { sqlType: "float16" };
      case Type.Float32:
        return { sqlType: "float32" };
      case Type.Float64:
        return { sqlType: "float64" };
      case Type.Int:
        return { sqlType: "int32" };
      case Type.Int16:
        return { sqlType: "int16" };
      case Type.Int32:
        return { sqlType: "int32" };
      case Type.Int64:
        return { sqlType: "int64" };
      case Type.Uint16:
        return { sqlType: "uint16" };
      case Type.Uint32:
        return { sqlType: "uint32" };
      case Type.Uint64:
        return { sqlType: "uint64" };
      case Type.Uint8:
        return { sqlType: "uint8" };
      case Type.IntervalDayTime:
        return { sqlType: "interval[dt]" };
      case Type.IntervalYearMonth:
        return { sqlType: "interval[m]" };
      case Type.List: {
        const list = type;
        return {
          sqlType: "list",
          valueType: arrowToSQLType(list.valueType)
        };
      }
      case Type.FixedSizeBinary: {
        const bin = type;
        return { sqlType: "fixedsizebinary", byteWidth: bin.byteWidth };
      }
      case Type.Null:
        return { sqlType: "null" };
      case Type.Utf8:
        return { sqlType: "utf8" };
      case Type.Struct: {
        const struct_ = type;
        return {
          sqlType: "struct",
          fields: struct_.children.map((c) => arrowToSQLField(c.name, c.type))
        };
      }
      case Type.Map: {
        const map_ = type;
        return {
          sqlType: "map",
          keyType: arrowToSQLType(map_.keyType),
          valueType: arrowToSQLType(map_.valueType)
        };
      }
      case Type.Time:
        return { sqlType: "time[s]" };
      case Type.TimeMicrosecond:
        return { sqlType: "time[us]" };
      case Type.TimeMillisecond:
        return { sqlType: "time[ms]" };
      case Type.TimeNanosecond:
        return { sqlType: "time[ns]" };
      case Type.TimeSecond:
        return { sqlType: "time[s]" };
      case Type.Timestamp: {
        const ts = type;
        return { sqlType: "timestamp", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampSecond: {
        const ts = type;
        return { sqlType: "timestamp[s]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMicrosecond: {
        const ts = type;
        return { sqlType: "timestamp[us]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampNanosecond: {
        const ts = type;
        return { sqlType: "timestamp[ns]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMillisecond: {
        const ts = type;
        return { sqlType: "timestamp[ms]", timezone: ts.timezone || void 0 };
      }
    }
    throw new Error(`unsupported arrow type: ${type.toString()}`);
  }
  function arrowToSQLField(name, type) {
    const t = arrowToSQLType(type);
    t.name = name;
    return t;
  }

  // src/bindings/bindings_base.ts
  var TEXT_ENCODER2 = new TextEncoder();
  var DuckDBBindingsBase = class {
    constructor(logger, runtime) {
      this._instance = null;
      this._initPromise = null;
      this._initPromiseResolver = () => {
      };
      this.onInstantiationProgress = [];
      this._logger = logger;
      this._runtime = runtime;
      this._nextUDFId = 1;
    }
    get logger() {
      return this._logger;
    }
    get mod() {
      return this._instance;
    }
    get pthread() {
      return this.mod.PThread || null;
    }
    async instantiate(onProgress = (_) => {
    }) {
      if (this._instance != null) {
        return this;
      }
      if (this._initPromise != null) {
        this.onInstantiationProgress.push(onProgress);
        await this._initPromise;
      }
      this._initPromise = new Promise((resolve) => {
        this._initPromiseResolver = resolve;
      });
      this.onInstantiationProgress = [onProgress];
      this._instance = await this.instantiateImpl({
        print: console.log.bind(console),
        printErr: console.log.bind(console),
        onRuntimeInitialized: this._initPromiseResolver
      });
      await this._initPromise;
      this._initPromise = null;
      this.onInstantiationProgress = this.onInstantiationProgress.filter((x) => x != onProgress);
      return this;
    }
    open(config) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_open", ["string"], [JSON.stringify(config)]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    reset() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_reset", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    getVersion() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_get_version", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const version = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return version;
    }
    getFeatureFlags() {
      return this.mod.ccall("duckdb_web_get_feature_flags", "number", [], []);
    }
    tokenize(text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_tokenize", ["string"], [text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    connect() {
      const conn = this.mod.ccall("duckdb_web_connect", "number", [], []);
      return new DuckDBConnection(this, conn);
    }
    disconnect(conn) {
      this.mod.ccall("duckdb_web_disconnect", null, ["number"], [conn]);
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "dropUDFFunctions",
            connectionId: conn
          });
        }
      }
    }
    runQuery(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_query_run", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    startPendingQuery(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_pending_query_start", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    pollPendingQuery(conn) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_pending_query_poll", ["number"], [conn]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    cancelPendingQuery(conn) {
      return this.mod.ccall("duckdb_web_pending_query_cancel", "boolean", ["number"], [conn]);
    }
    fetchQueryResults(conn) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_query_fetch_results", ["number"], [conn]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    getTableNames(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_get_tablenames", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    createScalarFunction(conn, name, returns, func) {
      const decl = {
        functionId: this._nextUDFId,
        name,
        returnType: arrowToSQLType(returns)
      };
      const def = {
        functionId: decl.functionId,
        connectionId: conn,
        name,
        returnType: returns,
        func
      };
      this._nextUDFId += 1;
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_udf_scalar_create",
        ["number", "string"],
        [conn, JSON.stringify(decl)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._udfFunctions = (globalThis.DUCKDB_RUNTIME._udfFunctions || /* @__PURE__ */ new Map()).set(
        def.functionId,
        def
      );
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "registerUDFFunction",
            udf: def
          });
        }
      }
    }
    createPrepared(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_prepared_create", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      return d;
    }
    closePrepared(conn, statement) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_prepared_close", ["number", "number"], [conn, statement]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    runPrepared(conn, statement, params) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_run",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    sendPrepared(conn, statement, params) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_send",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const bufferPtr = this.mod._malloc(buffer.length);
      const bufferOfs = this.mod.HEAPU8.subarray(bufferPtr, bufferPtr + buffer.length);
      bufferOfs.set(buffer);
      const optJSON = options ? JSON.stringify(options) : "";
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_arrow_from_ipc_stream",
        ["number", "number", "number", "string"],
        [conn, bufferPtr, buffer.length, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_csv_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_json_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    globFiles(path) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_glob_file_infos", ["string"], [path]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const infoStr = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      const info = JSON.parse(infoStr);
      if (info == null) {
        return [];
      }
      return info;
    }
    registerFileURL(name, url, proto, directIO = false) {
      if (url === void 0) {
        url = name;
      }
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string"],
        [name, url, proto, directIO]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    registerFileText(name, text) {
      const buffer = TEXT_ENCODER2.encode(text);
      this.registerFileBuffer(name, buffer);
    }
    registerFileBuffer(name, buffer) {
      const ptr = this.mod._malloc(buffer.length);
      const dst = this.mod.HEAPU8.subarray(ptr, ptr + buffer.length);
      dst.set(buffer);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_buffer",
        ["string", "number", "number"],
        [name, ptr, buffer.length]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    registerFileHandle(name, handle, protocol, directIO) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string", "number", "boolean"],
        [name, name, protocol, directIO]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._files = (globalThis.DUCKDB_RUNTIME._files || /* @__PURE__ */ new Map()).set(name, handle);
      if (this.pthread) {
        for (const worker2 of this.pthread.runningWorkers) {
          worker2.postMessage({
            cmd: "registerFileHandle",
            fileName: name,
            fileHandle: handle
          });
        }
        for (const worker2 of this.pthread.unusedWorkers) {
          worker2.postMessage({
            cmd: "dropFileHandle",
            fileName: name
          });
        }
      }
    }
    dropFile(name) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_file", ["string"], [name]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    dropFiles() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_files", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    flushFiles() {
      this.mod.ccall("duckdb_web_flush_files", null, [], []);
    }
    copyFileToPath(name, path) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_path", ["string", "string"], [name, path]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    copyFileToBuffer(name) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_buffer", ["string"], [name]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const buffer = this.mod.HEAPU8.subarray(d, d + n);
      const copy = new Uint8Array(buffer.length);
      copy.set(buffer);
      dropResponseBuffers(this.mod);
      return copy;
    }
    collectFileStatistics(file, enable) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_collect_file_stats", ["string", "boolean"], [file, enable]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    exportFileStatistics(file) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_export_file_stats", ["string"], [file]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      return new FileStatistics(this.mod.HEAPU8.subarray(d, d + n));
    }
  };

  // src/log.ts
  var VoidLogger = class {
    log(_entry) {
    }
  };

  // ../../node_modules/wasm-feature-detect/dist/esm/index.js
  var bulkMemory = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11]));
  var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
  var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
  var threads = () => (async (e) => {
    try {
      return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
    } catch (e2) {
      return false;
    }
  })(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

  // src/platform.ts
  var isNode = () => typeof navigator === "undefined" ? true : false;
  var bigInt64Array = null;
  var wasmExceptions = null;
  var wasmThreads = null;
  var wasmSIMD = null;
  var wasmBulkMemory = null;
  async function getPlatformFeatures() {
    if (bigInt64Array == null) {
      bigInt64Array = typeof BigInt64Array != "undefined";
    }
    if (wasmExceptions == null) {
      wasmExceptions = await exceptions();
    }
    if (wasmThreads == null) {
      wasmThreads = await threads();
    }
    if (wasmSIMD == null) {
      wasmSIMD = await simd();
    }
    if (wasmBulkMemory == null) {
      wasmBulkMemory = await bulkMemory();
    }
    return {
      bigInt64Array,
      crossOriginIsolated: isNode() || globalThis.crossOriginIsolated || false,
      wasmExceptions,
      wasmSIMD,
      wasmThreads,
      wasmBulkMemory
    };
  }
  async function selectBundle(bundles) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (platform.wasmSIMD && platform.wasmThreads && platform.crossOriginIsolated && bundles.coi) {
        return {
          mainModule: bundles.coi.mainModule,
          mainWorker: bundles.coi.mainWorker,
          pthreadWorker: bundles.coi.pthreadWorker
        };
      }
      if (bundles.eh) {
        return {
          mainModule: bundles.eh.mainModule,
          mainWorker: bundles.eh.mainWorker,
          pthreadWorker: null
        };
      }
    }
    return {
      mainModule: bundles.mvp.mainModule,
      mainWorker: bundles.mvp.mainWorker,
      pthreadWorker: null
    };
  }

  // src/utils/s3_helper.ts
  var import_js_sha256 = __toESM(require_sha256());
  var getHTTPHost = function(config, url, bucket) {
    if (config?.endpoint?.startsWith("http")) {
      const httpHost = `${config?.endpoint}`;
      const offset = httpHost.indexOf("://") + 3;
      return httpHost.substring(offset);
    } else if (config?.endpoint) {
      return `${bucket}.${config?.endpoint}`;
    } else {
      return `${bucket}.s3.amazonaws.com`;
    }
  };
  function getS3Params(config, url, method2) {
    const parsedS3Url = parseS3Url(url);
    let path = parsedS3Url.path;
    if (isPathStyleAccess(config)) {
      path = `/${parsedS3Url.bucket}${path}`;
    }
    return {
      url: path,
      query: "",
      host: getHTTPHost(config, url, parsedS3Url.bucket),
      region: config?.region ?? "",
      service: "s3",
      method: method2,
      accessKeyId: config?.accessKeyId ?? "",
      secretAccessKey: config?.secretAccessKey ?? "",
      sessionToken: config?.sessionToken ?? "",
      dateNow: new Date().toISOString().replace(/-/g, "").split("T")[0],
      datetimeNow: new Date().toISOString().replace(/-/g, "").replace(/:/g, "").split(".")[0] + "Z"
    };
  }
  function uriEncode(input, encode_slash = false) {
    const hexDigit = "0123456789ABCDEF";
    let result = "";
    for (let i = 0; i < input.length; i++) {
      const ch = input[i];
      if (ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z" || ch >= "0" && ch <= "9" || ch == "_" || ch == "-" || ch == "~" || ch == ".") {
        result += ch;
      } else if (ch == "/") {
        if (encode_slash) {
          result += "%2F";
        } else {
          result += ch;
        }
      } else {
        result += "%";
        result += hexDigit[ch.charCodeAt(0) >> 4];
        result += hexDigit[ch.charCodeAt(0) & 15];
      }
    }
    return result;
  }
  function createS3Headers(params, payloadParams = null) {
    const payloadHash = payloadParams?.contentHash ?? "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    const res = /* @__PURE__ */ new Map();
    res.set("x-amz-date", params.datetimeNow);
    res.set("x-amz-content-sha256", payloadHash);
    if (params.sessionToken) {
      res.set("x-amz-security-token", params.sessionToken);
    }
    let signedHeaders = "";
    if (payloadParams?.contentType) {
      signedHeaders += "content-type;";
    }
    signedHeaders += "host;x-amz-content-sha256;x-amz-date";
    if (params.sessionToken) {
      signedHeaders += ";x-amz-security-token";
    }
    let canonicalRequest = params.method + "\n" + uriEncode(params.url) + "\n" + params.query;
    if (payloadParams?.contentType) {
      canonicalRequest += "\ncontent-type:" + payloadParams?.contentType;
    }
    canonicalRequest += "\nhost:" + params.host + "\nx-amz-content-sha256:" + payloadHash + "\nx-amz-date:" + params.datetimeNow;
    if (params.sessionToken && params.sessionToken.length > 0) {
      canonicalRequest += "\nx-amz-security-token:" + params.sessionToken;
    }
    canonicalRequest += "\n\n" + signedHeaders + "\n" + payloadHash;
    const canonicalRequestHashStr = (0, import_js_sha256.sha256)(canonicalRequest);
    const stringToSign = "AWS4-HMAC-SHA256\n" + params.datetimeNow + "\n" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request\n" + canonicalRequestHashStr;
    const signKey = "AWS4" + params.secretAccessKey;
    const kDate = import_js_sha256.sha256.hmac.arrayBuffer(signKey, params.dateNow);
    const kRegion = import_js_sha256.sha256.hmac.arrayBuffer(kDate, params.region);
    const kService = import_js_sha256.sha256.hmac.arrayBuffer(kRegion, params.service);
    const signingKey = import_js_sha256.sha256.hmac.arrayBuffer(kService, "aws4_request");
    const signature = import_js_sha256.sha256.hmac(signingKey, stringToSign);
    res.set("Authorization", "AWS4-HMAC-SHA256 Credential=" + params.accessKeyId + "/" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request, SignedHeaders=" + signedHeaders + ", Signature=" + signature);
    return res;
  }
  var createS3HeadersFromS3Config = function(config, url, method2, contentType = null, payload = null) {
    const params = getS3Params(config, url, method2);
    const payloadParams = {
      contentType,
      contentHash: payload ? import_js_sha256.sha256.hex(payload) : null
    };
    return createS3Headers(params, payloadParams);
  };
  function addS3Headers(xhr, config, url, method2, contentType = null, payload = null) {
    if (config?.accessKeyId || config?.sessionToken) {
      const headers = createS3HeadersFromS3Config(config, url, method2, contentType, payload);
      headers.forEach((value, header) => {
        xhr.setRequestHeader(header, value);
      });
      if (contentType) {
        xhr.setRequestHeader("content-type", contentType);
      }
    }
  }
  function parseS3Url(url) {
    if (url.indexOf("s3://") != 0) {
      throw new Error("URL needs to start with s3://");
    }
    const slashPos = url.indexOf("/", 5);
    if (slashPos == -1) {
      throw new Error("URL needs to contain a '/' after the host");
    }
    const bucket = url.substring(5, slashPos);
    if (!bucket) {
      throw new Error("URL needs to contain a bucket name");
    }
    const path = url.substring(slashPos);
    if (!path) {
      throw new Error("URL needs to contain key");
    }
    return { bucket, path };
  }
  function isPathStyleAccess(config) {
    if (config?.endpoint?.startsWith("http")) {
      return true;
    }
    return false;
  }
  function getHTTPUrl(config, url) {
    const parsedUrl = parseS3Url(url);
    if (isPathStyleAccess(config)) {
      return `${config?.endpoint}/${parsedUrl.bucket}` + parsedUrl.path;
    }
    return "https://" + getHTTPHost(config, url, parsedUrl.bucket) + parsedUrl.path;
  }

  // src/bindings/runtime_browser.ts
  var BROWSER_RUNTIME = {
    _files: /* @__PURE__ */ new Map(),
    _fileInfoCache: /* @__PURE__ */ new Map(),
    _udfFunctions: /* @__PURE__ */ new Map(),
    _globalFileInfo: null,
    getFileInfo(mod, fileId) {
      try {
        const cached = BROWSER_RUNTIME._fileInfoCache.get(fileId);
        const [s, d, n] = callSRet(
          mod,
          "duckdb_web_fs_get_file_info_by_id",
          ["number", "number"],
          [fileId, cached?.cacheEpoch || 0]
        );
        if (s !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return cached;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info = JSON.parse(infoStr);
        if (info == null) {
          return null;
        }
        const file = { ...info, blob: null };
        BROWSER_RUNTIME._fileInfoCache.set(fileId, file);
        return file;
      } catch (e) {
        return null;
      }
    },
    getGlobalFileInfo(mod) {
      try {
        const [s, d, n] = callSRet(
          mod,
          "duckdb_web_get_global_file_info",
          ["number"],
          [BROWSER_RUNTIME._globalFileInfo?.cacheEpoch || 0]
        );
        if (s !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return BROWSER_RUNTIME._globalFileInfo;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info = JSON.parse(infoStr);
        if (info == null) {
          return null;
        }
        BROWSER_RUNTIME._globalFileInfo = { ...info, blob: null };
        return BROWSER_RUNTIME._globalFileInfo;
      } catch (e) {
        return null;
      }
    },
    testPlatformFeature: (_mod, feature) => {
      switch (feature) {
        case 1:
          return typeof BigInt64Array !== "undefined";
        default:
          console.warn(`test for unknown feature: ${feature}`);
          return false;
      }
    },
    getDefaultDataProtocol(mod) {
      return 2 /* BROWSER_FILEREADER */;
    },
    openFile: (mod, fileId, flags) => {
      try {
        BROWSER_RUNTIME._fileInfoCache.delete(fileId);
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (flags & 1 /* FILE_FLAGS_READ */ && flags & 2 /* FILE_FLAGS_WRITE */) {
              throw new Error(
                `Opening file ${file.fileName} failed: cannot open file with both read and write flags set`
              );
            } else if (flags & 32 /* FILE_FLAGS_APPEND */) {
              throw new Error(
                `Opening file ${file.fileName} failed: appending to HTTP/S3 files is not supported`
              );
            } else if (flags & 2 /* FILE_FLAGS_WRITE */) {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.send(null);
              if (xhr.status != 200 && xhr.status != 404) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Unexpected return status from server (${xhr.status})`
                );
              } else if (xhr.status == 404 && !(flags & 8 /* FILE_FLAGS_FILE_CREATE */ || flags & 16 /* FILE_FLAGS_FILE_CREATE_NEW */)) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Cannot write to non-existent file without FILE_FLAGS_FILE_CREATE or FILE_FLAGS_FILE_CREATE_NEW flag.`
                );
              }
              const data = mod._malloc(1);
              const src = new Uint8Array();
              mod.HEAPU8.set(src, data);
              const result = mod._malloc(2 * 8);
              mod.HEAPF64[(result >> 3) + 0] = 1;
              mod.HEAPF64[(result >> 3) + 1] = data;
              return result;
            } else if (flags != 1 /* FILE_FLAGS_READ */) {
              throw new Error(`Opening file ${file.fileName} failed: unsupported file flags: ${flags}`);
            }
            let contentLength = null;
            let error = null;
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.setRequestHeader("Range", `bytes=0-`);
              xhr.send(null);
              contentLength = xhr.getResponseHeader("Content-Length");
              if (contentLength !== null && xhr.status == 206) {
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                mod.HEAPF64[(result >> 3) + 1] = 0;
                return result;
              }
            } catch (e) {
              error = e;
              console.warn(`HEAD request with range header failed: ${e}`);
            }
            if (file.allowFullHttpReads) {
              if (contentLength !== null && +contentLength > 1) {
                const xhr2 = new XMLHttpRequest();
                if (file.dataProtocol == 5 /* S3 */) {
                  xhr2.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                  addS3Headers(xhr2, file.s3Config, file.dataUrl, "GET");
                } else {
                  xhr2.open("GET", file.dataUrl, false);
                }
                xhr2.setRequestHeader("Range", `bytes=0-0`);
                xhr2.send(null);
                const contentLength2 = xhr2.getResponseHeader("Content-Length");
                if (xhr2.status == 206 && contentLength2 !== null && +contentLength2 == 1) {
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                  mod.HEAPF64[(result >> 3) + 1] = 0;
                  return result;
                }
                if (xhr2.status == 200 && contentLength2 !== null && +contentLength2 == +contentLength) {
                  console.warn(`fall back to full HTTP read for: ${file.dataUrl}`);
                  const data = mod._malloc(xhr2.response.byteLength);
                  const src = new Uint8Array(xhr2.response, 0, xhr2.response.byteLength);
                  mod.HEAPU8.set(src, data);
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = xhr2.response.byteLength;
                  mod.HEAPF64[(result >> 3) + 1] = data;
                  return result;
                }
              }
              console.warn(`falling back to full HTTP read for: ${file.dataUrl}`);
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              if (xhr.status == 200) {
                const data = mod._malloc(xhr.response.byteLength);
                const src = new Uint8Array(xhr.response, 0, xhr.response.byteLength);
                mod.HEAPU8.set(src, data);
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = xhr.response.byteLength;
                mod.HEAPF64[(result >> 3) + 1] = data;
                return result;
              }
            }
            if (error != null) {
              throw new Error(`Reading file ${file.fileName} failed with error: ${error}`);
            }
            return 0;
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (handle) {
              const result2 = mod._malloc(2 * 8);
              mod.HEAPF64[(result2 >> 3) + 0] = handle.size;
              mod.HEAPF64[(result2 >> 3) + 1] = 0;
              return result2;
            }
            console.warn(`Buffering missing file: ${file.fileName}`);
            const result = mod._malloc(2 * 8);
            const buffer = mod._malloc(1);
            mod.HEAPF64[(result >> 3) + 0] = 1;
            mod.HEAPF64[(result >> 3) + 1] = buffer;
            return result;
          }
        }
      } catch (e) {
        console.error(e.toString());
        failWith(mod, e.toString());
      }
      return 0;
    },
    glob: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          if (xhr.status != 200 && xhr.status !== 206) {
            if (!BROWSER_RUNTIME.getGlobalFileInfo(mod)?.allowFullHttpReads) {
              failWith(mod, `HEAD request failed: ${path}, with full http reads are disabled`);
              return;
            }
            const xhr2 = new XMLHttpRequest();
            if (path.startsWith("s3://")) {
              const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
              xhr2.open("GET", getHTTPUrl(globalInfo?.s3Config, path), false);
              addS3Headers(xhr2, globalInfo?.s3Config, path, "HEAD");
            } else {
              xhr2.open("GET", path, false);
            }
            xhr2.setRequestHeader("Range", `bytes=0-0`);
            xhr2.send(null);
            if (xhr2.status != 200 && xhr2.status !== 206) {
              failWith(mod, `HEAD and GET requests failed: ${path}`);
              return;
            }
            const contentLength = xhr2.getResponseHeader("Content-Length");
            if (contentLength && +contentLength > 1) {
              console.warn(`Range request for ${path} did not return a partial response: ${xhr2.status} "${xhr2.statusText}"`);
            }
          }
          mod.ccall("duckdb_web_fs_glob_add_path", null, ["string"], [path]);
        }
      } catch (e) {
        failWith(mod, e.toString());
        return 0;
      }
    },
    checkFile: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          return xhr.status == 206 || xhr.status == 200;
        }
      } catch (e) {
        return false;
      }
      return false;
    },
    syncFile: (_mod, _fileId) => {
    },
    closeFile: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      BROWSER_RUNTIME._fileInfoCache.delete(fileId);
      switch (file?.dataProtocol) {
        case 0 /* BUFFER */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          break;
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle.flush();
        }
      }
    },
    truncateFile: (mod, fileId, newSize) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, `Cannot truncate a http file`);
          return;
        case 5 /* S3 */:
          failWith(mod, `Cannot truncate an s3 file`);
          return;
        case 0 /* BUFFER */:
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, `truncateFile not implemented`);
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle.truncate(newSize);
        }
      }
      return 0;
    },
    readFile(mod, fileId, buf, bytes, location) {
      if (bytes == 0) {
        return 0;
      }
      try {
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (!file.dataUrl) {
              throw new Error(`Missing data URL for file ${fileId}`);
            }
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file?.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file?.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.setRequestHeader("Range", `bytes=${location}-${location + bytes - 1}`);
              xhr.send(null);
              if (xhr.status == 206 || xhr.status == 200 && bytes == xhr.response.byteLength && location == 0) {
                const src = new Uint8Array(xhr.response, 0, Math.min(xhr.response.byteLength, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else if (xhr.status == 200) {
                console.warn(`Range request for ${file.dataUrl} did not return a partial response: ${xhr.status} "${xhr.statusText}"`);
                const src = new Uint8Array(xhr.response, location, Math.min(xhr.response.byteLength - location, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else {
                throw new Error(
                  `Range request for ${file.dataUrl} did returned non-success status: ${xhr.status} "${xhr.statusText}"`
                );
              }
            } catch (e) {
              throw new Error(`Range request for ${file.dataUrl} failed with error: ${e}"`);
            }
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle) {
              throw new Error(`No HTML5 file registered with name: ${file.fileName}`);
            }
            const sliced = handle.slice(location, location + bytes);
            const data = new Uint8Array(new FileReaderSync().readAsArrayBuffer(sliced));
            mod.HEAPU8.set(data, buf);
            return data.byteLength;
          }
          case 3 /* BROWSER_FSACCESS */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle) {
              throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
            }
            const out = mod.HEAPU8.subarray(buf, buf + bytes);
            return handle.read(out, { at: location });
          }
        }
        return 0;
      } catch (e) {
        failWith(mod, e.toString());
        return 0;
      }
    },
    writeFile: (mod, fileId, buf, bytes, location) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, "Cannot write to HTTP file");
          return 0;
        case 5 /* S3 */: {
          const buffer = mod.HEAPU8.subarray(buf, buf + bytes);
          const xhr = new XMLHttpRequest();
          xhr.open("PUT", getHTTPUrl(file?.s3Config, file.dataUrl), false);
          addS3Headers(xhr, file?.s3Config, file.dataUrl, "PUT", "", buffer);
          xhr.send(buffer);
          return bytes;
        }
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, "cannot write using the html5 file reader api");
          return 0;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          const input = mod.HEAPU8.subarray(buf, buf + bytes);
          return handle.write(input, { at: location });
        }
      }
      return 0;
    },
    getLastFileModificationTime: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 2 /* BROWSER_FILEREADER */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw Error(`No handle available for file: ${file.fileName}`);
          }
          return 0;
        }
        case 4 /* HTTP */:
        case 5 /* S3 */:
          return new Date().getTime();
      }
      return 0;
    },
    checkDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`checkDirectory: ${path}`);
      return false;
    },
    createDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`createDirectory: ${path}`);
    },
    removeDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`removeDirectory: ${path}`);
    },
    listDirectoryEntries: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`listDirectoryEntries: ${path}`);
      return false;
    },
    moveFile: (mod, fromPtr, fromLen, toPtr, toLen) => {
      const from = readString(mod, fromPtr, fromLen);
      const to = readString(mod, toPtr, toLen);
      const handle = BROWSER_RUNTIME._files?.get(from);
      if (handle !== void 0) {
        BROWSER_RUNTIME._files.delete(handle);
        BROWSER_RUNTIME._files.set(to, handle);
      }
      for (const [key, value] of BROWSER_RUNTIME._fileInfoCache?.entries() || []) {
        if (value.dataUrl == from) {
          BROWSER_RUNTIME._fileInfoCache.delete(key);
          break;
        }
      }
      return true;
    },
    removeFile: (_mod, _pathPtr, _pathLen) => {
    },
    callScalarUDF: (mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) => {
      callScalarUDF(BROWSER_RUNTIME, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize);
    }
  };
  var runtime_browser_default = BROWSER_RUNTIME;

  // src/bindings/duckdb-mvp.js
  var import_meta = {};
  var DuckDB = (() => {
    var _scriptDir = import_meta.url;
    return async function(DuckDB5 = {}) {
      var Module = typeof DuckDB5 != "undefined" ? DuckDB5 : {};
      var readyPromiseResolve, readyPromiseReject;
      Module["ready"] = new Promise((resolve, reject) => {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      ["_main", "_malloc", "_free", "_duckdb_web_clear_response", "_duckdb_web_collect_file_stats", "_duckdb_web_connect", "_duckdb_web_copy_file_to_buffer", "_duckdb_web_copy_file_to_path", "_duckdb_web_disconnect", "_duckdb_web_export_file_stats", "_duckdb_web_fail_with", "_duckdb_web_flush_file", "_duckdb_web_flush_files", "_duckdb_web_fs_drop_file", "_duckdb_web_fs_drop_files", "_duckdb_web_fs_get_file_info_by_id", "_duckdb_web_fs_get_file_info_by_name", "_duckdb_web_fs_glob_add_path", "_duckdb_web_fs_glob_file_infos", "_duckdb_web_fs_register_file_buffer", "_duckdb_web_fs_register_file_url", "_duckdb_web_get_feature_flags", "_duckdb_web_get_global_file_info", "_duckdb_web_get_tablenames", "_duckdb_web_get_version", "_duckdb_web_insert_arrow_from_ipc_stream", "_duckdb_web_insert_csv_from_path", "_duckdb_web_insert_json_from_path", "_duckdb_web_open", "_duckdb_web_pending_query_cancel", "_duckdb_web_pending_query_poll", "_duckdb_web_pending_query_start", "_duckdb_web_prepared_close", "_duckdb_web_prepared_create", "_duckdb_web_prepared_run", "_duckdb_web_prepared_send", "_duckdb_web_query_fetch_results", "_duckdb_web_query_run", "_duckdb_web_reset", "_duckdb_web_tokenize", "_duckdb_web_udf_scalar_create", "_fflush", "onRuntimeInitialized"].forEach((prop) => {
        if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) {
          Object.defineProperty(Module["ready"], prop, {
            get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
            set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
          });
        }
      });
      var moduleOverrides = Object.assign({}, Module);
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
      var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      if (Module["ENVIRONMENT"]) {
        throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
      }
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      if (ENVIRONMENT_IS_NODE) {
        if (typeof process == "undefined" || !process.release || process.release.name !== "node")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        var nodeVersion = process.versions.node;
        var numericVersion = nodeVersion.split(".").slice(0, 3);
        numericVersion = numericVersion[0] * 1e4 + numericVersion[1] * 100 + numericVersion[2].split("-")[0] * 1;
        var minVersion = 101900;
        if (numericVersion < 101900) {
          throw new Error("This emscripten-generated code requires node v10.19.19.0 (detected v" + nodeVersion + ")");
        }
        const { createRequire } = await import("module");
        var require2 = createRequire(import_meta.url);
        var fs = require2("fs");
        var nodePath = require2("path");
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = require2("url").fileURLToPath(new URL("./", import_meta.url));
        }
        read_ = (filename, binary) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          return fs.readFileSync(filename, binary ? void 0 : "utf8");
        };
        readBinary = (filename) => {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert(ret.buffer);
          return ret;
        };
        readAsync = (filename, onload, onerror, binary = true) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
            if (err2)
              onerror(err2);
            else
              onload(binary ? data.buffer : data);
          });
        };
        if (!Module["thisProgram"] && process.argv.length > 1) {
          thisProgram = process.argv[1].replace(/\\/g, "/");
        }
        arguments_ = process.argv.slice(2);
        quit_ = (status, toThrow) => {
          process.exitCode = status;
          throw toThrow;
        };
        Module["inspect"] = () => "[Emscripten Module object]";
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof process == "object" && typeof require2 === "function" || typeof window == "object" || typeof importScripts == "function")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        if (typeof read != "undefined") {
          read_ = (f) => {
            return read(f);
          };
        }
        readBinary = (f) => {
          let data;
          if (typeof readbuffer == "function") {
            return new Uint8Array(readbuffer(f));
          }
          data = read(f, "binary");
          assert(typeof data == "object");
          return data;
        };
        readAsync = (f, onload, onerror) => {
          setTimeout(() => onload(readBinary(f)), 0);
        };
        if (typeof clearTimeout == "undefined") {
          globalThis.clearTimeout = (id) => {
          };
        }
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit == "function") {
          quit_ = (status, toThrow) => {
            setTimeout(() => {
              if (!(toThrow instanceof ExitStatus)) {
                let toLog = toThrow;
                if (toThrow && typeof toThrow == "object" && toThrow.stack) {
                  toLog = [toThrow, toThrow.stack];
                }
                err(`exiting due to exception: ${toLog}`);
              }
              quit(status);
            });
            throw toThrow;
          };
        }
        if (typeof print != "undefined") {
          if (typeof console == "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        if (!(typeof window == "object" || typeof importScripts == "function"))
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        {
          read_ = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url, onload, onerror) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = (title) => document.title = title;
      } else {
        throw new Error("environment detection error");
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.error.bind(console);
      Object.assign(Module, moduleOverrides);
      moduleOverrides = null;
      checkIncomingModuleAPI();
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      legacyModuleProp("arguments", "arguments_");
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      legacyModuleProp("thisProgram", "thisProgram");
      if (Module["quit"])
        quit_ = Module["quit"];
      legacyModuleProp("quit", "quit_");
      assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
      assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
      assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
      assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
      assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
      legacyModuleProp("read", "read_");
      legacyModuleProp("readAsync", "readAsync");
      legacyModuleProp("readBinary", "readBinary");
      legacyModuleProp("setWindowTitle", "setWindowTitle");
      var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
      var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
      var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
      var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";
      assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      legacyModuleProp("wasmBinary", "wasmBinary");
      var noExitRuntime = Module["noExitRuntime"] || true;
      legacyModuleProp("noExitRuntime", "noExitRuntime");
      if (typeof WebAssembly != "object") {
        abort("no native wasm support detected");
      }
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed" + (text ? ": " + text : ""));
        }
      }
      var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateMemoryViews() {
        var b = wasmMemory.buffer;
        Module["HEAP8"] = HEAP8 = new Int8Array(b);
        Module["HEAP16"] = HEAP16 = new Int16Array(b);
        Module["HEAP32"] = HEAP32 = new Int32Array(b);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      }
      assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
      assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
      assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
      assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
      var wasmTable;
      function writeStackCookie() {
        var max = _emscripten_stack_get_end();
        assert((max & 3) == 0);
        if (max == 0) {
          max += 4;
        }
        HEAPU32[max >>> 2] = 34821223;
        HEAPU32[max + 4 >>> 2] = 2310721022;
        HEAPU32[0 >>> 2] = 1668509029;
      }
      function checkStackCookie() {
        if (ABORT)
          return;
        var max = _emscripten_stack_get_end();
        if (max == 0) {
          max += 4;
        }
        var cookie1 = HEAPU32[max >>> 2];
        var cookie2 = HEAPU32[max + 4 >>> 2];
        if (cookie1 != 34821223 || cookie2 != 2310721022) {
          abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
        }
        if (HEAPU32[0 >>> 2] != 1668509029) {
          abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
        }
      }
      (function() {
        var h16 = new Int16Array(1);
        var h8 = new Int8Array(h16.buffer);
        h16[0] = 25459;
        if (h8[0] !== 115 || h8[1] !== 99)
          throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
      })();
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATEXIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeKeepaliveCounter = 0;
      function keepRuntimeAlive() {
        return noExitRuntime || runtimeKeepaliveCounter > 0;
      }
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        assert(!runtimeInitialized);
        runtimeInitialized = true;
        checkStackCookie();
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        checkStackCookie();
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        checkStackCookie();
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnInit(cb) {
        __ATINIT__.unshift(cb);
      }
      function addOnPreMain(cb) {
        __ATMAIN__.unshift(cb);
      }
      function addOnExit(cb) {
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      var runDependencyTracking = {};
      function getUniqueRunDependency(id) {
        var orig = id;
        while (1) {
          if (!runDependencyTracking[id])
            return id;
          id = orig + Math.random();
        }
      }
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(!runDependencyTracking[id]);
          runDependencyTracking[id] = 1;
          if (runDependencyWatcher === null && typeof setInterval != "undefined") {
            runDependencyWatcher = setInterval(() => {
              if (ABORT) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
                return;
              }
              var shown = false;
              for (var dep in runDependencyTracking) {
                if (!shown) {
                  shown = true;
                  err("still waiting on run dependencies:");
                }
                err("dependency: " + dep);
              }
              if (shown) {
                err("(end of list)");
              }
            }, 1e4);
          }
        } else {
          err("warning: run dependency added without ID");
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(runDependencyTracking[id]);
          delete runDependencyTracking[id];
        } else {
          err("warning: run dependency removed without ID");
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what = "Aborted(" + what + ")";
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return filename.startsWith(dataURIPrefix);
      }
      function isFileURI(filename) {
        return filename.startsWith("file://");
      }
      function createExportWrapper(name, fixedasm) {
        return function() {
          var displayName = name;
          var asm2 = fixedasm;
          if (!fixedasm) {
            asm2 = Module["asm"];
          }
          assert(runtimeInitialized, "native function `" + displayName + "` called before runtime initialization");
          if (!asm2[name]) {
            assert(asm2[name], "exported native function `" + displayName + "` not found");
          }
          return asm2[name].apply(null, arguments);
        };
      }
      var wasmBinaryFile;
      if (Module["locateFile"]) {
        wasmBinaryFile = "./duckdb-mvp.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
      } else {
        wasmBinaryFile = new URL("./duckdb-mvp.wasm", import_meta.url).href;
      }
      function getBinary2(file) {
        try {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise(binaryFile) {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
          if (typeof fetch == "function") {
            return fetch(binaryFile, {
              credentials: "same-origin"
            }).then((response) => {
              if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + binaryFile + "'";
              }
              return response["arrayBuffer"]();
            }).catch(() => getBinary2(binaryFile));
          }
        }
        return Promise.resolve().then(() => getBinary2(binaryFile));
      }
      function instantiateArrayBuffer(binaryFile, imports, receiver) {
        return getBinaryPromise(binaryFile).then((binary) => {
          return WebAssembly.instantiate(binary, imports);
        }).then((instance9) => {
          return instance9;
        }).then(receiver, (reason) => {
          err("failed to asynchronously prepare wasm: " + reason);
          if (isFileURI(wasmBinaryFile)) {
            err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
          }
          abort(reason);
        });
      }
      function instantiateAsync(binary, binaryFile, imports, callback) {
        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
          return fetch(binaryFile, {
            credentials: "same-origin"
          }).then((response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          });
        } else {
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
      }
      function createWasm() {
        var info = {
          "env": wasmImports,
          "wasi_snapshot_preview1": wasmImports
        };
        function receiveInstance(instance9, module2) {
          var exports2 = instance9.exports;
          Module["asm"] = exports2;
          wasmMemory = Module["asm"]["memory"];
          assert(wasmMemory, "memory not found in wasm exports");
          updateMemoryViews();
          wasmTable = Module["asm"]["__indirect_function_table"];
          assert(wasmTable, "table not found in wasm exports");
          addOnInit(Module["asm"]["__wasm_call_ctors"]);
          removeRunDependency("wasm-instantiate");
          return exports2;
        }
        addRunDependency("wasm-instantiate");
        var trueModule = Module;
        function receiveInstantiationResult(result) {
          assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
          trueModule = null;
          receiveInstance(result["instance"]);
        }
        if (Module["instantiateWasm"]) {
          try {
            return Module["instantiateWasm"](info, receiveInstance);
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            readyPromiseReject(e);
          }
        }
        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
        return {};
      }
      var tempDouble;
      var tempI64;
      function legacyModuleProp(prop, newName) {
        if (!Object.getOwnPropertyDescriptor(Module, prop)) {
          Object.defineProperty(Module, prop, {
            configurable: true,
            get: function() {
              abort("Module." + prop + " has been replaced with plain " + newName + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
            }
          });
        }
      }
      function ignoredModuleProp(prop) {
        if (Object.getOwnPropertyDescriptor(Module, prop)) {
          abort("`Module." + prop + "` was supplied but `" + prop + "` not included in INCOMING_MODULE_JS_API");
        }
      }
      function isExportedByForceFilesystem(name) {
        return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
      }
      function missingGlobal(sym, msg) {
        if (typeof globalThis !== "undefined") {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
              return void 0;
            }
          });
        }
      }
      missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
      function missingLibrarySymbol(sym) {
        if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
              var librarySymbol = sym;
              if (!librarySymbol.startsWith("_")) {
                librarySymbol = "$" + sym;
              }
              msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              warnOnce(msg);
              return void 0;
            }
          });
        }
        unexportedRuntimeSymbol(sym);
      }
      function unexportedRuntimeSymbol(sym) {
        if (!Object.getOwnPropertyDescriptor(Module, sym)) {
          Object.defineProperty(Module, sym, {
            configurable: true,
            get: function() {
              var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              abort(msg);
            }
          });
        }
      }
      function dbg(text) {
        console.warn.apply(console, arguments);
      }
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          callbacks.shift()(Module);
        }
      }
      function getValue2(ptr, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            return HEAP8[ptr >>> 0];
          case "i8":
            return HEAP8[ptr >>> 0];
          case "i16":
            return HEAP16[ptr >>> 1];
          case "i32":
            return HEAP32[ptr >>> 2];
          case "i64":
            abort("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return HEAPF32[ptr >>> 2];
          case "double":
            return HEAPF64[ptr >>> 3];
          case "*":
            return HEAPU32[ptr >>> 2];
          default:
            abort(`invalid type for getValue: ${type}`);
        }
      }
      function ptrToString(ptr) {
        assert(typeof ptr === "number");
        return "0x" + ptr.toString(16).padStart(8, "0");
      }
      function setValue(ptr, value, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i8":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i16":
            HEAP16[ptr >>> 1] = value;
            break;
          case "i32":
            HEAP32[ptr >>> 2] = value;
            break;
          case "i64":
            abort("to do setValue(i64) use WASM_BIGINT");
          case "float":
            HEAPF32[ptr >>> 2] = value;
            break;
          case "double":
            HEAPF64[ptr >>> 3] = value;
            break;
          case "*":
            HEAPU32[ptr >>> 2] = value;
            break;
          default:
            abort(`invalid type for setValue: ${type}`);
        }
      }
      function warnOnce(text) {
        if (!warnOnce.shown)
          warnOnce.shown = {};
        if (!warnOnce.shown[text]) {
          warnOnce.shown[text] = 1;
          if (ENVIRONMENT_IS_NODE)
            text = "warning: " + text;
          err(text);
        }
      }
      function _XML_GetBuffer() {
        err("missing function: XML_GetBuffer");
        abort(-1);
      }
      function _XML_GetErrorCode() {
        err("missing function: XML_GetErrorCode");
        abort(-1);
      }
      function _XML_Parse() {
        err("missing function: XML_Parse");
        abort(-1);
      }
      function _XML_ParseBuffer() {
        err("missing function: XML_ParseBuffer");
        abort(-1);
      }
      function _XML_ParserCreate() {
        err("missing function: XML_ParserCreate");
        abort(-1);
      }
      function _XML_ParserFree() {
        err("missing function: XML_ParserFree");
        abort(-1);
      }
      function _XML_ResumeParser() {
        err("missing function: XML_ResumeParser");
        abort(-1);
      }
      function _XML_SetCharacterDataHandler() {
        err("missing function: XML_SetCharacterDataHandler");
        abort(-1);
      }
      function _XML_SetElementHandler() {
        err("missing function: XML_SetElementHandler");
        abort(-1);
      }
      function _XML_SetUserData() {
        err("missing function: XML_SetUserData");
        abort(-1);
      }
      function _XML_StopParser() {
        err("missing function: XML_StopParser");
        abort(-1);
      }
      function ExceptionInfo(excPtr) {
        this.excPtr = excPtr;
        this.ptr = excPtr - 24;
        this.set_type = function(type) {
          HEAPU32[this.ptr + 4 >>> 2] = type;
        };
        this.get_type = function() {
          return HEAPU32[this.ptr + 4 >>> 2];
        };
        this.set_destructor = function(destructor) {
          HEAPU32[this.ptr + 8 >>> 2] = destructor;
        };
        this.get_destructor = function() {
          return HEAPU32[this.ptr + 8 >>> 2];
        };
        this.set_caught = function(caught) {
          caught = caught ? 1 : 0;
          HEAP8[this.ptr + 12 >>> 0] = caught;
        };
        this.get_caught = function() {
          return HEAP8[this.ptr + 12 >>> 0] != 0;
        };
        this.set_rethrown = function(rethrown) {
          rethrown = rethrown ? 1 : 0;
          HEAP8[this.ptr + 13 >>> 0] = rethrown;
        };
        this.get_rethrown = function() {
          return HEAP8[this.ptr + 13 >>> 0] != 0;
        };
        this.init = function(type, destructor) {
          this.set_adjusted_ptr(0);
          this.set_type(type);
          this.set_destructor(destructor);
        };
        this.set_adjusted_ptr = function(adjustedPtr) {
          HEAPU32[this.ptr + 16 >>> 2] = adjustedPtr;
        };
        this.get_adjusted_ptr = function() {
          return HEAPU32[this.ptr + 16 >>> 2];
        };
        this.get_exception_ptr = function() {
          var isPointer = ___cxa_is_pointer_type(this.get_type());
          if (isPointer) {
            return HEAPU32[this.excPtr >>> 2];
          }
          var adjusted = this.get_adjusted_ptr();
          if (adjusted !== 0)
            return adjusted;
          return this.excPtr;
        };
      }
      var exceptionLast = 0;
      var uncaughtExceptionCount = 0;
      function ___cxa_throw(ptr, type, destructor) {
        var info = new ExceptionInfo(ptr);
        info.init(type, destructor);
        exceptionLast = ptr;
        uncaughtExceptionCount++;
        assert(false, "Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.");
      }
      var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html";
      function ___dlsym(handle, symbol, ra) {
        abort(dlopenMissingError);
      }
      var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
        idx >>>= 0;
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
          return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = "";
        while (idx < endPtr) {
          var u0 = heapOrArray[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heapOrArray[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heapOrArray[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            if ((u0 & 248) != 240)
              warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        assert(typeof ptr == "number");
        ptr >>>= 0;
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      var SYSCALLS = {
        varargs: void 0,
        get: function() {
          assert(SYSCALLS.varargs != void 0);
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        },
        getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }
      };
      function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
        assert(nfds <= 64, "nfds must be less than or equal to 64");
        assert(!exceptfds, "exceptfds not supported");
        var total = 0;
        var srcReadLow = readfds ? HEAP32[readfds >>> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2] : 0;
        var srcWriteLow = writefds ? HEAP32[writefds >>> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2] : 0;
        var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0;
        var dstReadLow = 0, dstReadHigh = 0;
        var dstWriteLow = 0, dstWriteHigh = 0;
        var dstExceptLow = 0, dstExceptHigh = 0;
        var allLow = (readfds ? HEAP32[readfds >>> 2] : 0) | (writefds ? HEAP32[writefds >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2] : 0);
        var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0);
        var check = function(fd2, low, high, val) {
          return fd2 < 32 ? low & val : high & val;
        };
        for (var fd = 0; fd < nfds; fd++) {
          var mask = 1 << fd % 32;
          if (!check(fd, allLow, allHigh, mask)) {
            continue;
          }
          var stream = SYSCALLS.getStreamFromFD(fd);
          var flags = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            flags = stream.stream_ops.poll(stream);
          }
          if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
            fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
            total++;
          }
          if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
            fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
            total++;
          }
          if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
            fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
            total++;
          }
        }
        if (readfds) {
          HEAP32[readfds >>> 2] = dstReadLow;
          HEAP32[readfds + 4 >>> 2] = dstReadHigh;
        }
        if (writefds) {
          HEAP32[writefds >>> 2] = dstWriteLow;
          HEAP32[writefds + 4 >>> 2] = dstWriteHigh;
        }
        if (exceptfds) {
          HEAP32[exceptfds >>> 2] = dstExceptLow;
          HEAP32[exceptfds + 4 >>> 2] = dstExceptHigh;
        }
        return total;
      }
      function SOCKFS() {
        err("missing function: $SOCKFS");
        abort(-1);
      }
      function FS() {
        err("missing function: $FS");
        abort(-1);
      }
      function getSocketFromFD(fd) {
        var socket = SOCKFS.getSocket(fd);
        if (!socket)
          throw new FS.ErrnoError(8);
        return socket;
      }
      function setErrNo(value) {
        HEAP32[___errno_location() >>> 2] = value;
        return value;
      }
      var Sockets = {
        BUFFER_SIZE: 10240,
        MAX_BUFFER_SIZE: 10485760,
        nextFd: 1,
        fds: {},
        nextport: 1,
        maxport: 65535,
        peer: null,
        connections: {},
        portmap: {},
        localAddr: 4261412874,
        addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
      };
      function inetNtop4(addr) {
        return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
      }
      function inetNtop6(ints) {
        var str = "";
        var word = 0;
        var longest = 0;
        var lastzero = 0;
        var zstart = 0;
        var len = 0;
        var i = 0;
        var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
        var hasipv4 = true;
        var v4part = "";
        for (i = 0; i < 5; i++) {
          if (parts[i] !== 0) {
            hasipv4 = false;
            break;
          }
        }
        if (hasipv4) {
          v4part = inetNtop4(parts[6] | parts[7] << 16);
          if (parts[5] === -1) {
            str = "::ffff:";
            str += v4part;
            return str;
          }
          if (parts[5] === 0) {
            str = "::";
            if (v4part === "0.0.0.0")
              v4part = "";
            if (v4part === "0.0.0.1")
              v4part = "1";
            str += v4part;
            return str;
          }
        }
        for (word = 0; word < 8; word++) {
          if (parts[word] === 0) {
            if (word - lastzero > 1) {
              len = 0;
            }
            lastzero = word;
            len++;
          }
          if (len > longest) {
            longest = len;
            zstart = word - longest + 1;
          }
        }
        for (word = 0; word < 8; word++) {
          if (longest > 1) {
            if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
              if (word === zstart) {
                str += ":";
                if (zstart === 0)
                  str += ":";
              }
              continue;
            }
          }
          str += Number(_ntohs(parts[word] & 65535)).toString(16);
          str += word < 7 ? ":" : "";
        }
        return str;
      }
      function readSockaddr(sa, salen) {
        var family = HEAP16[sa >>> 1];
        var port = _ntohs(HEAPU16[sa + 2 >>> 1]);
        var addr;
        switch (family) {
          case 2:
            if (salen !== 16) {
              return {
                errno: 28
              };
            }
            addr = HEAP32[sa + 4 >>> 2];
            addr = inetNtop4(addr);
            break;
          case 10:
            if (salen !== 28) {
              return {
                errno: 28
              };
            }
            addr = [HEAP32[sa + 8 >>> 2], HEAP32[sa + 12 >>> 2], HEAP32[sa + 16 >>> 2], HEAP32[sa + 20 >>> 2]];
            addr = inetNtop6(addr);
            break;
          default:
            return {
              errno: 5
            };
        }
        return {
          family,
          addr,
          port
        };
      }
      function inetPton4(str) {
        var b = str.split(".");
        for (var i = 0; i < 4; i++) {
          var tmp2 = Number(b[i]);
          if (isNaN(tmp2))
            return null;
          b[i] = tmp2;
        }
        return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
      }
      function jstoi_q(str) {
        return parseInt(str);
      }
      function inetPton6(str) {
        var words;
        var w, offset, z, i;
        var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
        var parts = [];
        if (!valid6regx.test(str)) {
          return null;
        }
        if (str === "::") {
          return [0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (str.startsWith("::")) {
          str = str.replace("::", "Z:");
        } else {
          str = str.replace("::", ":Z:");
        }
        if (str.indexOf(".") > 0) {
          str = str.replace(new RegExp("[.]", "g"), ":");
          words = str.split(":");
          words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
          words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
          words = words.slice(0, words.length - 2);
        } else {
          words = str.split(":");
        }
        offset = 0;
        z = 0;
        for (w = 0; w < words.length; w++) {
          if (typeof words[w] == "string") {
            if (words[w] === "Z") {
              for (z = 0; z < 8 - words.length + 1; z++) {
                parts[w + z] = 0;
              }
              offset = z - 1;
            } else {
              parts[w + offset] = _htons(parseInt(words[w], 16));
            }
          } else {
            parts[w + offset] = words[w];
          }
        }
        return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
      }
      var DNS = {
        address_map: {
          id: 1,
          addrs: {},
          names: {}
        },
        lookup_name: function(name) {
          var res = inetPton4(name);
          if (res !== null) {
            return name;
          }
          res = inetPton6(name);
          if (res !== null) {
            return name;
          }
          var addr;
          if (DNS.address_map.addrs[name]) {
            addr = DNS.address_map.addrs[name];
          } else {
            var id = DNS.address_map.id++;
            assert(id < 65535, "exceeded max address mappings of 65535");
            addr = "172.29." + (id & 255) + "." + (id & 65280);
            DNS.address_map.names[addr] = name;
            DNS.address_map.addrs[name] = addr;
          }
          return addr;
        },
        lookup_addr: function(addr) {
          if (DNS.address_map.names[addr]) {
            return DNS.address_map.names[addr];
          }
          return null;
        }
      };
      function getSocketAddress(addrp, addrlen, allowNull) {
        if (allowNull && addrp === 0)
          return null;
        var info = readSockaddr(addrp, addrlen);
        if (info.errno)
          throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      }
      function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.bind(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.connect(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_faccessat(dirfd, path, amode, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_fcntl64(fd, cmd, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_fstat64(fd, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function convertI32PairToI53Checked(lo, hi) {
        assert(lo == lo >>> 0 || lo == (lo | 0));
        assert(hi === (hi | 0));
        return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
      }
      function ___syscall_ftruncate64(fd, length_low, length_high) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
        outIdx >>>= 0;
        assert(typeof str === "string");
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++ >>> 0] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 192 | u >> 6;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 224 | u >> 12;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            if (u > 1114111)
              warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
            heap[outIdx++ >>> 0] = 240 | u >> 18;
            heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          }
        }
        heap[outIdx >>> 0] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      function ___syscall_getdents64(fd, dirp, count) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function zeroMemory(address, size) {
        HEAPU8.fill(0, address, address + size);
        return address;
      }
      function writeSockaddr(sa, family, addr, port, addrlen) {
        switch (family) {
          case 2:
            addr = inetPton4(addr);
            zeroMemory(sa, 16);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 16;
            }
            HEAP16[sa >>> 1] = family;
            HEAP32[sa + 4 >>> 2] = addr;
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          case 10:
            addr = inetPton6(addr);
            zeroMemory(sa, 28);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 28;
            }
            HEAP32[sa >>> 2] = family;
            HEAP32[sa + 8 >>> 2] = addr[0];
            HEAP32[sa + 12 >>> 2] = addr[1];
            HEAP32[sa + 16 >>> 2] = addr[2];
            HEAP32[sa + 20 >>> 2] = addr[3];
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          default:
            return 5;
        }
        return 0;
      }
      function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        if (!sock.daddr) {
          return -53;
        }
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
        assert(!errno);
        return 0;
      }
      function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
        var sock = getSocketFromFD(fd);
        if (level === 1) {
          if (optname === 4) {
            HEAP32[optval >>> 2] = sock.error;
            HEAP32[optlen >>> 2] = 4;
            sock.error = null;
            return 0;
          }
        }
        return -50;
      }
      function ___syscall_ioctl(fd, op, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_lstat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_mkdirat(dirfd, path, mode) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_newfstatat(dirfd, path, buf, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_openat(dirfd, path, flags, varargs) {
        SYSCALLS.varargs = varargs;
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
        var sock = getSocketFromFD(fd);
        var msg = sock.sock_ops.recvmsg(sock, len);
        if (!msg)
          return 0;
        if (addr) {
          var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
          assert(!errno);
        }
        HEAPU8.set(msg.buffer, buf >>> 0);
        return msg.buffer.byteLength;
      }
      function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_rmdir(path) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_socket(domain, type, protocol) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_stat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_unlinkat(dirfd, path, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      var nowIsMonotonic = true;
      function __emscripten_get_now_is_monotonic() {
        return nowIsMonotonic;
      }
      function readI53FromI64(ptr) {
        return HEAPU32[ptr >>> 2] + HEAP32[ptr + 4 >>> 2] * 4294967296;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      function ydayFromDate(date) {
        var leap = isLeapYear(date.getFullYear());
        var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
        var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
        return yday;
      }
      function __localtime_js(time, tmPtr) {
        var date = new Date(readI53FromI64(time) * 1e3);
        HEAP32[tmPtr >>> 2] = date.getSeconds();
        HEAP32[tmPtr + 4 >>> 2] = date.getMinutes();
        HEAP32[tmPtr + 8 >>> 2] = date.getHours();
        HEAP32[tmPtr + 12 >>> 2] = date.getDate();
        HEAP32[tmPtr + 16 >>> 2] = date.getMonth();
        HEAP32[tmPtr + 20 >>> 2] = date.getFullYear() - 1900;
        HEAP32[tmPtr + 24 >>> 2] = date.getDay();
        var yday = ydayFromDate(date) | 0;
        HEAP32[tmPtr + 28 >>> 2] = yday;
        HEAP32[tmPtr + 36 >>> 2] = -(date.getTimezoneOffset() * 60);
        var start = new Date(date.getFullYear(), 0, 1);
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var winterOffset = start.getTimezoneOffset();
        var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
        HEAP32[tmPtr + 32 >>> 2] = dst;
      }
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var c = str.charCodeAt(i);
          if (c <= 127) {
            len++;
          } else if (c <= 2047) {
            len += 2;
          } else if (c >= 55296 && c <= 57343) {
            len += 4;
            ++i;
          } else {
            len += 3;
          }
        }
        return len;
      }
      function stringToNewUTF8(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = _malloc(size);
        if (ret)
          stringToUTF8(str, ret, size);
        return ret;
      }
      function __tzset_js(timezone, daylight, tzname) {
        var currentYear = new Date().getFullYear();
        var winter = new Date(currentYear, 0, 1);
        var summer = new Date(currentYear, 6, 1);
        var winterOffset = winter.getTimezoneOffset();
        var summerOffset = summer.getTimezoneOffset();
        var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
        HEAPU32[timezone >>> 2] = stdTimezoneOffset * 60;
        HEAP32[daylight >>> 2] = Number(winterOffset != summerOffset);
        function extractZone(date) {
          var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
          return match ? match[1] : "GMT";
        }
        var winterName = extractZone(winter);
        var summerName = extractZone(summer);
        var winterNamePtr = stringToNewUTF8(winterName);
        var summerNamePtr = stringToNewUTF8(summerName);
        if (summerOffset < winterOffset) {
          HEAPU32[tzname >>> 2] = winterNamePtr;
          HEAPU32[tzname + 4 >>> 2] = summerNamePtr;
        } else {
          HEAPU32[tzname >>> 2] = summerNamePtr;
          HEAPU32[tzname + 4 >>> 2] = winterNamePtr;
        }
      }
      function _abort() {
        abort("native code called abort()");
      }
      function _dlopen(filename, flags) {
        abort(dlopenMissingError);
      }
      function _duckdb_web_fs_directory_create(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_list_files(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_remove(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_close(fileId) {
        return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
      }
      function _duckdb_web_fs_file_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_get_last_modified_time(fileId) {
        return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
      }
      function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
        return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
      }
      function _duckdb_web_fs_file_open(fileId, flags) {
        return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags);
      }
      function _duckdb_web_fs_file_read(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_file_truncate(fileId, newSize) {
        return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
      }
      function _duckdb_web_fs_file_write(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_get_default_data_protocol(Module2) {
        return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
      }
      function _duckdb_web_fs_glob(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
      }
      function _duckdb_web_test_platform_feature(feature) {
        return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
      }
      function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
        return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
      }
      function _emscripten_console_error(str) {
        assert(typeof str == "number");
        console.error(UTF8ToString(str));
      }
      function _emscripten_date_now() {
        return Date.now();
      }
      function getHeapMax() {
        return 4294901760;
      }
      function _emscripten_get_heap_max() {
        return getHeapMax();
      }
      var _emscripten_get_now;
      if (ENVIRONMENT_IS_NODE) {
        global.performance = require2("perf_hooks").performance;
      }
      _emscripten_get_now = () => performance.now();
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
      }
      function emscripten_realloc_buffer(size) {
        var b = wasmMemory.buffer;
        var pages = size - b.byteLength + 65535 >>> 16;
        try {
          wasmMemory.grow(pages);
          updateMemoryViews();
          return 1;
        } catch (e) {
          err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        assert(requestedSize > oldSize);
        var maxHeapSize = getHeapMax();
        if (requestedSize > maxHeapSize) {
          err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
          return false;
        }
        var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
        return false;
      }
      var ENV = {};
      function getExecutableName() {
        return thisProgram || "./this.program";
      }
      function getEnvStrings() {
        if (!getEnvStrings.strings) {
          var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
          var env = {
            "USER": "web_user",
            "LOGNAME": "web_user",
            "PATH": "/",
            "PWD": "/",
            "HOME": "/home/web_user",
            "LANG": lang,
            "_": getExecutableName()
          };
          for (var x in ENV) {
            if (ENV[x] === void 0)
              delete env[x];
            else
              env[x] = ENV[x];
          }
          var strings = [];
          for (var x in env) {
            strings.push(`${x}=${env[x]}`);
          }
          getEnvStrings.strings = strings;
        }
        return getEnvStrings.strings;
      }
      function stringToAscii(str, buffer) {
        for (var i = 0; i < str.length; ++i) {
          assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));
          HEAP8[buffer++ >>> 0] = str.charCodeAt(i);
        }
        HEAP8[buffer >>> 0] = 0;
      }
      function _environ_get(__environ, environ_buf) {
        var bufSize = 0;
        getEnvStrings().forEach(function(string, i) {
          var ptr = environ_buf + bufSize;
          HEAPU32[__environ + i * 4 >>> 2] = ptr;
          stringToAscii(string, ptr);
          bufSize += string.length + 1;
        });
        return 0;
      }
      function _environ_sizes_get(penviron_count, penviron_buf_size) {
        var strings = getEnvStrings();
        HEAPU32[penviron_count >>> 2] = strings.length;
        var bufSize = 0;
        strings.forEach(function(string) {
          bufSize += string.length + 1;
        });
        HEAPU32[penviron_buf_size >>> 2] = bufSize;
        return 0;
      }
      function _fd_close(fd) {
        abort("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_fdstat_get(fd, pbuf) {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          assert(fd == 0 || fd == 1 || fd == 2);
          var type = 2;
          if (fd == 0) {
            rightsBase = 2;
          } else if (fd == 1 || fd == 2) {
            rightsBase = 64;
          }
          flags = 1;
        }
        HEAP8[pbuf >>> 0] = type;
        HEAP16[pbuf + 2 >>> 1] = flags;
        tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2] = tempI64[0], HEAP32[pbuf + 12 >>> 2] = tempI64[1];
        tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2] = tempI64[0], HEAP32[pbuf + 20 >>> 2] = tempI64[1];
        return 0;
      }
      function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pread called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pwrite called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_read(fd, iov, iovcnt, pnum) {
        abort("fd_read called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        return 70;
      }
      function _fd_sync(fd) {
        abort("fd_sync called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      var printCharBuffers = [null, [], []];
      function printChar(stream, curr) {
        var buffer = printCharBuffers[stream];
        assert(buffer);
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      }
      function flush_NO_FILESYSTEM() {
        _fflush(0);
        if (printCharBuffers[1].length)
          printChar(1, 10);
        if (printCharBuffers[2].length)
          printChar(2, 10);
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        var num = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAPU32[iov >>> 2];
          var len = HEAPU32[iov + 4 >>> 2];
          iov += 8;
          for (var j = 0; j < len; j++) {
            printChar(fd, HEAPU8[ptr + j >>> 0]);
          }
          num += len;
        }
        HEAPU32[pnum >>> 2] = num;
        return 0;
      }
      function _getaddrinfo(node, service, hint, out2) {
        var addrs = [];
        var canon = null;
        var addr = 0;
        var port = 0;
        var flags = 0;
        var family = 0;
        var type = 0;
        var proto = 0;
        var ai, last;
        function allocaddrinfo(family2, type2, proto2, canon2, addr2, port2) {
          var sa, salen, ai2;
          var errno;
          salen = family2 === 10 ? 28 : 16;
          addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
          sa = _malloc(salen);
          errno = writeSockaddr(sa, family2, addr2, port2);
          assert(!errno);
          ai2 = _malloc(32);
          HEAP32[ai2 + 4 >>> 2] = family2;
          HEAP32[ai2 + 8 >>> 2] = type2;
          HEAP32[ai2 + 12 >>> 2] = proto2;
          HEAPU32[ai2 + 24 >>> 2] = canon2;
          HEAPU32[ai2 + 20 >>> 2] = sa;
          if (family2 === 10) {
            HEAP32[ai2 + 16 >>> 2] = 28;
          } else {
            HEAP32[ai2 + 16 >>> 2] = 16;
          }
          HEAP32[ai2 + 28 >>> 2] = 0;
          return ai2;
        }
        if (hint) {
          flags = HEAP32[hint >>> 2];
          family = HEAP32[hint + 4 >>> 2];
          type = HEAP32[hint + 8 >>> 2];
          proto = HEAP32[hint + 12 >>> 2];
        }
        if (type && !proto) {
          proto = type === 2 ? 17 : 6;
        }
        if (!type && proto) {
          type = proto === 17 ? 2 : 1;
        }
        if (proto === 0) {
          proto = 6;
        }
        if (type === 0) {
          type = 1;
        }
        if (!node && !service) {
          return -2;
        }
        if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
          return -1;
        }
        if (hint !== 0 && HEAP32[hint >>> 2] & 2 && !node) {
          return -1;
        }
        if (flags & 32) {
          return -2;
        }
        if (type !== 0 && type !== 1 && type !== 2) {
          return -7;
        }
        if (family !== 0 && family !== 2 && family !== 10) {
          return -6;
        }
        if (service) {
          service = UTF8ToString(service);
          port = parseInt(service, 10);
          if (isNaN(port)) {
            if (flags & 1024) {
              return -2;
            }
            return -8;
          }
        }
        if (!node) {
          if (family === 0) {
            family = 2;
          }
          if ((flags & 1) === 0) {
            if (family === 2) {
              addr = _htonl(2130706433);
            } else {
              addr = [0, 0, 0, 1];
            }
          }
          ai = allocaddrinfo(family, type, proto, null, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        node = UTF8ToString(node);
        addr = inetPton4(node);
        if (addr !== null) {
          if (family === 0 || family === 2) {
            family = 2;
          } else if (family === 10 && flags & 8) {
            addr = [0, 0, _htonl(65535), addr];
            family = 10;
          } else {
            return -2;
          }
        } else {
          addr = inetPton6(node);
          if (addr !== null) {
            if (family === 0 || family === 10) {
              family = 10;
            } else {
              return -2;
            }
          }
        }
        if (addr != null) {
          ai = allocaddrinfo(family, type, proto, node, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        if (flags & 4) {
          return -2;
        }
        node = DNS.lookup_name(node);
        addr = inetPton4(node);
        if (family === 0) {
          family = 2;
        } else if (family === 10) {
          addr = [0, 0, _htonl(65535), addr];
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAPU32[out2 >>> 2] = ai;
        return 0;
      }
      function initRandomFill() {
        if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
          return (view) => crypto.getRandomValues(view);
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = require2("crypto");
            var randomFillSync = crypto_module["randomFillSync"];
            if (randomFillSync) {
              return (view) => crypto_module["randomFillSync"](view);
            }
            var randomBytes = crypto_module["randomBytes"];
            return (view) => (view.set(randomBytes(view.byteLength)), view);
          } catch (e) {
          }
        }
        abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
      }
      function randomFill(view) {
        return (randomFill = initRandomFill())(view);
      }
      function _getentropy(buffer, size) {
        randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
        return 0;
      }
      function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
        var info = readSockaddr(sa, salen);
        if (info.errno) {
          return -6;
        }
        var port = info.port;
        var addr = info.addr;
        var overflowed = false;
        if (node && nodelen) {
          var lookup;
          if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
            if (flags & 8) {
              return -2;
            }
          } else {
            addr = lookup;
          }
          var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
          if (numBytesWrittenExclNull + 1 >= nodelen) {
            overflowed = true;
          }
        }
        if (serv && servlen) {
          port = "" + port;
          var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
          if (numBytesWrittenExclNull + 1 >= servlen) {
            overflowed = true;
          }
        }
        if (overflowed) {
          return -12;
        }
        return 0;
      }
      function arraySum(array, index) {
        var sum2 = 0;
        for (var i = 0; i <= index; sum2 += array[i++]) {
        }
        return sum2;
      }
      var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function addDays(date, days) {
        var newDate = new Date(date.getTime());
        while (days > 0) {
          var leap = isLeapYear(newDate.getFullYear());
          var currentMonth = newDate.getMonth();
          var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
          if (days > daysInCurrentMonth - newDate.getDate()) {
            days -= daysInCurrentMonth - newDate.getDate() + 1;
            newDate.setDate(1);
            if (currentMonth < 11) {
              newDate.setMonth(currentMonth + 1);
            } else {
              newDate.setMonth(0);
              newDate.setFullYear(newDate.getFullYear() + 1);
            }
          } else {
            newDate.setDate(newDate.getDate() + days);
            return newDate;
          }
        }
        return newDate;
      }
      function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull)
          u8array.length = numBytesWritten;
        return u8array;
      }
      function writeArrayToMemory(array, buffer) {
        assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
        HEAP8.set(array, buffer >>> 0);
      }
      function _strftime(s, maxsize, format, tm) {
        var tm_zone = HEAP32[tm + 40 >>> 2];
        var date = {
          tm_sec: HEAP32[tm >>> 2],
          tm_min: HEAP32[tm + 4 >>> 2],
          tm_hour: HEAP32[tm + 8 >>> 2],
          tm_mday: HEAP32[tm + 12 >>> 2],
          tm_mon: HEAP32[tm + 16 >>> 2],
          tm_year: HEAP32[tm + 20 >>> 2],
          tm_wday: HEAP32[tm + 24 >>> 2],
          tm_yday: HEAP32[tm + 28 >>> 2],
          tm_isdst: HEAP32[tm + 32 >>> 2],
          tm_gmtoff: HEAP32[tm + 36 >>> 2],
          tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
        };
        var pattern = UTF8ToString(format);
        var EXPANSION_RULES_1 = {
          "%c": "%a %b %d %H:%M:%S %Y",
          "%D": "%m/%d/%y",
          "%F": "%Y-%m-%d",
          "%h": "%b",
          "%r": "%I:%M:%S %p",
          "%R": "%H:%M",
          "%T": "%H:%M:%S",
          "%x": "%m/%d/%y",
          "%X": "%H:%M:%S",
          "%Ec": "%c",
          "%EC": "%C",
          "%Ex": "%m/%d/%y",
          "%EX": "%H:%M:%S",
          "%Ey": "%y",
          "%EY": "%Y",
          "%Od": "%d",
          "%Oe": "%e",
          "%OH": "%H",
          "%OI": "%I",
          "%Om": "%m",
          "%OM": "%M",
          "%OS": "%S",
          "%Ou": "%u",
          "%OU": "%U",
          "%OV": "%V",
          "%Ow": "%w",
          "%OW": "%W",
          "%Oy": "%y"
        };
        for (var rule in EXPANSION_RULES_1) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
        }
        var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        function leadingSomething(value, digits, character) {
          var str = typeof value == "number" ? value.toString() : value || "";
          while (str.length < digits) {
            str = character[0] + str;
          }
          return str;
        }
        function leadingNulls(value, digits) {
          return leadingSomething(value, digits, "0");
        }
        function compareByDay(date1, date2) {
          function sgn(value) {
            return value < 0 ? -1 : value > 0 ? 1 : 0;
          }
          var compare;
          if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
              compare = sgn(date1.getDate() - date2.getDate());
            }
          }
          return compare;
        }
        function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0:
              return new Date(janFourth.getFullYear() - 1, 11, 29);
            case 1:
              return janFourth;
            case 2:
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3:
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4:
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5:
              return new Date(janFourth.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(janFourth.getFullYear() - 1, 11, 30);
          }
        }
        function getWeekBasedYear(date2) {
          var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear() + 1;
            }
            return thisDate.getFullYear();
          }
          return thisDate.getFullYear() - 1;
        }
        var EXPANSION_RULES_2 = {
          "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          },
          "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          },
          "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          },
          "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          },
          "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          },
          "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          },
          "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          },
          "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          },
          "%G": function(date2) {
            return getWeekBasedYear(date2);
          },
          "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          },
          "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          },
          "%j": function(date2) {
            return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          },
          "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          },
          "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          },
          "%n": function() {
            return "\n";
          },
          "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            }
            return "PM";
          },
          "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          },
          "%t": function() {
            return "	";
          },
          "%u": function(date2) {
            return date2.tm_wday || 7;
          },
          "%U": function(date2) {
            var days = date2.tm_yday + 7 - date2.tm_wday;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%V": function(date2) {
            var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
            if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
              val++;
            }
            if (!val) {
              val = 52;
              var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
              if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                val++;
              }
            } else if (val == 53) {
              var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
              if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                val = 1;
            }
            return leadingNulls(val, 2);
          },
          "%w": function(date2) {
            return date2.tm_wday;
          },
          "%W": function(date2) {
            var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          },
          "%Y": function(date2) {
            return date2.tm_year + 1900;
          },
          "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          },
          "%Z": function(date2) {
            return date2.tm_zone;
          },
          "%%": function() {
            return "%";
          }
        };
        pattern = pattern.replace(/%%/g, "\0\0");
        for (var rule in EXPANSION_RULES_2) {
          if (pattern.includes(rule)) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
          }
        }
        pattern = pattern.replace(/\0\0/g, "%");
        var bytes = intArrayFromString(pattern, false);
        if (bytes.length > maxsize) {
          return 0;
        }
        writeArrayToMemory(bytes, s);
        return bytes.length - 1;
      }
      function _strftime_l(s, maxsize, format, tm, loc) {
        return _strftime(s, maxsize, format, tm);
      }
      function _ucnv_close_64() {
        err("missing function: ucnv_close_64");
        abort(-1);
      }
      function _ucnv_convertEx_64() {
        err("missing function: ucnv_convertEx_64");
        abort(-1);
      }
      function _ucnv_open_64() {
        err("missing function: ucnv_open_64");
        abort(-1);
      }
      function _ucnv_toAlgorithmic_64() {
        err("missing function: ucnv_toAlgorithmic_64");
        abort(-1);
      }
      function _ucsdet_close_64() {
        err("missing function: ucsdet_close_64");
        abort(-1);
      }
      function _ucsdet_detect_64() {
        err("missing function: ucsdet_detect_64");
        abort(-1);
      }
      function _ucsdet_getConfidence_64() {
        err("missing function: ucsdet_getConfidence_64");
        abort(-1);
      }
      function _ucsdet_getName_64() {
        err("missing function: ucsdet_getName_64");
        abort(-1);
      }
      function _ucsdet_open_64() {
        err("missing function: ucsdet_open_64");
        abort(-1);
      }
      function _ucsdet_setText_64() {
        err("missing function: ucsdet_setText_64");
        abort(-1);
      }
      function _unzClose() {
        err("missing function: unzClose");
        abort(-1);
      }
      function _unzCloseCurrentFile() {
        err("missing function: unzCloseCurrentFile");
        abort(-1);
      }
      function _unzGetCurrentFileInfo() {
        err("missing function: unzGetCurrentFileInfo");
        abort(-1);
      }
      function _unzGetCurrentFileInfo64() {
        err("missing function: unzGetCurrentFileInfo64");
        abort(-1);
      }
      function _unzGetGlobalInfo() {
        err("missing function: unzGetGlobalInfo");
        abort(-1);
      }
      function _unzGoToFirstFile() {
        err("missing function: unzGoToFirstFile");
        abort(-1);
      }
      function _unzGoToNextFile() {
        err("missing function: unzGoToNextFile");
        abort(-1);
      }
      function _unzLocateFile() {
        err("missing function: unzLocateFile");
        abort(-1);
      }
      function _unzOpen() {
        err("missing function: unzOpen");
        abort(-1);
      }
      function _unzOpen2() {
        err("missing function: unzOpen2");
        abort(-1);
      }
      function _unzOpenCurrentFile() {
        err("missing function: unzOpenCurrentFile");
        abort(-1);
      }
      function _unzReadCurrentFile() {
        err("missing function: unzReadCurrentFile");
        abort(-1);
      }
      function _proc_exit(code) {
        EXITSTATUS = code;
        if (!keepRuntimeAlive()) {
          if (Module["onExit"])
            Module["onExit"](code);
          ABORT = true;
        }
        quit_(code, new ExitStatus(code));
      }
      function exitJS(status, implicit) {
        EXITSTATUS = status;
        checkUnflushedContent();
        if (keepRuntimeAlive() && !implicit) {
          var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
          readyPromiseReject(msg);
          err(msg);
        }
        _proc_exit(status);
      }
      function handleException(e) {
        if (e instanceof ExitStatus || e == "unwind") {
          return EXITSTATUS;
        }
        checkStackCookie();
        if (e instanceof WebAssembly.RuntimeError) {
          if (_emscripten_stack_get_current() <= 0) {
            err("Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)");
          }
        }
        quit_(1, e);
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function stringToUTF8OnStack(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = stackAlloc(size);
        stringToUTF8(str, ret, size);
        return ret;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {
          "string": (str) => {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              ret2 = stringToUTF8OnStack(str);
            }
            return ret2;
          },
          "array": (arr) => {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          }
        };
        function convertReturnValue(ret2) {
          if (returnType === "string") {
            return UTF8ToString(ret2);
          }
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        assert(returnType !== "array", 'Return type should not be "array".');
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        function onDone(ret2) {
          if (stack !== 0)
            stackRestore(stack);
          return convertReturnValue(ret2);
        }
        ret = onDone(ret);
        return ret;
      }
      function checkIncomingModuleAPI() {
        ignoredModuleProp("fetchSettings");
      }
      var wasmImports = {
        "XML_GetBuffer": _XML_GetBuffer,
        "XML_GetErrorCode": _XML_GetErrorCode,
        "XML_Parse": _XML_Parse,
        "XML_ParseBuffer": _XML_ParseBuffer,
        "XML_ParserCreate": _XML_ParserCreate,
        "XML_ParserFree": _XML_ParserFree,
        "XML_ResumeParser": _XML_ResumeParser,
        "XML_SetCharacterDataHandler": _XML_SetCharacterDataHandler,
        "XML_SetElementHandler": _XML_SetElementHandler,
        "XML_SetUserData": _XML_SetUserData,
        "XML_StopParser": _XML_StopParser,
        "__cxa_throw": ___cxa_throw,
        "__dlsym": ___dlsym,
        "__syscall__newselect": ___syscall__newselect,
        "__syscall_bind": ___syscall_bind,
        "__syscall_connect": ___syscall_connect,
        "__syscall_faccessat": ___syscall_faccessat,
        "__syscall_fcntl64": ___syscall_fcntl64,
        "__syscall_fstat64": ___syscall_fstat64,
        "__syscall_ftruncate64": ___syscall_ftruncate64,
        "__syscall_getdents64": ___syscall_getdents64,
        "__syscall_getpeername": ___syscall_getpeername,
        "__syscall_getsockopt": ___syscall_getsockopt,
        "__syscall_ioctl": ___syscall_ioctl,
        "__syscall_lstat64": ___syscall_lstat64,
        "__syscall_mkdirat": ___syscall_mkdirat,
        "__syscall_newfstatat": ___syscall_newfstatat,
        "__syscall_openat": ___syscall_openat,
        "__syscall_recvfrom": ___syscall_recvfrom,
        "__syscall_renameat": ___syscall_renameat,
        "__syscall_rmdir": ___syscall_rmdir,
        "__syscall_sendto": ___syscall_sendto,
        "__syscall_socket": ___syscall_socket,
        "__syscall_stat64": ___syscall_stat64,
        "__syscall_unlinkat": ___syscall_unlinkat,
        "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
        "_localtime_js": __localtime_js,
        "_tzset_js": __tzset_js,
        "abort": _abort,
        "dlopen": _dlopen,
        "duckdb_web_fs_directory_create": _duckdb_web_fs_directory_create,
        "duckdb_web_fs_directory_exists": _duckdb_web_fs_directory_exists,
        "duckdb_web_fs_directory_list_files": _duckdb_web_fs_directory_list_files,
        "duckdb_web_fs_directory_remove": _duckdb_web_fs_directory_remove,
        "duckdb_web_fs_file_close": _duckdb_web_fs_file_close,
        "duckdb_web_fs_file_exists": _duckdb_web_fs_file_exists,
        "duckdb_web_fs_file_get_last_modified_time": _duckdb_web_fs_file_get_last_modified_time,
        "duckdb_web_fs_file_move": _duckdb_web_fs_file_move,
        "duckdb_web_fs_file_open": _duckdb_web_fs_file_open,
        "duckdb_web_fs_file_read": _duckdb_web_fs_file_read,
        "duckdb_web_fs_file_truncate": _duckdb_web_fs_file_truncate,
        "duckdb_web_fs_file_write": _duckdb_web_fs_file_write,
        "duckdb_web_fs_get_default_data_protocol": _duckdb_web_fs_get_default_data_protocol,
        "duckdb_web_fs_glob": _duckdb_web_fs_glob,
        "duckdb_web_test_platform_feature": _duckdb_web_test_platform_feature,
        "duckdb_web_udf_scalar_call": _duckdb_web_udf_scalar_call,
        "emscripten_console_error": _emscripten_console_error,
        "emscripten_date_now": _emscripten_date_now,
        "emscripten_get_heap_max": _emscripten_get_heap_max,
        "emscripten_get_now": _emscripten_get_now,
        "emscripten_memcpy_big": _emscripten_memcpy_big,
        "emscripten_resize_heap": _emscripten_resize_heap,
        "environ_get": _environ_get,
        "environ_sizes_get": _environ_sizes_get,
        "fd_close": _fd_close,
        "fd_fdstat_get": _fd_fdstat_get,
        "fd_pread": _fd_pread,
        "fd_pwrite": _fd_pwrite,
        "fd_read": _fd_read,
        "fd_seek": _fd_seek,
        "fd_sync": _fd_sync,
        "fd_write": _fd_write,
        "getaddrinfo": _getaddrinfo,
        "getentropy": _getentropy,
        "getnameinfo": _getnameinfo,
        "strftime_l": _strftime_l,
        "ucnv_close_64": _ucnv_close_64,
        "ucnv_convertEx_64": _ucnv_convertEx_64,
        "ucnv_open_64": _ucnv_open_64,
        "ucnv_toAlgorithmic_64": _ucnv_toAlgorithmic_64,
        "ucsdet_close_64": _ucsdet_close_64,
        "ucsdet_detect_64": _ucsdet_detect_64,
        "ucsdet_getConfidence_64": _ucsdet_getConfidence_64,
        "ucsdet_getName_64": _ucsdet_getName_64,
        "ucsdet_open_64": _ucsdet_open_64,
        "ucsdet_setText_64": _ucsdet_setText_64,
        "unzClose": _unzClose,
        "unzCloseCurrentFile": _unzCloseCurrentFile,
        "unzGetCurrentFileInfo": _unzGetCurrentFileInfo,
        "unzGetCurrentFileInfo64": _unzGetCurrentFileInfo64,
        "unzGetGlobalInfo": _unzGetGlobalInfo,
        "unzGoToFirstFile": _unzGoToFirstFile,
        "unzGoToNextFile": _unzGoToNextFile,
        "unzLocateFile": _unzLocateFile,
        "unzOpen": _unzOpen,
        "unzOpen2": _unzOpen2,
        "unzOpenCurrentFile": _unzOpenCurrentFile,
        "unzReadCurrentFile": _unzReadCurrentFile
      };
      var asm = createWasm();
      var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
      var _main = Module["_main"] = createExportWrapper("main");
      var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = createExportWrapper("duckdb_web_fs_glob_add_path");
      var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = createExportWrapper("duckdb_web_clear_response");
      var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = createExportWrapper("duckdb_web_fail_with");
      var _duckdb_web_reset = Module["_duckdb_web_reset"] = createExportWrapper("duckdb_web_reset");
      var _duckdb_web_connect = Module["_duckdb_web_connect"] = createExportWrapper("duckdb_web_connect");
      var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = createExportWrapper("duckdb_web_disconnect");
      var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = createExportWrapper("duckdb_web_flush_files");
      var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = createExportWrapper("duckdb_web_flush_file");
      var _duckdb_web_open = Module["_duckdb_web_open"] = createExportWrapper("duckdb_web_open");
      var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = createExportWrapper("duckdb_web_get_global_file_info");
      var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = createExportWrapper("duckdb_web_collect_file_stats");
      var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = createExportWrapper("duckdb_web_export_file_stats");
      var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = createExportWrapper("duckdb_web_fs_drop_file");
      var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = createExportWrapper("duckdb_web_fs_drop_files");
      var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = createExportWrapper("duckdb_web_fs_glob_file_infos");
      var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = createExportWrapper("duckdb_web_fs_get_file_info_by_id");
      var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = createExportWrapper("duckdb_web_fs_get_file_info_by_name");
      var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = createExportWrapper("duckdb_web_fs_register_file_url");
      var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = createExportWrapper("duckdb_web_fs_register_file_buffer");
      var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = createExportWrapper("duckdb_web_copy_file_to_buffer");
      var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = createExportWrapper("duckdb_web_copy_file_to_path");
      var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = createExportWrapper("duckdb_web_get_version");
      var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = createExportWrapper("duckdb_web_get_feature_flags");
      var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = createExportWrapper("duckdb_web_tokenize");
      var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = createExportWrapper("duckdb_web_udf_scalar_create");
      var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = createExportWrapper("duckdb_web_prepared_create");
      var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = createExportWrapper("duckdb_web_prepared_close");
      var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = createExportWrapper("duckdb_web_prepared_run");
      var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = createExportWrapper("duckdb_web_prepared_send");
      var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = createExportWrapper("duckdb_web_query_run");
      var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = createExportWrapper("duckdb_web_pending_query_start");
      var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = createExportWrapper("duckdb_web_pending_query_poll");
      var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = createExportWrapper("duckdb_web_pending_query_cancel");
      var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = createExportWrapper("duckdb_web_query_fetch_results");
      var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = createExportWrapper("duckdb_web_get_tablenames");
      var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = createExportWrapper("duckdb_web_insert_arrow_from_ipc_stream");
      var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = createExportWrapper("duckdb_web_insert_csv_from_path");
      var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = createExportWrapper("duckdb_web_insert_json_from_path");
      var ___errno_location = createExportWrapper("__errno_location");
      var _fflush = Module["_fflush"] = createExportWrapper("fflush");
      var _htonl = createExportWrapper("htonl");
      var _htons = createExportWrapper("htons");
      var _ntohs = createExportWrapper("ntohs");
      var _malloc = Module["_malloc"] = createExportWrapper("malloc");
      var _free = Module["_free"] = createExportWrapper("free");
      var _emscripten_stack_init = function() {
        return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
      };
      var _emscripten_stack_get_free = function() {
        return (_emscripten_stack_get_free = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
      };
      var _emscripten_stack_get_base = function() {
        return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
      };
      var _emscripten_stack_get_end = function() {
        return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
      };
      var stackSave = createExportWrapper("stackSave");
      var stackRestore = createExportWrapper("stackRestore");
      var stackAlloc = createExportWrapper("stackAlloc");
      var _emscripten_stack_get_current = function() {
        return (_emscripten_stack_get_current = Module["asm"]["emscripten_stack_get_current"]).apply(null, arguments);
      };
      var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type");
      var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
      var dynCall_iiiiij = Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij");
      var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj");
      var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj");
      var dynCall_viijii = Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii");
      var dynCall_viijji = Module["dynCall_viijji"] = createExportWrapper("dynCall_viijji");
      var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");
      var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");
      var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij");
      var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");
      var dynCall_vjjijij = Module["dynCall_vjjijij"] = createExportWrapper("dynCall_vjjijij");
      var dynCall_vijjji = Module["dynCall_vijjji"] = createExportWrapper("dynCall_vijjji");
      var dynCall_vjjii = Module["dynCall_vjjii"] = createExportWrapper("dynCall_vjjii");
      var dynCall_viiiiiji = Module["dynCall_viiiiiji"] = createExportWrapper("dynCall_viiiiiji");
      var dynCall_jiiiji = Module["dynCall_jiiiji"] = createExportWrapper("dynCall_jiiiji");
      var dynCall_jiiij = Module["dynCall_jiiij"] = createExportWrapper("dynCall_jiiij");
      var dynCall_jijjij = Module["dynCall_jijjij"] = createExportWrapper("dynCall_jijjij");
      var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij");
      var dynCall_vijjj = Module["dynCall_vijjj"] = createExportWrapper("dynCall_vijjj");
      var dynCall_vijj = Module["dynCall_vijj"] = createExportWrapper("dynCall_vijj");
      var dynCall_viijj = Module["dynCall_viijj"] = createExportWrapper("dynCall_viijj");
      var dynCall_jiijii = Module["dynCall_jiijii"] = createExportWrapper("dynCall_jiijii");
      var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");
      var dynCall_viijiiiii = Module["dynCall_viijiiiii"] = createExportWrapper("dynCall_viijiiiii");
      var dynCall_viijiiij = Module["dynCall_viijiiij"] = createExportWrapper("dynCall_viijiiij");
      var dynCall_vijiiiji = Module["dynCall_vijiiiji"] = createExportWrapper("dynCall_vijiiiji");
      var dynCall_viiiij = Module["dynCall_viiiij"] = createExportWrapper("dynCall_viiiij");
      var dynCall_jiiji = Module["dynCall_jiiji"] = createExportWrapper("dynCall_jiiji");
      var dynCall_viiijij = Module["dynCall_viiijij"] = createExportWrapper("dynCall_viiijij");
      var dynCall_viijiij = Module["dynCall_viijiij"] = createExportWrapper("dynCall_viijiij");
      var dynCall_viiiiijj = Module["dynCall_viiiiijj"] = createExportWrapper("dynCall_viiiiijj");
      var dynCall_viiijji = Module["dynCall_viiijji"] = createExportWrapper("dynCall_viiijji");
      var dynCall_vijii = Module["dynCall_vijii"] = createExportWrapper("dynCall_vijii");
      var dynCall_iiiiiji = Module["dynCall_iiiiiji"] = createExportWrapper("dynCall_iiiiiji");
      var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij");
      var dynCall_iiijj = Module["dynCall_iiijj"] = createExportWrapper("dynCall_iiijj");
      var dynCall_iijii = Module["dynCall_iijii"] = createExportWrapper("dynCall_iijii");
      var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");
      var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");
      var dynCall_viijjj = Module["dynCall_viijjj"] = createExportWrapper("dynCall_viijjj");
      var dynCall_viiijj = Module["dynCall_viiijj"] = createExportWrapper("dynCall_viiijj");
      var dynCall_jijj = Module["dynCall_jijj"] = createExportWrapper("dynCall_jijj");
      var dynCall_jiiiii = Module["dynCall_jiiiii"] = createExportWrapper("dynCall_jiiiii");
      var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");
      var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");
      var dynCall_viijij = Module["dynCall_viijij"] = createExportWrapper("dynCall_viijij");
      var dynCall_viiij = Module["dynCall_viiij"] = createExportWrapper("dynCall_viiij");
      var dynCall_j = Module["dynCall_j"] = createExportWrapper("dynCall_j");
      var dynCall_viiijiiiijj = Module["dynCall_viiijiiiijj"] = createExportWrapper("dynCall_viiijiiiijj");
      var dynCall_jiiiij = Module["dynCall_jiiiij"] = createExportWrapper("dynCall_jiiiij");
      var dynCall_jj = Module["dynCall_jj"] = createExportWrapper("dynCall_jj");
      var dynCall_ij = Module["dynCall_ij"] = createExportWrapper("dynCall_ij");
      var dynCall_ijjj = Module["dynCall_ijjj"] = createExportWrapper("dynCall_ijjj");
      var dynCall_jjjd = Module["dynCall_jjjd"] = createExportWrapper("dynCall_jjjd");
      var dynCall_jjjjjjd = Module["dynCall_jjjjjjd"] = createExportWrapper("dynCall_jjjjjjd");
      var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij");
      var dynCall_viiijiiijii = Module["dynCall_viiijiiijii"] = createExportWrapper("dynCall_viiijiiijii");
      var dynCall_viijijiiii = Module["dynCall_viijijiiii"] = createExportWrapper("dynCall_viijijiiii");
      var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji");
      var dynCall_jiiiijj = Module["dynCall_jiiiijj"] = createExportWrapper("dynCall_jiiiijj");
      var dynCall_viiiji = Module["dynCall_viiiji"] = createExportWrapper("dynCall_viiiji");
      var dynCall_viiiiji = Module["dynCall_viiiiji"] = createExportWrapper("dynCall_viiiiji");
      var dynCall_jijiiii = Module["dynCall_jijiiii"] = createExportWrapper("dynCall_jijiiii");
      var dynCall_viiijiji = Module["dynCall_viiijiji"] = createExportWrapper("dynCall_viiijiji");
      var dynCall_viijiji = Module["dynCall_viijiji"] = createExportWrapper("dynCall_viijiji");
      var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");
      Module["stackAlloc"] = stackAlloc;
      Module["stackSave"] = stackSave;
      Module["stackRestore"] = stackRestore;
      Module["ccall"] = ccall;
      var missingLibrarySymbols = ["getHostByName", "traverseStack", "getCallstack", "emscriptenLog", "convertPCtoSourceLocation", "readEmAsmArgs", "jstoi_s", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "HandleAllocator", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "cwrap", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "setMainLoop", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "__glGenObject", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory"];
      missingLibrarySymbols.forEach(missingLibrarySymbol);
      var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "ptrToString", "zeroMemory", "exitJS", "getHeapMax", "emscripten_realloc_buffer", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "UNWIND_CACHE", "readEmAsmArgsArray", "jstoi_q", "getExecutableName", "handleException", "readI53FromI64", "convertI32PairToI53Checked", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToNewUTF8", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "currentFullscreenStrategy", "restoreOldWindowedStyle", "ExitStatus", "getEnvStrings", "flush_NO_FILESYSTEM", "dlopenMissingError", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "Browser", "wget", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "emscripten_webgl_power_preferences", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "GLFW", "allocateUTF8", "allocateUTF8OnStack", "SOCKFS", "FS"];
      unexportedSymbols.forEach(unexportedRuntimeSymbol);
      var calledRun;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function callMain() {
        assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
        assert(__ATPRERUN__.length == 0, "cannot call main when preRun functions remain to be called");
        var entryFunction = _main;
        var argc = 0;
        var argv = 0;
        try {
          var ret = entryFunction(argc, argv);
          exitJS(ret, true);
          return ret;
        } catch (e) {
          return handleException(e);
        }
      }
      function stackCheckInit() {
        _emscripten_stack_init();
        writeStackCookie();
      }
      function run() {
        if (runDependencies > 0) {
          return;
        }
        stackCheckInit();
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          readyPromiseResolve(Module);
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (shouldRunNow)
            callMain();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
        checkStackCookie();
      }
      function checkUnflushedContent() {
        var oldOut = out;
        var oldErr = err;
        var has = false;
        out = err = (x) => {
          has = true;
        };
        try {
          flush_NO_FILESYSTEM();
        } catch (e) {
        }
        out = oldOut;
        err = oldErr;
        if (has) {
          warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");
          warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");
        }
      }
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"])
        shouldRunNow = false;
      run();
      return DuckDB5.ready;
    };
  })();
  var duckdb_mvp_default = DuckDB;

  // src/bindings/bindings_browser_base.ts
  var DuckDBBrowserBindings = class extends DuckDBBindingsBase {
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL) {
      super(logger, runtime);
      this.mainModuleURL = mainModuleURL;
      this.pthreadWorkerURL = pthreadWorkerURL;
    }
    locateFile(path, prefix) {
      if (path.endsWith(".wasm")) {
        return this.mainModuleURL;
      }
      if (path.endsWith(".worker.js")) {
        if (!this.pthreadWorkerURL) {
          throw new Error("Missing DuckDB worker URL!");
        }
        return this.pthreadWorkerURL;
      }
      throw new Error(`WASM instantiation requested unexpected file: prefix=${prefix} path=${path}`);
    }
    instantiateWasm(imports, success) {
      globalThis.DUCKDB_RUNTIME = this._runtime;
      const handlers = this.onInstantiationProgress;
      if (WebAssembly.instantiateStreaming) {
        if (typeof TransformStream === "function") {
          const fetchWithProgress = async () => {
            const request = new Request(this.mainModuleURL);
            const response2 = await fetch(request);
            const contentLengthHdr = response2.headers.get("content-length");
            const contentLength = contentLengthHdr ? parseInt(contentLengthHdr, 10) || 0 : 0;
            const start = new Date();
            const progress = {
              startedAt: start,
              updatedAt: start,
              bytesTotal: contentLength || 0,
              bytesLoaded: 0
            };
            const tracker = {
              transform(chunk, ctrl) {
                progress.bytesLoaded += chunk.byteLength;
                const now = new Date();
                if (now.getTime() - progress.updatedAt.getTime() < 20) {
                  progress.updatedAt = now;
                  ctrl.enqueue(chunk);
                  return;
                }
                for (const p of handlers) {
                  p(progress);
                }
                ctrl.enqueue(chunk);
              }
            };
            const ts = new TransformStream(tracker);
            return new Response(response2.body?.pipeThrough(ts), response2);
          };
          const response = fetchWithProgress();
          WebAssembly.instantiateStreaming(response, imports).then((output) => {
            success(output.instance, output.module);
          });
        } else {
          console.warn("instantiating without progress handler since transform streams are unavailable");
          const request = new Request(this.mainModuleURL);
          WebAssembly.instantiateStreaming(fetch(request), imports).then((output) => {
            success(output.instance, output.module);
          });
        }
      } else if (typeof XMLHttpRequest == "function") {
        const xhr = new XMLHttpRequest();
        const url = this.mainModuleURL;
        const start = new Date();
        const progress = {
          startedAt: start,
          updatedAt: start,
          bytesTotal: 0,
          bytesLoaded: 0
        };
        xhr.open("GET", url);
        xhr.responseType = "arraybuffer";
        xhr.onerror = (error) => {
          this.logger.log({
            timestamp: new Date(),
            level: 4 /* ERROR */,
            origin: 3 /* BINDINGS */,
            topic: 5 /* INSTANTIATE */,
            event: 2 /* ERROR */,
            value: "Failed to load WASM: " + error
          });
          throw new Error(error.toString());
        };
        xhr.onprogress = (e) => {
          progress.bytesTotal = e.total;
          progress.bytesLoaded = e.loaded;
          const now = new Date();
          if (now.getTime() - progress.updatedAt.getTime() < 20) {
            progress.updatedAt = now;
            return;
          }
          for (const p of handlers) {
            p(progress);
          }
        };
        xhr.onload = () => {
          WebAssembly.instantiate(xhr.response, imports).then((output) => {
            success(output.instance, output.module);
          }).catch((error) => {
            this.logger.log({
              timestamp: new Date(),
              level: 4 /* ERROR */,
              origin: 3 /* BINDINGS */,
              topic: 5 /* INSTANTIATE */,
              event: 2 /* ERROR */,
              value: "Failed to instantiate WASM: " + error
            });
            throw new Error(error);
          });
        };
        xhr.send();
      } else {
        console.warn("instantiating with manual fetch since streaming instantiation and xhrs are unavailable");
        const run = async () => {
          const request = new Request(this.mainModuleURL);
          const response = await fetch(request);
          const buffer = await response.arrayBuffer();
          WebAssembly.instantiate(buffer, imports).then((output) => {
            success(output.instance, output.module);
          });
        };
        run();
      }
      return [];
    }
  };

  // src/bindings/bindings_browser_mvp.ts
  var DuckDB2 = class extends DuckDBBrowserBindings {
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime, mainModuleURL, pthreadWorkerURL);
    }
    instantiateImpl(moduleOverrides) {
      return duckdb_mvp_default({
        ...moduleOverrides,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/bindings/duckdb-eh.js
  var import_meta2 = {};
  var DuckDB3 = (() => {
    var _scriptDir = import_meta2.url;
    return async function(DuckDB5 = {}) {
      var Module = typeof DuckDB5 != "undefined" ? DuckDB5 : {};
      var readyPromiseResolve, readyPromiseReject;
      Module["ready"] = new Promise((resolve, reject) => {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      ["_main", "_malloc", "_free", "_duckdb_web_clear_response", "_duckdb_web_collect_file_stats", "_duckdb_web_connect", "_duckdb_web_copy_file_to_buffer", "_duckdb_web_copy_file_to_path", "_duckdb_web_disconnect", "_duckdb_web_export_file_stats", "_duckdb_web_fail_with", "_duckdb_web_flush_file", "_duckdb_web_flush_files", "_duckdb_web_fs_drop_file", "_duckdb_web_fs_drop_files", "_duckdb_web_fs_get_file_info_by_id", "_duckdb_web_fs_get_file_info_by_name", "_duckdb_web_fs_glob_add_path", "_duckdb_web_fs_glob_file_infos", "_duckdb_web_fs_register_file_buffer", "_duckdb_web_fs_register_file_url", "_duckdb_web_get_feature_flags", "_duckdb_web_get_global_file_info", "_duckdb_web_get_tablenames", "_duckdb_web_get_version", "_duckdb_web_insert_arrow_from_ipc_stream", "_duckdb_web_insert_csv_from_path", "_duckdb_web_insert_json_from_path", "_duckdb_web_open", "_duckdb_web_pending_query_cancel", "_duckdb_web_pending_query_poll", "_duckdb_web_pending_query_start", "_duckdb_web_prepared_close", "_duckdb_web_prepared_create", "_duckdb_web_prepared_run", "_duckdb_web_prepared_send", "_duckdb_web_query_fetch_results", "_duckdb_web_query_run", "_duckdb_web_reset", "_duckdb_web_tokenize", "_duckdb_web_udf_scalar_create", "getExceptionMessage", "___get_exception_message", "___cpp_exception", "___cxa_increment_exception_refcount", "___cxa_decrement_exception_refcount", "___thrown_object_from_unwind_exception", "_fflush", "onRuntimeInitialized"].forEach((prop) => {
        if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) {
          Object.defineProperty(Module["ready"], prop, {
            get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
            set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
          });
        }
      });
      var moduleOverrides = Object.assign({}, Module);
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
      var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      if (Module["ENVIRONMENT"]) {
        throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
      }
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      if (ENVIRONMENT_IS_NODE) {
        if (typeof process == "undefined" || !process.release || process.release.name !== "node")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        var nodeVersion = process.versions.node;
        var numericVersion = nodeVersion.split(".").slice(0, 3);
        numericVersion = numericVersion[0] * 1e4 + numericVersion[1] * 100 + numericVersion[2].split("-")[0] * 1;
        var minVersion = 101900;
        if (numericVersion < 101900) {
          throw new Error("This emscripten-generated code requires node v10.19.19.0 (detected v" + nodeVersion + ")");
        }
        const { createRequire } = await import("module");
        var require2 = createRequire(import_meta2.url);
        var fs = require2("fs");
        var nodePath = require2("path");
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = require2("url").fileURLToPath(new URL("./", import_meta2.url));
        }
        read_ = (filename, binary) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          return fs.readFileSync(filename, binary ? void 0 : "utf8");
        };
        readBinary = (filename) => {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert(ret.buffer);
          return ret;
        };
        readAsync = (filename, onload, onerror, binary = true) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
            if (err2)
              onerror(err2);
            else
              onload(binary ? data.buffer : data);
          });
        };
        if (!Module["thisProgram"] && process.argv.length > 1) {
          thisProgram = process.argv[1].replace(/\\/g, "/");
        }
        arguments_ = process.argv.slice(2);
        quit_ = (status, toThrow) => {
          process.exitCode = status;
          throw toThrow;
        };
        Module["inspect"] = () => "[Emscripten Module object]";
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof process == "object" && typeof require2 === "function" || typeof window == "object" || typeof importScripts == "function")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        if (typeof read != "undefined") {
          read_ = (f) => {
            return read(f);
          };
        }
        readBinary = (f) => {
          let data;
          if (typeof readbuffer == "function") {
            return new Uint8Array(readbuffer(f));
          }
          data = read(f, "binary");
          assert(typeof data == "object");
          return data;
        };
        readAsync = (f, onload, onerror) => {
          setTimeout(() => onload(readBinary(f)), 0);
        };
        if (typeof clearTimeout == "undefined") {
          globalThis.clearTimeout = (id) => {
          };
        }
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit == "function") {
          quit_ = (status, toThrow) => {
            setTimeout(() => {
              if (!(toThrow instanceof ExitStatus)) {
                let toLog = toThrow;
                if (toThrow && typeof toThrow == "object" && toThrow.stack) {
                  toLog = [toThrow, toThrow.stack];
                }
                err(`exiting due to exception: ${toLog}`);
              }
              quit(status);
            });
            throw toThrow;
          };
        }
        if (typeof print != "undefined") {
          if (typeof console == "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        if (!(typeof window == "object" || typeof importScripts == "function"))
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        {
          read_ = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url, onload, onerror) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = (title) => document.title = title;
      } else {
        throw new Error("environment detection error");
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.error.bind(console);
      Object.assign(Module, moduleOverrides);
      moduleOverrides = null;
      checkIncomingModuleAPI();
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      legacyModuleProp("arguments", "arguments_");
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      legacyModuleProp("thisProgram", "thisProgram");
      if (Module["quit"])
        quit_ = Module["quit"];
      legacyModuleProp("quit", "quit_");
      assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
      assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
      assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
      assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
      assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
      legacyModuleProp("read", "read_");
      legacyModuleProp("readAsync", "readAsync");
      legacyModuleProp("readBinary", "readBinary");
      legacyModuleProp("setWindowTitle", "setWindowTitle");
      var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
      var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
      var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
      var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";
      assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      legacyModuleProp("wasmBinary", "wasmBinary");
      var noExitRuntime = Module["noExitRuntime"] || true;
      legacyModuleProp("noExitRuntime", "noExitRuntime");
      if (typeof WebAssembly != "object") {
        abort("no native wasm support detected");
      }
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed" + (text ? ": " + text : ""));
        }
      }
      var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateMemoryViews() {
        var b = wasmMemory.buffer;
        Module["HEAP8"] = HEAP8 = new Int8Array(b);
        Module["HEAP16"] = HEAP16 = new Int16Array(b);
        Module["HEAP32"] = HEAP32 = new Int32Array(b);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      }
      assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
      assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
      assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
      assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
      var wasmTable;
      function writeStackCookie() {
        var max = _emscripten_stack_get_end();
        assert((max & 3) == 0);
        if (max == 0) {
          max += 4;
        }
        HEAPU32[max >>> 2] = 34821223;
        HEAPU32[max + 4 >>> 2] = 2310721022;
        HEAPU32[0 >>> 2] = 1668509029;
      }
      function checkStackCookie() {
        if (ABORT)
          return;
        var max = _emscripten_stack_get_end();
        if (max == 0) {
          max += 4;
        }
        var cookie1 = HEAPU32[max >>> 2];
        var cookie2 = HEAPU32[max + 4 >>> 2];
        if (cookie1 != 34821223 || cookie2 != 2310721022) {
          abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
        }
        if (HEAPU32[0 >>> 2] != 1668509029) {
          abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
        }
      }
      (function() {
        var h16 = new Int16Array(1);
        var h8 = new Int8Array(h16.buffer);
        h16[0] = 25459;
        if (h8[0] !== 115 || h8[1] !== 99)
          throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
      })();
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATEXIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeKeepaliveCounter = 0;
      function keepRuntimeAlive() {
        return noExitRuntime || runtimeKeepaliveCounter > 0;
      }
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        assert(!runtimeInitialized);
        runtimeInitialized = true;
        checkStackCookie();
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        checkStackCookie();
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        checkStackCookie();
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnInit(cb) {
        __ATINIT__.unshift(cb);
      }
      function addOnPreMain(cb) {
        __ATMAIN__.unshift(cb);
      }
      function addOnExit(cb) {
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      var runDependencyTracking = {};
      function getUniqueRunDependency(id) {
        var orig = id;
        while (1) {
          if (!runDependencyTracking[id])
            return id;
          id = orig + Math.random();
        }
      }
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(!runDependencyTracking[id]);
          runDependencyTracking[id] = 1;
          if (runDependencyWatcher === null && typeof setInterval != "undefined") {
            runDependencyWatcher = setInterval(() => {
              if (ABORT) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
                return;
              }
              var shown = false;
              for (var dep in runDependencyTracking) {
                if (!shown) {
                  shown = true;
                  err("still waiting on run dependencies:");
                }
                err("dependency: " + dep);
              }
              if (shown) {
                err("(end of list)");
              }
            }, 1e4);
          }
        } else {
          err("warning: run dependency added without ID");
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(runDependencyTracking[id]);
          delete runDependencyTracking[id];
        } else {
          err("warning: run dependency removed without ID");
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what = "Aborted(" + what + ")";
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        if (runtimeInitialized) {
          ___trap();
        }
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return filename.startsWith(dataURIPrefix);
      }
      function isFileURI(filename) {
        return filename.startsWith("file://");
      }
      function createExportWrapper(name, fixedasm) {
        return function() {
          var displayName = name;
          var asm2 = fixedasm;
          if (!fixedasm) {
            asm2 = Module["asm"];
          }
          assert(runtimeInitialized, "native function `" + displayName + "` called before runtime initialization");
          if (!asm2[name]) {
            assert(asm2[name], "exported native function `" + displayName + "` not found");
          }
          return asm2[name].apply(null, arguments);
        };
      }
      var wasmBinaryFile;
      if (Module["locateFile"]) {
        wasmBinaryFile = "./duckdb-eh.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
      } else {
        wasmBinaryFile = new URL("./duckdb-eh.wasm", import_meta2.url).href;
      }
      function getBinary2(file) {
        try {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise(binaryFile) {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
          if (typeof fetch == "function") {
            return fetch(binaryFile, {
              credentials: "same-origin"
            }).then((response) => {
              if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + binaryFile + "'";
              }
              return response["arrayBuffer"]();
            }).catch(() => getBinary2(binaryFile));
          }
        }
        return Promise.resolve().then(() => getBinary2(binaryFile));
      }
      function instantiateArrayBuffer(binaryFile, imports, receiver) {
        return getBinaryPromise(binaryFile).then((binary) => {
          return WebAssembly.instantiate(binary, imports);
        }).then((instance9) => {
          return instance9;
        }).then(receiver, (reason) => {
          err("failed to asynchronously prepare wasm: " + reason);
          if (isFileURI(wasmBinaryFile)) {
            err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
          }
          abort(reason);
        });
      }
      function instantiateAsync(binary, binaryFile, imports, callback) {
        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
          return fetch(binaryFile, {
            credentials: "same-origin"
          }).then((response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          });
        } else {
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
      }
      function createWasm() {
        var info = {
          "env": wasmImports,
          "wasi_snapshot_preview1": wasmImports
        };
        function receiveInstance(instance9, module2) {
          var exports2 = instance9.exports;
          Module["asm"] = exports2;
          wasmMemory = Module["asm"]["memory"];
          assert(wasmMemory, "memory not found in wasm exports");
          updateMemoryViews();
          wasmTable = Module["asm"]["__indirect_function_table"];
          assert(wasmTable, "table not found in wasm exports");
          addOnInit(Module["asm"]["__wasm_call_ctors"]);
          removeRunDependency("wasm-instantiate");
          return exports2;
        }
        addRunDependency("wasm-instantiate");
        var trueModule = Module;
        function receiveInstantiationResult(result) {
          assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
          trueModule = null;
          receiveInstance(result["instance"]);
        }
        if (Module["instantiateWasm"]) {
          try {
            return Module["instantiateWasm"](info, receiveInstance);
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            readyPromiseReject(e);
          }
        }
        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
        return {};
      }
      var tempDouble;
      var tempI64;
      function legacyModuleProp(prop, newName) {
        if (!Object.getOwnPropertyDescriptor(Module, prop)) {
          Object.defineProperty(Module, prop, {
            configurable: true,
            get: function() {
              abort("Module." + prop + " has been replaced with plain " + newName + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
            }
          });
        }
      }
      function ignoredModuleProp(prop) {
        if (Object.getOwnPropertyDescriptor(Module, prop)) {
          abort("`Module." + prop + "` was supplied but `" + prop + "` not included in INCOMING_MODULE_JS_API");
        }
      }
      function isExportedByForceFilesystem(name) {
        return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
      }
      function missingGlobal(sym, msg) {
        if (typeof globalThis !== "undefined") {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
              return void 0;
            }
          });
        }
      }
      missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
      function missingLibrarySymbol(sym) {
        if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
              var librarySymbol = sym;
              if (!librarySymbol.startsWith("_")) {
                librarySymbol = "$" + sym;
              }
              msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              warnOnce(msg);
              return void 0;
            }
          });
        }
        unexportedRuntimeSymbol(sym);
      }
      function unexportedRuntimeSymbol(sym) {
        if (!Object.getOwnPropertyDescriptor(Module, sym)) {
          Object.defineProperty(Module, sym, {
            configurable: true,
            get: function() {
              var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              abort(msg);
            }
          });
        }
      }
      function dbg(text) {
        console.warn.apply(console, arguments);
      }
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          callbacks.shift()(Module);
        }
      }
      function getCppExceptionTag() {
        return Module["asm"]["__cpp_exception"];
      }
      function getCppExceptionThrownObjectFromWebAssemblyException(ex) {
        var unwind_header = ex.getArg(getCppExceptionTag(), 0);
        return ___thrown_object_from_unwind_exception(unwind_header);
      }
      function decrementExceptionRefcount(ex) {
        var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
        ___cxa_decrement_exception_refcount(ptr);
      }
      function withStackSave(f) {
        var stack = stackSave();
        var ret = f();
        stackRestore(stack);
        return ret;
      }
      var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
        idx >>>= 0;
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
          return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = "";
        while (idx < endPtr) {
          var u0 = heapOrArray[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heapOrArray[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heapOrArray[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            if ((u0 & 248) != 240)
              warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        assert(typeof ptr == "number");
        ptr >>>= 0;
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function getExceptionMessageCommon(ptr) {
        return withStackSave(function() {
          var type_addr_addr = stackAlloc(4);
          var message_addr_addr = stackAlloc(4);
          ___get_exception_message(ptr, type_addr_addr, message_addr_addr);
          var type_addr = HEAPU32[type_addr_addr >>> 2];
          var message_addr = HEAPU32[message_addr_addr >>> 2];
          var type = UTF8ToString(type_addr);
          _free(type_addr);
          var message;
          if (message_addr) {
            message = UTF8ToString(message_addr);
            _free(message_addr);
          }
          return [type, message];
        });
      }
      function getExceptionMessage(ex) {
        var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
        return getExceptionMessageCommon(ptr);
      }
      Module["getExceptionMessage"] = getExceptionMessage;
      function getValue2(ptr, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            return HEAP8[ptr >>> 0];
          case "i8":
            return HEAP8[ptr >>> 0];
          case "i16":
            return HEAP16[ptr >>> 1];
          case "i32":
            return HEAP32[ptr >>> 2];
          case "i64":
            abort("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return HEAPF32[ptr >>> 2];
          case "double":
            return HEAPF64[ptr >>> 3];
          case "*":
            return HEAPU32[ptr >>> 2];
          default:
            abort(`invalid type for getValue: ${type}`);
        }
      }
      function incrementExceptionRefcount(ex) {
        var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
        ___cxa_increment_exception_refcount(ptr);
      }
      function ptrToString(ptr) {
        assert(typeof ptr === "number");
        return "0x" + ptr.toString(16).padStart(8, "0");
      }
      function setValue(ptr, value, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i8":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i16":
            HEAP16[ptr >>> 1] = value;
            break;
          case "i32":
            HEAP32[ptr >>> 2] = value;
            break;
          case "i64":
            abort("to do setValue(i64) use WASM_BIGINT");
          case "float":
            HEAPF32[ptr >>> 2] = value;
            break;
          case "double":
            HEAPF64[ptr >>> 3] = value;
            break;
          case "*":
            HEAPU32[ptr >>> 2] = value;
            break;
          default:
            abort(`invalid type for setValue: ${type}`);
        }
      }
      function warnOnce(text) {
        if (!warnOnce.shown)
          warnOnce.shown = {};
        if (!warnOnce.shown[text]) {
          warnOnce.shown[text] = 1;
          if (ENVIRONMENT_IS_NODE)
            text = "warning: " + text;
          err(text);
        }
      }
      function _XML_GetBuffer() {
        err("missing function: XML_GetBuffer");
        abort(-1);
      }
      function _XML_GetErrorCode() {
        err("missing function: XML_GetErrorCode");
        abort(-1);
      }
      function _XML_Parse() {
        err("missing function: XML_Parse");
        abort(-1);
      }
      function _XML_ParseBuffer() {
        err("missing function: XML_ParseBuffer");
        abort(-1);
      }
      function _XML_ParserCreate() {
        err("missing function: XML_ParserCreate");
        abort(-1);
      }
      function _XML_ParserFree() {
        err("missing function: XML_ParserFree");
        abort(-1);
      }
      function _XML_ResumeParser() {
        err("missing function: XML_ResumeParser");
        abort(-1);
      }
      function _XML_SetCharacterDataHandler() {
        err("missing function: XML_SetCharacterDataHandler");
        abort(-1);
      }
      function _XML_SetElementHandler() {
        err("missing function: XML_SetElementHandler");
        abort(-1);
      }
      function _XML_SetUserData() {
        err("missing function: XML_SetUserData");
        abort(-1);
      }
      function _XML_StopParser() {
        err("missing function: XML_StopParser");
        abort(-1);
      }
      function ___assert_fail(condition, filename, line, func) {
        abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }
      var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html";
      function ___dlsym(handle, symbol, ra) {
        abort(dlopenMissingError);
      }
      var SYSCALLS = {
        varargs: void 0,
        get: function() {
          assert(SYSCALLS.varargs != void 0);
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        },
        getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }
      };
      function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
        assert(nfds <= 64, "nfds must be less than or equal to 64");
        assert(!exceptfds, "exceptfds not supported");
        var total = 0;
        var srcReadLow = readfds ? HEAP32[readfds >>> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2] : 0;
        var srcWriteLow = writefds ? HEAP32[writefds >>> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2] : 0;
        var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0;
        var dstReadLow = 0, dstReadHigh = 0;
        var dstWriteLow = 0, dstWriteHigh = 0;
        var dstExceptLow = 0, dstExceptHigh = 0;
        var allLow = (readfds ? HEAP32[readfds >>> 2] : 0) | (writefds ? HEAP32[writefds >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2] : 0);
        var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0);
        var check = function(fd2, low, high, val) {
          return fd2 < 32 ? low & val : high & val;
        };
        for (var fd = 0; fd < nfds; fd++) {
          var mask = 1 << fd % 32;
          if (!check(fd, allLow, allHigh, mask)) {
            continue;
          }
          var stream = SYSCALLS.getStreamFromFD(fd);
          var flags = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            flags = stream.stream_ops.poll(stream);
          }
          if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
            fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
            total++;
          }
          if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
            fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
            total++;
          }
          if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
            fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
            total++;
          }
        }
        if (readfds) {
          HEAP32[readfds >>> 2] = dstReadLow;
          HEAP32[readfds + 4 >>> 2] = dstReadHigh;
        }
        if (writefds) {
          HEAP32[writefds >>> 2] = dstWriteLow;
          HEAP32[writefds + 4 >>> 2] = dstWriteHigh;
        }
        if (exceptfds) {
          HEAP32[exceptfds >>> 2] = dstExceptLow;
          HEAP32[exceptfds + 4 >>> 2] = dstExceptHigh;
        }
        return total;
      }
      function SOCKFS() {
        err("missing function: $SOCKFS");
        abort(-1);
      }
      function FS() {
        err("missing function: $FS");
        abort(-1);
      }
      function getSocketFromFD(fd) {
        var socket = SOCKFS.getSocket(fd);
        if (!socket)
          throw new FS.ErrnoError(8);
        return socket;
      }
      function setErrNo(value) {
        HEAP32[___errno_location() >>> 2] = value;
        return value;
      }
      var Sockets = {
        BUFFER_SIZE: 10240,
        MAX_BUFFER_SIZE: 10485760,
        nextFd: 1,
        fds: {},
        nextport: 1,
        maxport: 65535,
        peer: null,
        connections: {},
        portmap: {},
        localAddr: 4261412874,
        addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
      };
      function inetNtop4(addr) {
        return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
      }
      function inetNtop6(ints) {
        var str = "";
        var word = 0;
        var longest = 0;
        var lastzero = 0;
        var zstart = 0;
        var len = 0;
        var i = 0;
        var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
        var hasipv4 = true;
        var v4part = "";
        for (i = 0; i < 5; i++) {
          if (parts[i] !== 0) {
            hasipv4 = false;
            break;
          }
        }
        if (hasipv4) {
          v4part = inetNtop4(parts[6] | parts[7] << 16);
          if (parts[5] === -1) {
            str = "::ffff:";
            str += v4part;
            return str;
          }
          if (parts[5] === 0) {
            str = "::";
            if (v4part === "0.0.0.0")
              v4part = "";
            if (v4part === "0.0.0.1")
              v4part = "1";
            str += v4part;
            return str;
          }
        }
        for (word = 0; word < 8; word++) {
          if (parts[word] === 0) {
            if (word - lastzero > 1) {
              len = 0;
            }
            lastzero = word;
            len++;
          }
          if (len > longest) {
            longest = len;
            zstart = word - longest + 1;
          }
        }
        for (word = 0; word < 8; word++) {
          if (longest > 1) {
            if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
              if (word === zstart) {
                str += ":";
                if (zstart === 0)
                  str += ":";
              }
              continue;
            }
          }
          str += Number(_ntohs(parts[word] & 65535)).toString(16);
          str += word < 7 ? ":" : "";
        }
        return str;
      }
      function readSockaddr(sa, salen) {
        var family = HEAP16[sa >>> 1];
        var port = _ntohs(HEAPU16[sa + 2 >>> 1]);
        var addr;
        switch (family) {
          case 2:
            if (salen !== 16) {
              return {
                errno: 28
              };
            }
            addr = HEAP32[sa + 4 >>> 2];
            addr = inetNtop4(addr);
            break;
          case 10:
            if (salen !== 28) {
              return {
                errno: 28
              };
            }
            addr = [HEAP32[sa + 8 >>> 2], HEAP32[sa + 12 >>> 2], HEAP32[sa + 16 >>> 2], HEAP32[sa + 20 >>> 2]];
            addr = inetNtop6(addr);
            break;
          default:
            return {
              errno: 5
            };
        }
        return {
          family,
          addr,
          port
        };
      }
      function inetPton4(str) {
        var b = str.split(".");
        for (var i = 0; i < 4; i++) {
          var tmp2 = Number(b[i]);
          if (isNaN(tmp2))
            return null;
          b[i] = tmp2;
        }
        return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
      }
      function jstoi_q(str) {
        return parseInt(str);
      }
      function inetPton6(str) {
        var words;
        var w, offset, z, i;
        var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
        var parts = [];
        if (!valid6regx.test(str)) {
          return null;
        }
        if (str === "::") {
          return [0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (str.startsWith("::")) {
          str = str.replace("::", "Z:");
        } else {
          str = str.replace("::", ":Z:");
        }
        if (str.indexOf(".") > 0) {
          str = str.replace(new RegExp("[.]", "g"), ":");
          words = str.split(":");
          words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
          words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
          words = words.slice(0, words.length - 2);
        } else {
          words = str.split(":");
        }
        offset = 0;
        z = 0;
        for (w = 0; w < words.length; w++) {
          if (typeof words[w] == "string") {
            if (words[w] === "Z") {
              for (z = 0; z < 8 - words.length + 1; z++) {
                parts[w + z] = 0;
              }
              offset = z - 1;
            } else {
              parts[w + offset] = _htons(parseInt(words[w], 16));
            }
          } else {
            parts[w + offset] = words[w];
          }
        }
        return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
      }
      var DNS = {
        address_map: {
          id: 1,
          addrs: {},
          names: {}
        },
        lookup_name: function(name) {
          var res = inetPton4(name);
          if (res !== null) {
            return name;
          }
          res = inetPton6(name);
          if (res !== null) {
            return name;
          }
          var addr;
          if (DNS.address_map.addrs[name]) {
            addr = DNS.address_map.addrs[name];
          } else {
            var id = DNS.address_map.id++;
            assert(id < 65535, "exceeded max address mappings of 65535");
            addr = "172.29." + (id & 255) + "." + (id & 65280);
            DNS.address_map.names[addr] = name;
            DNS.address_map.addrs[name] = addr;
          }
          return addr;
        },
        lookup_addr: function(addr) {
          if (DNS.address_map.names[addr]) {
            return DNS.address_map.names[addr];
          }
          return null;
        }
      };
      function getSocketAddress(addrp, addrlen, allowNull) {
        if (allowNull && addrp === 0)
          return null;
        var info = readSockaddr(addrp, addrlen);
        if (info.errno)
          throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      }
      function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.bind(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.connect(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_faccessat(dirfd, path, amode, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_fcntl64(fd, cmd, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_fstat64(fd, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function convertI32PairToI53Checked(lo, hi) {
        assert(lo == lo >>> 0 || lo == (lo | 0));
        assert(hi === (hi | 0));
        return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
      }
      function ___syscall_ftruncate64(fd, length_low, length_high) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
        outIdx >>>= 0;
        assert(typeof str === "string");
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++ >>> 0] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 192 | u >> 6;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 224 | u >> 12;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            if (u > 1114111)
              warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
            heap[outIdx++ >>> 0] = 240 | u >> 18;
            heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          }
        }
        heap[outIdx >>> 0] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      function ___syscall_getdents64(fd, dirp, count) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function zeroMemory(address, size) {
        HEAPU8.fill(0, address, address + size);
        return address;
      }
      function writeSockaddr(sa, family, addr, port, addrlen) {
        switch (family) {
          case 2:
            addr = inetPton4(addr);
            zeroMemory(sa, 16);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 16;
            }
            HEAP16[sa >>> 1] = family;
            HEAP32[sa + 4 >>> 2] = addr;
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          case 10:
            addr = inetPton6(addr);
            zeroMemory(sa, 28);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 28;
            }
            HEAP32[sa >>> 2] = family;
            HEAP32[sa + 8 >>> 2] = addr[0];
            HEAP32[sa + 12 >>> 2] = addr[1];
            HEAP32[sa + 16 >>> 2] = addr[2];
            HEAP32[sa + 20 >>> 2] = addr[3];
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          default:
            return 5;
        }
        return 0;
      }
      function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        if (!sock.daddr) {
          return -53;
        }
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
        assert(!errno);
        return 0;
      }
      function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
        var sock = getSocketFromFD(fd);
        if (level === 1) {
          if (optname === 4) {
            HEAP32[optval >>> 2] = sock.error;
            HEAP32[optlen >>> 2] = 4;
            sock.error = null;
            return 0;
          }
        }
        return -50;
      }
      function ___syscall_ioctl(fd, op, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_lstat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_mkdirat(dirfd, path, mode) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_newfstatat(dirfd, path, buf, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_openat(dirfd, path, flags, varargs) {
        SYSCALLS.varargs = varargs;
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
        var sock = getSocketFromFD(fd);
        var msg = sock.sock_ops.recvmsg(sock, len);
        if (!msg)
          return 0;
        if (addr) {
          var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
          assert(!errno);
        }
        HEAPU8.set(msg.buffer, buf >>> 0);
        return msg.buffer.byteLength;
      }
      function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_rmdir(path) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_socket(domain, type, protocol) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_stat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_unlinkat(dirfd, path, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___throw_exception_with_stack_trace(ex) {
        var e = new WebAssembly.Exception(getCppExceptionTag(), [ex], {
          traceStack: true
        });
        e.message = getExceptionMessage(e);
        if (e.stack) {
          var arr = e.stack.split("\n");
          arr.splice(1, 1);
          e.stack = arr.join("\n");
        }
        throw e;
      }
      var nowIsMonotonic = true;
      function __emscripten_get_now_is_monotonic() {
        return nowIsMonotonic;
      }
      function readI53FromI64(ptr) {
        return HEAPU32[ptr >>> 2] + HEAP32[ptr + 4 >>> 2] * 4294967296;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      function ydayFromDate(date) {
        var leap = isLeapYear(date.getFullYear());
        var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
        var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
        return yday;
      }
      function __localtime_js(time, tmPtr) {
        var date = new Date(readI53FromI64(time) * 1e3);
        HEAP32[tmPtr >>> 2] = date.getSeconds();
        HEAP32[tmPtr + 4 >>> 2] = date.getMinutes();
        HEAP32[tmPtr + 8 >>> 2] = date.getHours();
        HEAP32[tmPtr + 12 >>> 2] = date.getDate();
        HEAP32[tmPtr + 16 >>> 2] = date.getMonth();
        HEAP32[tmPtr + 20 >>> 2] = date.getFullYear() - 1900;
        HEAP32[tmPtr + 24 >>> 2] = date.getDay();
        var yday = ydayFromDate(date) | 0;
        HEAP32[tmPtr + 28 >>> 2] = yday;
        HEAP32[tmPtr + 36 >>> 2] = -(date.getTimezoneOffset() * 60);
        var start = new Date(date.getFullYear(), 0, 1);
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var winterOffset = start.getTimezoneOffset();
        var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
        HEAP32[tmPtr + 32 >>> 2] = dst;
      }
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var c = str.charCodeAt(i);
          if (c <= 127) {
            len++;
          } else if (c <= 2047) {
            len += 2;
          } else if (c >= 55296 && c <= 57343) {
            len += 4;
            ++i;
          } else {
            len += 3;
          }
        }
        return len;
      }
      function stringToNewUTF8(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = _malloc(size);
        if (ret)
          stringToUTF8(str, ret, size);
        return ret;
      }
      function __tzset_js(timezone, daylight, tzname) {
        var currentYear = new Date().getFullYear();
        var winter = new Date(currentYear, 0, 1);
        var summer = new Date(currentYear, 6, 1);
        var winterOffset = winter.getTimezoneOffset();
        var summerOffset = summer.getTimezoneOffset();
        var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
        HEAPU32[timezone >>> 2] = stdTimezoneOffset * 60;
        HEAP32[daylight >>> 2] = Number(winterOffset != summerOffset);
        function extractZone(date) {
          var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
          return match ? match[1] : "GMT";
        }
        var winterName = extractZone(winter);
        var summerName = extractZone(summer);
        var winterNamePtr = stringToNewUTF8(winterName);
        var summerNamePtr = stringToNewUTF8(summerName);
        if (summerOffset < winterOffset) {
          HEAPU32[tzname >>> 2] = winterNamePtr;
          HEAPU32[tzname + 4 >>> 2] = summerNamePtr;
        } else {
          HEAPU32[tzname >>> 2] = summerNamePtr;
          HEAPU32[tzname + 4 >>> 2] = winterNamePtr;
        }
      }
      function _abort() {
        abort("native code called abort()");
      }
      function _dlopen(filename, flags) {
        abort(dlopenMissingError);
      }
      function _duckdb_web_fs_directory_create(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_list_files(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_remove(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_close(fileId) {
        return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
      }
      function _duckdb_web_fs_file_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_get_last_modified_time(fileId) {
        return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
      }
      function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
        return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
      }
      function _duckdb_web_fs_file_open(fileId, flags) {
        return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags);
      }
      function _duckdb_web_fs_file_read(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_file_truncate(fileId, newSize) {
        return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
      }
      function _duckdb_web_fs_file_write(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_get_default_data_protocol(Module2) {
        return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
      }
      function _duckdb_web_fs_glob(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
      }
      function _duckdb_web_test_platform_feature(feature) {
        return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
      }
      function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
        return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
      }
      function _emscripten_console_error(str) {
        assert(typeof str == "number");
        console.error(UTF8ToString(str));
      }
      function _emscripten_date_now() {
        return Date.now();
      }
      function getHeapMax() {
        return 4294901760;
      }
      function _emscripten_get_heap_max() {
        return getHeapMax();
      }
      var _emscripten_get_now;
      if (ENVIRONMENT_IS_NODE) {
        global.performance = require2("perf_hooks").performance;
      }
      _emscripten_get_now = () => performance.now();
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
      }
      function emscripten_realloc_buffer(size) {
        var b = wasmMemory.buffer;
        var pages = size - b.byteLength + 65535 >>> 16;
        try {
          wasmMemory.grow(pages);
          updateMemoryViews();
          return 1;
        } catch (e) {
          err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        assert(requestedSize > oldSize);
        var maxHeapSize = getHeapMax();
        if (requestedSize > maxHeapSize) {
          err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
          return false;
        }
        var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
        return false;
      }
      var ENV = {};
      function getExecutableName() {
        return thisProgram || "./this.program";
      }
      function getEnvStrings() {
        if (!getEnvStrings.strings) {
          var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
          var env = {
            "USER": "web_user",
            "LOGNAME": "web_user",
            "PATH": "/",
            "PWD": "/",
            "HOME": "/home/web_user",
            "LANG": lang,
            "_": getExecutableName()
          };
          for (var x in ENV) {
            if (ENV[x] === void 0)
              delete env[x];
            else
              env[x] = ENV[x];
          }
          var strings = [];
          for (var x in env) {
            strings.push(`${x}=${env[x]}`);
          }
          getEnvStrings.strings = strings;
        }
        return getEnvStrings.strings;
      }
      function stringToAscii(str, buffer) {
        for (var i = 0; i < str.length; ++i) {
          assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));
          HEAP8[buffer++ >>> 0] = str.charCodeAt(i);
        }
        HEAP8[buffer >>> 0] = 0;
      }
      function _environ_get(__environ, environ_buf) {
        var bufSize = 0;
        getEnvStrings().forEach(function(string, i) {
          var ptr = environ_buf + bufSize;
          HEAPU32[__environ + i * 4 >>> 2] = ptr;
          stringToAscii(string, ptr);
          bufSize += string.length + 1;
        });
        return 0;
      }
      function _environ_sizes_get(penviron_count, penviron_buf_size) {
        var strings = getEnvStrings();
        HEAPU32[penviron_count >>> 2] = strings.length;
        var bufSize = 0;
        strings.forEach(function(string) {
          bufSize += string.length + 1;
        });
        HEAPU32[penviron_buf_size >>> 2] = bufSize;
        return 0;
      }
      function _fd_close(fd) {
        abort("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_fdstat_get(fd, pbuf) {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          assert(fd == 0 || fd == 1 || fd == 2);
          var type = 2;
          if (fd == 0) {
            rightsBase = 2;
          } else if (fd == 1 || fd == 2) {
            rightsBase = 64;
          }
          flags = 1;
        }
        HEAP8[pbuf >>> 0] = type;
        HEAP16[pbuf + 2 >>> 1] = flags;
        tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2] = tempI64[0], HEAP32[pbuf + 12 >>> 2] = tempI64[1];
        tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2] = tempI64[0], HEAP32[pbuf + 20 >>> 2] = tempI64[1];
        return 0;
      }
      function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pread called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pwrite called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_read(fd, iov, iovcnt, pnum) {
        abort("fd_read called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        return 70;
      }
      function _fd_sync(fd) {
        abort("fd_sync called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      var printCharBuffers = [null, [], []];
      function printChar(stream, curr) {
        var buffer = printCharBuffers[stream];
        assert(buffer);
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      }
      function flush_NO_FILESYSTEM() {
        _fflush(0);
        if (printCharBuffers[1].length)
          printChar(1, 10);
        if (printCharBuffers[2].length)
          printChar(2, 10);
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        var num = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAPU32[iov >>> 2];
          var len = HEAPU32[iov + 4 >>> 2];
          iov += 8;
          for (var j = 0; j < len; j++) {
            printChar(fd, HEAPU8[ptr + j >>> 0]);
          }
          num += len;
        }
        HEAPU32[pnum >>> 2] = num;
        return 0;
      }
      function _getaddrinfo(node, service, hint, out2) {
        var addrs = [];
        var canon = null;
        var addr = 0;
        var port = 0;
        var flags = 0;
        var family = 0;
        var type = 0;
        var proto = 0;
        var ai, last;
        function allocaddrinfo(family2, type2, proto2, canon2, addr2, port2) {
          var sa, salen, ai2;
          var errno;
          salen = family2 === 10 ? 28 : 16;
          addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
          sa = _malloc(salen);
          errno = writeSockaddr(sa, family2, addr2, port2);
          assert(!errno);
          ai2 = _malloc(32);
          HEAP32[ai2 + 4 >>> 2] = family2;
          HEAP32[ai2 + 8 >>> 2] = type2;
          HEAP32[ai2 + 12 >>> 2] = proto2;
          HEAPU32[ai2 + 24 >>> 2] = canon2;
          HEAPU32[ai2 + 20 >>> 2] = sa;
          if (family2 === 10) {
            HEAP32[ai2 + 16 >>> 2] = 28;
          } else {
            HEAP32[ai2 + 16 >>> 2] = 16;
          }
          HEAP32[ai2 + 28 >>> 2] = 0;
          return ai2;
        }
        if (hint) {
          flags = HEAP32[hint >>> 2];
          family = HEAP32[hint + 4 >>> 2];
          type = HEAP32[hint + 8 >>> 2];
          proto = HEAP32[hint + 12 >>> 2];
        }
        if (type && !proto) {
          proto = type === 2 ? 17 : 6;
        }
        if (!type && proto) {
          type = proto === 17 ? 2 : 1;
        }
        if (proto === 0) {
          proto = 6;
        }
        if (type === 0) {
          type = 1;
        }
        if (!node && !service) {
          return -2;
        }
        if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
          return -1;
        }
        if (hint !== 0 && HEAP32[hint >>> 2] & 2 && !node) {
          return -1;
        }
        if (flags & 32) {
          return -2;
        }
        if (type !== 0 && type !== 1 && type !== 2) {
          return -7;
        }
        if (family !== 0 && family !== 2 && family !== 10) {
          return -6;
        }
        if (service) {
          service = UTF8ToString(service);
          port = parseInt(service, 10);
          if (isNaN(port)) {
            if (flags & 1024) {
              return -2;
            }
            return -8;
          }
        }
        if (!node) {
          if (family === 0) {
            family = 2;
          }
          if ((flags & 1) === 0) {
            if (family === 2) {
              addr = _htonl(2130706433);
            } else {
              addr = [0, 0, 0, 1];
            }
          }
          ai = allocaddrinfo(family, type, proto, null, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        node = UTF8ToString(node);
        addr = inetPton4(node);
        if (addr !== null) {
          if (family === 0 || family === 2) {
            family = 2;
          } else if (family === 10 && flags & 8) {
            addr = [0, 0, _htonl(65535), addr];
            family = 10;
          } else {
            return -2;
          }
        } else {
          addr = inetPton6(node);
          if (addr !== null) {
            if (family === 0 || family === 10) {
              family = 10;
            } else {
              return -2;
            }
          }
        }
        if (addr != null) {
          ai = allocaddrinfo(family, type, proto, node, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        if (flags & 4) {
          return -2;
        }
        node = DNS.lookup_name(node);
        addr = inetPton4(node);
        if (family === 0) {
          family = 2;
        } else if (family === 10) {
          addr = [0, 0, _htonl(65535), addr];
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAPU32[out2 >>> 2] = ai;
        return 0;
      }
      function initRandomFill() {
        if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
          return (view) => crypto.getRandomValues(view);
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = require2("crypto");
            var randomFillSync = crypto_module["randomFillSync"];
            if (randomFillSync) {
              return (view) => crypto_module["randomFillSync"](view);
            }
            var randomBytes = crypto_module["randomBytes"];
            return (view) => (view.set(randomBytes(view.byteLength)), view);
          } catch (e) {
          }
        }
        abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
      }
      function randomFill(view) {
        return (randomFill = initRandomFill())(view);
      }
      function _getentropy(buffer, size) {
        randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
        return 0;
      }
      function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
        var info = readSockaddr(sa, salen);
        if (info.errno) {
          return -6;
        }
        var port = info.port;
        var addr = info.addr;
        var overflowed = false;
        if (node && nodelen) {
          var lookup;
          if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
            if (flags & 8) {
              return -2;
            }
          } else {
            addr = lookup;
          }
          var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
          if (numBytesWrittenExclNull + 1 >= nodelen) {
            overflowed = true;
          }
        }
        if (serv && servlen) {
          port = "" + port;
          var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
          if (numBytesWrittenExclNull + 1 >= servlen) {
            overflowed = true;
          }
        }
        if (overflowed) {
          return -12;
        }
        return 0;
      }
      function arraySum(array, index) {
        var sum2 = 0;
        for (var i = 0; i <= index; sum2 += array[i++]) {
        }
        return sum2;
      }
      var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function addDays(date, days) {
        var newDate = new Date(date.getTime());
        while (days > 0) {
          var leap = isLeapYear(newDate.getFullYear());
          var currentMonth = newDate.getMonth();
          var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
          if (days > daysInCurrentMonth - newDate.getDate()) {
            days -= daysInCurrentMonth - newDate.getDate() + 1;
            newDate.setDate(1);
            if (currentMonth < 11) {
              newDate.setMonth(currentMonth + 1);
            } else {
              newDate.setMonth(0);
              newDate.setFullYear(newDate.getFullYear() + 1);
            }
          } else {
            newDate.setDate(newDate.getDate() + days);
            return newDate;
          }
        }
        return newDate;
      }
      function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull)
          u8array.length = numBytesWritten;
        return u8array;
      }
      function writeArrayToMemory(array, buffer) {
        assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
        HEAP8.set(array, buffer >>> 0);
      }
      function _strftime(s, maxsize, format, tm) {
        var tm_zone = HEAP32[tm + 40 >>> 2];
        var date = {
          tm_sec: HEAP32[tm >>> 2],
          tm_min: HEAP32[tm + 4 >>> 2],
          tm_hour: HEAP32[tm + 8 >>> 2],
          tm_mday: HEAP32[tm + 12 >>> 2],
          tm_mon: HEAP32[tm + 16 >>> 2],
          tm_year: HEAP32[tm + 20 >>> 2],
          tm_wday: HEAP32[tm + 24 >>> 2],
          tm_yday: HEAP32[tm + 28 >>> 2],
          tm_isdst: HEAP32[tm + 32 >>> 2],
          tm_gmtoff: HEAP32[tm + 36 >>> 2],
          tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
        };
        var pattern = UTF8ToString(format);
        var EXPANSION_RULES_1 = {
          "%c": "%a %b %d %H:%M:%S %Y",
          "%D": "%m/%d/%y",
          "%F": "%Y-%m-%d",
          "%h": "%b",
          "%r": "%I:%M:%S %p",
          "%R": "%H:%M",
          "%T": "%H:%M:%S",
          "%x": "%m/%d/%y",
          "%X": "%H:%M:%S",
          "%Ec": "%c",
          "%EC": "%C",
          "%Ex": "%m/%d/%y",
          "%EX": "%H:%M:%S",
          "%Ey": "%y",
          "%EY": "%Y",
          "%Od": "%d",
          "%Oe": "%e",
          "%OH": "%H",
          "%OI": "%I",
          "%Om": "%m",
          "%OM": "%M",
          "%OS": "%S",
          "%Ou": "%u",
          "%OU": "%U",
          "%OV": "%V",
          "%Ow": "%w",
          "%OW": "%W",
          "%Oy": "%y"
        };
        for (var rule in EXPANSION_RULES_1) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
        }
        var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        function leadingSomething(value, digits, character) {
          var str = typeof value == "number" ? value.toString() : value || "";
          while (str.length < digits) {
            str = character[0] + str;
          }
          return str;
        }
        function leadingNulls(value, digits) {
          return leadingSomething(value, digits, "0");
        }
        function compareByDay(date1, date2) {
          function sgn(value) {
            return value < 0 ? -1 : value > 0 ? 1 : 0;
          }
          var compare;
          if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
              compare = sgn(date1.getDate() - date2.getDate());
            }
          }
          return compare;
        }
        function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0:
              return new Date(janFourth.getFullYear() - 1, 11, 29);
            case 1:
              return janFourth;
            case 2:
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3:
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4:
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5:
              return new Date(janFourth.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(janFourth.getFullYear() - 1, 11, 30);
          }
        }
        function getWeekBasedYear(date2) {
          var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear() + 1;
            }
            return thisDate.getFullYear();
          }
          return thisDate.getFullYear() - 1;
        }
        var EXPANSION_RULES_2 = {
          "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          },
          "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          },
          "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          },
          "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          },
          "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          },
          "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          },
          "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          },
          "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          },
          "%G": function(date2) {
            return getWeekBasedYear(date2);
          },
          "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          },
          "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          },
          "%j": function(date2) {
            return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          },
          "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          },
          "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          },
          "%n": function() {
            return "\n";
          },
          "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            }
            return "PM";
          },
          "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          },
          "%t": function() {
            return "	";
          },
          "%u": function(date2) {
            return date2.tm_wday || 7;
          },
          "%U": function(date2) {
            var days = date2.tm_yday + 7 - date2.tm_wday;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%V": function(date2) {
            var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
            if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
              val++;
            }
            if (!val) {
              val = 52;
              var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
              if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                val++;
              }
            } else if (val == 53) {
              var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
              if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                val = 1;
            }
            return leadingNulls(val, 2);
          },
          "%w": function(date2) {
            return date2.tm_wday;
          },
          "%W": function(date2) {
            var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          },
          "%Y": function(date2) {
            return date2.tm_year + 1900;
          },
          "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          },
          "%Z": function(date2) {
            return date2.tm_zone;
          },
          "%%": function() {
            return "%";
          }
        };
        pattern = pattern.replace(/%%/g, "\0\0");
        for (var rule in EXPANSION_RULES_2) {
          if (pattern.includes(rule)) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
          }
        }
        pattern = pattern.replace(/\0\0/g, "%");
        var bytes = intArrayFromString(pattern, false);
        if (bytes.length > maxsize) {
          return 0;
        }
        writeArrayToMemory(bytes, s);
        return bytes.length - 1;
      }
      function _strftime_l(s, maxsize, format, tm, loc) {
        return _strftime(s, maxsize, format, tm);
      }
      function _ucnv_close_64() {
        err("missing function: ucnv_close_64");
        abort(-1);
      }
      function _ucnv_convertEx_64() {
        err("missing function: ucnv_convertEx_64");
        abort(-1);
      }
      function _ucnv_open_64() {
        err("missing function: ucnv_open_64");
        abort(-1);
      }
      function _ucnv_toAlgorithmic_64() {
        err("missing function: ucnv_toAlgorithmic_64");
        abort(-1);
      }
      function _ucsdet_close_64() {
        err("missing function: ucsdet_close_64");
        abort(-1);
      }
      function _ucsdet_detect_64() {
        err("missing function: ucsdet_detect_64");
        abort(-1);
      }
      function _ucsdet_getConfidence_64() {
        err("missing function: ucsdet_getConfidence_64");
        abort(-1);
      }
      function _ucsdet_getName_64() {
        err("missing function: ucsdet_getName_64");
        abort(-1);
      }
      function _ucsdet_open_64() {
        err("missing function: ucsdet_open_64");
        abort(-1);
      }
      function _ucsdet_setText_64() {
        err("missing function: ucsdet_setText_64");
        abort(-1);
      }
      function _unzClose() {
        err("missing function: unzClose");
        abort(-1);
      }
      function _unzCloseCurrentFile() {
        err("missing function: unzCloseCurrentFile");
        abort(-1);
      }
      function _unzGetCurrentFileInfo() {
        err("missing function: unzGetCurrentFileInfo");
        abort(-1);
      }
      function _unzGetCurrentFileInfo64() {
        err("missing function: unzGetCurrentFileInfo64");
        abort(-1);
      }
      function _unzGetGlobalInfo() {
        err("missing function: unzGetGlobalInfo");
        abort(-1);
      }
      function _unzGoToFirstFile() {
        err("missing function: unzGoToFirstFile");
        abort(-1);
      }
      function _unzGoToNextFile() {
        err("missing function: unzGoToNextFile");
        abort(-1);
      }
      function _unzLocateFile() {
        err("missing function: unzLocateFile");
        abort(-1);
      }
      function _unzOpen() {
        err("missing function: unzOpen");
        abort(-1);
      }
      function _unzOpen2() {
        err("missing function: unzOpen2");
        abort(-1);
      }
      function _unzOpenCurrentFile() {
        err("missing function: unzOpenCurrentFile");
        abort(-1);
      }
      function _unzReadCurrentFile() {
        err("missing function: unzReadCurrentFile");
        abort(-1);
      }
      function _proc_exit(code) {
        EXITSTATUS = code;
        if (!keepRuntimeAlive()) {
          if (Module["onExit"])
            Module["onExit"](code);
          ABORT = true;
        }
        quit_(code, new ExitStatus(code));
      }
      function exitJS(status, implicit) {
        EXITSTATUS = status;
        checkUnflushedContent();
        if (keepRuntimeAlive() && !implicit) {
          var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
          readyPromiseReject(msg);
          err(msg);
        }
        _proc_exit(status);
      }
      function handleException(e) {
        if (e instanceof ExitStatus || e == "unwind") {
          return EXITSTATUS;
        }
        checkStackCookie();
        if (e instanceof WebAssembly.RuntimeError) {
          if (_emscripten_stack_get_current() <= 0) {
            err("Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)");
          }
        }
        quit_(1, e);
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function stringToUTF8OnStack(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = stackAlloc(size);
        stringToUTF8(str, ret, size);
        return ret;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {
          "string": (str) => {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              ret2 = stringToUTF8OnStack(str);
            }
            return ret2;
          },
          "array": (arr) => {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          }
        };
        function convertReturnValue(ret2) {
          if (returnType === "string") {
            return UTF8ToString(ret2);
          }
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        assert(returnType !== "array", 'Return type should not be "array".');
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        function onDone(ret2) {
          if (stack !== 0)
            stackRestore(stack);
          return convertReturnValue(ret2);
        }
        ret = onDone(ret);
        return ret;
      }
      function checkIncomingModuleAPI() {
        ignoredModuleProp("fetchSettings");
      }
      var wasmImports = {
        "XML_GetBuffer": _XML_GetBuffer,
        "XML_GetErrorCode": _XML_GetErrorCode,
        "XML_Parse": _XML_Parse,
        "XML_ParseBuffer": _XML_ParseBuffer,
        "XML_ParserCreate": _XML_ParserCreate,
        "XML_ParserFree": _XML_ParserFree,
        "XML_ResumeParser": _XML_ResumeParser,
        "XML_SetCharacterDataHandler": _XML_SetCharacterDataHandler,
        "XML_SetElementHandler": _XML_SetElementHandler,
        "XML_SetUserData": _XML_SetUserData,
        "XML_StopParser": _XML_StopParser,
        "__assert_fail": ___assert_fail,
        "__dlsym": ___dlsym,
        "__syscall__newselect": ___syscall__newselect,
        "__syscall_bind": ___syscall_bind,
        "__syscall_connect": ___syscall_connect,
        "__syscall_faccessat": ___syscall_faccessat,
        "__syscall_fcntl64": ___syscall_fcntl64,
        "__syscall_fstat64": ___syscall_fstat64,
        "__syscall_ftruncate64": ___syscall_ftruncate64,
        "__syscall_getdents64": ___syscall_getdents64,
        "__syscall_getpeername": ___syscall_getpeername,
        "__syscall_getsockopt": ___syscall_getsockopt,
        "__syscall_ioctl": ___syscall_ioctl,
        "__syscall_lstat64": ___syscall_lstat64,
        "__syscall_mkdirat": ___syscall_mkdirat,
        "__syscall_newfstatat": ___syscall_newfstatat,
        "__syscall_openat": ___syscall_openat,
        "__syscall_recvfrom": ___syscall_recvfrom,
        "__syscall_renameat": ___syscall_renameat,
        "__syscall_rmdir": ___syscall_rmdir,
        "__syscall_sendto": ___syscall_sendto,
        "__syscall_socket": ___syscall_socket,
        "__syscall_stat64": ___syscall_stat64,
        "__syscall_unlinkat": ___syscall_unlinkat,
        "__throw_exception_with_stack_trace": ___throw_exception_with_stack_trace,
        "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
        "_localtime_js": __localtime_js,
        "_tzset_js": __tzset_js,
        "abort": _abort,
        "dlopen": _dlopen,
        "duckdb_web_fs_directory_create": _duckdb_web_fs_directory_create,
        "duckdb_web_fs_directory_exists": _duckdb_web_fs_directory_exists,
        "duckdb_web_fs_directory_list_files": _duckdb_web_fs_directory_list_files,
        "duckdb_web_fs_directory_remove": _duckdb_web_fs_directory_remove,
        "duckdb_web_fs_file_close": _duckdb_web_fs_file_close,
        "duckdb_web_fs_file_exists": _duckdb_web_fs_file_exists,
        "duckdb_web_fs_file_get_last_modified_time": _duckdb_web_fs_file_get_last_modified_time,
        "duckdb_web_fs_file_move": _duckdb_web_fs_file_move,
        "duckdb_web_fs_file_open": _duckdb_web_fs_file_open,
        "duckdb_web_fs_file_read": _duckdb_web_fs_file_read,
        "duckdb_web_fs_file_truncate": _duckdb_web_fs_file_truncate,
        "duckdb_web_fs_file_write": _duckdb_web_fs_file_write,
        "duckdb_web_fs_get_default_data_protocol": _duckdb_web_fs_get_default_data_protocol,
        "duckdb_web_fs_glob": _duckdb_web_fs_glob,
        "duckdb_web_test_platform_feature": _duckdb_web_test_platform_feature,
        "duckdb_web_udf_scalar_call": _duckdb_web_udf_scalar_call,
        "emscripten_console_error": _emscripten_console_error,
        "emscripten_date_now": _emscripten_date_now,
        "emscripten_get_heap_max": _emscripten_get_heap_max,
        "emscripten_get_now": _emscripten_get_now,
        "emscripten_memcpy_big": _emscripten_memcpy_big,
        "emscripten_resize_heap": _emscripten_resize_heap,
        "environ_get": _environ_get,
        "environ_sizes_get": _environ_sizes_get,
        "fd_close": _fd_close,
        "fd_fdstat_get": _fd_fdstat_get,
        "fd_pread": _fd_pread,
        "fd_pwrite": _fd_pwrite,
        "fd_read": _fd_read,
        "fd_seek": _fd_seek,
        "fd_sync": _fd_sync,
        "fd_write": _fd_write,
        "getaddrinfo": _getaddrinfo,
        "getentropy": _getentropy,
        "getnameinfo": _getnameinfo,
        "strftime_l": _strftime_l,
        "ucnv_close_64": _ucnv_close_64,
        "ucnv_convertEx_64": _ucnv_convertEx_64,
        "ucnv_open_64": _ucnv_open_64,
        "ucnv_toAlgorithmic_64": _ucnv_toAlgorithmic_64,
        "ucsdet_close_64": _ucsdet_close_64,
        "ucsdet_detect_64": _ucsdet_detect_64,
        "ucsdet_getConfidence_64": _ucsdet_getConfidence_64,
        "ucsdet_getName_64": _ucsdet_getName_64,
        "ucsdet_open_64": _ucsdet_open_64,
        "ucsdet_setText_64": _ucsdet_setText_64,
        "unzClose": _unzClose,
        "unzCloseCurrentFile": _unzCloseCurrentFile,
        "unzGetCurrentFileInfo": _unzGetCurrentFileInfo,
        "unzGetCurrentFileInfo64": _unzGetCurrentFileInfo64,
        "unzGetGlobalInfo": _unzGetGlobalInfo,
        "unzGoToFirstFile": _unzGoToFirstFile,
        "unzGoToNextFile": _unzGoToNextFile,
        "unzLocateFile": _unzLocateFile,
        "unzOpen": _unzOpen,
        "unzOpen2": _unzOpen2,
        "unzOpenCurrentFile": _unzOpenCurrentFile,
        "unzReadCurrentFile": _unzReadCurrentFile
      };
      var asm = createWasm();
      var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
      var _main = Module["_main"] = createExportWrapper("main");
      var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = createExportWrapper("duckdb_web_fs_glob_add_path");
      var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = createExportWrapper("duckdb_web_clear_response");
      var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = createExportWrapper("duckdb_web_fail_with");
      var _duckdb_web_reset = Module["_duckdb_web_reset"] = createExportWrapper("duckdb_web_reset");
      var _duckdb_web_connect = Module["_duckdb_web_connect"] = createExportWrapper("duckdb_web_connect");
      var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = createExportWrapper("duckdb_web_disconnect");
      var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = createExportWrapper("duckdb_web_flush_files");
      var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = createExportWrapper("duckdb_web_flush_file");
      var _duckdb_web_open = Module["_duckdb_web_open"] = createExportWrapper("duckdb_web_open");
      var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = createExportWrapper("duckdb_web_get_global_file_info");
      var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = createExportWrapper("duckdb_web_collect_file_stats");
      var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = createExportWrapper("duckdb_web_export_file_stats");
      var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = createExportWrapper("duckdb_web_fs_drop_file");
      var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = createExportWrapper("duckdb_web_fs_drop_files");
      var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = createExportWrapper("duckdb_web_fs_glob_file_infos");
      var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = createExportWrapper("duckdb_web_fs_get_file_info_by_id");
      var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = createExportWrapper("duckdb_web_fs_get_file_info_by_name");
      var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = createExportWrapper("duckdb_web_fs_register_file_url");
      var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = createExportWrapper("duckdb_web_fs_register_file_buffer");
      var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = createExportWrapper("duckdb_web_copy_file_to_buffer");
      var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = createExportWrapper("duckdb_web_copy_file_to_path");
      var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = createExportWrapper("duckdb_web_get_version");
      var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = createExportWrapper("duckdb_web_get_feature_flags");
      var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = createExportWrapper("duckdb_web_tokenize");
      var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = createExportWrapper("duckdb_web_udf_scalar_create");
      var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = createExportWrapper("duckdb_web_prepared_create");
      var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = createExportWrapper("duckdb_web_prepared_close");
      var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = createExportWrapper("duckdb_web_prepared_run");
      var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = createExportWrapper("duckdb_web_prepared_send");
      var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = createExportWrapper("duckdb_web_query_run");
      var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = createExportWrapper("duckdb_web_pending_query_start");
      var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = createExportWrapper("duckdb_web_pending_query_poll");
      var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = createExportWrapper("duckdb_web_pending_query_cancel");
      var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = createExportWrapper("duckdb_web_query_fetch_results");
      var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = createExportWrapper("duckdb_web_get_tablenames");
      var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = createExportWrapper("duckdb_web_insert_arrow_from_ipc_stream");
      var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = createExportWrapper("duckdb_web_insert_csv_from_path");
      var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = createExportWrapper("duckdb_web_insert_json_from_path");
      var ___errno_location = createExportWrapper("__errno_location");
      var _fflush = Module["_fflush"] = createExportWrapper("fflush");
      var _htonl = createExportWrapper("htonl");
      var _htons = createExportWrapper("htons");
      var _ntohs = createExportWrapper("ntohs");
      var _malloc = Module["_malloc"] = createExportWrapper("malloc");
      var _free = Module["_free"] = createExportWrapper("free");
      var ___trap = function() {
        return (___trap = Module["asm"]["__trap"]).apply(null, arguments);
      };
      var _emscripten_stack_init = function() {
        return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
      };
      var _emscripten_stack_get_free = function() {
        return (_emscripten_stack_get_free = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
      };
      var _emscripten_stack_get_base = function() {
        return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
      };
      var _emscripten_stack_get_end = function() {
        return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
      };
      var stackSave = createExportWrapper("stackSave");
      var stackRestore = createExportWrapper("stackRestore");
      var stackAlloc = createExportWrapper("stackAlloc");
      var _emscripten_stack_get_current = function() {
        return (_emscripten_stack_get_current = Module["asm"]["emscripten_stack_get_current"]).apply(null, arguments);
      };
      var ___cxa_decrement_exception_refcount = Module["___cxa_decrement_exception_refcount"] = createExportWrapper("__cxa_decrement_exception_refcount");
      var ___cxa_increment_exception_refcount = Module["___cxa_increment_exception_refcount"] = createExportWrapper("__cxa_increment_exception_refcount");
      var ___thrown_object_from_unwind_exception = Module["___thrown_object_from_unwind_exception"] = createExportWrapper("__thrown_object_from_unwind_exception");
      var ___get_exception_message = Module["___get_exception_message"] = createExportWrapper("__get_exception_message");
      var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
      var dynCall_iiiiij = Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij");
      var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj");
      var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj");
      var dynCall_viijii = Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii");
      var dynCall_viijji = Module["dynCall_viijji"] = createExportWrapper("dynCall_viijji");
      var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");
      var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");
      var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij");
      var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");
      var dynCall_vjjijij = Module["dynCall_vjjijij"] = createExportWrapper("dynCall_vjjijij");
      var dynCall_vijjji = Module["dynCall_vijjji"] = createExportWrapper("dynCall_vijjji");
      var dynCall_vjjii = Module["dynCall_vjjii"] = createExportWrapper("dynCall_vjjii");
      var dynCall_viiiiiji = Module["dynCall_viiiiiji"] = createExportWrapper("dynCall_viiiiiji");
      var dynCall_jiiiji = Module["dynCall_jiiiji"] = createExportWrapper("dynCall_jiiiji");
      var dynCall_jiiij = Module["dynCall_jiiij"] = createExportWrapper("dynCall_jiiij");
      var dynCall_jijjij = Module["dynCall_jijjij"] = createExportWrapper("dynCall_jijjij");
      var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij");
      var dynCall_vijjj = Module["dynCall_vijjj"] = createExportWrapper("dynCall_vijjj");
      var dynCall_vijj = Module["dynCall_vijj"] = createExportWrapper("dynCall_vijj");
      var dynCall_viijj = Module["dynCall_viijj"] = createExportWrapper("dynCall_viijj");
      var dynCall_jiijii = Module["dynCall_jiijii"] = createExportWrapper("dynCall_jiijii");
      var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");
      var dynCall_viijiiiii = Module["dynCall_viijiiiii"] = createExportWrapper("dynCall_viijiiiii");
      var dynCall_viijiiij = Module["dynCall_viijiiij"] = createExportWrapper("dynCall_viijiiij");
      var dynCall_vijiiiji = Module["dynCall_vijiiiji"] = createExportWrapper("dynCall_vijiiiji");
      var dynCall_viiiij = Module["dynCall_viiiij"] = createExportWrapper("dynCall_viiiij");
      var dynCall_jiiji = Module["dynCall_jiiji"] = createExportWrapper("dynCall_jiiji");
      var dynCall_viiijij = Module["dynCall_viiijij"] = createExportWrapper("dynCall_viiijij");
      var dynCall_viijiij = Module["dynCall_viijiij"] = createExportWrapper("dynCall_viijiij");
      var dynCall_viiiiijj = Module["dynCall_viiiiijj"] = createExportWrapper("dynCall_viiiiijj");
      var dynCall_viiijji = Module["dynCall_viiijji"] = createExportWrapper("dynCall_viiijji");
      var dynCall_vijii = Module["dynCall_vijii"] = createExportWrapper("dynCall_vijii");
      var dynCall_iiiiiji = Module["dynCall_iiiiiji"] = createExportWrapper("dynCall_iiiiiji");
      var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij");
      var dynCall_iiijj = Module["dynCall_iiijj"] = createExportWrapper("dynCall_iiijj");
      var dynCall_iijii = Module["dynCall_iijii"] = createExportWrapper("dynCall_iijii");
      var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");
      var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");
      var dynCall_viijjj = Module["dynCall_viijjj"] = createExportWrapper("dynCall_viijjj");
      var dynCall_viiijj = Module["dynCall_viiijj"] = createExportWrapper("dynCall_viiijj");
      var dynCall_jijj = Module["dynCall_jijj"] = createExportWrapper("dynCall_jijj");
      var dynCall_jiiiii = Module["dynCall_jiiiii"] = createExportWrapper("dynCall_jiiiii");
      var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");
      var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");
      var dynCall_viijij = Module["dynCall_viijij"] = createExportWrapper("dynCall_viijij");
      var dynCall_viiij = Module["dynCall_viiij"] = createExportWrapper("dynCall_viiij");
      var dynCall_j = Module["dynCall_j"] = createExportWrapper("dynCall_j");
      var dynCall_viiijiiiijj = Module["dynCall_viiijiiiijj"] = createExportWrapper("dynCall_viiijiiiijj");
      var dynCall_jiiiij = Module["dynCall_jiiiij"] = createExportWrapper("dynCall_jiiiij");
      var dynCall_jj = Module["dynCall_jj"] = createExportWrapper("dynCall_jj");
      var dynCall_ij = Module["dynCall_ij"] = createExportWrapper("dynCall_ij");
      var dynCall_ijjj = Module["dynCall_ijjj"] = createExportWrapper("dynCall_ijjj");
      var dynCall_jjjd = Module["dynCall_jjjd"] = createExportWrapper("dynCall_jjjd");
      var dynCall_jjjjjjd = Module["dynCall_jjjjjjd"] = createExportWrapper("dynCall_jjjjjjd");
      var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij");
      var dynCall_viiijiiijii = Module["dynCall_viiijiiijii"] = createExportWrapper("dynCall_viiijiiijii");
      var dynCall_viijijiiii = Module["dynCall_viijijiiii"] = createExportWrapper("dynCall_viijijiiii");
      var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji");
      var dynCall_jiiiijj = Module["dynCall_jiiiijj"] = createExportWrapper("dynCall_jiiiijj");
      var dynCall_viiiji = Module["dynCall_viiiji"] = createExportWrapper("dynCall_viiiji");
      var dynCall_viiiiji = Module["dynCall_viiiiji"] = createExportWrapper("dynCall_viiiiji");
      var dynCall_jijiiii = Module["dynCall_jijiiii"] = createExportWrapper("dynCall_jijiiii");
      var dynCall_viiijiji = Module["dynCall_viiijiji"] = createExportWrapper("dynCall_viiijiji");
      var dynCall_viijiji = Module["dynCall_viijiji"] = createExportWrapper("dynCall_viijiji");
      var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");
      Module["stackAlloc"] = stackAlloc;
      Module["stackSave"] = stackSave;
      Module["stackRestore"] = stackRestore;
      Module["ccall"] = ccall;
      var missingLibrarySymbols = ["getHostByName", "traverseStack", "getCallstack", "emscriptenLog", "convertPCtoSourceLocation", "readEmAsmArgs", "jstoi_s", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "HandleAllocator", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "cwrap", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "setMainLoop", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "__glGenObject", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory"];
      missingLibrarySymbols.forEach(missingLibrarySymbol);
      var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "ptrToString", "zeroMemory", "exitJS", "getHeapMax", "emscripten_realloc_buffer", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "UNWIND_CACHE", "readEmAsmArgsArray", "jstoi_q", "getExecutableName", "handleException", "readI53FromI64", "convertI32PairToI53Checked", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToNewUTF8", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "currentFullscreenStrategy", "restoreOldWindowedStyle", "ExitStatus", "getEnvStrings", "flush_NO_FILESYSTEM", "dlopenMissingError", "promiseMap", "getExceptionMessageCommon", "getCppExceptionTag", "getCppExceptionThrownObjectFromWebAssemblyException", "incrementExceptionRefcount", "decrementExceptionRefcount", "getExceptionMessage", "Browser", "wget", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "emscripten_webgl_power_preferences", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "GLFW", "allocateUTF8", "allocateUTF8OnStack", "SOCKFS", "FS"];
      unexportedSymbols.forEach(unexportedRuntimeSymbol);
      var calledRun;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function callMain() {
        assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
        assert(__ATPRERUN__.length == 0, "cannot call main when preRun functions remain to be called");
        var entryFunction = _main;
        var argc = 0;
        var argv = 0;
        try {
          var ret = entryFunction(argc, argv);
          exitJS(ret, true);
          return ret;
        } catch (e) {
          return handleException(e);
        }
      }
      function stackCheckInit() {
        _emscripten_stack_init();
        writeStackCookie();
      }
      function run() {
        if (runDependencies > 0) {
          return;
        }
        stackCheckInit();
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          readyPromiseResolve(Module);
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (shouldRunNow)
            callMain();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
        checkStackCookie();
      }
      function checkUnflushedContent() {
        var oldOut = out;
        var oldErr = err;
        var has = false;
        out = err = (x) => {
          has = true;
        };
        try {
          flush_NO_FILESYSTEM();
        } catch (e) {
        }
        out = oldOut;
        err = oldErr;
        if (has) {
          warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");
          warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");
        }
      }
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"])
        shouldRunNow = false;
      run();
      return DuckDB5.ready;
    };
  })();
  var duckdb_eh_default = DuckDB3;

  // src/bindings/bindings_browser_eh.ts
  var DuckDB4 = class extends DuckDBBrowserBindings {
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime, mainModuleURL, pthreadWorkerURL);
    }
    instantiateImpl(moduleOverrides) {
      return duckdb_eh_default({
        ...moduleOverrides,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/targets/duckdb-browser-blocking.ts
  async function createDuckDB(bundles, logger, runtime) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (bundles.eh) {
        return new DuckDB4(logger, runtime, bundles.eh.mainModule);
      }
    }
    return new DuckDB2(logger, runtime, bundles.mvp.mainModule);
  }

  // src/parallel/async_connection.ts
  var AsyncDuckDBConnection = class {
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    get bindings() {
      return this._bindings;
    }
    async close() {
      return this._bindings.disconnect(this._conn);
    }
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    async query(text) {
      this._bindings.logger.log({
        timestamp: new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      const buffer = await this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync(), "Reader is not sync");
      console.assert(reader.isFile(), "Reader is not file");
      return new Table(reader);
    }
    async send(text) {
      this._bindings.logger.log({
        timestamp: new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      let header = await this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await this._bindings.pollPendingQuery(this._conn);
      }
      const iter = new AsyncResultStreamIterator(this._bindings, this._conn, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
    async cancelSent() {
      return await this._bindings.cancelPendingQuery(this._conn);
    }
    async getTableNames(query) {
      return await this._bindings.getTableNames(this._conn, query);
    }
    async prepare(text) {
      const stmt = await this._bindings.createPrepared(this._conn, text);
      return new AsyncPreparedStatement(this._bindings, this._conn, stmt);
    }
    async insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      await this.insertArrowFromIPCStream(buffer, options);
    }
    async insertArrowFromIPCStream(buffer, options) {
      await this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    async insertCSVFromPath(text, options) {
      await this._bindings.insertCSVFromPath(this._conn, text, options);
    }
    async insertJSONFromPath(text, options) {
      await this._bindings.insertJSONFromPath(this._conn, text, options);
    }
  };
  var AsyncResultStreamIterator = class {
    constructor(db2, conn, header) {
      this.db = db2;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
      this._inFlight = null;
    }
    async next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      let buffer;
      if (this._inFlight != null) {
        buffer = await this._inFlight;
        this._inFlight = null;
      } else {
        buffer = await this.db.fetchQueryResults(this.conn);
      }
      this._depleted = buffer.length == 0;
      if (!this._depleted) {
        this._inFlight = this.db.fetchQueryResults(this.conn);
      }
      return {
        done: this._depleted,
        value: buffer
      };
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var AsyncPreparedStatement = class {
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    async close() {
      await this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    async query(...params) {
      const buffer = await this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    async send(...params) {
      const header = await this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new AsyncResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/parallel/worker_request.ts
  var WorkerTask = class {
    constructor(type, data) {
      this.promiseResolver = () => {
      };
      this.promiseRejecter = () => {
      };
      this.type = type;
      this.data = data;
      this.promise = new Promise(
        (resolve, reject) => {
          this.promiseResolver = resolve;
          this.promiseRejecter = reject;
        }
      );
    }
  };

  // src/parallel/async_bindings.ts
  var TEXT_ENCODER3 = new TextEncoder();
  var AsyncDuckDB = class {
    constructor(logger, worker2 = null) {
      this._onInstantiationProgress = [];
      this._worker = null;
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
      this._nextMessageId = 0;
      this._pendingRequests = /* @__PURE__ */ new Map();
      this._logger = logger;
      this._onMessageHandler = this.onMessage.bind(this);
      this._onErrorHandler = this.onError.bind(this);
      this._onCloseHandler = this.onClose.bind(this);
      if (worker2 != null)
        this.attach(worker2);
    }
    get logger() {
      return this._logger;
    }
    attach(worker2) {
      this._worker = worker2;
      this._worker.addEventListener("message", this._onMessageHandler);
      this._worker.addEventListener("error", this._onErrorHandler);
      this._worker.addEventListener("close", this._onCloseHandler);
      this._workerShutdownPromise = new Promise(
        (resolve, _reject) => {
          this._workerShutdownResolver = resolve;
        }
      );
    }
    detach() {
      if (!this._worker)
        return;
      this._worker.removeEventListener("message", this._onMessageHandler);
      this._worker.removeEventListener("error", this._onErrorHandler);
      this._worker.removeEventListener("close", this._onCloseHandler);
      this._worker = null;
      this._workerShutdownResolver(null);
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    async terminate() {
      if (!this._worker)
        return;
      this._worker.terminate();
      this._worker = null;
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    async postTask(task, transfer = []) {
      if (!this._worker) {
        console.error("cannot send a message since the worker is not set!");
        return void 0;
      }
      const mid = this._nextMessageId++;
      this._pendingRequests.set(mid, task);
      this._worker.postMessage(
        {
          messageId: mid,
          type: task.type,
          data: task.data
        },
        transfer
      );
      return await task.promise;
    }
    onMessage(event) {
      const response = event.data;
      switch (response.type) {
        case "LOG" /* LOG */: {
          this._logger.log(response.data);
          return;
        }
        case "INSTANTIATE_PROGRESS" /* INSTANTIATE_PROGRESS */: {
          for (const p of this._onInstantiationProgress) {
            p(response.data);
          }
          return;
        }
      }
      const task = this._pendingRequests.get(response.requestId);
      if (!task) {
        console.warn(`unassociated response: [${response.requestId}, ${response.type.toString()}]`);
        return;
      }
      this._pendingRequests.delete(response.requestId);
      if (response.type == "ERROR" /* ERROR */) {
        const e = new Error(response.data.message);
        e.name = response.data.name;
        e.stack = response.data.stack;
        task.promiseRejecter(e);
        return;
      }
      switch (task.type) {
        case "CLOSE_PREPARED" /* CLOSE_PREPARED */:
        case "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */:
        case "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */:
        case "DISCONNECT" /* DISCONNECT */:
        case "DROP_FILE" /* DROP_FILE */:
        case "DROP_FILES" /* DROP_FILES */:
        case "FLUSH_FILES" /* FLUSH_FILES */:
        case "INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */:
        case "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */:
        case "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */:
        case "OPEN" /* OPEN */:
        case "PING" /* PING */:
        case "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */:
        case "REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */:
        case "REGISTER_FILE_URL" /* REGISTER_FILE_URL */:
        case "RESET" /* RESET */:
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "INSTANTIATE" /* INSTANTIATE */:
          this._onInstantiationProgress = [];
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */:
          if (response.type == "FILE_INFOS" /* FILE_INFOS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_VERSION" /* GET_VERSION */:
          if (response.type == "VERSION_STRING" /* VERSION_STRING */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */:
          if (response.type == "FEATURE_FLAGS" /* FEATURE_FLAGS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_TABLE_NAMES" /* GET_TABLE_NAMES */:
          if (response.type == "TABLE_NAMES" /* TABLE_NAMES */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "TOKENIZE" /* TOKENIZE */:
          if (response.type == "SCRIPT_TOKENS" /* SCRIPT_TOKENS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */:
          if (response.type == "FILE_BUFFER" /* FILE_BUFFER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */:
          if (response.type == "FILE_STATISTICS" /* FILE_STATISTICS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CONNECT" /* CONNECT */:
          if (response.type == "CONNECTION_INFO" /* CONNECTION_INFO */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "RUN_PREPARED" /* RUN_PREPARED */:
        case "RUN_QUERY" /* RUN_QUERY */:
          if (response.type == "QUERY_RESULT" /* QUERY_RESULT */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "SEND_PREPARED" /* SEND_PREPARED */:
          if (response.type == "QUERY_RESULT_HEADER" /* QUERY_RESULT_HEADER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "START_PENDING_QUERY" /* START_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */:
          this._onInstantiationProgress = [];
          if (response.type == "SUCCESS" /* SUCCESS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */:
          if (response.type == "QUERY_RESULT_CHUNK" /* QUERY_RESULT_CHUNK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CREATE_PREPARED" /* CREATE_PREPARED */:
          if (response.type == "PREPARED_STATEMENT_ID" /* PREPARED_STATEMENT_ID */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
      }
      task.promiseRejecter(new Error(`unexpected response type: ${response.type.toString()}`));
    }
    onError(event) {
      console.error(event);
      console.error(`error in duckdb worker: ${event.message}`);
      this._pendingRequests.clear();
    }
    onClose() {
      this._workerShutdownResolver(null);
      if (this._pendingRequests.size != 0) {
        console.warn(`worker terminated with ${this._pendingRequests.size} pending requests`);
        return;
      }
      this._pendingRequests.clear();
    }
    async reset() {
      const task = new WorkerTask("RESET" /* RESET */, null);
      return await this.postTask(task);
    }
    async ping() {
      const task = new WorkerTask("PING" /* PING */, null);
      await this.postTask(task);
    }
    async dropFile(name) {
      const task = new WorkerTask("DROP_FILE" /* DROP_FILE */, name);
      return await this.postTask(task);
    }
    async dropFiles() {
      const task = new WorkerTask("DROP_FILES" /* DROP_FILES */, null);
      return await this.postTask(task);
    }
    async flushFiles() {
      const task = new WorkerTask("FLUSH_FILES" /* FLUSH_FILES */, null);
      return await this.postTask(task);
    }
    async instantiate(mainModuleURL, pthreadWorkerURL = null, progress = (_p2) => {
    }) {
      this._onInstantiationProgress.push(progress);
      const task = new WorkerTask(
        "INSTANTIATE" /* INSTANTIATE */,
        [mainModuleURL, pthreadWorkerURL]
      );
      return await this.postTask(task);
    }
    async getVersion() {
      const task = new WorkerTask("GET_VERSION" /* GET_VERSION */, null);
      const version = await this.postTask(task);
      return version;
    }
    async getFeatureFlags() {
      const task = new WorkerTask(
        "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */,
        null
      );
      const feature = await this.postTask(task);
      return feature;
    }
    async open(config) {
      const task = new WorkerTask("OPEN" /* OPEN */, config);
      await this.postTask(task);
    }
    async tokenize(text) {
      const task = new WorkerTask("TOKENIZE" /* TOKENIZE */, text);
      const tokens = await this.postTask(task);
      return tokens;
    }
    async connectInternal() {
      const task = new WorkerTask("CONNECT" /* CONNECT */, null);
      return await this.postTask(task);
    }
    async connect() {
      const cid = await this.connectInternal();
      return new AsyncDuckDBConnection(this, cid);
    }
    async disconnect(conn) {
      const task = new WorkerTask(
        "DISCONNECT" /* DISCONNECT */,
        conn
      );
      await this.postTask(task);
    }
    async runQuery(conn, text) {
      const task = new WorkerTask(
        "RUN_QUERY" /* RUN_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async startPendingQuery(conn, text) {
      const task = new WorkerTask(
        "START_PENDING_QUERY" /* START_PENDING_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async pollPendingQuery(conn) {
      const task = new WorkerTask(
        "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    async cancelPendingQuery(conn) {
      const task = new WorkerTask(
        "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    async fetchQueryResults(conn) {
      const task = new WorkerTask(
        "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */,
        conn
      );
      return await this.postTask(task);
    }
    async getTableNames(conn, text) {
      const task = new WorkerTask(
        "GET_TABLE_NAMES" /* GET_TABLE_NAMES */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async createPrepared(conn, text) {
      const task = new WorkerTask(
        "CREATE_PREPARED" /* CREATE_PREPARED */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async closePrepared(conn, statement) {
      const task = new WorkerTask(
        "CLOSE_PREPARED" /* CLOSE_PREPARED */,
        [conn, statement]
      );
      await this.postTask(task);
    }
    async runPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "RUN_PREPARED" /* RUN_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    async sendPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "SEND_PREPARED" /* SEND_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    async globFiles(path) {
      const task = new WorkerTask(
        "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */,
        path
      );
      return await this.postTask(task);
    }
    async registerFileText(name, text) {
      const buffer = TEXT_ENCODER3.encode(text);
      await this.registerFileBuffer(name, buffer);
    }
    async registerFileURL(name, url, proto, directIO) {
      if (url === void 0) {
        url = name;
      }
      const task = new WorkerTask("REGISTER_FILE_URL" /* REGISTER_FILE_URL */, [name, url, proto, directIO]);
      await this.postTask(task);
    }
    async registerEmptyFileBuffer(name) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name, new Uint8Array()]
      );
      await this.postTask(task);
    }
    async registerFileBuffer(name, buffer) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name, buffer]
      );
      await this.postTask(task, [buffer.buffer]);
    }
    async registerFileHandle(name, handle, protocol, directIO) {
      const task = new WorkerTask("REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */, [name, handle, protocol, directIO]);
      await this.postTask(task, []);
    }
    async collectFileStatistics(name, enable) {
      const task = new WorkerTask(
        "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */,
        [name, enable]
      );
      await this.postTask(task, []);
    }
    async exportFileStatistics(name) {
      const task = new WorkerTask(
        "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */,
        name
      );
      return await this.postTask(task, []);
    }
    async copyFileToBuffer(name) {
      const task = new WorkerTask(
        "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */,
        name
      );
      return await this.postTask(task);
    }
    async copyFileToPath(name, path) {
      const task = new WorkerTask(
        "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */,
        [name, path]
      );
      await this.postTask(task);
    }
    async insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const task = new WorkerTask("INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */, [conn, buffer, options]);
      await this.postTask(task, [buffer.buffer]);
    }
    async insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
    async insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
  };

  // src/worker.ts
  var import_web_worker = __toESM(require_browser());
  async function createWorker(url) {
    const request = new Request(url);
    const workerScript = await fetch(request);
    const workerURL = URL.createObjectURL(await workerScript.blob());
    return new import_web_worker.default(workerURL);
  }

  // test/all_types.test.ts
  var MINIMUM_DATE_STR = "-271821-04-20";
  var MINIMUM_DATE = new Date(Date.UTC(-271821, 3, 20));
  var MAXIMUM_DATE_STR = "275760-09-13";
  var MAXIMUM_DATE = new Date(Date.UTC(275760, 8, 13));
  var NOT_IMPLEMENTED_TYPES = [
    "timestamp_s",
    "timestamp_ms",
    "timestamp_ns",
    "timestamp_tz",
    "hugeint",
    "dec_18_6",
    "dec38_10",
    "uuid",
    "map",
    "json",
    "date_array",
    "timestamp_array",
    "timestamptz_array"
  ];
  var PARTIALLY_IMPLEMENTED_TYPES = ["date", "timestamp"];
  var PARTIALLY_IMPLEMENTED_ANSWER_MAP = {
    date: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null],
    timestamp: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null]
  };
  var PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS = [
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Date,'${MAXIMUM_DATE_STR}'::Date,null],i + 1)) as date`,
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Timestamp,'${MAXIMUM_DATE_STR}'::Timestamp,null],i + 1)) as timestamp`
  ];
  var TYPES_REQUIRING_CUSTOM_CONFIG = ["dec_4_1", "dec_9_4"];
  var FULLY_IMPLEMENTED_ANSWER_MAP = {
    bool: [false, true, null],
    tinyint: [-128, 127, null],
    smallint: [-32768, 32767, null],
    int: [-2147483648, 2147483647, null],
    utinyint: [0, 255, null],
    usmallint: [0, 65535, null],
    uint: [0, 4294967295, null],
    ubigint: [BigInt(0), BigInt("18446744073709551615"), null],
    bigint: [BigInt("-9223372036854775808"), BigInt("9223372036854775807"), null],
    time: [BigInt(0), BigInt(new Date("1970-01-01T23:59:59.999+00:00").valueOf()) * BigInt(1e3) + BigInt(999), null],
    time_tz: [
      BigInt(0),
      BigInt(new Date("1970-01-01T23:59:59.999+00:00").valueOf()) * BigInt(1e3) + BigInt(999),
      null
    ],
    interval: [new Int32Array([0, 0]), new Int32Array([0, 0]), null],
    float: [-34028234663852886e22, 34028234663852886e22, null],
    double: [-17976931348623157e292, 17976931348623157e292, null],
    varchar: ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goo\0se", null],
    small_enum: ["DUCK_DUCK_ENUM", "GOOSE", null],
    medium_enum: ["enum_0", "enum_299", null],
    large_enum: ["enum_0", "enum_69999", null],
    int_array: [[], [42, 999, null, null, -42], null],
    double_array: [[], [42, NaN, Infinity, -Infinity, null, -42], null],
    varchar_array: [[], ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goose", null, ""], null],
    nested_int_array: [[], [[], [42, 999, null, null, -42], null, [], [42, 999, null, null, -42]], null],
    struct: ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null],
    struct_of_arrays: [
      '{"a":null,"b":null}',
      '{"a":[42,999,null,null,-42],"b":["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}","goose",null,""]}',
      null
    ],
    array_of_structs: [[], ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null], null],
    blob: [
      Uint8Array.from([
        116,
        104,
        105,
        115,
        105,
        115,
        97,
        108,
        111,
        110,
        103,
        98,
        108,
        111,
        98,
        0,
        119,
        105,
        116,
        104,
        110,
        117,
        108,
        108,
        98,
        121,
        116,
        101,
        115
      ]),
      Uint8Array.from([0, 0, 0, 97]),
      null
    ]
  };
  var REPLACE_COLUMNS = PARTIALLY_IMPLEMENTED_TYPES.concat(NOT_IMPLEMENTED_TYPES).concat(TYPES_REQUIRING_CUSTOM_CONFIG);
  function unpack(v) {
    if (v === null)
      return null;
    if (v instanceof Vector) {
      const ret = Array.from(v.toArray());
      for (let i = 0; i < ret.length; i++) {
        if (!v.isValid(i)) {
          ret[i] = null;
        }
      }
      return unpack(ret);
    } else if (v instanceof Array) {
      const ret = [];
      for (let i = 0; i < v.length; i++) {
        ret[i] = unpack(v[i]);
      }
      return ret;
    } else if (v instanceof Uint8Array) {
      return v;
    } else if (v.toJSON instanceof Function) {
      return JSON.stringify(v.toJSON());
    }
    return v;
  }
  function getValue(x) {
    if (typeof x?.valueOf === "function") {
      return x.valueOf();
    } else {
      return x;
    }
  }
  var ALL_TYPES_TEST = [
    {
      name: "fully supported types",
      query: `SELECT * REPLACE('not_implemented' as map) FROM test_all_types()`,
      skip: REPLACE_COLUMNS,
      answerMap: FULLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: REPLACE_COLUMNS.length + Object.keys(FULLY_IMPLEMENTED_ANSWER_MAP).length,
      queryConfig: null
    },
    {
      name: "partially supported types",
      query: `SELECT ${PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS.join(", ")}
                FROM range(0, 3) tbl(i)`,
      skip: [],
      answerMap: PARTIALLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: PARTIALLY_IMPLEMENTED_TYPES.length,
      queryConfig: null
    },
    {
      name: "types with custom config",
      query: `SELECT ${TYPES_REQUIRING_CUSTOM_CONFIG.join(",")} FROM test_all_types()`,
      skip: [],
      answerMap: {
        dec_4_1: [-999.9000000000001, 999.9000000000001, null],
        dec_9_4: [-99999.99990000001, 99999.99990000001, null]
      },
      answerCount: TYPES_REQUIRING_CUSTOM_CONFIG.length,
      queryConfig: {
        castDecimalToDouble: true
      }
    }
  ];
  function testAllTypes(db2) {
    let conn;
    beforeEach(() => {
      db2().flushFiles();
    });
    afterEach(() => {
      if (conn) {
        conn.close();
        conn = null;
      }
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Test All Types", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = db2().connect();
          const results = conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s of test.skip) {
            skip.set(s, true);
          }
          for (let i = 0; i < results.numCols; i++) {
            const name = results.schema.fields[i].name;
            if (name == "bit")
              continue;
            const col = results.getChildAt(i);
            if (skip.get(name))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(unpack(getValue(col.get(0)))).withContext(name).toEqual(test.answerMap[name][0]);
            expect(unpack(getValue(col.get(1)))).withContext(name).toEqual(test.answerMap[name][1]);
            expect(col.get(2)).withContext(name).toEqual(test.answerMap[name][2]);
          }
        });
      }
    });
  }
  function testAllTypesAsync(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Test All Types Async", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, async () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = await db2().connect();
          const results = await conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s of test.skip) {
            skip.set(s, true);
          }
          for (let i = 0; i < results.numCols; i++) {
            const name = results.schema.fields[i].name;
            if (name == "bit")
              continue;
            const col = results.getChildAt(i);
            if (skip.get(name))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(Object.keys(test.answerMap)).toContain(name);
            expect(unpack(getValue(col.get(0)))).withContext(name + "|" + col?.toString() + "|[0]").toEqual(test.answerMap[name][0]);
            expect(unpack(getValue(col.get(1)))).withContext(name + "|" + col?.toString() + "|[1]").toEqual(test.answerMap[name][1]);
            expect(col.get(2)).withContext(name + "|" + col?.toString() + "|[2]").toEqual(test.answerMap[name][2]);
          }
        });
      }
    });
  }

  // test/httpfs_test.ts
  var BUCKET_NAME = "test-bucket";
  var ACCESS_KEY_ID = "S3RVER";
  var ACCESS_KEY_SECRET = "S3RVER";
  var S3_ENDPOINT = "http://localhost:4923";
  var S3_REGION = "eu-west-1";
  var setAwsConfig = async function(conn, type = 1 /* VALID */) {
    switch (type) {
      case 0 /* EMPTY */:
        await conn.query("SET s3_region='';");
        await conn.query("SET s3_access_key_id='';");
        await conn.query("SET s3_secret_access_key='';");
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 1 /* VALID */:
        await conn.query(`SET s3_region='${S3_REGION}';`);
        await conn.query(`SET s3_access_key_id='${ACCESS_KEY_ID}';`);
        await conn.query(`SET s3_secret_access_key='${ACCESS_KEY_SECRET}';`);
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 2 /* INVALID */:
        await conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        await conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        await conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        await conn.query("SET s3_session_token='INVALIDSESSIONTOKEN';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
    }
  };
  function testHTTPFS(sdb) {
    let conn;
    const getModule = function() {
      let module2 = null;
      conn.useUnsafe((bindings, con_number) => {
        module2 = bindings.mod;
      });
      expect(module2).toBeDefined();
      return module2;
    };
    const reset = async () => {
      sdb().reset();
      conn = sdb().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS", () => {
      it("s3 config is set correctly", async () => {
        const module2 = getModule();
        const globalFileInfo = runtime_browser_default.getGlobalFileInfo(module2);
        const cacheEpoch = globalFileInfo.cacheEpoch;
        expect(globalFileInfo?.s3Config).toBeDefined();
        expect(globalFileInfo?.s3Config?.region).toEqual("");
        expect(globalFileInfo?.s3Config?.accessKeyId).toEqual("");
        expect(globalFileInfo?.s3Config?.secretAccessKey).toEqual("");
        expect(globalFileInfo?.s3Config?.sessionToken).toEqual("");
        expect(globalFileInfo?.s3Config?.endpoint).toEqual("");
        conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        conn.query("SET s3_session_token='ANICESESSIONTOKEN';");
        conn.query("SET s3_endpoint='s3.some.sort.of.cloud';");
        const globalFileInfoUpdated = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoUpdated?.s3Config).toBeDefined();
        expect(globalFileInfoUpdated?.cacheEpoch).toEqual(cacheEpoch + 5);
        const params = getS3Params(globalFileInfoUpdated?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(params.url).toEqual("/testfile.txt");
        expect(params.query).toEqual("");
        expect(params.host).toEqual("test-bucket.s3.some.sort.of.cloud");
        expect(params.region).toEqual("a-very-remote-and-non-existent-s3-region");
        expect(params.service).toEqual("s3");
        expect(params.method).toEqual("GET");
        expect(params.accessKeyId).toEqual("THISACCESSKEYIDISNOTVALID");
        expect(params.secretAccessKey).toEqual("THISSECRETACCESSKEYISNOTVALID");
        expect(params.sessionToken).toEqual("ANICESESSIONTOKEN");
        conn.query("SET s3_endpoint='http://localhost:1337';");
        const globalFileInfoFullHttpEndpoint = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsFullHttpEndpoint = getS3Params(
          globalFileInfoFullHttpEndpoint?.s3Config,
          "s3://test-bucket/testfile.txt",
          "GET"
        );
        expect(paramsFullHttpEndpoint.host).toEqual("localhost:1337");
        await reset();
        const globalFileInfoCleared = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsCleared = getS3Params(globalFileInfoCleared?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(paramsCleared.url).toEqual("/testfile.txt");
        expect(paramsCleared.query).toEqual("");
        expect(paramsCleared.host).toEqual("test-bucket.s3.amazonaws.com");
        expect(paramsCleared.region).toEqual("");
        expect(paramsCleared.service).toEqual("s3");
        expect(paramsCleared.method).toEqual("GET");
        expect(paramsCleared.accessKeyId).toEqual("");
        expect(paramsCleared.secretAccessKey).toEqual("");
        expect(paramsCleared.sessionToken).toEqual("");
      });
      it("url parsing is correct", () => {
        const module2 = getModule();
        conn.query("SET s3_endpoint='';");
        const globalFileInfoDefault = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDefault?.s3Config).toBeDefined();
        const defaultUrl = getHTTPUrl(globalFileInfoDefault?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(defaultUrl).toEqual(`https://${BUCKET_NAME}.s3.amazonaws.com/test-file.csv`);
        conn.query("SET s3_endpoint='https://duckdblabs.com';");
        const globalFileInfoFullUrl = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoFullUrl?.s3Config).toBeDefined();
        const fullUrl = getHTTPUrl(globalFileInfoFullUrl?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(fullUrl).toEqual(`https://duckdblabs.com/${BUCKET_NAME}/test-file.csv`);
        conn.query("SET s3_endpoint='duckdblabs.com';");
        const globalFileInfoDomain = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDomain?.s3Config).toBeDefined();
        const domainOnlyUrl = getHTTPUrl(globalFileInfoDomain?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(domainOnlyUrl).toEqual(`https://${BUCKET_NAME}.duckdblabs.com/test-file.csv`);
      });
      it("s3 helper passes validation", () => {
        const testParams1 = {
          url: "/",
          query: "",
          host: "my-precious-bucket.s3.amazonaws.com",
          region: "us-east-1",
          service: "s3",
          method: "GET",
          accessKeyId: "AKIAIOSFODNN7EXAMPLE",
          secretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
          sessionToken: "",
          dateNow: "20150915",
          datetimeNow: "20150915T124500Z"
        };
        const result = createS3Headers(testParams1).get("Authorization");
        expect(result).toEqual(
          "AWS4-HMAC-SHA256 Credential=AKIAIOSFODNN7EXAMPLE/20150915/us-east-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=182072eb53d85c36b2d791a1fa46a12d23454ec1e921b02075c23aee40166d5a"
        );
        const canonical_query_string = "delimiter=%2F&encoding-type=url&list-type=2&prefix=";
        const testParams2 = {
          url: "/",
          query: canonical_query_string,
          host: "my-precious-bucket.s3.eu-west-1.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "GET",
          accessKeyId: "ASIAYSPIOYDTHTBIITVC",
          secretAccessKey: "vs1BZPxSL2qVARBSg5vCMKJsavCoEPlo/HSHRaVe",
          sessionToken: "IQoJb3JpZ2luX2VjENX//////////wEaCWV1LXdlc3QtMSJHMEUCIQDfjzs9BYHrEXDMU/NR+PHV1uSTr7CSVSQdjKSfiPRLdgIgCCztF0VMbi9+uHHAfBVKhV4t9MlUrQg3VAOIsLxrWyoqlAIIHRAAGgw1ODk0MzQ4OTY2MTQiDOGl2DsYxENcKCbh+irxARe91faI+hwUhT60sMGRFg0GWefKnPclH4uRFzczrDOcJlAAaQRJ7KOsT8BrJlrY1jSgjkO7PkVjPp92vi6lJX77bg99MkUTJActiOKmd84XvAE5bFc/jFbqechtBjXzopAPkKsGuaqAhCenXnFt6cwq+LZikv/NJGVw7TRphLV+Aq9PSL9XwdzIgsW2qXwe1c3rxDNj53yStRZHVggdxJ0OgHx5v040c98gFphzSULHyg0OY6wmCMTYcswpb4kO2IIi6AiD9cY25TlwPKRKPi5CdBsTPnyTeW62u7PvwK0fTSy4ZuJUuGKQnH2cKmCXquEwoOHEiQY6nQH9fzY/EDGHMRxWWhxu0HiqIfsuFqC7GS0p0ToKQE+pzNsvVwMjZc+KILIDDQpdCWRIwu53I5PZy2Cvk+3y4XLvdZKQCsAKqeOc4c94UAS4NmUT7mCDOuRV0cLBVM8F0JYBGrUxyI+YoIvHhQWmnRLuKgTb5PkF7ZWrXBHFWG5/tZDOvBbbaCWTlRCL9b0Vpg5+BM/81xd8jChP4w83",
          dateNow: "20210904",
          datetimeNow: "20210904T121746Z"
        };
        const result2 = createS3Headers(testParams2).get("Authorization");
        expect(result2).toEqual(
          "AWS4-HMAC-SHA256 Credential=ASIAYSPIOYDTHTBIITVC/20210904/eu-west-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date;x-amz-security-token, Signature=4d9d6b59d7836b6485f6ad822de97be40287da30347d83042ea7fbed530dc4c0"
        );
        const testParams3 = {
          url: "/correct_auth_test.csv",
          query: "",
          host: "test-bucket-ceiveran.s3.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "PUT",
          accessKeyId: "S3RVER",
          secretAccessKey: "S3RVER",
          sessionToken: "",
          dateNow: "20220121",
          datetimeNow: "20220121T141452Z"
        };
        const test3PayloadParams = {
          contentHash: "28a0cf6ac5c4cb73793091fe6ecc6a68bf90855ac9186158748158f50241bb0c",
          contentType: "text/data;charset=utf-8"
        };
        const result3 = createS3Headers(testParams3, test3PayloadParams).get("Authorization");
        expect(result3).toEqual(
          "AWS4-HMAC-SHA256 Credential=S3RVER/20220121/eu-west-1/s3/aws4_request, SignedHeaders=content-type;host;x-amz-content-sha256;x-amz-date, Signature=5d9a6cbfaa78a6d0f2ab7df0445e2f1cc9c80cd3655ac7de9e7219c036f23f02"
        );
        expect(uriEncode("/category=Books/")).toEqual("/category%3DBooks/");
        expect(uriEncode("/?category=Books&title=Ducks Retreat/")).toEqual(
          "/%3Fcategory%3DBooks%26title%3DDucks%20Retreat/"
        );
        expect(uriEncode("/?category=Books&title=Ducks Retreat/", true)).toEqual(
          "%2F%3Fcategory%3DBooks%26title%3DDucks%20Retreat%2F"
        );
      });
    });
  }
  function testHTTPFSAsync(adb2, resolveData2, baseDir) {
    let conn;
    const putTestFileToS3 = async function(fileName, format, test_data) {
      await adb2().registerFileBuffer("test_file.parquet", test_data);
      if (!conn) {
        conn = await adb2().connect();
      }
      await setAwsConfig(conn, 1 /* VALID */);
      await conn.query(`CREATE TABLE test_table AS (SELECT * FROM parquet_scan('test_file.parquet'));`);
      await conn.query(`COPY test_table TO 's3://${BUCKET_NAME}/${fileName}.${format}' (FORMAT '${format}');`);
      await adb2().flushFiles();
      await adb2().dropFiles();
    };
    const assertTestFileResultCorrect = async function(result, test_data) {
      await adb2().registerFileBuffer("test_file_baseline.parquet", test_data);
      await conn.query(`SELECT * FROM parquet_scan('test_file_baseline.parquet');`);
    };
    const reset = async () => {
      await adb2().reset();
      conn = await adb2().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS Async", () => {
      it("can fetch https file", async () => {
        const results = await conn.query(
          `select * from "https://raw.githubusercontent.com/duckdb/duckdb-wasm/master/data/test.csv";`
        );
        expect(BigInt(results.getChildAt(2)?.get(2))).toEqual(BigInt(9n));
      });
      it("can read and write csv file from S3 with correct auth credentials", async () => {
        let data = await resolveData2("/uni/studenten.parquet");
        await setAwsConfig(conn);
        await putTestFileToS3("correct_auth_test", "csv", data);
        const results_with_auth = await conn.query(`select * from "s3://${BUCKET_NAME}/correct_auth_test.csv";`);
        data = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data);
      });
      it("can read and write parquet file from S3 with correct auth credentials", async () => {
        let data = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("correct_auth_test", "parquet", data);
        await setAwsConfig(conn);
        const results_with_auth = await conn.query(
          `select * from "s3://${BUCKET_NAME}/correct_auth_test.parquet";`
        );
        data = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data);
      });
      it("can not read a file with incorrect credentials", async () => {
        const data = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("incorrect_auth_test", "parquet", data);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select * from "s3://${BUCKET_NAME}/incorrect_auth_test.csv";`)
        ).toBeRejected();
      });
      it("properly invalidates file caches on settings update.", async () => {
        const data = await resolveData2("/tpch/0_01/parquet/lineitem.parquet");
        await putTestFileToS3("file_cache_invalidation_test", "parquet", data);
        await setAwsConfig(conn);
        const results_correct = await conn.query(
          `select l_partkey from "s3://${BUCKET_NAME}/file_cache_invalidation_test.parquet" limit 1;`
        );
        expect(results_correct.getChildAt(0)?.get(0)).toEqual(1552);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select avg(l_partkey) from "s3://${BUCKET_NAME}/lineitem.parquet";`)
        ).toBeRejected();
      });
      it("write after read throws incorrect flag error without dropping files", async () => {
        await setAwsConfig(conn);
        await conn.query(
          `COPY (SELECT * FROM range(1000,1010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
        );
        const result = await conn.query(`SELECT * FROM "s3://${BUCKET_NAME}/test_written.csv";`);
        expect(Number(result.getChildAt(0)?.get(6))).toEqual(Number(1006));
        await expectAsync(
          conn.query(
            `COPY (SELECT * FROM range(2000,2010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
          )
        ).toBeRejectedWithError("Invalid Error: File is not opened in write mode");
      });
    });
  }

  // test/bindings.test.ts
  function testBindings(db2, baseURL2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("DuckDBBindings", () => {
      describe("error handling", () => {
        it("INVALID SQL", async () => {
          let error = null;
          try {
            await conn.send("INVALID");
          } catch (e) {
            error = e;
          }
          expect(error).not.toBe(null);
        });
      });
      describe("Check version", () => {
        it("Version check", async () => {
          await db2().reset();
          conn = db2().connect();
          const version = conn.query(
            "select * from (select version()) where version() != 'v0.0.1-dev0';"
          );
          const rows = version.toArray();
          expect(rows.length).toEqual(1);
          await db2().reset();
        });
      });
      describe("Reset", () => {
        it("table must disappear", async () => {
          await db2().reset();
          conn = db2().connect();
          conn.query("CREATE TABLE foo (a int)");
          let table = conn.query("PRAGMA show_tables;");
          let rows = table.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0]?.name).toEqual("foo");
          await db2().reset();
          conn = db2().connect();
          table = conn.query("PRAGMA show_tables;");
          rows = table.toArray();
          expect(rows.length).toEqual(0);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const result = stmt.query(234);
          expect(result.numRows).toBe(10001);
          stmt.close();
        });
        it("Streaming", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = stmt.send(234);
          let size = 0;
          for (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          conn.close();
        });
        it("Typecheck", async () => {
          conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          expect(
            () => stmt.query(true, 100, 1e4, 1e6, 5e9, 0.5, Math.PI, "hello world", "hi")
          ).not.toThrow();
          expect(
            () => stmt.query(
              "test",
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              1e4,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e6,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e4,
              5e9,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          conn.close();
        });
      });
    });
  }
  function testAsyncBindings(adb2, baseURL2, baseDirProto) {
    beforeEach(async () => {
    });
    afterEach(async () => {
      await adb2().flushFiles();
      await adb2().dropFiles();
      await adb2().open({
        path: ":memory:"
      });
    });
    describe("Bindings", () => {
      describe("Open", () => {
        it("Remote TPCH 0_01", async () => {
          await adb2().registerFileURL("tpch_0_01.db", `${baseURL2}/tpch/0_01/duckdb/db`, baseDirProto, false);
          await adb2().open({
            path: "tpch_0_01.db"
          });
          const conn = await adb2().connect();
          const table = await conn.query("select count(*)::INTEGER as a from lineitem");
          const rows = table.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0]?.a).toEqual(60175);
        });
      });
      describe("Patching", () => {
        it("Count(*) Default", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: false
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Int);
        });
        it("Count(*) No BigInt", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: true
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Float);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v + ? FROM generate_series(0, 10000) as t(v);");
          const result = await stmt.query(234);
          expect(result.numRows).toBe(10001);
          await stmt.close();
        });
        it("Streaming", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = await stmt.send(234);
          let size = 0;
          for await (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          await conn.close();
        });
        it("Typecheck", async () => {
          const conn = await adb2().connect();
          await conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = await conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          const expectToThrow = async (fn) => {
            let throwed = false;
            try {
              await fn();
            } catch (e) {
              throwed = true;
            }
            expect(throwed).toBe(true);
          };
          expectToThrow(async () => {
            await stmt.query(
              "test",
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              1e4,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e6,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e4,
              5e9,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          await conn.close();
        });
      });
      describe("AccessMode", () => {
        it("READ_ONLY", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 2 /* READ_ONLY */
            })
          ).toBeRejectedWithError(/Cannot launch in-memory database in read-only mode/);
        });
        it("READ_WRITE", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 3 /* READ_WRITE */
            })
          ).toBeResolved();
        });
      });
      describe("Cancellation", () => {
        it("hello cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeTrue();
          let polledHeader = null;
          let polledError = null;
          try {
            polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).toBeNull();
          expect(polledError).not.toBeNull();
          expect(polledError.toString()).toEqual("Error: query was canceled");
          const canceledAgain = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(canceledAgain).toBeFalse();
          const table = await conn.query("select 42::integer;");
          expect(table.schema.fields.length).toEqual(1);
        });
        it("noop cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          let polledHeader = null;
          let polledError = null;
          try {
            while (polledHeader == null) {
              polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
            }
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).not.toBeNull();
          expect(polledError).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeFalse();
          const anotherOne = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(anotherOne).toBeFalse();
        });
      });
    });
  }

  // test/batch_stream.test.ts
  var testRows = 1e4;
  function testBatchStream(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++);
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i++));
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++);
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i++));
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
  }

  // test/batch_stream_async.test.ts
  var testRows2 = 1e4;
  function testAsyncBatchStream(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("AsyncDuckDB", () => {
      it("ping", async () => {
        await db2().ping();
      });
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
      describe("scripts", () => {
        it("test1", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS x, (sin(v) * 100 + 100)::INTEGER AS y FROM generate_series(0, ${testRows2}) as t(v)
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(2);
            for (const row of batch) {
              expect(row.x).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
  }

  // test/filesystem.test.ts
  var decoder2 = new TextDecoder();
  function testFilesystem(db2, resolveData2, baseDir, baseDirProto) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("File buffer registration", () => {
      const test = async () => {
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      };
      it("File buffer used once", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
      });
      it("File buffer registered twice", async () => {
        const students0 = await resolveData2("/uni/studenten.parquet");
        const students1 = await resolveData2("/uni/studenten.parquet");
        expect(students0).not.toBeNull();
        expect(students1).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students0);
        await test();
        await db2().registerFileBuffer("studenten.parquet", students1);
        await test();
      });
      it("File buffer used twice", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
        await test();
      });
    });
    describe("Parquet Scans", () => {
      it("single table from buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("simple join", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        const hoeren = await resolveData2("/uni/hoeren.parquet");
        const vorlesungen = await resolveData2("/uni/vorlesungen.parquet");
        expect(students).not.toBeNull();
        expect(hoeren).not.toBeNull();
        expect(vorlesungen).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerFileBuffer("hoeren.parquet", hoeren);
        await db2().registerFileBuffer("vorlesungen.parquet", vorlesungen);
        const result = await conn.send(`
                    SELECT students.matrnr, vorlesungen.titel
                    FROM parquet_scan('studenten.parquet') students
                    INNER JOIN parquet_scan('hoeren.parquet') hoeren ON (students.matrnr = hoeren.matrnr)
                    INNER JOIN parquet_scan('vorlesungen.parquet') vorlesungen ON (vorlesungen.vorlnr = hoeren.vorlnr);
                `);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.numCols).toBe(2);
        const flat = [];
        for (const row of table) {
          flat.push({
            matrnr: row?.matrnr,
            titel: row?.titel?.toString()
          });
        }
        expect(flat).toEqual([
          { matrnr: 26120, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Logik" },
          { matrnr: 28106, titel: "Ethik" },
          { matrnr: 28106, titel: "Wissenschaftstheorie" },
          { matrnr: 28106, titel: "Bioethik" },
          { matrnr: 28106, titel: "Der Wiener Kreis" },
          { matrnr: 29120, titel: "Grundz\xFCge" },
          { matrnr: 29120, titel: "Ethik" },
          { matrnr: 29120, titel: "M\xE4eutik" },
          { matrnr: 29555, titel: "Glaube und Wissen" },
          { matrnr: 25403, titel: "Glaube und Wissen" }
        ]);
      });
    });
    describe("Writing", () => {
      it("Copy To CSV Buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students.csv");
        await conn.query(`CREATE TABLE students AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students TO 'students.csv' WITH (HEADER 1, DELIMITER ';', FORMAT CSV);`);
        await conn.query(`DROP TABLE IF EXISTS students`);
        const outBuffer = await db2().copyFileToBuffer("students.csv");
        expect(outBuffer).not.toBeNull();
        const text = decoder2.decode(outBuffer);
        expect(text).toBe(`matrnr;name;semester
24002;Xenokrates;18
25403;Jonas;12
26120;Fichte;10
26830;Aristoxenos;8
27550;Schopenhauer;6
28106;Carnap;3
29120;Theophrastos;2
29555;Feuerbach;2
`);
      });
      it("Copy To Parquet", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students2.parquet");
        await conn.query(`CREATE TABLE students2 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students2 TO 'students2.parquet' (FORMAT PARQUET);`);
        const url = await db2().copyFileToBuffer("students2.parquet");
        expect(url).not.toBeNull();
      });
      it("Copy To Parquet And Load Again", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students3.parquet");
        await conn.query(`CREATE TABLE students3 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students3 TO 'students3.parquet' (FORMAT PARQUET);`);
        const url = await db2().copyFileToBuffer("students3.parquet");
        expect(url).not.toBeNull();
        await conn.query(`CREATE TABLE students4 AS SELECT * FROM parquet_scan('students3.parquet');`);
        const result = await conn.send(`SELECT matrnr FROM students4;`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
    });
    describe("File access", () => {
      it("Small Parquet file", async () => {
        await db2().registerFileURL("studenten.parquet", `${baseDir}/uni/studenten.parquet`, baseDirProto, true);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("Large Parquet file", async () => {
        await db2().registerFileURL(
          "lineitem.parquet",
          `${baseDir}/tpch/0_01/parquet/lineitem.parquet`,
          baseDirProto,
          true
        );
        const result = await conn.send(`SELECT count(*)::INTEGER as cnt FROM parquet_scan('lineitem.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.get(0)).toBeGreaterThan(6e4);
      });
    });
    describe("Export", () => {
      it("Generate Series as CSV", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportcsv'`);
        const results = await db2().globFiles("/tmp/duckdbexportcsv/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportcsv/foo.csv",
          "/tmp/duckdbexportcsv/load.sql",
          "/tmp/duckdbexportcsv/schema.sql"
        ]);
        const csv_buffer_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/foo.csv");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(csv_buffer_utf8.length).not.toEqual(0);
        const load_script = decoder2.decode(load_script_utf8);
        const schema_script = decoder2.decode(schema_script_utf8);
        const csv_buffer = decoder2.decode(csv_buffer_utf8);
        expect(load_script.trim()).toEqual(
          `COPY foo FROM '/tmp/duckdbexportcsv/foo.csv' (FORMAT 'csv', quote '"', delimiter ',', header 0);`
        );
        expect(schema_script.trim()).toEqual(`CREATE TABLE foo(v BIGINT);`);
        expect(csv_buffer.trim()).toEqual(`1
2
3
4
5`);
      });
      it("Generate Series as Parquet", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportparquet' (FORMAT PARQUET)`);
        const results = await db2().globFiles("/tmp/duckdbexportparquet/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportparquet/foo.parquet",
          "/tmp/duckdbexportparquet/load.sql",
          "/tmp/duckdbexportparquet/schema.sql"
        ]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/foo.parquet");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(
          `SELECT v::integer FROM parquet_scan('/tmp/duckdbexportparquet/foo.parquet')`
        );
        expect(content.nullCount).toEqual(0);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
    describe("Copy", () => {
      it("Generate Series as Parquet", async () => {
        await conn.query(
          `COPY (SELECT * FROM generate_series(1, 5) t(v)) TO '/tmp/duckdbcopytest.parquet' (FORMAT 'parquet')`
        );
        const results = await db2().globFiles("/tmp/duckdbcopytest*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(1);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual(["/tmp/duckdbcopytest.parquet"]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbcopytest.parquet");
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(`SELECT v::integer FROM parquet_scan('/tmp/duckdbcopytest.parquet')`);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
  }

  // test/table_test.ts
  function compareTable(table, expected) {
    const colCount = expected.length;
    expect(table.numCols).toEqual(colCount);
    if (colCount == 0)
      return;
    const rowCount = expected[0].values.length;
    for (let i = 0; i < colCount; ++i) {
      expect(expected[i].values.length).toEqual(rowCount);
      expect(table.getChildAt(i)?.length).toEqual(rowCount);
      expect(table.schema.fields[i]?.name).toEqual(expected[i].name);
    }
    for (let i = 0; i < colCount; ++i) {
      const col = table.getChildAt(i);
      const have = [];
      for (let j = 0; j < rowCount; ++j) {
        have.push(col.get(j));
      }
      expect(Number(have)).toEqual(Number(expected[i].values));
    }
  }

  // test/insert_arrow.test.ts
  var buildUtf8Array = (values) => {
    const builder = new Utf8Builder({
      type: new Utf8()
    });
    for (const v of values) {
      builder.append(v);
    }
    builder.finish();
    return builder.flush();
  };
  var ARROW_INSERT_TESTS = [
    {
      name: "integers_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int32()),
        new Field2("c", new Int32())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int32(), data: new Int32Array([2, 5, 8]) }),
            makeData({ type: new Int32(), data: new Int32Array([3, 6, 9]) })
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "combined_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "combined_2",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        },
        {
          numRows: 2,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([10, 13]) }),
            makeData({ type: new Int16(), data: new Int16Array([11, 14]) }),
            buildUtf8Array(["12", "15"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7, 10, 13] },
        { name: "b", values: [2, 5, 8, 11, 14] },
        { name: "c", values: ["3", "6", "9", "12", "15"] }
      ]
    }
  ];
  function testArrowInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data);
          });
          const table = new Table(test.schema, batches);
          conn.insertArrowTable(table, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testArrowInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow async insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data);
          });
          const table = new Table(test.schema, batches);
          await conn.insertArrowTable(table, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describe("Arrow async insert from table", () => {
      it("simple integers", async () => {
        await conn.query(`DROP TABLE IF EXISTS insert_from_table`);
        const table = new Table({
          a: makeVector(new Int32Array([1, 4, 7])),
          b: makeVector(new Int32Array([2, 5, 8])),
          c: vectorFromArray(["3", "6", "9"])
        });
        await conn.insertArrowTable(table, {
          name: "insert_from_vectors"
        });
        const results = await conn.query("select * from insert_from_vectors");
        compareTable(results, [
          { name: "a", values: [1, 4, 7] },
          { name: "b", values: [2, 5, 8] },
          { name: "c", values: ["3", "6", "9"] }
        ]);
      });
    });
  }

  // test/insert_json.test.ts
  function describeBrowser(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder2 = new TextEncoder();
  var JSON_INSERT_TESTS = [
    {
      name: "rows_integers",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "cols_integers",
      input: `{
            "a": [1, 4, 7],
            "b": [2, 5, 8],
            "c": [3, 6, 9]
        }`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "options_1",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo",
        shape: "row-array" /* ROW_ARRAY */,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    }
  ];
  var TEST_FILE = "TEST";
  function testJSONInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Sync", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          db2().registerFileBuffer(TEST_FILE, buffer);
          conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testJSONInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Buffer Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE, buffer);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser("JSON Insert Blob Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/insert_csv.test.ts
  function describeBrowser2(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder3 = new TextEncoder();
  var CSV_INSERT_TESTS = [
    {
      name: "integers_auto_1",
      input: `"a","b","c"
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a,b,c
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_3",
      input: `a,b,c`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "column0", values: ["a"] },
        { name: "column1", values: ["b"] },
        { name: "column2", values: ["c"] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a
1
4
7
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [{ name: "a", values: [1, 4, 7] }]
    },
    {
      name: "options_1",
      input: `1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo2",
        header: false,
        detect: false,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo2",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "options_2",
      input: `1|2|01/02/2020
4|5|01/03/2020
7|8|01/04/2020
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        dateFormat: "%m/%d/%Y",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new DateDay()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(2020, 0, 2)),
            new Date(Date.UTC(2020, 0, 3)),
            new Date(Date.UTC(2020, 0, 4))
          ]
        }
      ]
    },
    {
      name: "options_3",
      input: `1|2|20:32:45 1992-03-02
4|5|20:32:50 1992-03-02
7|8|20:32:55 1992-03-02
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        quote: "'",
        timestampFormat: "%H:%M:%S %Y-%m-%d",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new TimestampSecond()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(1992, 2, 2, 20, 32, 45)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 50)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 55)).getTime()
          ]
        }
      ]
    }
  ];
  var TEST_FILE2 = "TEST";
  function testCSVInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Sync", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          db2().registerFileBuffer(TEST_FILE2, buffer);
          conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testCSVInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Buffer Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE2, buffer);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser2("CSV Insert Blob Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE2, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/tokenizer.test.ts
  function testTokenization(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }
  function testTokenizationAsync(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(await db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(await db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }

  // test/tablenames.test.ts
  var TABLENAME_TESTS = [
    {
      name: "standard",
      input: "SELECT * FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "fetch_specific",
      input: "SELECT col_a FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "multiple_tables",
      input: "SELECT * FROM my_table1, my_table2, my_table3",
      tables: ["my_table1", "my_table2", "my_table3"]
    },
    {
      name: "same_table_multiple_times",
      input: "SELECT col_a FROM my_table, my_table m2, my_table m3",
      tables: ["my_table"]
    },
    {
      name: "subqueries",
      input: "SELECT * FROM (SELECT * FROM (SELECT * FROM my_table) bla) bla3",
      tables: ["my_table"]
    },
    {
      name: "join",
      input: "SELECT col_a FROM my_table JOIN my_table2 ON (my_table.col_b=my_table2.col_d)",
      tables: ["my_table", "my_table2"]
    },
    {
      name: "scalar_subquery",
      input: "SELECT (SELECT COUNT(*) FROM my_table)",
      tables: ["my_table"]
    },
    {
      name: "set_operations",
      input: "SELECT * FROM my_table UNION ALL SELECT * FROM my_table2 INTERSECT SELECT * FROM my_table3",
      tables: ["my_table", "my_table2", "my_table3"]
    },
    {
      name: "window_functions",
      input: "SELECT row_number() OVER (ORDER BY (SELECT i+j FROM my_table2)) FROM my_table",
      tables: ["my_table", "my_table2"]
    }
  ];
  function testTableNames(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
    });
    describe("TableNames", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, () => {
          const tables = conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }
  function testTableNamesAsync(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
    });
    describe("TableNames Async", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, async () => {
          const tables = await conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }

  // test/regression/github_332.test.ts
  function test332(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("332", async () => {
        await db2().registerFileText(
          "Products.csv",
          `ProductGroup,Product,Year,Quarter,Revenue,Units,Count,Product Key,Reseller,Product Info,QuarterAsNumber
Electronics,Phone,2018,Q1,103,7,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q1,102,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2019,Q1,98,12,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2018,Q1,104,3,1,2018-Q1,Samsung,Format=XML; <Properties>\u2026,1
Electronics,Computer,2019,Q1,83,7,1,2019-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2018,Q1,17,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2019,Q1,20,7,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2018,Q1,25,12,1,2018-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Movies,2019,Q1,26,13,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2018,Q2,99,4,1,2018-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2019,Q2,84,20,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2018,Q2,17,4,1,2018-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Media,Theater,2019,Q2,22,5,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2018,Q2,25,12,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2019,Q2,26,14,1,2019-Q2,Google,Format=XML; <Properties>\u2026,2
Electronics,Phone,2000,Q1,103,7,1,2000-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2001,Q1,102,4,1,2001-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2002,Q1,98,12,1,2002-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Computer,2003,Q1,104,3,1,2003-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2004,Q1,83,7,1,2004-Q1,Samsung,Format=XML; <Properties>\u2026,1
Media,Theater,2005,Q1,17,4,1,2005-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2006,Q1,20,7,1,2006-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2007,Q1,25,12,1,2007-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2008,Q1,26,13,1,2008-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Phone,2009,Q2,105,5,1,2009-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2010,Q2,82,15,1,2010-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2011,Q2,99,4,1,2011-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2012,Q2,84,20,1,2012-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2013,Q2,17,4,1,2013-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2014,Q2,22,5,1,2014-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2015,Q2,25,12,1,2015-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2016,Q2,26,14,1,2016-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2017,Q1,26,13,1,2017-Q1,Google,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2020,Q2,99,4,1,2020-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q1,103,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2020,Q2,102,4,1,2020-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q3,98,12,1,2020-Q3,LG,Format=XML; <Properties>\u2026,3
Electronics,Computer,2020,Q4,104,3,1,2020-Q4,LG,Format=XML; <Properties>\u2026,4
Electronics,Computer,2020,Q1,83,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,17,4,1,2020-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,20,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
`
        );
        await conn.query("CREATE TABLE products AS SELECT * FROM 'Products.csv'");
        const all = await conn.query("SELECT * FROM products");
        expect(all.schema.fields.length).toBe(11);
        expect(all.schema.fields[0].name).toBe("ProductGroup");
        const insensitive = await conn.query("SELECT productgroup FROM products GROUP BY productgroup");
        expect(insensitive.schema.fields.length).toBe(1);
        expect(insensitive.schema.fields[0].name).toBe("ProductGroup");
        expect(insensitive.toArray().length).toEqual(2);
        await conn.query("DROP TABLE products");
      });
    });
  }

  // test/regression/github_334.test.ts
  function test334(adb2) {
    describe("GitHub issues", () => {
      describe("334", () => {
        it("CSV insert", async () => {
          await adb2().registerFileText(`data.csv`, "1|foo\n2|bar\n");
          const conn = await adb2().connect();
          await conn.insertCSVFromPath("data.csv", {
            schema: "main",
            name: "foo",
            detect: false,
            header: false,
            delimiter: "|",
            columns: {
              col1: new Int32(),
              col2: new Utf8()
            }
          });
          await conn.query("DROP TABLE IF EXISTS foo");
          await conn.close();
          await adb2().dropFile("data.csv");
        });
        it("JSON row insert", async () => {
          await adb2().registerFileText(
            "rows.json",
            `[
                    { "col1": 1, "col2": "foo" },
                    { "col1": 2, "col2": "bar" },
                ]`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("rows.json", { name: "rows" });
          await conn.query("DROP TABLE IF EXISTS rows");
          await conn.close();
          await adb2().dropFile("rows.json");
        });
        it("JSON column insert", async () => {
          await adb2().registerFileText(
            "columns.json",
            `{
                    "col1": [1, 2],
                    "col2": ["foo", "bar"]
                }`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("columns.json", { name: "columns" });
          await conn.query("DROP TABLE IF EXISTS columns");
          await conn.close();
          await adb2().dropFile("columns.json");
        });
        it("Query result materialized", async () => {
          const conn = await adb2().connect();
          await conn.query(`
                SELECT * FROM generate_series(1, 100) t(v)
            `);
          await conn.close();
        });
        it("Query result streamed", async () => {
          const conn = await adb2().connect();
          for await (const batch of await conn.send(`
                SELECT * FROM generate_series(1, 100) t(v)
            `)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await conn.close();
        });
        it("Prepared statement materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          await stmt.query(234);
          await stmt.close();
          await conn.close();
        });
        it("Prepared statement streamed", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          for await (const batch of await stmt.send(234)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await stmt.close();
          await conn.close();
        });
      });
    });
  }

  // test/regression/github_393.test.ts
  function test393(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("393", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: false
          }
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithoutCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)).getTime());
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)));
      });
    });
  }

  // test/regression/github_448.test.ts
  function test448(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("448", async () => {
        conn = await db2().connect();
        await conn.query(`create temp table test448(i integer)`);
        await conn.query(`insert into test448 values (1),(2),(1)`);
        let result = await conn.query(`select * from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(3);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 1]));
        result = await conn.query(`select histogram(i) from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(1);
        const array = result.getChildAt(0).toArray();
        expect(array.length).toEqual(1);
        expect(array[0].toString()).toEqual("{1: 2, 2: 1}");
      });
    });
  }

  // test/regression/github_470.test.ts
  function test470(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("470", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: false
          }
        });
        conn = await db2().connect();
        const result1 = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(result1.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithCast.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithDefault = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithDefault.toArray()[0]?.interval?.toString()).toEqual("0,3");
      });
    });
  }

  // test/regression/github_477.test.ts
  function test477(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("477", async () => {
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithoutCast.schema.fields[0].type.scale).toEqual(1);
        expect(resultWithoutCast.schema.fields[0].type.precision).toEqual(2);
        expect(resultWithoutCast.toArray()[0]?.decimal == -19).toBe(false);
        await db2().open({
          path: ":memory:",
          query: {
            castDecimalToDouble: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithCast.toArray()[0]?.decimal).toEqual(-1.9000000000000001);
      });
    });
  }

  // test/regression/index.ts
  function testRegressionAsync(adb2) {
    test332(adb2);
    test334(adb2);
    test393(adb2);
    test448(adb2);
    test470(adb2);
    test477(adb2);
  }

  // test/udf.test.ts
  function testUDF(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("UDF", () => {
      it("simple", async () => {
        conn.createScalarFunction("jsudf", new Int32(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1e4]));
      });
      it("double", async () => {
        conn.createScalarFunction("jsudf2", new Float64(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf2(v::DOUBLE))::DOUBLE as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Float64Array([1e4]));
      });
      it("2 args", async () => {
        conn.createScalarFunction("jsudf3", new Int32(), (a, b) => a + b);
        const result = conn.query(
          "SELECT max(jsudf3(v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([2e4]));
      });
      it("3 args", async () => {
        conn.createScalarFunction("jsudf3args", new Int32(), (a, b, c) => a + b + c);
        const result = conn.query(
          "SELECT max(jsudf3args(v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([3e4]));
      });
      it("4 args", async () => {
        conn.createScalarFunction("jsudf4args", new Int32(), (a, b, c, d) => a + b + c + d);
        const result = conn.query(
          "SELECT max(jsudf4args(v::INTEGER, v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([4e4]));
      });
      it("noargs", async () => {
        conn.createScalarFunction("jsudf4", new Int32(), () => 42);
        const result = conn.query("SELECT max(jsudf4())::INTEGER as foo FROM generate_series(1, 10000) as t(v)");
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("withnulls", async () => {
        conn.createScalarFunction("jsudf5", new Int32(), (a) => a == null ? -100 : a);
        const result = conn.query(
          "SELECT min(jsudf5((case when v % 2 = 0 then v else null end)::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("stringparam", async () => {
        function jsudf6(s) {
          return s.length;
        }
        conn.createScalarFunction("jsudf6", new Int32(), jsudf6);
        const result = conn.query(
          "SELECT max(jsudf6('str_' || v))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("stringparamnulls", async () => {
        function jsudf7(s) {
          if (s == void 0) {
            return 0;
          } else {
            return s.length;
          }
        }
        conn.createScalarFunction("jsudf7", new Int32(), jsudf7);
        const result = conn.query(
          "SELECT max(jsudf7((case when v % 2 = 0 then 'str_' || v else null end)::VARCHAR))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("nullintreturn", async () => {
        conn.createScalarFunction("jsudf8", new Int32(), (a) => void 0);
        const result = conn.query(
          "SELECT max(COALESCE(jsudf8(v::INTEGER), 42))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("stringreturn", async () => {
        conn.createScalarFunction("jsudf9", new Utf8(), (a) => "Hello " + a);
        const result = conn.query(
          "SELECT max(LENGTH(jsudf9(v::INTEGER)))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([11]));
      });
      it("nullstringreturn", async () => {
        conn.createScalarFunction("jsudf10", new Utf8(), (a) => a % 2 == 0 ? "Hello" : void 0);
        const result = conn.query(
          "SELECT COUNT(jsudf10(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([5e3]));
      });
      it("struct", async () => {
        conn.createScalarFunction("jsudf11", new Int32(), (a) => a.x == null ? -100 : a.x);
        const result = conn.query(
          `SELECT min(jsudf11({'x': (case when v % 2 = 0 then v else null end)::INTEGER, 'y': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnested", async () => {
        conn.createScalarFunction("jsudf12", new Int32(), (a) => a.x.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf12({'x': {'y': (case when v % 2 = 0 then v else null end)::INTEGER }, 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnestednull", async () => {
        conn.createScalarFunction("jsudf13", new Int32(), (a) => a.x?.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf13({'x': (case when v % 2 = 0 then {'y': v::INTEGER } else null end), 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
    });
  }

  // test/index_browser.ts
  var DUCKDB_BUNDLES = {
    mvp: {
      mainModule: new URL("/static/duckdb-mvp.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-mvp.worker.js", window.location.href).href
    },
    eh: {
      mainModule: new URL("/static/duckdb-eh.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-eh.worker.js", window.location.href).href
    },
    coi: {
      mainModule: new URL("/static/duckdb-coi.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-coi.worker.js", window.location.href).href,
      pthreadWorker: new URL("/static/duckdb-browser-coi.pthread.worker.js", window.location.href).href
    }
  };
  var DUCKDB_BUNDLE = null;
  describe("wasm check", () => {
    it("worker and wasm urls", async () => {
      if ((await getPlatformFeatures()).crossOriginIsolated && await exceptions() && await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.coi.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.coi.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(DUCKDB_BUNDLES.coi.pthreadWorker);
      }
      if (await exceptions() && !await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.eh.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.eh.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
      if (!await exceptions()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.mvp.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.mvp.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
    });
  });
  jasmine.DEFAULT_TIMEOUT_INTERVAL = 6e4;
  var resolveBuffer = async (url) => {
    const req = await fetch(`/data${url}`);
    if (!req.ok)
      return null;
    return new Uint8Array(await req.arrayBuffer());
  };
  var resolveData = async (url) => {
    switch (url) {
      case "/uni/all.zip":
        return await resolveBuffer("/uni/all.zip");
      case "/uni/assistenten.parquet":
        return await resolveBuffer("/uni/assistenten.parquet");
      case "/uni/studenten.parquet":
        return await resolveBuffer("/uni/studenten.parquet");
      case "/uni/hoeren.parquet":
        return await resolveBuffer("/uni/hoeren.parquet");
      case "/uni/vorlesungen.parquet":
        return await resolveBuffer("/uni/vorlesungen.parquet");
      case "/tpch/0_01/parquet/lineitem.parquet":
        return await resolveBuffer("/tpch/0_01/parquet/lineitem.parquet");
      default:
        return null;
    }
  };
  var db = null;
  var adb = null;
  var worker = null;
  beforeAll(async () => {
    const logger = new VoidLogger();
    db = await createDuckDB(DUCKDB_BUNDLES, logger, BROWSER_RUNTIME);
    await db.instantiate((_) => {
    });
    DUCKDB_BUNDLE = await selectBundle(DUCKDB_BUNDLES);
    worker = await createWorker(DUCKDB_BUNDLE.mainWorker);
    adb = new AsyncDuckDB(logger, worker);
    await adb.instantiate(DUCKDB_BUNDLE.mainModule, DUCKDB_BUNDLE.pthreadWorker);
  });
  afterAll(async () => {
    if (worker)
      worker.terminate();
  });
  var baseURL = window.location.origin;
  var dataURL = `${baseURL}/data`;
  testHTTPFS(() => db);
  testHTTPFSAsync(() => adb, resolveData, dataURL);
  testUDF(() => db);
  testTableNames(() => db);
  testTableNamesAsync(() => adb);
  testRegressionAsync(() => adb);
  testAllTypes(() => db);
  testAllTypesAsync(() => adb);
  testBindings(() => db, dataURL);
  testAsyncBindings(() => adb, dataURL, 4 /* HTTP */);
  testBatchStream(() => db);
  testAsyncBatchStream(() => adb);
  testFilesystem(() => adb, resolveData, dataURL, 4 /* HTTP */);
  testArrowInsert(() => db);
  testArrowInsertAsync(() => adb);
  testJSONInsert(() => db);
  testJSONInsertAsync(() => adb);
  testCSVInsert(() => db);
  testCSVInsertAsync(() => adb);
  testTokenization(() => db);
  testTokenizationAsync(() => adb);
})();
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy1zaGEyNTYvc3JjL3NoYTI1Ni5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvd2ViLXdvcmtlci9janMvYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9idWZmZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvdXRmOC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9jb21wYXQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby9pby9hZGFwdGVycy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2VudW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvdmVjdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL3ByZXR0eS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9ibi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3R5cGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL21hdGgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3Ivc2V0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvcm93L3Jvdy9zdHJ1Y3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvZ2V0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvcm93L3Jvdy9tYXAudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvYml0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZGF0YS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9jaHVuay50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci9pbmRleG9mLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2l0ZXJhdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2J5dGVsZW5ndGgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92ZWN0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdmFsaWQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvYnVmZmVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2Jsb2NrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvdXRpbHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9sb25nLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvZW5jb2RpbmcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9ieXRlLWJ1ZmZlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2J1aWxkZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9rZXktdmFsdWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9tZXRhZGF0YS12ZXJzaW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZW5kaWFubmVzcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RpY3Rpb25hcnkta2luZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ludC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RpY3Rpb25hcnktZW5jb2RpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9iaW5hcnkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9ib29sLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZGF0ZS11bml0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZGF0ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RlY2ltYWwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi90aW1lLXVuaXQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9maXhlZC1zaXplLWJpbmFyeS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ZpeGVkLXNpemUtbGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3ByZWNpc2lvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2Zsb2F0aW5nLXBvaW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvaW50ZXJ2YWwtdW5pdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ludGVydmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvbGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL21hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL251bGwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9zdHJ1Y3RfLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvdGltZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3RpbWVzdGFtcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3VuaW9uLW1vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi91bmlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3V0ZjgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi90eXBlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZmllbGQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9zY2hlbWEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9mb290ZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9zY2hlbWEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pcGMvbWV0YWRhdGEvaXBjL21ldGFkYXRhL2ZpbGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby9pby9pbnRlcmZhY2VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vaW8vc3RyZWFtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vaW8vZmlsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9pbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvdmVjdG9ybG9hZGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2JpbmFyeS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9ib29sLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2RhdGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvZGVjaW1hbC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9kaWN0aW9uYXJ5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2ZpeGVkc2l6ZWJpbmFyeS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9maXhlZHNpemVsaXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2Zsb2F0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2ludGVydmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2ludC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9saXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL21hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9udWxsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL3N0cnVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci90aW1lc3RhbXAudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdGltZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci91bmlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci91dGY4LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2J1aWxkZXJjdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL3R5cGVjb21wYXJhdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmFjdG9yaWVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL3JlY29yZGJhdGNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdGFibGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9yZWNvcmRiYXRjaC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2JvZHktY29tcHJlc3Npb24tbWV0aG9kLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvY29tcHJlc3Npb24tdHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2JvZHktY29tcHJlc3Npb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9idWZmZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9maWVsZC1ub2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvcmVjb3JkLWJhdGNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZGljdGlvbmFyeS1iYXRjaC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL21lc3NhZ2UtaGVhZGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvbWVzc2FnZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci90eXBlYXNzZW1ibGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL21ldGFkYXRhL2lwYy9tZXRhZGF0YS9qc29uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL21ldGFkYXRhL2lwYy9tZXRhZGF0YS9tZXNzYWdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL2lwYy9tZXNzYWdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL2lwYy9yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvdmVjdG9yYXNzZW1ibGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL2lwYy93cml0ZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby93aGF0d2cvaW8vd2hhdHdnL2l0ZXJhYmxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vd2hhdHdnL2lvL3doYXR3Zy9idWlsZGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vd2hhdHdnL2lvL3doYXR3Zy9yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby93aGF0d2cvaW8vd2hhdHdnL3dyaXRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9pcGMvc2VyaWFsaXphdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L0Fycm93LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvQXJyb3cuZG9tLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9jb25uZWN0aW9uLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy91ZGZfcnVudGltZS50cyIsICIuLi9zcmMvYmluZGluZ3MvcnVudGltZS50cyIsICIuLi9zcmMvYmluZGluZ3MvZmlsZV9zdGF0cy50cyIsICIuLi9zcmMvanNvbl90eXBlZGVmLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19iYXNlLnRzIiwgIi4uL3NyYy9sb2cudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3dhc20tZmVhdHVyZS1kZXRlY3QvZGlzdC9lc20vaW5kZXguanMiLCAiLi4vc3JjL3BsYXRmb3JtLnRzIiwgIi4uL3NyYy91dGlscy9zM19oZWxwZXIudHMiLCAiLi4vc3JjL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlci50cyIsICIuLi9zcmMvYmluZGluZ3MvZHVja2RiLW12cC5qcyIsICIuLi9zcmMvYmluZGluZ3MvYmluZGluZ3NfYnJvd3Nlcl9iYXNlLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX212cC50cyIsICIuLi9zcmMvYmluZGluZ3MvZHVja2RiLWVoLmpzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX2VoLnRzIiwgIi4uL3NyYy90YXJnZXRzL2R1Y2tkYi1icm93c2VyLWJsb2NraW5nLnRzIiwgIi4uL3NyYy9wYXJhbGxlbC9hc3luY19jb25uZWN0aW9uLnRzIiwgIi4uL3NyYy9wYXJhbGxlbC93b3JrZXJfcmVxdWVzdC50cyIsICIuLi9zcmMvcGFyYWxsZWwvYXN5bmNfYmluZGluZ3MudHMiLCAiLi4vc3JjL3dvcmtlci50cyIsICIuLi90ZXN0L2FsbF90eXBlcy50ZXN0LnRzIiwgIi4uL3Rlc3QvaHR0cGZzX3Rlc3QudHMiLCAiLi4vdGVzdC9iaW5kaW5ncy50ZXN0LnRzIiwgIi4uL3Rlc3QvYmF0Y2hfc3RyZWFtLnRlc3QudHMiLCAiLi4vdGVzdC9iYXRjaF9zdHJlYW1fYXN5bmMudGVzdC50cyIsICIuLi90ZXN0L2ZpbGVzeXN0ZW0udGVzdC50cyIsICIuLi90ZXN0L3RhYmxlX3Rlc3QudHMiLCAiLi4vdGVzdC9pbnNlcnRfYXJyb3cudGVzdC50cyIsICIuLi90ZXN0L2luc2VydF9qc29uLnRlc3QudHMiLCAiLi4vdGVzdC9pbnNlcnRfY3N2LnRlc3QudHMiLCAiLi4vdGVzdC90b2tlbml6ZXIudGVzdC50cyIsICIuLi90ZXN0L3RhYmxlbmFtZXMudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vZ2l0aHViXzMzMi50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9naXRodWJfMzM0LnRlc3QudHMiLCAiLi4vdGVzdC9yZWdyZXNzaW9uL2dpdGh1Yl8zOTMudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vZ2l0aHViXzQ0OC50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9naXRodWJfNDcwLnRlc3QudHMiLCAiLi4vdGVzdC9yZWdyZXNzaW9uL2dpdGh1Yl80NzcudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vaW5kZXgudHMiLCAiLi4vdGVzdC91ZGYudGVzdC50cyIsICIuLi90ZXN0L2luZGV4X2Jyb3dzZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fc3ByZWFkQXJyYXk7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uKG0sIG8pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwgIi8qKlxuICogW2pzLXNoYTI1Nl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEyNTZ9XG4gKlxuICogQHZlcnNpb24gMC45LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAxN1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRVJST1IgPSAnaW5wdXQgaXMgaW52YWxpZCB0eXBlJztcbiAgdmFyIFdJTkRPVyA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnO1xuICB2YXIgcm9vdCA9IFdJTkRPVyA/IHdpbmRvdyA6IHt9O1xuICBpZiAocm9vdC5KU19TSEEyNTZfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEyNTZfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTI1Nl9OT19DT01NT05fSlMgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XG4gIHZhciBBTUQgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAhcm9vdC5KU19TSEEyNTZfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgRVhUUkEgPSBbLTIxNDc0ODM2NDgsIDgzODg2MDgsIDMyNzY4LCAxMjhdO1xuICB2YXIgU0hJRlQgPSBbMjQsIDE2LCA4LCAwXTtcbiAgdmFyIEsgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG4gIF07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdhcnJheScsICdkaWdlc3QnLCAnYXJyYXlCdWZmZXInXTtcblxuICB2YXIgYmxvY2tzID0gW107XG5cbiAgaWYgKHJvb3QuSlNfU0hBMjU2X05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKG91dHB1dFR5cGUsIGlzMjI0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IFNoYTI1NihpczIyNCwgdHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGlzMjI0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZCgnaGV4JywgaXMyMjQpO1xuICAgIGlmIChOT0RFX0pTKSB7XG4gICAgICBtZXRob2QgPSBub2RlV3JhcChtZXRob2QsIGlzMjI0KTtcbiAgICB9XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMjU2KGlzMjI0KTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVPdXRwdXRNZXRob2QodHlwZSwgaXMyMjQpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBub2RlV3JhcCA9IGZ1bmN0aW9uIChtZXRob2QsIGlzMjI0KSB7XG4gICAgdmFyIGNyeXB0byA9IGV2YWwoXCJyZXF1aXJlKCdjcnlwdG8nKVwiKTtcbiAgICB2YXIgQnVmZmVyID0gZXZhbChcInJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclwiKTtcbiAgICB2YXIgYWxnb3JpdGhtID0gaXMyMjQgPyAnc2hhMjI0JyA6ICdzaGEyNTYnO1xuICAgIHZhciBub2RlTWV0aG9kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKG1lc3NhZ2UsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSB8fFxuICAgICAgICBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKG5ldyBCdWZmZXIobWVzc2FnZSkpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWV0aG9kKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5vZGVNZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgaXMyMjQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBIbWFjU2hhMjU2KGtleSwgaXMyMjQsIHRydWUpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhtYWNNZXRob2QgPSBmdW5jdGlvbiAoaXMyMjQpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlSG1hY091dHB1dE1ldGhvZCgnaGV4JywgaXMyMjQpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEhtYWNTaGEyNTYoa2V5LCBpczIyNCk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5KS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kKHR5cGUsIGlzMjI0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGEyNTYoaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIGlmIChpczIyNCkge1xuICAgICAgdGhpcy5oMCA9IDB4YzEwNTllZDg7XG4gICAgICB0aGlzLmgxID0gMHgzNjdjZDUwNztcbiAgICAgIHRoaXMuaDIgPSAweDMwNzBkZDE3O1xuICAgICAgdGhpcy5oMyA9IDB4ZjcwZTU5Mzk7XG4gICAgICB0aGlzLmg0ID0gMHhmZmMwMGIzMTtcbiAgICAgIHRoaXMuaDUgPSAweDY4NTgxNTExO1xuICAgICAgdGhpcy5oNiA9IDB4NjRmOThmYTc7XG4gICAgICB0aGlzLmg3ID0gMHhiZWZhNGZhNDtcbiAgICB9IGVsc2UgeyAvLyAyNTZcbiAgICAgIHRoaXMuaDAgPSAweDZhMDllNjY3O1xuICAgICAgdGhpcy5oMSA9IDB4YmI2N2FlODU7XG4gICAgICB0aGlzLmgyID0gMHgzYzZlZjM3MjtcbiAgICAgIHRoaXMuaDMgPSAweGE1NGZmNTNhO1xuICAgICAgdGhpcy5oNCA9IDB4NTEwZTUyN2Y7XG4gICAgICB0aGlzLmg1ID0gMHg5YjA1Njg4YztcbiAgICAgIHRoaXMuaDYgPSAweDFmODNkOWFiO1xuICAgICAgdGhpcy5oNyA9IDB4NWJlMGNkMTk7XG4gICAgfVxuXG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzMjI0ID0gaXMyMjQ7XG4gIH1cblxuICBTaGEyNTYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmhhc2hlZCkge1xuICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgIHRoaXMuYnl0ZXMgKz0gaSAtIHRoaXMuc3RhcnQ7XG4gICAgICBpZiAoaSA+PSA2NCkge1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgIHRoaXMuaGFzaGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgIHRoaXMuaEJ5dGVzICs9IHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2IDw8IDA7XG4gICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgfVxuICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgIGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgIH1cbiAgICBibG9ja3NbMTRdID0gdGhpcy5oQnl0ZXMgPDwgMyB8IHRoaXMuYnl0ZXMgPj4+IDI5O1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQsIGYgPSB0aGlzLmg1LCBnID0gdGhpcy5oNixcbiAgICAgIGggPSB0aGlzLmg3LCBibG9ja3MgPSB0aGlzLmJsb2NrcywgaiwgczAsIHMxLCBtYWosIHQxLCB0MiwgY2gsIGFiLCBkYSwgY2QsIGJjO1xuXG4gICAgZm9yIChqID0gMTY7IGogPCA2NDsgKytqKSB7XG4gICAgICAvLyByaWdodHJvdGF0ZVxuICAgICAgdDEgPSBibG9ja3NbaiAtIDE1XTtcbiAgICAgIHMwID0gKCh0MSA+Pj4gNykgfCAodDEgPDwgMjUpKSBeICgodDEgPj4+IDE4KSB8ICh0MSA8PCAxNCkpIF4gKHQxID4+PiAzKTtcbiAgICAgIHQxID0gYmxvY2tzW2ogLSAyXTtcbiAgICAgIHMxID0gKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXiAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeICh0MSA+Pj4gMTApO1xuICAgICAgYmxvY2tzW2pdID0gYmxvY2tzW2ogLSAxNl0gKyBzMCArIGJsb2Nrc1tqIC0gN10gKyBzMSA8PCAwO1xuICAgIH1cblxuICAgIGJjID0gYiAmIGM7XG4gICAgZm9yIChqID0gMDsgaiA8IDY0OyBqICs9IDQpIHtcbiAgICAgIGlmICh0aGlzLmZpcnN0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzMjI0KSB7XG4gICAgICAgICAgYWIgPSAzMDAwMzI7XG4gICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAxNDEzMjU3ODE5O1xuICAgICAgICAgIGggPSB0MSAtIDE1MDA1NDU5OSA8PCAwO1xuICAgICAgICAgIGQgPSB0MSArIDI0MTc3MDc3IDw8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWIgPSA3MDQ3NTExMDk7XG4gICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAyMTAyNDQyNDg7XG4gICAgICAgICAgaCA9IHQxIC0gMTUyMTQ4NjUzNCA8PCAwO1xuICAgICAgICAgIGQgPSB0MSArIDE0MzY5NDU2NSA8PCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXiAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXiAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAgIHMxID0gKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXiAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXiAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgICAgYWIgPSBhICYgYjtcbiAgICAgICAgbWFqID0gYWIgXiAoYSAmIGMpIF4gYmM7XG4gICAgICAgIGNoID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuICAgICAgICB0MSA9IGggKyBzMSArIGNoICsgS1tqXSArIGJsb2Nrc1tqXTtcbiAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgaCA9IGQgKyB0MSA8PCAwO1xuICAgICAgICBkID0gdDEgKyB0MiA8PCAwO1xuICAgICAgfVxuICAgICAgczAgPSAoKGQgPj4+IDIpIHwgKGQgPDwgMzApKSBeICgoZCA+Pj4gMTMpIHwgKGQgPDwgMTkpKSBeICgoZCA+Pj4gMjIpIHwgKGQgPDwgMTApKTtcbiAgICAgIHMxID0gKChoID4+PiA2KSB8IChoIDw8IDI2KSkgXiAoKGggPj4+IDExKSB8IChoIDw8IDIxKSkgXiAoKGggPj4+IDI1KSB8IChoIDw8IDcpKTtcbiAgICAgIGRhID0gZCAmIGE7XG4gICAgICBtYWogPSBkYSBeIChkICYgYikgXiBhYjtcbiAgICAgIGNoID0gKGggJiBlKSBeICh+aCAmIGYpO1xuICAgICAgdDEgPSBnICsgczEgKyBjaCArIEtbaiArIDFdICsgYmxvY2tzW2ogKyAxXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBnID0gYyArIHQxIDw8IDA7XG4gICAgICBjID0gdDEgKyB0MiA8PCAwO1xuICAgICAgczAgPSAoKGMgPj4+IDIpIHwgKGMgPDwgMzApKSBeICgoYyA+Pj4gMTMpIHwgKGMgPDwgMTkpKSBeICgoYyA+Pj4gMjIpIHwgKGMgPDwgMTApKTtcbiAgICAgIHMxID0gKChnID4+PiA2KSB8IChnIDw8IDI2KSkgXiAoKGcgPj4+IDExKSB8IChnIDw8IDIxKSkgXiAoKGcgPj4+IDI1KSB8IChnIDw8IDcpKTtcbiAgICAgIGNkID0gYyAmIGQ7XG4gICAgICBtYWogPSBjZCBeIChjICYgYSkgXiBkYTtcbiAgICAgIGNoID0gKGcgJiBoKSBeICh+ZyAmIGUpO1xuICAgICAgdDEgPSBmICsgczEgKyBjaCArIEtbaiArIDJdICsgYmxvY2tzW2ogKyAyXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBmID0gYiArIHQxIDw8IDA7XG4gICAgICBiID0gdDEgKyB0MiA8PCAwO1xuICAgICAgczAgPSAoKGIgPj4+IDIpIHwgKGIgPDwgMzApKSBeICgoYiA+Pj4gMTMpIHwgKGIgPDwgMTkpKSBeICgoYiA+Pj4gMjIpIHwgKGIgPDwgMTApKTtcbiAgICAgIHMxID0gKChmID4+PiA2KSB8IChmIDw8IDI2KSkgXiAoKGYgPj4+IDExKSB8IChmIDw8IDIxKSkgXiAoKGYgPj4+IDI1KSB8IChmIDw8IDcpKTtcbiAgICAgIGJjID0gYiAmIGM7XG4gICAgICBtYWogPSBiYyBeIChiICYgZCkgXiBjZDtcbiAgICAgIGNoID0gKGYgJiBnKSBeICh+ZiAmIGgpO1xuICAgICAgdDEgPSBlICsgczEgKyBjaCArIEtbaiArIDNdICsgYmxvY2tzW2ogKyAzXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBlID0gYSArIHQxIDw8IDA7XG4gICAgICBhID0gdDEgKyB0MiA8PCAwO1xuICAgIH1cblxuICAgIHRoaXMuaDAgPSB0aGlzLmgwICsgYSA8PCAwO1xuICAgIHRoaXMuaDEgPSB0aGlzLmgxICsgYiA8PCAwO1xuICAgIHRoaXMuaDIgPSB0aGlzLmgyICsgYyA8PCAwO1xuICAgIHRoaXMuaDMgPSB0aGlzLmgzICsgZCA8PCAwO1xuICAgIHRoaXMuaDQgPSB0aGlzLmg0ICsgZSA8PCAwO1xuICAgIHRoaXMuaDUgPSB0aGlzLmg1ICsgZiA8PCAwO1xuICAgIHRoaXMuaDYgPSB0aGlzLmg2ICsgZyA8PCAwO1xuICAgIHRoaXMuaDcgPSB0aGlzLmg3ICsgaCA8PCAwO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNCwgaDUgPSB0aGlzLmg1LFxuICAgICAgaDYgPSB0aGlzLmg2LCBoNyA9IHRoaXMuaDc7XG5cbiAgICB2YXIgaGV4ID0gSEVYX0NIQVJTWyhoMCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDAgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gyICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDMgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDQgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNCAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNSA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g1ICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg2ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDYgJiAweDBGXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGg3ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNyA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDcgPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNyAmIDB4MEZdO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUudG9TdHJpbmcgPSBTaGEyNTYucHJvdG90eXBlLmhleDtcblxuICBTaGEyNTYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQsIGg1ID0gdGhpcy5oNSxcbiAgICAgIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuXG4gICAgdmFyIGFyciA9IFtcbiAgICAgIChoMCA+PiAyNCkgJiAweEZGLCAoaDAgPj4gMTYpICYgMHhGRiwgKGgwID4+IDgpICYgMHhGRiwgaDAgJiAweEZGLFxuICAgICAgKGgxID4+IDI0KSAmIDB4RkYsIChoMSA+PiAxNikgJiAweEZGLCAoaDEgPj4gOCkgJiAweEZGLCBoMSAmIDB4RkYsXG4gICAgICAoaDIgPj4gMjQpICYgMHhGRiwgKGgyID4+IDE2KSAmIDB4RkYsIChoMiA+PiA4KSAmIDB4RkYsIGgyICYgMHhGRixcbiAgICAgIChoMyA+PiAyNCkgJiAweEZGLCAoaDMgPj4gMTYpICYgMHhGRiwgKGgzID4+IDgpICYgMHhGRiwgaDMgJiAweEZGLFxuICAgICAgKGg0ID4+IDI0KSAmIDB4RkYsIChoNCA+PiAxNikgJiAweEZGLCAoaDQgPj4gOCkgJiAweEZGLCBoNCAmIDB4RkYsXG4gICAgICAoaDUgPj4gMjQpICYgMHhGRiwgKGg1ID4+IDE2KSAmIDB4RkYsIChoNSA+PiA4KSAmIDB4RkYsIGg1ICYgMHhGRixcbiAgICAgIChoNiA+PiAyNCkgJiAweEZGLCAoaDYgPj4gMTYpICYgMHhGRiwgKGg2ID4+IDgpICYgMHhGRiwgaDYgJiAweEZGXG4gICAgXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGFyci5wdXNoKChoNyA+PiAyNCkgJiAweEZGLCAoaDcgPj4gMTYpICYgMHhGRiwgKGg3ID4+IDgpICYgMHhGRiwgaDcgJiAweEZGKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmFycmF5ID0gU2hhMjU2LnByb3RvdHlwZS5kaWdlc3Q7XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuaXMyMjQgPyAyOCA6IDMyKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDIwLCB0aGlzLmg1KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjQsIHRoaXMuaDYpO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKDI4LCB0aGlzLmg3KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBmdW5jdGlvbiBIbWFjU2hhMjU2KGtleSwgaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIHZhciBpLCB0eXBlID0gdHlwZW9mIGtleTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBieXRlcyA9IFtdLCBsZW5ndGggPSBrZXkubGVuZ3RoLCBpbmRleCA9IDAsIGNvZGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhjMCB8IChjb2RlID4+IDYpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ZTAgfCAoY29kZSA+PiAxMikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhmMCB8IChjb2RlID4+IDE4KSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleSA9IGJ5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIGtleS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBrZXkgPSBuZXcgVWludDhBcnJheShrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkubGVuZ3RoID4gNjQpIHtcbiAgICAgIGtleSA9IChuZXcgU2hhMjU2KGlzMjI0LCB0cnVlKSkudXBkYXRlKGtleSkuYXJyYXkoKTtcbiAgICB9XG5cbiAgICB2YXIgb0tleVBhZCA9IFtdLCBpS2V5UGFkID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIHZhciBiID0ga2V5W2ldIHx8IDA7XG4gICAgICBvS2V5UGFkW2ldID0gMHg1YyBeIGI7XG4gICAgICBpS2V5UGFkW2ldID0gMHgzNiBeIGI7XG4gICAgfVxuXG4gICAgU2hhMjU2LmNhbGwodGhpcywgaXMyMjQsIHNoYXJlZE1lbW9yeSk7XG5cbiAgICB0aGlzLnVwZGF0ZShpS2V5UGFkKTtcbiAgICB0aGlzLm9LZXlQYWQgPSBvS2V5UGFkO1xuICAgIHRoaXMuaW5uZXIgPSB0cnVlO1xuICAgIHRoaXMuc2hhcmVkTWVtb3J5ID0gc2hhcmVkTWVtb3J5O1xuICB9XG4gIEhtYWNTaGEyNTYucHJvdG90eXBlID0gbmV3IFNoYTI1NigpO1xuXG4gIEhtYWNTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgdGhpcy5pbm5lciA9IGZhbHNlO1xuICAgICAgdmFyIGlubmVySGFzaCA9IHRoaXMuYXJyYXkoKTtcbiAgICAgIFNoYTI1Ni5jYWxsKHRoaXMsIHRoaXMuaXMyMjQsIHRoaXMuc2hhcmVkTWVtb3J5KTtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMub0tleVBhZCk7XG4gICAgICB0aGlzLnVwZGF0ZShpbm5lckhhc2gpO1xuICAgICAgU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IGNyZWF0ZU1ldGhvZCgpO1xuICBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHM7XG4gIGV4cG9ydHMuc2hhMjI0ID0gY3JlYXRlTWV0aG9kKHRydWUpO1xuICBleHBvcnRzLnNoYTI1Ni5obWFjID0gY3JlYXRlSG1hY01ldGhvZCgpO1xuICBleHBvcnRzLnNoYTIyNC5obWFjID0gY3JlYXRlSG1hY01ldGhvZCh0cnVlKTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc2hhMjU2ID0gZXhwb3J0cy5zaGEyNTY7XG4gICAgcm9vdC5zaGEyMjQgPSBleHBvcnRzLnNoYTIyNDtcbiAgICBpZiAoQU1EKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsICIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gV29ya2VyOyIsICJpbXBvcnQgdHNsaWIgZnJvbSAnLi4vdHNsaWIuanMnO1xyXG5jb25zdCB7XHJcbiAgICBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbixcclxuICAgIF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcixcclxuICAgIF9fZ2VuZXJhdG9yLFxyXG4gICAgX19leHBvcnRTdGFyLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nLFxyXG4gICAgX192YWx1ZXMsXHJcbiAgICBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZCxcclxuICAgIF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG59ID0gdHNsaWI7XHJcbmV4cG9ydCB7XHJcbiAgICBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbixcclxuICAgIF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcixcclxuICAgIF9fZ2VuZXJhdG9yLFxyXG4gICAgX19leHBvcnRTdGFyLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nLFxyXG4gICAgX192YWx1ZXMsXHJcbiAgICBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZCxcclxuICAgIF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG59O1xyXG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiZXhwb3J0IGNvbnN0IFNJWkVPRl9TSE9SVCA9IDI7XHJcbmV4cG9ydCBjb25zdCBTSVpFT0ZfSU5UID0gNDtcclxuZXhwb3J0IGNvbnN0IEZJTEVfSURFTlRJRklFUl9MRU5HVEggPSA0O1xyXG5leHBvcnQgY29uc3QgU0laRV9QUkVGSVhfTEVOR1RIID0gNDtcclxuIiwgImV4cG9ydCBjb25zdCBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xyXG5leHBvcnQgY29uc3QgZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzIuYnVmZmVyKTtcclxuZXhwb3J0IGNvbnN0IGZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGludDMyLmJ1ZmZlcik7XHJcbmV4cG9ydCBjb25zdCBpc0xpdHRsZUVuZGlhbiA9IG5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwgMF0pLmJ1ZmZlcilbMF0gPT09IDE7XHJcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9uZyhsb3csIGhpZ2gpIHtcclxuICAgIHJldHVybiBMb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBMb25nIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUobG93LCBoaWdoKSB7XHJcbiAgICAgICAgLy8gU3BlY2lhbC1jYXNlIHplcm8gdG8gYXZvaWQgR0Mgb3ZlcmhlYWQgZm9yIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgcmV0dXJuIGxvdyA9PSAwICYmIGhpZ2ggPT0gMCA/IExvbmcuWkVSTyA6IG5ldyBMb25nKGxvdywgaGlnaCk7XHJcbiAgICB9XHJcbiAgICB0b0Zsb2F0NjQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyA+Pj4gMCkgKyB0aGlzLmhpZ2ggKiAweDEwMDAwMDAwMDtcclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA9PSBvdGhlci5sb3cgJiYgdGhpcy5oaWdoID09IG90aGVyLmhpZ2g7XHJcbiAgICB9XHJcbn1cclxuTG9uZy5aRVJPID0gbmV3IExvbmcoMCwgMCk7XHJcbiIsICJleHBvcnQgdmFyIEVuY29kaW5nO1xyXG4oZnVuY3Rpb24gKEVuY29kaW5nKSB7XHJcbiAgICBFbmNvZGluZ1tFbmNvZGluZ1tcIlVURjhfQllURVNcIl0gPSAxXSA9IFwiVVRGOF9CWVRFU1wiO1xyXG4gICAgRW5jb2RpbmdbRW5jb2RpbmdbXCJVVEYxNl9TVFJJTkdcIl0gPSAyXSA9IFwiVVRGMTZfU1RSSU5HXCI7XHJcbn0pKEVuY29kaW5nIHx8IChFbmNvZGluZyA9IHt9KSk7XHJcbiIsICJpbXBvcnQgeyBGSUxFX0lERU5USUZJRVJfTEVOR1RILCBTSVpFT0ZfSU5UIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi9sb25nXCI7XHJcbmltcG9ydCB7IGludDMyLCBpc0xpdHRsZUVuZGlhbiwgZmxvYXQzMiwgZmxvYXQ2NCB9IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IEVuY29kaW5nIH0gZnJvbSBcIi4vZW5jb2RpbmdcIjtcclxuZXhwb3J0IGNsYXNzIEJ5dGVCdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgQnl0ZUJ1ZmZlciB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYnl0ZXMgKGBVaW50OEFycmF5YClcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYnl0ZXNfKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc18gPSBieXRlc187XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW5kIGFsbG9jYXRlIGEgbmV3IEJ5dGVCdWZmZXIgd2l0aCBhIGdpdmVuIHNpemUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhbGxvY2F0ZShieXRlX3NpemUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZV9zaXplKSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uXyA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdW5kZXJseWluZyBgVWludDhBcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgcG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25fO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGJ1ZmZlcidzIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25fID0gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYnVmZmVyJ3MgY2FwYWNpdHkuXHJcbiAgICAgKi9cclxuICAgIGNhcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzXy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZWFkSW50OChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDgob2Zmc2V0KSA8PCAyNCA+PiAyNDtcclxuICAgIH1cclxuICAgIHJlYWRVaW50OChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XTtcclxuICAgIH1cclxuICAgIHJlYWRJbnQxNihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDE2KG9mZnNldCkgPDwgMTYgPj4gMTY7XHJcbiAgICB9XHJcbiAgICByZWFkVWludDE2KG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgODtcclxuICAgIH1cclxuICAgIHJlYWRJbnQzMihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDggfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDNdIDw8IDI0O1xyXG4gICAgfVxyXG4gICAgcmVhZFVpbnQzMihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0KSA+Pj4gMDtcclxuICAgIH1cclxuICAgIHJlYWRJbnQ2NChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcodGhpcy5yZWFkSW50MzIob2Zmc2V0KSwgdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCkpO1xyXG4gICAgfVxyXG4gICAgcmVhZFVpbnQ2NChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcodGhpcy5yZWFkVWludDMyKG9mZnNldCksIHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSk7XHJcbiAgICB9XHJcbiAgICByZWFkRmxvYXQzMihvZmZzZXQpIHtcclxuICAgICAgICBpbnQzMlswXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIGZsb2F0MzJbMF07XHJcbiAgICB9XHJcbiAgICByZWFkRmxvYXQ2NChvZmZzZXQpIHtcclxuICAgICAgICBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICAgICAgaW50MzJbaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcclxuICAgICAgICByZXR1cm4gZmxvYXQ2NFswXTtcclxuICAgIH1cclxuICAgIHdyaXRlSW50OChvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVVaW50OChvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQxNihvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcclxuICAgIH1cclxuICAgIHdyaXRlVWludDE2KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcclxuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDE2O1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XHJcbiAgICB9XHJcbiAgICB3cml0ZVVpbnQzMihvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcclxuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDE2O1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XHJcbiAgICB9XHJcbiAgICB3cml0ZUludDY0KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCB2YWx1ZS5sb3cpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcclxuICAgIH1cclxuICAgIHdyaXRlVWludDY0KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgdmFsdWUubG93KTtcclxuICAgICAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCArIDQsIHZhbHVlLmhpZ2gpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVGbG9hdDMyKG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICBmbG9hdDMyWzBdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgaW50MzJbMF0pO1xyXG4gICAgfVxyXG4gICAgd3JpdGVGbG9hdDY0KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICBmbG9hdDY0WzBdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgaW50MzJbaXNMaXR0bGVFbmRpYW4gPyAwIDogMV0pO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcclxuICAgICAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXHJcbiAgICAgKiBzdGFydCBvZiBhIHRoZSByb290IHZ0YWJsZSkuXHJcbiAgICAgKi9cclxuICAgIGdldEJ1ZmZlcklkZW50aWZpZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnl0ZXNfLmxlbmd0aCA8IHRoaXMucG9zaXRpb25fICsgU0laRU9GX0lOVCArXHJcbiAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fICsgU0laRU9GX0lOVCArIGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9vayB1cCBhIGZpZWxkIGluIHRoZSB2dGFibGUsIHJldHVybiBhbiBvZmZzZXQgaW50byB0aGUgb2JqZWN0LCBvciAwIGlmIHRoZVxyXG4gICAgICogZmllbGQgaXMgbm90IHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIF9fb2Zmc2V0KGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IHZ0YWJsZSA9IGJiX3BvcyAtIHRoaXMucmVhZEludDMyKGJiX3Bvcyk7XHJcbiAgICAgICAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAgICAgKi9cclxuICAgIF9fdW5pb24odCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdC5iYl9wb3MgPSBvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIHQuYmIgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBKYXZhU2NyaXB0IHN0cmluZyBmcm9tIFVURi04IGRhdGEgc3RvcmVkIGluc2lkZSB0aGUgRmxhdEJ1ZmZlci5cclxuICAgICAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxyXG4gICAgICpcclxuICAgICAqIFRvIGF2b2lkIHRoZSBjb252ZXJzaW9uIHRvIFVURi0xNiwgcGFzcyBFbmNvZGluZy5VVEY4X0JZVEVTIGFzXHJcbiAgICAgKiB0aGUgXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHRvXHJcbiAgICAgKiBhbmQgZnJvbSBVVEYtMTYgd2hlbiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyXHJcbiAgICAgKiBGbGF0QnVmZmVyIGxhdGVyIG9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSBvcHRfZW5jb2RpbmcgRGVmYXVsdHMgdG8gVVRGMTZfU1RSSU5HXHJcbiAgICAgKi9cclxuICAgIF9fc3RyaW5nKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIG9mZnNldCArPSBTSVpFT0ZfSU5UO1xyXG4gICAgICAgIGlmIChvcHRfZW5jb2RpbmcgPT09IEVuY29kaW5nLlVURjhfQllURVMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IGNvZGVQb2ludDtcclxuICAgICAgICAgICAgLy8gRGVjb2RlIFVURi04XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xyXG4gICAgICAgICAgICBpZiAoYSA8IDB4QzApIHtcclxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcclxuICAgICAgICAgICAgICAgIGlmIChhIDwgMHhFMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYSAmIDB4MUYpIDw8IDYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiICYgMHgzRik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IDB4RjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYSAmIDB4MEYpIDw8IDEyKSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiICYgMHgzRikgPDwgNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjICYgMHgzRik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYSAmIDB4MDcpIDw8IDE4KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiICYgMHgzRikgPDwgMTIpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGMgJiAweDNGKSA8PCA2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGQgJiAweDNGKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRW5jb2RlIFVURi0xNlxyXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDAsIChjb2RlUG9pbnQgJiAoKDEgPDwgMTApIC0gMSkpICsgMHhEQzAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdW5pb25zIHRoYXQgY2FuIGNvbnRhaW4gc3RyaW5nIGFzIGl0cyBtZW1iZXIsIGlmIGEgVGFibGUtZGVyaXZlZCB0eXBlIHRoZW4gaW5pdGlhbGl6ZSBpdCxcclxuICAgICAqIGlmIGEgc3RyaW5nIHRoZW4gcmV0dXJuIGEgbmV3IG9uZVxyXG4gICAgICpcclxuICAgICAqIFdBUk5JTkc6IHN0cmluZ3MgYXJlIGltbXV0YWJsZSBpbiBKUyBzbyB3ZSBjYW4ndCBjaGFuZ2UgdGhlIHN0cmluZyB0aGF0IHRoZSB1c2VyIGdhdmUgdXMsIHRoaXNcclxuICAgICAqIG1ha2VzIHRoZSBiZWhhdmlvdXIgb2YgX191bmlvbl93aXRoX3N0cmluZyBkaWZmZXJlbnQgY29tcGFyZWQgdG8gX191bmlvblxyXG4gICAgICovXHJcbiAgICBfX3VuaW9uX3dpdGhfc3RyaW5nKG8sIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19zdHJpbmcob2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX191bmlvbihvLCBvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcmVsYXRpdmUgb2Zmc2V0IHN0b3JlZCBhdCBcIm9mZnNldFwiXHJcbiAgICAgKi9cclxuICAgIF9faW5kaXJlY3Qob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RhcnQgb2YgZGF0YSBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIF9fdmVjdG9yKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpICsgU0laRU9GX0lOVDsgLy8gZGF0YSBzdGFydHMgYWZ0ZXIgdGhlIGxlbmd0aFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIF9fdmVjdG9yX2xlbihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XHJcbiAgICB9XHJcbiAgICBfX2hhc19pZGVudGlmaWVyKGlkZW50KSB7XHJcbiAgICAgICAgaWYgKGlkZW50Lmxlbmd0aCAhPSBGSUxFX0lERU5USUZJRVJfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcclxuICAgICAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaWRlbnQuY2hhckNvZGVBdChpKSAhPSB0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb24oKSArIFNJWkVPRl9JTlQgKyBpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBnZW5lcmF0ZWQgY29kZSBkZXBlbmRpbmcgb24gdGhpcyBmaWxlIGRpcmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVMb25nKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHJldHVybiBMb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBsaXN0IGZvciBvYmogYXBpXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNjYWxhckxpc3QobGlzdEFjY2Vzc29yLCBsaXN0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RBY2Nlc3NvcihpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2gobGlzdEFjY2Vzc29yKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBsaXN0IGZvciBvYmogYXBpXHJcbiAgICAgKiBAcGFyYW0gbGlzdEFjY2Vzc29yIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBpbmRleCBhbmQgcmV0dXJuIGRhdGEgYXQgdGhhdCBpbmRleFxyXG4gICAgICogQHBhcmFtIGxpc3RMZW5ndGggbGlzdExlbmd0aFxyXG4gICAgICogQHBhcmFtIHJlcyByZXN1bHQgbGlzdFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVPYmpMaXN0KGxpc3RBY2Nlc3NvciwgbGlzdExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGxpc3RBY2Nlc3NvcihpKTtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2godmFsLnVucGFjaygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBCeXRlQnVmZmVyIH0gZnJvbSBcIi4vYnl0ZS1idWZmZXJcIjtcclxuaW1wb3J0IHsgU0laRU9GX1NIT1JULCBTSVpFX1BSRUZJWF9MRU5HVEgsIFNJWkVPRl9JTlQsIEZJTEVfSURFTlRJRklFUl9MRU5HVEggfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgTG9uZyB9IGZyb20gXCIuL2xvbmdcIjtcclxuZXhwb3J0IGNsYXNzIEJ1aWxkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBGbGF0QnVmZmVyQnVpbGRlci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0X2luaXRpYWxfc2l6ZSkge1xyXG4gICAgICAgIC8qKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuICovXHJcbiAgICAgICAgdGhpcy5taW5hbGlnbiA9IDE7XHJcbiAgICAgICAgLyoqIFRoZSB2dGFibGUgZm9yIHRoZSBjdXJyZW50IHRhYmxlLiAqL1xyXG4gICAgICAgIHRoaXMudnRhYmxlID0gbnVsbDtcclxuICAgICAgICAvKiogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuICovXHJcbiAgICAgICAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcclxuICAgICAgICAvKiogV2hldGhlciB3ZSBhcmUgY3VycmVudGx5IHNlcmlhbGl6aW5nIGEgdGFibGUuICovXHJcbiAgICAgICAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKiBTdGFydGluZyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgc3RydWN0L3RhYmxlLiAqL1xyXG4gICAgICAgIHRoaXMub2JqZWN0X3N0YXJ0ID0gMDtcclxuICAgICAgICAvKiogTGlzdCBvZiBvZmZzZXRzIG9mIGFsbCB2dGFibGVzLiAqL1xyXG4gICAgICAgIHRoaXMudnRhYmxlcyA9IFtdO1xyXG4gICAgICAgIC8qKiBGb3IgdGhlIGN1cnJlbnQgdmVjdG9yIGJlaW5nIGJ1aWx0LiAqL1xyXG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XHJcbiAgICAgICAgLyoqIEZhbHNlIG9taXRzIGRlZmF1bHQgdmFsdWVzIGZyb20gdGhlIHNlcmlhbGl6ZWQgZGF0YSAqL1xyXG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0cmluZ19tYXBzID0gbnVsbDtcclxuICAgICAgICBsZXQgaW5pdGlhbF9zaXplO1xyXG4gICAgICAgIGlmICghb3B0X2luaXRpYWxfc2l6ZSkge1xyXG4gICAgICAgICAgICBpbml0aWFsX3NpemUgPSAxMDI0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5pdGlhbF9zaXplID0gb3B0X2luaXRpYWxfc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge0J5dGVCdWZmZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJiID0gQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xyXG4gICAgICAgIHRoaXMuc3BhY2UgPSBpbml0aWFsX3NpemU7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmJiLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5zcGFjZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcclxuICAgICAgICB0aGlzLm1pbmFsaWduID0gMTtcclxuICAgICAgICB0aGlzLnZ0YWJsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcclxuICAgICAgICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMudnRhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XHJcbiAgICAgICAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RyaW5nX21hcHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcclxuICAgICAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXHJcbiAgICAgKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9yY2VEZWZhdWx0cyB0cnVlIGFsd2F5cyBzZXJpYWxpemVzIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIGZvcmNlRGVmYXVsdHMoZm9yY2VEZWZhdWx0cykge1xyXG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmb3JjZURlZmF1bHRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIEJ5dGVCdWZmZXIgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcclxuICAgICAqIGNhbGxlZCBmaW5pc2goKS4gVGhlIGFjdHVhbCBkYXRhIHN0YXJ0cyBhdCB0aGUgQnl0ZUJ1ZmZlcidzIGN1cnJlbnQgcG9zaXRpb24sXHJcbiAgICAgKiBub3QgbmVjZXNzYXJpbHkgYXQgMC5cclxuICAgICAqL1xyXG4gICAgZGF0YUJ1ZmZlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBieXRlcyByZXByZXNlbnRpbmcgdGhlIEZsYXRCdWZmZXIuIE9ubHkgY2FsbCB0aGlzIGFmdGVyIHlvdSd2ZVxyXG4gICAgICogY2FsbGVkIGZpbmlzaCgpLlxyXG4gICAgICovXHJcbiAgICBhc1VpbnQ4QXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksIHRoaXMuYmIucG9zaXRpb24oKSArIHRoaXMub2Zmc2V0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlIHRvIHdyaXRlIGFuIGVsZW1lbnQgb2YgYHNpemVgIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYCBoYXZlIGJlZW5cclxuICAgICAqIHdyaXR0ZW4sIGUuZy4gaWYgeW91IHdyaXRlIGEgc3RyaW5nLCB5b3UgbmVlZCB0byBhbGlnbiBzdWNoIHRoZSBpbnQgbGVuZ3RoXHJcbiAgICAgKiBmaWVsZCBpcyBhbGlnbmVkIHRvIDQgYnl0ZXMsIGFuZCB0aGUgc3RyaW5nIGRhdGEgZm9sbG93cyBpdCBkaXJlY3RseS4gSWYgYWxsXHJcbiAgICAgKiB5b3UgbmVlZCB0byBkbyBpcyBhbGlnbm1lbnQsIGBhZGRpdGlvbmFsX2J5dGVzYCB3aWxsIGJlIDAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNpemUgVGhpcyBpcyB0aGUgb2YgdGhlIG5ldyBlbGVtZW50IHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbF9ieXRlcyBUaGUgcGFkZGluZyBzaXplXHJcbiAgICAgKi9cclxuICAgIHByZXAoc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBiaWdnZXN0IHRoaW5nIHdlJ3ZlIGV2ZXIgYWxpZ25lZCB0by5cclxuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMubWluYWxpZ24pIHtcclxuICAgICAgICAgICAgdGhpcy5taW5hbGlnbiA9IHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGFtb3VudCBvZiBhbGlnbm1lbnQgbmVlZGVkIHN1Y2ggdGhhdCBgc2l6ZWAgaXMgcHJvcGVybHlcclxuICAgICAgICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxyXG4gICAgICAgIGNvbnN0IGFsaWduX3NpemUgPSAoKH4odGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSArIGFkZGl0aW9uYWxfYnl0ZXMpKSArIDEpICYgKHNpemUgLSAxKTtcclxuICAgICAgICAvLyBSZWFsbG9jYXRlIHRoZSBidWZmZXIgaWYgbmVlZGVkLlxyXG4gICAgICAgIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcclxuICAgICAgICAgICAgdGhpcy5iYiA9IEJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYik7XHJcbiAgICAgICAgICAgIHRoaXMuc3BhY2UgKz0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gb2xkX2J1Zl9zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhZChhbGlnbl9zaXplKTtcclxuICAgIH1cclxuICAgIHBhZChieXRlX3NpemUpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQ4KC0tdGhpcy5zcGFjZSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQ4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZUludDE2KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW50NjQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJiLndyaXRlSW50NjQodGhpcy5zcGFjZSAtPSA4LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZUZsb2F0MzIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlRmxvYXQ2NCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRJbnQ4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDEsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQ4KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGBpbnQxNmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBpbnQxNmAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRJbnQxNih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucHJlcCgyLCAwKTtcclxuICAgICAgICB0aGlzLndyaXRlSW50MTYodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYGludDMyYCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGludDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGFkZEludDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDQsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50NjRgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgYWRkSW50NjQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnByZXAoOCwgMCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDY0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgYGZsb2F0MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgZmxvYXQzMmAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRGbG9hdDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDQsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRGbG9hdDY0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDgsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDY0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGFkZEZpZWxkSW50OCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEludDE2KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEludDMyKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEludDY0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCAhdmFsdWUuZXF1YWxzKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEZsb2F0MzIodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEZsb2F0MzIodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkRmllbGRGbG9hdDY0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRGbG9hdDY0KHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZEZpZWxkT2Zmc2V0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRPZmZzZXQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJ1Y3RzIGFyZSBzdG9yZWQgaW5saW5lLCBzbyBub3RoaW5nIGFkZGl0aW9uYWwgaXMgYmVpbmcgYWRkZWQuIGBkYCBpcyBhbHdheXMgMC5cclxuICAgICAqL1xyXG4gICAgYWRkRmllbGRTdHJ1Y3Qodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXN0ZWQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJ1Y3R1cmVzIGFyZSBhbHdheXMgc3RvcmVkIGlubGluZSwgdGhleSBuZWVkIHRvIGJlIGNyZWF0ZWQgcmlnaHRcclxuICAgICAqIHdoZXJlIHRoZXkncmUgdXNlZC4gIFlvdSdsbCBnZXQgdGhpcyBhc3NlcnRpb24gZmFpbHVyZSBpZiB5b3VcclxuICAgICAqIGNyZWF0ZWQgaXQgZWxzZXdoZXJlLlxyXG4gICAgICovXHJcbiAgICBuZXN0ZWQob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXHJcbiAgICAgKiB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgY29uc3RydWN0ZWRcclxuICAgICAqL1xyXG4gICAgbm90TmVzdGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVzdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY3VycmVudCB2dGFibGUgYXQgYHZvZmZzZXRgIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHNsb3Qodm9mZnNldCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBvZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXHJcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJiIFRoZSBjdXJyZW50IGJ1ZmZlciB3aXRoIHRoZSBleGlzdGluZyBkYXRhXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcclxuICAgICAqIHRvIGl0LiBUaGUgZGF0YSBpcyBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcclxuICAgICAqIGl0IGEgdWludDhBcnJheSB3ZSBuZWVkIHRvIHN1cHByZXNzIHRoZSB0eXBlIGNoZWNrOlxyXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ3Jvd0J5dGVCdWZmZXIoYmIpIHtcclxuICAgICAgICBjb25zdCBvbGRfYnVmX3NpemUgPSBiYi5jYXBhY2l0eSgpO1xyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBncm93IGJleW9uZCB3aGF0IGZpdHMgaW4gYW4gaW50LlxyXG4gICAgICAgIGlmIChvbGRfYnVmX3NpemUgJiAweEMwMDAwMDAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld19idWZfc2l6ZSA9IG9sZF9idWZfc2l6ZSA8PCAxO1xyXG4gICAgICAgIGNvbnN0IG5iYiA9IEJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcclxuICAgICAgICBuYmIuc2V0UG9zaXRpb24obmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcclxuICAgICAgICBuYmIuYnl0ZXMoKS5zZXQoYmIuYnl0ZXMoKSwgbmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcclxuICAgICAgICByZXR1cm4gbmJiO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uIG9mZnNldCwgcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2lsbCBiZSB3cml0dGVuLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGFkZE9mZnNldChvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLnByZXAoU0laRU9GX0lOVCwgMCk7IC8vIEVuc3VyZSBhbGlnbm1lbnQgaXMgYWxyZWFkeSBkb25lLlxyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgU0laRU9GX0lOVCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGVuY29kaW5nIGEgbmV3IG9iamVjdCBpbiB0aGUgYnVmZmVyLiAgVXNlcnMgd2lsbCBub3QgdXN1YWxseSBuZWVkIHRvXHJcbiAgICAgKiBjYWxsIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGdlbmVyYXRlIGhlbHBlciBtZXRob2RzXHJcbiAgICAgKiB0aGF0IGNhbGwgdGhpcyBtZXRob2QgaW50ZXJuYWxseS5cclxuICAgICAqL1xyXG4gICAgc3RhcnRPYmplY3QobnVtZmllbGRzKSB7XHJcbiAgICAgICAgdGhpcy5ub3ROZXN0ZWQoKTtcclxuICAgICAgICBpZiAodGhpcy52dGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZ0YWJsZSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZ0YWJsZV9pbl91c2UgPSBudW1maWVsZHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZ0YWJsZVtpXSA9IDA7IC8vIFRoaXMgd2lsbCBwdXNoIGFkZGl0aW9uYWwgZWxlbWVudHMgYXMgbmVlZGVkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMub2JqZWN0X3N0YXJ0ID0gdGhpcy5vZmZzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIG9mZiB3cml0aW5nIHRoZSBvYmplY3QgdGhhdCBpcyB1bmRlciBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCB0byB0aGUgb2JqZWN0IGluc2lkZSBgZGF0YUJ1ZmZlcmBcclxuICAgICAqL1xyXG4gICAgZW5kT2JqZWN0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsIHx8ICF0aGlzLmlzTmVzdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGVuZE9iamVjdCBjYWxsZWQgd2l0aG91dCBzdGFydE9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZEludDMyKDApO1xyXG4gICAgICAgIGNvbnN0IHZ0YWJsZWxvYyA9IHRoaXMub2Zmc2V0KCk7XHJcbiAgICAgICAgLy8gVHJpbSB0cmFpbGluZyB6ZXJvZXMuXHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLnZ0YWJsZV9pbl91c2UgLSAxO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxyXG4gICAgICAgIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7IH1cclxuICAgICAgICBjb25zdCB0cmltbWVkX3NpemUgPSBpICsgMTtcclxuICAgICAgICAvLyBXcml0ZSBvdXQgdGhlIGN1cnJlbnQgdnRhYmxlLlxyXG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAvLyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZS5cclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVtpXSAhPSAwID8gdnRhYmxlbG9jIC0gdGhpcy52dGFibGVbaV0gOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRfZmllbGRzID0gMjsgLy8gVGhlIGZpZWxkcyBiZWxvdzpcclxuICAgICAgICB0aGlzLmFkZEludDE2KHZ0YWJsZWxvYyAtIHRoaXMub2JqZWN0X3N0YXJ0KTtcclxuICAgICAgICBjb25zdCBsZW4gPSAodHJpbW1lZF9zaXplICsgc3RhbmRhcmRfZmllbGRzKSAqIFNJWkVPRl9TSE9SVDtcclxuICAgICAgICB0aGlzLmFkZEludDE2KGxlbik7XHJcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhbiBleGlzdGluZyB2dGFibGUgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IG9uZS5cclxuICAgICAgICBsZXQgZXhpc3RpbmdfdnRhYmxlID0gMDtcclxuICAgICAgICBjb25zdCB2dDEgPSB0aGlzLnNwYWNlO1xyXG4gICAgICAgIG91dGVyX2xvb3A6IGZvciAoaSA9IDA7IGkgPCB0aGlzLnZ0YWJsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdnQyID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy52dGFibGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGVuID09IHRoaXMuYmIucmVhZEludDE2KHZ0MikpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBTSVpFT0ZfU0hPUlQ7IGogPCBsZW47IGogKz0gU0laRU9GX1NIT1JUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmIucmVhZEludDE2KHZ0MSArIGopICE9IHRoaXMuYmIucmVhZEludDE2KHZ0MiArIGopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyX2xvb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdfdnRhYmxlID0gdGhpcy52dGFibGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nX3Z0YWJsZSkge1xyXG4gICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoOlxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxyXG4gICAgICAgICAgICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jO1xyXG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXHJcbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLCBleGlzdGluZ192dGFibGUgLSB2dGFibGVsb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gbWF0Y2g6XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgdnRhYmxlIHRvIHRoZSBsaXN0IG9mIHZ0YWJsZXMuXHJcbiAgICAgICAgICAgIHRoaXMudnRhYmxlcy5wdXNoKHRoaXMub2Zmc2V0KCkpO1xyXG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBjdXJyZW50IHZ0YWJsZS5cclxuICAgICAgICAgICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuYmIuY2FwYWNpdHkoKSAtIHZ0YWJsZWxvYywgdGhpcy5vZmZzZXQoKSAtIHZ0YWJsZWxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdnRhYmxlbG9jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGl6ZSBhIGJ1ZmZlciwgcG9pdGluZyB0byB0aGUgZ2l2ZW4gYHJvb3RfdGFibGVgLlxyXG4gICAgICovXHJcbiAgICBmaW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgb3B0X3NpemVfcHJlZml4KSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZV9wcmVmaXggPSBvcHRfc2l6ZV9wcmVmaXggPyBTSVpFX1BSRUZJWF9MRU5HVEggOiAwO1xyXG4gICAgICAgIGlmIChvcHRfZmlsZV9pZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVfaWRlbnRpZmllciA9IG9wdF9maWxlX2lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBTSVpFT0ZfSU5UICtcclxuICAgICAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlX2lkZW50aWZpZXIubGVuZ3RoICE9IEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcclxuICAgICAgICAgICAgICAgICAgICBGSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gRklMRV9JREVOVElGSUVSX0xFTkdUSCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW50OChmaWxlX2lkZW50aWZpZXIuY2hhckNvZGVBdChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmVwKHRoaXMubWluYWxpZ24sIFNJWkVPRl9JTlQgKyBzaXplX3ByZWZpeCk7XHJcbiAgICAgICAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XHJcbiAgICAgICAgaWYgKHNpemVfcHJlZml4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsaXplIGEgc2l6ZSBwcmVmaXhlZCBidWZmZXIsIHBvaW50aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXHJcbiAgICAgKi9cclxuICAgIGZpbmlzaFNpemVQcmVmaXhlZChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XHJcbiAgICAgICAgdGhpcy5maW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcclxuICAgICAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cclxuICAgICAqL1xyXG4gICAgcmVxdWlyZWRGaWVsZCh0YWJsZSwgZmllbGQpIHtcclxuICAgICAgICBjb25zdCB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xyXG4gICAgICAgIGNvbnN0IHZ0YWJsZV9zdGFydCA9IHRhYmxlX3N0YXJ0IC0gdGhpcy5iYi5yZWFkSW50MzIodGFibGVfc3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IG9rID0gdGhpcy5iYi5yZWFkSW50MTYodnRhYmxlX3N0YXJ0ICsgZmllbGQpICE9IDA7XHJcbiAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgdGhlIGNhbGxlciB3aWxsIHNob3cgd2hhdCBmaWVsZCBuZWVkcyB0byBiZSBzZXQuXHJcbiAgICAgICAgaWYgKCFvaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWVsZCAnICsgZmllbGQgKyAnIG11c3QgYmUgc2V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhIG5ldyBhcnJheS92ZWN0b3Igb2Ygb2JqZWN0cy4gIFVzZXJzIHVzdWFsbHkgd2lsbCBub3QgY2FsbFxyXG4gICAgICogdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgY3JlYXRlIGEgc3RhcnQvZW5kXHJcbiAgICAgKiBtZXRob2QgZm9yIHZlY3RvciB0eXBlcyBpbiBnZW5lcmF0ZWQgY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWxlbV9zaXplIFRoZSBzaXplIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlcclxuICAgICAqIEBwYXJhbSBudW1fZWxlbXMgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcclxuICAgICAqIEBwYXJhbSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudCBvZiB0aGUgYXJyYXlcclxuICAgICAqL1xyXG4gICAgc3RhcnRWZWN0b3IoZWxlbV9zaXplLCBudW1fZWxlbXMsIGFsaWdubWVudCkge1xyXG4gICAgICAgIHRoaXMubm90TmVzdGVkKCk7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gbnVtX2VsZW1zO1xyXG4gICAgICAgIHRoaXMucHJlcChTSVpFT0ZfSU5ULCBlbGVtX3NpemUgKiBudW1fZWxlbXMpO1xyXG4gICAgICAgIHRoaXMucHJlcChhbGlnbm1lbnQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7IC8vIEp1c3QgaW4gY2FzZSBhbGlnbm1lbnQgPiBpbnQuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBvZmYgdGhlIGNyZWF0aW9uIG9mIGFuIGFycmF5IGFuZCBhbGwgaXRzIGVsZW1lbnRzLiBUaGUgYXJyYXkgbXVzdCBiZVxyXG4gICAgICogY3JlYXRlZCB3aXRoIGBzdGFydFZlY3RvcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCBhdCB3aGljaCB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxyXG4gICAgICogc3RhcnRzLlxyXG4gICAgICovXHJcbiAgICBlbmRWZWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiB0aGUgc3RyaW5nIHBhc3NlZCBoYXNcclxuICAgICAqIGFscmVhZHkgYmVlbiBzZWVuLCB3ZSByZXR1cm4gdGhlIG9mZnNldCBvZiB0aGUgYWxyZWFkeSB3cml0dGVuIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzIFRoZSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgZW5jb2RlZCBzdHJpbmcgc3RhcnRzXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNoYXJlZFN0cmluZyhzKSB7XHJcbiAgICAgICAgaWYgKCFzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuc3RyaW5nX21hcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHJpbmdfbWFwcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nX21hcHMuaGFzKHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ19tYXBzLmdldChzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jcmVhdGVTdHJpbmcocyk7XHJcbiAgICAgICAgdGhpcy5zdHJpbmdfbWFwcy5zZXQocywgb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGUgdGhlIHN0cmluZyBgc2AgaW4gdGhlIGJ1ZmZlciB1c2luZyBVVEYtOC4gSWYgYSBVaW50OEFycmF5IGlzIHBhc3NlZFxyXG4gICAgICogaW5zdGVhZCBvZiBhIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBjb250YWluIHZhbGlkIFVURi04IGVuY29kZWQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxyXG4gICAgICogQHJldHVybiBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xyXG4gICAgICovXHJcbiAgICBjcmVhdGVTdHJpbmcocykge1xyXG4gICAgICAgIGlmICghcykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHV0Zjg7XHJcbiAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgICAgIHV0ZjggPSBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXRmOCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2RlUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgVVRGLTE2XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gcy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDB4RDgwMCB8fCBhID49IDB4REMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gcy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRW5jb2RlIFVURi04XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaChjb2RlUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4LnB1c2goKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNGKSB8IDB4ODApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4M0YpIHwgMHg4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaCgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZEludDgoMCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFZlY3RvcigxLCB1dGY4Lmxlbmd0aCwgMSk7XHJcbiAgICAgICAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlIC09IHV0ZjgubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IHV0ZjhbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBnZW5lcmF0ZWQgY29kZSBkZXBlbmRpbmcgb24gdGhpcyBmaWxlIGRpcmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVMb25nKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHJldHVybiBMb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBwYWNrIGFuIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIG9mZnNldCBvZiBvYmpcclxuICAgICAqL1xyXG4gICAgY3JlYXRlT2JqZWN0T2Zmc2V0KG9iaikge1xyXG4gICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmcob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoucGFjayh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHBhY2sgYSBsaXN0IG9mIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGxpc3Qgb2Ygb2Zmc2V0cyBvZiBlYWNoIG5vbiBudWxsIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVPYmplY3RPZmZzZXRMaXN0KGxpc3QpIHtcclxuICAgICAgICBjb25zdCByZXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2godGhpcy5jcmVhdGVPYmplY3RPZmZzZXQodmFsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBBcmd1bWVudCBmb3IgY3JlYXRlT2JqZWN0T2Zmc2V0TGlzdCBjYW5ub3QgY29udGFpbiBudWxsLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVTdHJ1Y3RPZmZzZXRMaXN0KGxpc3QsIHN0YXJ0RnVuYykge1xyXG4gICAgICAgIHN0YXJ0RnVuYyh0aGlzLCBsaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVPYmplY3RPZmZzZXRMaXN0KGxpc3QpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xyXG4gICAgfVxyXG59XHJcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IHsgRHVja0RCQmluZGluZ3MgfSBmcm9tICcuL2JpbmRpbmdzX2ludGVyZmFjZSc7XG5pbXBvcnQgeyBDU1ZJbnNlcnRPcHRpb25zLCBKU09OSW5zZXJ0T3B0aW9ucywgQXJyb3dJbnNlcnRPcHRpb25zIH0gZnJvbSAnLi9pbnNlcnRfb3B0aW9ucyc7XG5cbi8qKiBBIHRoaW4gaGVscGVyIHRvIGJpbmQgdGhlIGNvbm5lY3Rpb24gaWQgYW5kIHRhbGsgcmVjb3JkIGJhdGNoZXMgKi9cbmV4cG9ydCBjbGFzcyBEdWNrREJDb25uZWN0aW9uIHtcbiAgICAvKiogVGhlIGJpbmRpbmdzICovXG4gICAgcHJvdGVjdGVkIF9iaW5kaW5nczogRHVja0RCQmluZGluZ3M7XG4gICAgLyoqIFRoZSBjb25uZWN0aW9uIGhhbmRsZSAqL1xuICAgIHByb3RlY3RlZCBfY29ubjogbnVtYmVyO1xuXG4gICAgLyoqIENvbnN0cnVjdG9yICovXG4gICAgY29uc3RydWN0b3IoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25uOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5fY29ubiA9IGNvbm47XG4gICAgfVxuXG4gICAgLyoqIENsb3NlIGEgY29ubmVjdGlvbiAqL1xuICAgIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ3MuZGlzY29ubmVjdCh0aGlzLl9jb25uKTtcbiAgICB9XG5cbiAgICAvKiogQnJhdmUgc291bHMgbWF5IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbnN1bWUgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBpZCAqL1xuICAgIHB1YmxpYyB1c2VVbnNhZmU8Uj4oY2FsbGJhY2s6IChiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIGNvbm46IG51bWJlcikgPT4gUikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4pO1xuICAgIH1cblxuICAgIC8qKiBSdW4gYSBxdWVyeSAqL1xuICAgIHB1YmxpYyBxdWVyeTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55Pih0ZXh0OiBzdHJpbmcpOiBhcnJvdy5UYWJsZTxUPiB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2JpbmRpbmdzLnJ1blF1ZXJ5KHRoaXMuX2Nvbm4sIHRleHQpO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGJ1ZmZlcik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0ZpbGUoKSk7XG4gICAgICAgIHJldHVybiBuZXcgYXJyb3cuVGFibGUocmVhZGVyKTtcbiAgICB9XG5cbiAgICAvKiogU2VuZCBhIHF1ZXJ5ICovXG4gICAgcHVibGljIGFzeW5jIHNlbmQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYXJyb3cuRGF0YVR5cGUgfSA9IGFueT4oXG4gICAgICAgIHRleHQ6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPGFycm93LlJlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+PiB7XG4gICAgICAgIGxldCBoZWFkZXIgPSB0aGlzLl9iaW5kaW5ncy5zdGFydFBlbmRpbmdRdWVyeSh0aGlzLl9jb25uLCB0ZXh0KTtcbiAgICAgICAgd2hpbGUgKGhlYWRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBoZWFkZXIgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9iaW5kaW5ncy5wb2xsUGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4pKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUmVzdWx0U3RyZWFtSXRlcmF0b3IodGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4sIGhlYWRlcik7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGFycm93LlJlY29yZEJhdGNoUmVhZGVyLmZyb208VD4oaXRlcik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N0cmVhbSgpKTtcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG5cbiAgICAvKiogQ2FuY2VsIGEgcXVlcnkgdGhhdCB3YXMgc2VudCBlYXJsaWVyICovXG4gICAgcHVibGljIGNhbmNlbFNlbnQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5ncy5jYW5jZWxQZW5kaW5nUXVlcnkodGhpcy5fY29ubik7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0YWJsZSBuYW1lcyAqL1xuICAgIHB1YmxpYyBnZXRUYWJsZU5hbWVzKHF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iaW5kaW5ncy5nZXRUYWJsZU5hbWVzKHRoaXMuX2Nvbm4sIHF1ZXJ5KTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXG4gICAgcHVibGljIHByZXBhcmU8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYXJyb3cuRGF0YVR5cGUgfSA9IGFueT4odGV4dDogc3RyaW5nKTogUHJlcGFyZWRTdGF0ZW1lbnQge1xuICAgICAgICBjb25zdCBzdG10ID0gdGhpcy5fYmluZGluZ3MuY3JlYXRlUHJlcGFyZWQodGhpcy5fY29ubiwgdGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcGFyZWRTdGF0ZW1lbnQ8VD4odGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4sIHN0bXQpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBzY2FsYXIgZnVuY3Rpb24gKi9cbiAgICBwdWJsaWMgY3JlYXRlU2NhbGFyRnVuY3Rpb24obmFtZTogc3RyaW5nLCByZXR1cm5zOiBhcnJvdy5EYXRhVHlwZSwgZnVuYzogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKHRoaXMuX2Nvbm4sIG5hbWUsIHJldHVybnMsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKiBJbnNlcnQgYW4gYXJyb3cgdGFibGUgKi9cbiAgICBwdWJsaWMgaW5zZXJ0QXJyb3dUYWJsZSh0YWJsZTogYXJyb3cuVGFibGUsIG9wdGlvbnM6IEFycm93SW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xuXHRjb25zdCBidWZmZXIgPSBhcnJvdy50YWJsZVRvSVBDKHRhYmxlLCAnc3RyZWFtJyk7XG4gICAgICAgIHRoaXMuaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKGJ1ZmZlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnQgYW4gYXJyb3cgdGFibGUgZnJvbSBhbiBpcGMgc3RyZWFtICovXG4gICAgcHVibGljIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM6IEFycm93SW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9iaW5kaW5ncy5pbnNlcnRBcnJvd0Zyb21JUENTdHJlYW0odGhpcy5fY29ubiwgYnVmZmVyLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKiogSW5lc3J0IGNzdiBmaWxlIGZyb20gcGF0aCAqL1xuICAgIHB1YmxpYyBpbnNlcnRDU1ZGcm9tUGF0aChwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IENTVkluc2VydE9wdGlvbnMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ3MuaW5zZXJ0Q1NWRnJvbVBhdGgodGhpcy5fY29ubiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnQganNvbiBmaWxlIGZyb20gcGF0aCAqL1xuICAgIHB1YmxpYyBpbnNlcnRKU09ORnJvbVBhdGgocGF0aDogc3RyaW5nLCBvcHRpb25zOiBKU09OSW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9iaW5kaW5ncy5pbnNlcnRKU09ORnJvbVBhdGgodGhpcy5fY29ubiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG4vKiogQSByZXN1bHQgc3RyZWFtIGl0ZXJhdG9yICovXG5leHBvcnQgY2xhc3MgUmVzdWx0U3RyZWFtSXRlcmF0b3IgaW1wbGVtZW50cyBJdGVyYWJsZTxVaW50OEFycmF5PiB7XG4gICAgLyoqIEZpcnN0IGNodW5rPyAqL1xuICAgIF9maXJzdDogYm9vbGVhbjtcbiAgICAvKiogUmVhY2hlZCBlbmQgb2Ygc3RyZWFtPyAqL1xuICAgIF9kZXBsZXRlZDogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIHByb3RlY3RlZCBjb25uOiBudW1iZXIsIHByb3RlY3RlZCBoZWFkZXI6IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgdGhpcy5fZmlyc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZXBsZXRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5leHQoKTogSXRlcmF0b3JSZXN1bHQ8VWludDhBcnJheT4ge1xuICAgICAgICBpZiAodGhpcy5fZmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMuaGVhZGVyIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlcGxldGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlckk4ID0gdGhpcy5iaW5kaW5ncy5mZXRjaFF1ZXJ5UmVzdWx0cyh0aGlzLmNvbm4pO1xuICAgICAgICB0aGlzLl9kZXBsZXRlZCA9IGJ1ZmZlckk4Lmxlbmd0aCA9PSAwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdGhpcy5fZGVwbGV0ZWQsXG4gICAgICAgICAgICB2YWx1ZTogYnVmZmVySTgsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqIEEgdGhpbiBoZWxwZXIgdG8gYmluZCB0aGUgcHJlcGFyZWQgc3RhdGVtZW50IGlkKi9cbmV4cG9ydCBjbGFzcyBQcmVwYXJlZFN0YXRlbWVudDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PiB7XG4gICAgLyoqIFRoZSBiaW5kaW5ncyAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBiaW5kaW5nczogRHVja0RCQmluZGluZ3M7XG4gICAgLyoqIFRoZSBjb25uZWN0aW9uIGlkICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbm5lY3Rpb25JZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgc3RhdGVtZW50IGlkICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0YXRlbWVudElkOiBudW1iZXI7XG5cbiAgICAvKiogQ29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIGNvbm5lY3Rpb25JZDogbnVtYmVyLCBzdGF0ZW1lbnRJZDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50SWQgPSBzdGF0ZW1lbnRJZDtcbiAgICB9XG5cbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cbiAgICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MuY2xvc2VQcmVwYXJlZCh0aGlzLmNvbm5lY3Rpb25JZCwgdGhpcy5zdGF0ZW1lbnRJZCk7XG4gICAgfVxuXG4gICAgLyoqIFJ1biBhIHByZXBhcmVkIHN0YXRlbWVudCAqL1xuICAgIHB1YmxpYyBxdWVyeSguLi5wYXJhbXM6IGFueVtdKTogYXJyb3cuVGFibGU8VD4ge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJpbmRpbmdzLnJ1blByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGJ1ZmZlcik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0ZpbGUoKSk7XG4gICAgICAgIHJldHVybiBuZXcgYXJyb3cuVGFibGUocmVhZGVyIGFzIGFycm93LlJlY29yZEJhdGNoRmlsZVJlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqIFNlbmQgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cbiAgICBwdWJsaWMgc2VuZCguLi5wYXJhbXM6IGFueVtdKTogYXJyb3cuUmVjb3JkQmF0Y2hTdHJlYW1SZWFkZXI8VD4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSB0aGlzLmJpbmRpbmdzLnNlbmRQcmVwYXJlZCh0aGlzLmNvbm5lY3Rpb25JZCwgdGhpcy5zdGF0ZW1lbnRJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBSZXN1bHRTdHJlYW1JdGVyYXRvcih0aGlzLmJpbmRpbmdzLCB0aGlzLmNvbm5lY3Rpb25JZCwgaGVhZGVyKTtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihpdGVyKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3luYygpKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3RyZWFtKCkpO1xuICAgICAgICByZXR1cm4gcmVhZGVyIGFzIGFycm93LlJlY29yZEJhdGNoU3RyZWFtUmVhZGVyO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBEdWNrREJSdW50aW1lIH0gZnJvbSAnLi9ydW50aW1lJztcbmltcG9ydCB7IER1Y2tEQk1vZHVsZSB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XG5cbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuXG5mdW5jdGlvbiBzdG9yZUVycm9yKG1vZDogRHVja0RCTW9kdWxlLCByZXNwb25zZTogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBtc2dCdWZmZXIgPSBURVhUX0VOQ09ERVIuZW5jb2RlKG1lc3NhZ2UpO1xuICAgIGNvbnN0IGhlYXBBZGRyID0gbW9kLl9tYWxsb2MobXNnQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIGNvbnN0IGhlYXBBcnJheSA9IG1vZC5IRUFQVTguc3ViYXJyYXkoaGVhcEFkZHIsIGhlYXBBZGRyICsgbXNnQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIGhlYXBBcnJheS5zZXQobXNnQnVmZmVyKTtcbiAgICBtb2QuSEVBUEY2NFsocmVzcG9uc2UgPj4gMykgKyAwXSA9IDE7XG4gICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMV0gPSBoZWFwQWRkcjtcbiAgICBtb2QuSEVBUEY2NFsocmVzcG9uc2UgPj4gMykgKyAyXSA9IGhlYXBBcnJheS5ieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBnZXRUeXBlU2l6ZShwdHlwZTogc3RyaW5nKSB7XG4gICAgc3dpdGNoIChwdHlwZSkge1xuICAgICAgICBjYXNlICdVSU5UOCc6XG4gICAgICAgIGNhc2UgJ0lOVDgnOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgJ0lOVDMyJzpcbiAgICAgICAgY2FzZSAnRkxPQVQnOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGNhc2UgJ0lOVDY0JzpcbiAgICAgICAgY2FzZSAnVUlOVDY0JzpcbiAgICAgICAgY2FzZSAnRE9VQkxFJzpcbiAgICAgICAgY2FzZSAnVkFSQ0hBUic6XG4gICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHRyVG9BcnJheShtb2Q6IER1Y2tEQk1vZHVsZSwgcHRyOiBudW1iZXIsIHB0eXBlOiBzdHJpbmcsIG46IG51bWJlcikge1xuICAgIGNvbnN0IGhlYXAgPSBtb2QuSEVBUFU4LnN1YmFycmF5KHB0ciwgcHRyICsgbiAqIGdldFR5cGVTaXplKHB0eXBlKSk7XG4gICAgc3dpdGNoIChwdHlwZSkge1xuICAgICAgICBjYXNlICdVSU5UOCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XG4gICAgICAgIGNhc2UgJ0lOVDgnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQ4QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XG4gICAgICAgIGNhc2UgJ0lOVDMyJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcbiAgICAgICAgY2FzZSAnRkxPQVQnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XG4gICAgICAgIGNhc2UgJ0RPVUJMRSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcbiAgICAgICAgY2FzZSAnVkFSQ0hBUic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXk8c3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbD4oMCk7IC8vIGNvdWdoXG4gICAgfVxufVxuXG5mdW5jdGlvbiBwdHJUb1VpbnQ4QXJyYXkobW9kOiBEdWNrREJNb2R1bGUsIHB0cjogbnVtYmVyLCBuOiBudW1iZXIpIHtcbiAgICBjb25zdCBoZWFwID0gbW9kLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIG4pO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcbn1cbmZ1bmN0aW9uIHB0clRvRmxvYXQ2NEFycmF5KG1vZDogRHVja0RCTW9kdWxlLCBwdHI6IG51bWJlciwgbjogbnVtYmVyKSB7XG4gICAgY29uc3QgaGVhcCA9IG1vZC5IRUFQVTguc3ViYXJyYXkocHRyLCBwdHIgKyBuICogOCk7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XG59XG5cbmludGVyZmFjZSBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbiB7XG4gICAgbmFtZT86IHN0cmluZztcbiAgICBzcWxUeXBlOiBzdHJpbmc7XG4gICAgcGh5c2ljYWxUeXBlOiBzdHJpbmc7XG4gICAgdmFsaWRpdHlCdWZmZXI/OiBudW1iZXI7XG4gICAgZGF0YUJ1ZmZlcj86IG51bWJlcjtcbiAgICBsZW5ndGhCdWZmZXI/OiBudW1iZXI7XG4gICAgY2hpbGRyZW4/OiBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbltdO1xufVxuXG5pbnRlcmZhY2UgUmV0dXJuVHlwZURlc2NyaXB0aW9uIHtcbiAgICBzcWxUeXBlOiBzdHJpbmc7XG4gICAgcGh5c2ljYWxUeXBlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTY2hlbWFEZXNjcmlwdGlvbiB7XG4gICAgcm93czogbnVtYmVyO1xuICAgIGFyZ3M6IEFyZ3VtZW50VHlwZURlc2NyaXB0aW9uW107XG4gICAgcmV0OiBSZXR1cm5UeXBlRGVzY3JpcHRpb247XG59XG5cbnR5cGUgQXJndW1lbnRSZXNvbHZlciA9IChyb3c6IG51bWJlcikgPT4gYW55IHwgbnVsbDtcblxuLy8gdGhpcyBpcyBjYWxsZWQgZnJvbSB3ZWJkYi5jYy9DYWxsU2NhbGFyVURGRnVuY3Rpb24sIGNoYW5nZXMgaGVyZSBuZWVkIHRvIGJlIG1hdGNoZWQgdGhlcmVcbmV4cG9ydCBmdW5jdGlvbiBjYWxsU2NhbGFyVURGKFxuICAgIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsXG4gICAgbW9kOiBEdWNrREJNb2R1bGUsXG4gICAgcmVzcG9uc2U6IG51bWJlcixcbiAgICBmdW5jSWQ6IG51bWJlcixcbiAgICBkZXNjUHRyOiBudW1iZXIsXG4gICAgZGVzY1NpemU6IG51bWJlcixcbiAgICBwdHJzUHRyOiBudW1iZXIsXG4gICAgcHRyc1NpemU6IG51bWJlcixcbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVkZiA9IHJ1bnRpbWUuX3VkZkZ1bmN0aW9ucy5nZXQoZnVuY0lkKTtcbiAgICAgICAgaWYgKCF1ZGYpIHtcbiAgICAgICAgICAgIHN0b3JlRXJyb3IobW9kLCByZXNwb25zZSwgJ1Vua25vd24gVURGIHdpdGggaWQ6ICcgKyBmdW5jSWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0Rlc2MgPSBURVhUX0RFQ09ERVIuZGVjb2RlKG1vZC5IRUFQVTguc3ViYXJyYXkoZGVzY1B0ciwgZGVzY1B0ciArIGRlc2NTaXplKSk7XG4gICAgICAgIGNvbnN0IGRlc2MgPSBKU09OLnBhcnNlKHJhd0Rlc2MpIGFzIFNjaGVtYURlc2NyaXB0aW9uO1xuICAgICAgICBjb25zdCBwdHJzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCBwdHJzUHRyLCBwdHJzU2l6ZSAvIDgpO1xuXG4gICAgICAgIGNvbnN0IGJ1aWxkUmVzb2x2ZXIgPSAoYXJnOiBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbik6IEFyZ3VtZW50UmVzb2x2ZXIgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbGlkaXR5OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYXJnLnZhbGlkaXR5QnVmZmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGl0eSA9IHB0clRvVWludDhBcnJheShtb2QsIHB0cnNbYXJnLnZhbGlkaXR5QnVmZmVyXSBhcyBudW1iZXIsIGRlc2Mucm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZy5waHlzaWNhbFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdWQVJDSEFSJzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmRhdGFCdWZmZXIgPT09IG51bGwgfHwgYXJnLmRhdGFCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgZGF0YSB2aWV3LCBleHBlY3RlZCBkYXRhIGJ1ZmZlciBmb3IgVkFSQ0hBUiBhcmd1bWVudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoQnVmZmVyID09PSBudWxsIHx8IGFyZy5sZW5ndGhCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYWxmb3JtZWQgZGF0YSB2aWV3LCBleHBlY3RlZCBkYXRhIGxlbmd0aCBidWZmZXIgZm9yIFZBUkNIQVIgYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBwdHJUb0FycmF5KG1vZCwgcHRyc1thcmcuZGF0YUJ1ZmZlcl0gYXMgbnVtYmVyLCBhcmcucGh5c2ljYWxUeXBlLCBkZXNjLnJvd3MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdzOiAoc3RyaW5nIHwgbnVsbClbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdMZW5ndGhzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCBwdHJzW2FyZy5sZW5ndGhCdWZmZXJdIGFzIG51bWJlciwgZGVzYy5yb3dzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjLnJvd3M7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5ICE9IG51bGwgJiYgIXZhbGlkaXR5W2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViYXJyYXkgPSBtb2QuSEVBUFU4LnN1YmFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1tqXSBhcyBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJhd1tqXSBhcyBudW1iZXIpICsgKHN0cmluZ0xlbmd0aHNbal0gYXMgbnVtYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBURVhUX0RFQ09ERVIuZGVjb2RlKHN1YmFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChzdHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IHN0cmluZ3Nbcm93XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnU1RSVUNUJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXA6IGFueSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbjogQXJndW1lbnRSZXNvbHZlcltdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgKGFyZy5jaGlsZHJlbj8ubGVuZ3RoIHx8IDApOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhcmcuY2hpbGRyZW4hW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBidWlsZFJlc29sdmVyKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCgocm93OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbYXR0ci5uYW1lIV0gPSBjaGlsZChyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkaXR5IVtyb3ddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc29sdmVyIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzb2x2ZXIgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIocm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmRhdGFCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYWxmb3JtZWQgZGF0YSB2aWV3LCBleHBlY3RlZCBkYXRhIGJ1ZmZlciBmb3IgYXJndW1lbnQgb2YgdHlwZTogJyArIGFyZy5waHlzaWNhbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwdHJUb0FycmF5KG1vZCwgcHRyc1thcmcuZGF0YUJ1ZmZlcl0gYXMgbnVtYmVyLCBhcmcucGh5c2ljYWxUeXBlLCBkZXNjLnJvd3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRpdHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4gKCF2YWxpZGl0eSFbcm93XSA/IG51bGwgOiBkYXRhW3Jvd10pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4gZGF0YVtyb3ddO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRyYW5zbGF0ZSBhcmd1bWVudCBkYXRhXG4gICAgICAgIGNvbnN0IGFyZ1Jlc29sdmVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2MuYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYXJnUmVzb2x2ZXJzLnB1c2goYnVpbGRSZXNvbHZlcihkZXNjLmFyZ3NbaV0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBhcmUgcmVzdWx0IGJ1ZmZlcnNcbiAgICAgICAgLy8gVE9ETzogd2UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhvc2UgZXZlcnkgdGltZVxuICAgICAgICBjb25zdCByZXN1bHREYXRhTGVuID0gZGVzYy5yb3dzICogZ2V0VHlwZVNpemUoZGVzYy5yZXQucGh5c2ljYWxUeXBlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0RGF0YVB0ciA9IG1vZC5fbWFsbG9jKHJlc3VsdERhdGFMZW4pO1xuICAgICAgICBjb25zdCByZXN1bHREYXRhID0gcHRyVG9BcnJheShtb2QsIHJlc3VsdERhdGFQdHIsIGRlc2MucmV0LnBoeXNpY2FsVHlwZSwgZGVzYy5yb3dzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0VmFsaWRpdHlQdHIgPSBtb2QuX21hbGxvYyhkZXNjLnJvd3MpO1xuICAgICAgICBjb25zdCByZXN1bHRWYWxpZGl0eSA9IHB0clRvVWludDhBcnJheShtb2QsIHJlc3VsdFZhbGlkaXR5UHRyLCBkZXNjLnJvd3MpO1xuICAgICAgICBpZiAocmVzdWx0RGF0YS5sZW5ndGggPT0gMCB8fCByZXN1bHRWYWxpZGl0eS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgc3RvcmVFcnJvcihtb2QsIHJlc3BvbnNlLCBcIkNhbid0IGNyZWF0ZSBwaHlzaWNhbCBhcnJheXMgZm9yIHJlc3VsdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmF3UmVzdWx0RGF0YSA9IHJlc3VsdERhdGE7XG4gICAgICAgIGlmIChkZXNjLnJldC5waHlzaWNhbFR5cGUgPT0gJ1ZBUkNIQVInKSB7XG4gICAgICAgICAgICByYXdSZXN1bHREYXRhID0gbmV3IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw+KGRlc2Mucm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzYy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjLnJvd3M7ICsraSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjLmFyZ3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBhcmdzW2pdID0gYXJnUmVzb2x2ZXJzW2pdKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzID0gdWRmLmZ1bmMoLi4uYXJncyk7XG4gICAgICAgICAgICByYXdSZXN1bHREYXRhW2ldID0gcmVzO1xuICAgICAgICAgICAgcmVzdWx0VmFsaWRpdHlbaV0gPSByZXMgPT09IHVuZGVmaW5lZCB8fCByZXMgPT09IG51bGwgPyAwIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuY29kZSByZXR1cm4gdmFsdWVzXG4gICAgICAgIGxldCByZXN1bHRMZW5ndGhzUHRyID0gMDtcbiAgICAgICAgc3dpdGNoIChkZXNjLnJldC5waHlzaWNhbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1ZBUkNIQVInOiB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb2NhdGUgcmVzdWx0IGJ1ZmZlcnNcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHREYXRhVVRGOCA9IG5ldyBBcnJheTxVaW50OEFycmF5PigwKTsgLy8gY291Z2hcbiAgICAgICAgICAgICAgICByZXN1bHRMZW5ndGhzUHRyID0gbW9kLl9tYWxsb2MoZGVzYy5yb3dzICogZ2V0VHlwZVNpemUoJ0RPVUJMRScpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRMZW5ndGhzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCByZXN1bHRMZW5ndGhzUHRyLCBkZXNjLnJvd3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0d28gbG9vcHMgdG8gZmlndXJlIG91dCB0aGUgdG90YWwgbGVuZ3RoIGJ1dCBtYXliZSB3ZSBjYW4gYXZvaWQgdGhlIGRvdWJsZSBhbGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBkZXNjLnJvd3M7ICsrcm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHV0ZjggPSBURVhUX0VOQ09ERVIuZW5jb2RlKChyYXdSZXN1bHREYXRhIGFzIChzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKVtdKVtyb3ddIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RGF0YVVURjgucHVzaCh1dGY4KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0TGVuZ3Roc1tyb3ddID0gdXRmOC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHV0ZjgubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIG1hbGxvYyBhIGJ1ZmZlciBmb3IgdGhlIHN0cmluZ3MgdG8gbGl2ZSBpbiBmb3Igbm93XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyaW5nUHRyID0gbW9kLl9tYWxsb2ModG90YWxMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFN0cmluZ0J1ZiA9IG1vZC5IRUFQVTguc3ViYXJyYXkocmVzdWx0U3RyaW5nUHRyLCByZXN1bHRTdHJpbmdQdHIgKyB0b3RhbExlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3cgY29weSBhbGwgdGhlIHN0cmluZ3MgdG8gdGhlIG5ldyBidWZmZXIgYmFjayB0byBiYWNrXG4gICAgICAgICAgICAgICAgbGV0IHdyaXRlck9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgZGVzYy5yb3dzOyArK3Jvdykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHREYXRhW3Jvd10gPSB3cml0ZXJPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdFVURjggPSByZXN1bHREYXRhVVRGOFtyb3ddO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3cml0ZXIgPSByZXN1bHRTdHJpbmdCdWYuc3ViYXJyYXkod3JpdGVyT2Zmc2V0LCB3cml0ZXJPZmZzZXQgKyByZXN1bHRVVEY4Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5zZXQocmVzdWx0VVRGOCk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlck9mZnNldCArPSByZXN1bHRVVEY4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZWVkIHRvIHN0b3JlIHRocmVlIHBvaW50ZXJzLCBkYXRhLCB2YWxpZGl0eSBhbmQgbGVuZ3RoXG4gICAgICAgIGNvbnN0IHJldExlbiA9IDMgKiA4O1xuICAgICAgICBjb25zdCByZXRQdHIgPSBtb2QuX21hbGxvYyhyZXRMZW4pO1xuICAgICAgICBjb25zdCByZXRCdWZmZXIgPSBwdHJUb0Zsb2F0NjRBcnJheShtb2QsIHJldFB0ciwgMyk7XG4gICAgICAgIHJldEJ1ZmZlclswXSA9IHJlc3VsdERhdGFQdHI7XG4gICAgICAgIHJldEJ1ZmZlclsxXSA9IHJlc3VsdFZhbGlkaXR5UHRyO1xuICAgICAgICByZXRCdWZmZXJbMl0gPSByZXN1bHRMZW5ndGhzUHRyO1xuXG4gICAgICAgIC8vIFBhY2sgcmVzcG9uc2VcbiAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF0gPSAwO1xuICAgICAgICBtb2QuSEVBUEY2NFsocmVzcG9uc2UgPj4gMykgKyAxXSA9IHJldFB0cjtcbiAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMl0gPSAwO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICBzdG9yZUVycm9yKG1vZCwgcmVzcG9uc2UsIGUudG9TdHJpbmcoKSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IER1Y2tEQk1vZHVsZSB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XG5pbXBvcnQgeyBVREZGdW5jdGlvbiB9IGZyb20gJy4vdWRmX2Z1bmN0aW9uJztcbmltcG9ydCAqIGFzIHVkZl9ydCBmcm9tICcuL3VkZl9ydW50aW1lJztcblxuLyoqIFdyYXBwZXIgZm9yIFRleHREZWNvZGVyIHRvIHN1cHBvcnQgc2hhcmVkIGFycmF5IGJ1ZmZlcnMgKi9cbmZ1bmN0aW9uIFRleHREZWNvZGVyV3JhcHBlcigpOiAoaW5wdXQ/OiBCdWZmZXJTb3VyY2UpID0+IHN0cmluZyB7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgIHJldHVybiAoZGF0YTogYW55KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfTtcbn1cbi8qKiBIZWxwZXIgdG8gZGVjb2RlIHRleHQgKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVUZXh0ID0gVGV4dERlY29kZXJXcmFwcGVyKCk7XG5cbi8qKiBDb3B5IGEgYnVmZmVyICovXG5leHBvcnQgZnVuY3Rpb24gZmFpbFdpdGgobW9kOiBEdWNrREJNb2R1bGUsIG1zZzogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc29sZS5lcnJvcihgRkFJTCBXSVRIOiAke21zZ31gKTtcbiAgICBtb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfZmFpbF93aXRoJywgbnVsbCwgWydzdHJpbmcnXSwgW21zZ10pO1xufVxuXG4vKiogQ29weSBhIGJ1ZmZlciAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCdWZmZXIobW9kOiBEdWNrREJNb2R1bGUsIGJlZ2luOiBudW1iZXIsIGxlbmd0aDogbnVtYmVyKTogVWludDhBcnJheSB7XG4gICAgY29uc3QgYnVmZmVyID0gbW9kLkhFQVBVOC5zdWJhcnJheShiZWdpbiwgYmVnaW4gKyBsZW5ndGgpO1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpKTtcbiAgICBjb3B5LnNldChidWZmZXIpO1xuICAgIHJldHVybiBjb3B5O1xufVxuXG4vKiogRGVjb2RlIGEgc3RyaW5nICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmluZyhtb2Q6IER1Y2tEQk1vZHVsZSwgYmVnaW46IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBkZWNvZGVUZXh0KG1vZC5IRUFQVTguc3ViYXJyYXkoYmVnaW4sIGJlZ2luICsgbGVuZ3RoKSk7XG59XG5cbi8qKiBUaGUgZGF0YSBwcm90b2NvbCAqL1xuZXhwb3J0IGVudW0gRHVja0RCRGF0YVByb3RvY29sIHtcbiAgICBCVUZGRVIgPSAwLFxuICAgIE5PREVfRlMgPSAxLFxuICAgIEJST1dTRVJfRklMRVJFQURFUiA9IDIsXG4gICAgQlJPV1NFUl9GU0FDQ0VTUyA9IDMsXG4gICAgSFRUUCA9IDQsXG4gICAgUzMgPSA1LFxufVxuXG4vKiogRmlsZSBmbGFncyBmb3Igb3BlbmluZyBmaWxlcyovXG5leHBvcnQgZW51bSBGaWxlRmxhZ3Mge1xuICAgIC8vISBPcGVuIGZpbGUgd2l0aCByZWFkIGFjY2Vzc1xuICAgIEZJTEVfRkxBR1NfUkVBRCA9IDEgPDwgMCxcbiAgICAvLyEgT3BlbiBmaWxlIHdpdGggd3JpdGUgYWNjZXNzXG4gICAgRklMRV9GTEFHU19XUklURSA9IDEgPDwgMSxcbiAgICAvLyEgVXNlIGRpcmVjdCBJTyB3aGVuIHJlYWRpbmcvd3JpdGluZyB0byB0aGUgZmlsZVxuICAgIEZJTEVfRkxBR1NfRElSRUNUX0lPID0gMSA8PCAyLFxuICAgIC8vISBDcmVhdGUgZmlsZSBpZiBub3QgZXhpc3RzLCBjYW4gb25seSBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggV1JJVEVcbiAgICBGSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFID0gMSA8PCAzLFxuICAgIC8vISBBbHdheXMgY3JlYXRlIGEgbmV3IGZpbGUuIElmIGEgZmlsZSBleGlzdHMsIHRoZSBmaWxlIGlzIHRydW5jYXRlZC4gQ2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBDUkVBVEUuXG4gICAgRklMRV9GTEFHU19GSUxFX0NSRUFURV9ORVcgPSAxIDw8IDQsXG4gICAgLy8hIE9wZW4gZmlsZSBpbiBhcHBlbmQgbW9kZVxuICAgIEZJTEVfRkxBR1NfQVBQRU5EID0gMSA8PCA1LFxufVxuXG4vKiogQ29uZmlndXJhdGlvbiBmb3IgdGhlIEFXUyBTMyBGaWxlc3lzdGVtICovXG5leHBvcnQgaW50ZXJmYWNlIFMzQ29uZmlnIHtcbiAgICByZWdpb24/OiBzdHJpbmc7XG4gICAgZW5kcG9pbnQ/OiBzdHJpbmc7XG4gICAgYWNjZXNzS2V5SWQ/OiBzdHJpbmc7XG4gICAgc2VjcmV0QWNjZXNzS2V5Pzogc3RyaW5nO1xuICAgIHNlc3Npb25Ub2tlbj86IHN0cmluZztcbn1cblxuLyoqIEFuIGluZm8gZm9yIGEgZmlsZSByZWdpc3RlcmVkIHdpdGggRHVja0RCICovXG5leHBvcnQgaW50ZXJmYWNlIER1Y2tEQkZpbGVJbmZvIHtcbiAgICBjYWNoZUVwb2NoOiBudW1iZXI7XG4gICAgZmlsZUlkOiBudW1iZXI7XG4gICAgZmlsZU5hbWU6IHN0cmluZztcbiAgICBkYXRhUHJvdG9jb2w6IER1Y2tEQkRhdGFQcm90b2NvbDtcbiAgICBkYXRhVXJsOiBzdHJpbmcgfCBudWxsO1xuICAgIGFsbG93RnVsbEh0dHBSZWFkcz86IGJvb2xlYW47XG4gICAgczNDb25maWc/OiBTM0NvbmZpZztcbn1cblxuLyoqIEdsb2JhbCBpbmZvIGZvciBhbGwgZmlsZXMgcmVnaXN0ZXJlZCB3aXRoIER1Y2tEQiAqL1xuZXhwb3J0IGludGVyZmFjZSBEdWNrREJHbG9iYWxGaWxlSW5mbyB7XG4gICAgY2FjaGVFcG9jaDogbnVtYmVyO1xuICAgIGFsbG93RnVsbEh0dHBSZWFkcz86IGJvb2xlYW47XG4gICAgczNDb25maWc/OiBTM0NvbmZpZztcbn1cblxuLyoqIENhbGwgYSBmdW5jdGlvbiB3aXRoIHBhY2tlZCByZXNwb25zZSBidWZmZXIgKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsU1JldChcbiAgICBtb2Q6IER1Y2tEQk1vZHVsZSxcbiAgICBmdW5jTmFtZTogc3RyaW5nLFxuICAgIGFyZ1R5cGVzOiBBcnJheTxFbXNjcmlwdGVuLkpTVHlwZT4sXG4gICAgYXJnczogQXJyYXk8YW55Pixcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XG4gICAgY29uc3Qgc3RhY2tQb2ludGVyID0gbW9kLnN0YWNrU2F2ZSgpO1xuXG4gICAgLy8gQWxsb2NhdGUgdGhlIHBhY2tlZCByZXNwb25zZSBidWZmZXJcbiAgICBjb25zdCByZXNwb25zZSA9IG1vZC5zdGFja0FsbG9jKDMgKiA4KTtcbiAgICBhcmdUeXBlcy51bnNoaWZ0KCdudW1iZXInKTtcbiAgICBhcmdzLnVuc2hpZnQocmVzcG9uc2UpO1xuXG4gICAgLy8gRG8gdGhlIGNhbGxcbiAgICBtb2QuY2NhbGwoZnVuY05hbWUsIG51bGwsIGFyZ1R5cGVzLCBhcmdzKTtcblxuICAgIC8vIFJlYWQgdGhlIHJlc3BvbnNlXG4gICAgY29uc3Qgc3RhdHVzID0gbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF07XG4gICAgY29uc3QgZGF0YSA9IG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDFdO1xuICAgIGNvbnN0IGRhdGFTaXplID0gbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMl07XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBzdGFja1xuICAgIG1vZC5zdGFja1Jlc3RvcmUoc3RhY2tQb2ludGVyKTtcbiAgICByZXR1cm4gW3N0YXR1cywgZGF0YSwgZGF0YVNpemVdO1xufVxuXG4vKiogRHJvcCByZXNwb25zZSBidWZmZXJzICovXG5leHBvcnQgZnVuY3Rpb24gZHJvcFJlc3BvbnNlQnVmZmVycyhtb2Q6IER1Y2tEQk1vZHVsZSk6IHZvaWQge1xuICAgIG1vZC5jY2FsbCgnZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZScsIG51bGwsIFtdLCBbXSk7XG59XG5cbi8qKiBUaGUgZHVja2RiIHJ1bnRpbWUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCUnVudGltZSB7XG4gICAgX2ZpbGVzPzogTWFwPHN0cmluZywgYW55PjtcbiAgICBfdWRmRnVuY3Rpb25zOiBNYXA8bnVtYmVyLCBVREZGdW5jdGlvbj47XG5cbiAgICAvLyBUZXN0IGEgcGxhdGZvcm0gZmVhdHVyZVxuICAgIHRlc3RQbGF0Zm9ybUZlYXR1cmUobW9kOiBEdWNrREJNb2R1bGUsIGZlYXR1cmU6IG51bWJlcik6IGJvb2xlYW47XG5cbiAgICAvLyBGaWxlIEFQSXMgd2l0aCBkZWRpY2F0ZWQgZmlsZSBpZGVudGlmaWVyXG4gICAgZ2V0RGVmYXVsdERhdGFQcm90b2NvbChtb2Q6IER1Y2tEQk1vZHVsZSk6IG51bWJlcjtcbiAgICBvcGVuRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGZsYWdzOiBGaWxlRmxhZ3MpOiB2b2lkO1xuICAgIHN5bmNGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IHZvaWQ7XG4gICAgY2xvc2VGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IHZvaWQ7XG4gICAgZ2V0TGFzdEZpbGVNb2RpZmljYXRpb25UaW1lKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IG51bWJlcjtcbiAgICB0cnVuY2F0ZUZpbGUobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyLCBuZXdTaXplOiBudW1iZXIpOiB2b2lkO1xuICAgIHJlYWRGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgYnVmZmVyOiBudW1iZXIsIGJ5dGVzOiBudW1iZXIsIGxvY2F0aW9uOiBudW1iZXIpOiBudW1iZXI7XG4gICAgd3JpdGVGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgYnVmZmVyOiBudW1iZXIsIGJ5dGVzOiBudW1iZXIsIGxvY2F0aW9uOiBudW1iZXIpOiBudW1iZXI7XG5cbiAgICAvLyBGaWxlIEFQSXMgd2l0aCBwYXRoIHBhcmFtZXRlclxuICAgIHJlbW92ZURpcmVjdG9yeShtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiB2b2lkO1xuICAgIGNoZWNrRGlyZWN0b3J5KG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcik6IGJvb2xlYW47XG4gICAgY3JlYXRlRGlyZWN0b3J5KG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcik6IHZvaWQ7XG4gICAgbGlzdERpcmVjdG9yeUVudHJpZXMobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcbiAgICBnbG9iKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcik6IHZvaWQ7XG4gICAgbW92ZUZpbGUobW9kOiBEdWNrREJNb2R1bGUsIGZyb21QdHI6IG51bWJlciwgZnJvbUxlbjogbnVtYmVyLCB0b1B0cjogbnVtYmVyLCB0b0xlbjogbnVtYmVyKTogdm9pZDtcbiAgICBjaGVja0ZpbGUobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcbiAgICByZW1vdmVGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcik6IHZvaWQ7XG5cbiAgICAvLyBDYWxsIGEgc2NhbGFyIFVERiBmdW5jdGlvblxuICAgIGNhbGxTY2FsYXJVREYoXG4gICAgICAgIG1vZDogRHVja0RCTW9kdWxlLFxuICAgICAgICByZXNwb25zZTogbnVtYmVyLFxuICAgICAgICBmdW5jSWQ6IG51bWJlcixcbiAgICAgICAgZGVzY1B0cjogbnVtYmVyLFxuICAgICAgICBkZXNjU2l6ZTogbnVtYmVyLFxuICAgICAgICBwdHJzUHRyOiBudW1iZXIsXG4gICAgICAgIHB0cnNTaXplOiBudW1iZXIsXG4gICAgKTogdm9pZDtcbn1cblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUlVOVElNRTogRHVja0RCUnVudGltZSA9IHtcbiAgICBfdWRmRnVuY3Rpb25zOiBuZXcgTWFwKCksXG5cbiAgICB0ZXN0UGxhdGZvcm1GZWF0dXJlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmVhdHVyZTogbnVtYmVyKTogYm9vbGVhbiA9PiBmYWxzZSxcbiAgICBnZXREZWZhdWx0RGF0YVByb3RvY29sOiAoX21vZDogRHVja0RCTW9kdWxlKTogbnVtYmVyID0+IER1Y2tEQkRhdGFQcm90b2NvbC5CVUZGRVIsXG4gICAgb3BlbkZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlciwgZmxhZ3M6IEZpbGVGbGFncyk6IHZvaWQgPT4ge30sXG4gICAgc3luY0ZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IHZvaWQgPT4ge30sXG4gICAgY2xvc2VGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmlsZUlkOiBudW1iZXIpOiB2b2lkID0+IHt9LFxuICAgIGdldExhc3RGaWxlTW9kaWZpY2F0aW9uVGltZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2ZpbGVJZDogbnVtYmVyKTogbnVtYmVyID0+IHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB0cnVuY2F0ZUZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlciwgX25ld1NpemU6IG51bWJlcik6IHZvaWQgPT4ge30sXG4gICAgcmVhZEZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlciwgX2J1ZmZlcjogbnVtYmVyLCBfYnl0ZXM6IG51bWJlciwgX2xvY2F0aW9uOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHdyaXRlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2ZpbGVJZDogbnVtYmVyLCBfYnVmZmVyOiBudW1iZXIsIF9ieXRlczogbnVtYmVyLCBfbG9jYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICByZW1vdmVEaXJlY3Rvcnk6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiB2b2lkID0+IHt9LFxuICAgIGNoZWNrRGlyZWN0b3J5OiAoX21vZDogRHVja0RCTW9kdWxlLCBfcGF0aFB0cjogbnVtYmVyLCBfcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNyZWF0ZURpcmVjdG9yeTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IHZvaWQgPT4ge30sXG4gICAgbGlzdERpcmVjdG9yeUVudHJpZXM6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZ2xvYjogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IHZvaWQgPT4ge30sXG4gICAgbW92ZUZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9mcm9tUHRyOiBudW1iZXIsIF9mcm9tTGVuOiBudW1iZXIsIF90b1B0cjogbnVtYmVyLCBfdG9MZW46IG51bWJlcik6IHZvaWQgPT4ge30sXG4gICAgY2hlY2tGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfcGF0aFB0cjogbnVtYmVyLCBfcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbiA9PiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlbW92ZUZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiB2b2lkID0+IHt9LFxuICAgIGNhbGxTY2FsYXJVREY6IChcbiAgICAgICAgbW9kOiBEdWNrREJNb2R1bGUsXG4gICAgICAgIHJlc3BvbnNlOiBudW1iZXIsXG4gICAgICAgIGZ1bmNJZDogbnVtYmVyLFxuICAgICAgICBkZXNjUHRyOiBudW1iZXIsXG4gICAgICAgIGRlc2NTaXplOiBudW1iZXIsXG4gICAgICAgIHB0cnNQdHI6IG51bWJlcixcbiAgICAgICAgcHRyc1NpemU6IG51bWJlcixcbiAgICApOiB2b2lkID0+IHtcbiAgICAgICAgdWRmX3J0LmNhbGxTY2FsYXJVREYoREVGQVVMVF9SVU5USU1FLCBtb2QsIHJlc3BvbnNlLCBmdW5jSWQsIGRlc2NQdHIsIGRlc2NTaXplLCBwdHJzUHRyLCBwdHJzU2l6ZSk7XG4gICAgfSxcbn07XG4iLCAiZXhwb3J0IGludGVyZmFjZSBGaWxlQmxvY2tTdGF0aXN0aWNzIHtcbiAgICAvKiogVGhlIGZpbGUgcmVhZHMgY29sZCAqL1xuICAgIGZpbGVfcmVhZHNfY29sZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBhaGVhZHMgKi9cbiAgICBmaWxlX3JlYWRzX2FoZWFkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBmaWxlIHJlYWRzIGNhY2hlZCAqL1xuICAgIGZpbGVfcmVhZHNfY2FjaGVkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBmaWxlIHdyaXRlcyAqL1xuICAgIGZpbGVfd3JpdGVzOiBudW1iZXI7XG4gICAgLyoqIFRoZSBwYWdlIGFjY2Vzc2VzICovXG4gICAgcGFnZV9hY2Nlc3NlczogbnVtYmVyO1xuICAgIC8qKiBUaGUgcGFnZSBsb2FkcyAqL1xuICAgIHBhZ2VfbG9hZHM6IG51bWJlcjtcbn1cblxuLyoqIFRoZSBmaWxlIGJsb2NrIHN0YXRpc3RpY3MgKi9cbmV4cG9ydCBjbGFzcyBGaWxlU3RhdGlzdGljcyB7XG4gICAgLyoqIFRoZSBjb2xkIGZpbGUgcmVhZHMgKi9cbiAgICBwdWJsaWMgdG90YWxGaWxlUmVhZHNDb2xkOiBudW1iZXI7XG4gICAgLyoqIFRoZSBmaWxlIHJlYWRhaGVhZHMgKi9cbiAgICBwdWJsaWMgdG90YWxGaWxlUmVhZHNBaGVhZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgY2FjaGVkIGZpbGUgcmVhZHMgKi9cbiAgICBwdWJsaWMgdG90YWxGaWxlUmVhZHNDYWNoZWQ6IG51bWJlcjtcbiAgICAvKiogVGhlIGZpbGUgd3JpdGVzICovXG4gICAgcHVibGljIHRvdGFsRmlsZVdyaXRlczogbnVtYmVyO1xuICAgIC8qKiBUaGUgcGFnZSBhY2Nlc3NlcyAqL1xuICAgIHB1YmxpYyB0b3RhbFBhZ2VBY2Nlc3NlczogbnVtYmVyO1xuICAgIC8qKiBUaGUgcGFnZSBsb2FkcyAqL1xuICAgIHB1YmxpYyB0b3RhbFBhZ2VMb2FkczogbnVtYmVyO1xuICAgIC8qKiBUaGUgYmxvY2tzICovXG4gICAgcHVibGljIGJsb2NrU2l6ZTogbnVtYmVyO1xuICAgIC8qKiBUaGUgYmxvY2tzICovXG4gICAgcHVibGljIGJsb2NrU3RhdHM6IFVpbnQ4QXJyYXk7XG5cbiAgICBjb25zdHJ1Y3Rvcih1OGFycmF5OiBVaW50OEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkodThhcnJheS5idWZmZXIsIHU4YXJyYXkuYnl0ZU9mZnNldCwgdThhcnJheS5ieXRlTGVuZ3RoIC8gOCk7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcih1OGFycmF5LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgYmxvY2tzLnNldCh1OGFycmF5LnN1YmFycmF5KDcgKiA4KSk7XG4gICAgICAgIHRoaXMudG90YWxGaWxlUmVhZHNDb2xkID0gZjY0WzBdO1xuICAgICAgICB0aGlzLnRvdGFsRmlsZVJlYWRzQWhlYWQgPSBmNjRbMV07XG4gICAgICAgIHRoaXMudG90YWxGaWxlUmVhZHNDYWNoZWQgPSBmNjRbMl07XG4gICAgICAgIHRoaXMudG90YWxGaWxlV3JpdGVzID0gZjY0WzNdO1xuICAgICAgICB0aGlzLnRvdGFsUGFnZUFjY2Vzc2VzID0gZjY0WzRdO1xuICAgICAgICB0aGlzLnRvdGFsUGFnZUxvYWRzID0gZjY0WzVdO1xuICAgICAgICB0aGlzLmJsb2NrU2l6ZSA9IGY2NFs2XTtcbiAgICAgICAgdGhpcy5ibG9ja1N0YXRzID0gYmxvY2tzO1xuICAgIH1cblxuICAgIC8qKiBUaGUgYmxvY2sgc3RhdHMgKi9cbiAgICBwdWJsaWMgZ2V0QmxvY2tTdGF0cyhpbmRleDogbnVtYmVyLCBvdXQ/OiBGaWxlQmxvY2tTdGF0aXN0aWNzKTogRmlsZUJsb2NrU3RhdGlzdGljcyB7XG4gICAgICAgIG91dCA9IG91dCB8fCB7XG4gICAgICAgICAgICBmaWxlX3JlYWRzX2NvbGQ6IDAsXG4gICAgICAgICAgICBmaWxlX3JlYWRzX2FoZWFkOiAwLFxuICAgICAgICAgICAgZmlsZV9yZWFkc19jYWNoZWQ6IDAsXG4gICAgICAgICAgICBmaWxlX3dyaXRlczogMCxcbiAgICAgICAgICAgIHBhZ2VfYWNjZXNzZXM6IDAsXG4gICAgICAgICAgICBwYWdlX2xvYWRzOiAwLFxuICAgICAgICB9O1xuICAgICAgICBvdXQuZmlsZV93cml0ZXMgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMF0gJiAwYjExMTE7XG4gICAgICAgIG91dC5maWxlX3JlYWRzX2NvbGQgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMF0gPj4gNDtcbiAgICAgICAgb3V0LmZpbGVfcmVhZHNfYWhlYWQgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gJiAwYjExMTE7XG4gICAgICAgIG91dC5maWxlX3JlYWRzX2NhY2hlZCA9IHRoaXMuYmxvY2tTdGF0c1tpbmRleCAqIDMgKyAxXSA+PiA0O1xuICAgICAgICBvdXQucGFnZV9hY2Nlc3NlcyA9IHRoaXMuYmxvY2tTdGF0c1tpbmRleCAqIDMgKyAxXSAmIDBiMTExMTtcbiAgICAgICAgb3V0LnBhZ2VfbG9hZHMgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gPj4gNDtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG59XG4iLCAiaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcblxuZXhwb3J0IGludGVyZmFjZSBTUUxUeXBlIHtcbiAgICAvLy8gVGhlIHNxbCB0eXBlXG4gICAgc3FsVHlwZTogc3RyaW5nO1xuICAgIC8vLyBJcyBudWxsYWJsZT9cbiAgICBudWxsYWJsZT86IGJvb2xlYW47XG4gICAgLy8vIERlY2ltYWwgcHJlY2lzaW9uXG4gICAgcHJlY2lzaW9uPzogbnVtYmVyO1xuICAgIC8vLyBEZWNpbWFsIHNjYWxpbmdcbiAgICBzY2FsZT86IG51bWJlcjtcbiAgICAvLy8gVGltZXpvbmVcbiAgICB0aW1lem9uZT86IHN0cmluZztcbiAgICAvLy8gQnl0ZSB3aWR0aCAoRml4ZWRTaXplQmluYXJ5KVxuICAgIGJ5dGVXaWR0aD86IG51bWJlcjtcbiAgICAvLy8gS2V5IHR5cGVcbiAgICBrZXlUeXBlPzogU1FMVHlwZTtcbiAgICAvLy8gVmFsdWUgdHlwZVxuICAgIHZhbHVlVHlwZT86IFNRTFR5cGU7XG4gICAgLy8vIEZpZWxkc1xuICAgIGZpZWxkcz86IFNRTEZpZWxkW107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJvd1RvU1FMVHlwZSh0eXBlOiBhcnJvdy5EYXRhVHlwZSk6IFNRTFR5cGUge1xuICAgIHN3aXRjaCAodHlwZS50eXBlSWQpIHtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkJpbmFyeTpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdiaW5hcnknIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5Cb29sOlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Jvb2wnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5EYXRlOlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2RhdGUnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5EYXRlRGF5OlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2RhdGUzMltkXScgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkRhdGVNaWxsaXNlY29uZDpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdkYXRlNjRbbXNdJyB9O1xuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGVjaW1hbDoge1xuICAgICAgICAgICAgY29uc3QgZGVjID0gdHlwZSBhcyBhcnJvdy5EZWNpbWFsO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2RlY2ltYWwnLCBwcmVjaXNpb246IGRlYy5wcmVjaXNpb24sIHNjYWxlOiBkZWMuc2NhbGUgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRmxvYXQ6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZmxvYXQnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDE2OlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0MTYnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDMyOlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0MzInIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDY0OlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0NjQnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnQ6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnaW50MzInIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnQxNjpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQxNicgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkludDMyOlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2ludDMyJyB9O1xuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50NjQ6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnaW50NjQnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5VaW50MTY6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndWludDE2JyB9O1xuICAgICAgICBjYXNlIGFycm93LlR5cGUuVWludDMyOlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3VpbnQzMicgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlVpbnQ2NDpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1aW50NjQnIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5VaW50ODpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1aW50OCcgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkludGVydmFsRGF5VGltZTpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnRlcnZhbFtkdF0nIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnRlcnZhbFllYXJNb250aDpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnRlcnZhbFttXScgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkxpc3Q6IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB0eXBlIGFzIGFycm93Lkxpc3Q7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNxbFR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IGFycm93VG9TUUxUeXBlKGxpc3QudmFsdWVUeXBlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkZpeGVkU2l6ZUJpbmFyeToge1xuICAgICAgICAgICAgY29uc3QgYmluID0gdHlwZSBhcyBhcnJvdy5GaXhlZFNpemVCaW5hcnk7XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZml4ZWRzaXplYmluYXJ5JywgYnl0ZVdpZHRoOiBiaW4uYnl0ZVdpZHRoIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLk51bGw6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnbnVsbCcgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlV0Zjg6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndXRmOCcgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlN0cnVjdDoge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0XyA9IHR5cGUgYXMgYXJyb3cuU3RydWN0O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzcWxUeXBlOiAnc3RydWN0JyxcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHN0cnVjdF8uY2hpbGRyZW4ubWFwKGMgPT4gYXJyb3dUb1NRTEZpZWxkKGMubmFtZSwgYy50eXBlKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5NYXA6IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcF8gPSB0eXBlIGFzIGFycm93Lk1hcF87XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNxbFR5cGU6ICdtYXAnLFxuICAgICAgICAgICAgICAgIGtleVR5cGU6IGFycm93VG9TUUxUeXBlKG1hcF8ua2V5VHlwZSksXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBhcnJvd1RvU1FMVHlwZShtYXBfLnZhbHVlVHlwZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lOlxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbc10nIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lTWljcm9zZWNvbmQ6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZVt1c10nIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lTWlsbGlzZWNvbmQ6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZVttc10nIH07XG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lTmFub3NlY29uZDpcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lW25zXScgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVTZWNvbmQ6XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZVtzXScgfTtcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVzdGFtcDoge1xuICAgICAgICAgICAgY29uc3QgdHMgPSB0eXBlIGFzIGFycm93LlRpbWVzdGFtcDtcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXAnLCB0aW1lem9uZTogdHMudGltZXpvbmUgfHwgdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVzdGFtcFNlY29uZDoge1xuICAgICAgICAgICAgY29uc3QgdHMgPSB0eXBlIGFzIGFycm93LlRpbWVzdGFtcFNlY29uZDtcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbc10nLCB0aW1lem9uZTogdHMudGltZXpvbmUgfHwgdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVzdGFtcE1pY3Jvc2Vjb25kOiB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTWljcm9zZWNvbmQ7XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZXN0YW1wW3VzXScsIHRpbWV6b25lOiB0cy50aW1lem9uZSB8fCB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZXN0YW1wTmFub3NlY29uZDoge1xuICAgICAgICAgICAgY29uc3QgdHMgPSB0eXBlIGFzIGFycm93LlRpbWVzdGFtcE5hbm9zZWNvbmQ7XG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZXN0YW1wW25zXScsIHRpbWV6b25lOiB0cy50aW1lem9uZSB8fCB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZXN0YW1wTWlsbGlzZWNvbmQ6IHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gdHlwZSBhcyBhcnJvdy5UaW1lc3RhbXBNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbbXNdJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXJyb3cgdHlwZTogJHt0eXBlLnRvU3RyaW5nKCl9YCk7XG59XG5cbmV4cG9ydCB0eXBlIFNRTEZpZWxkID0gU1FMVHlwZSAmIHsgbmFtZTogc3RyaW5nIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBhcnJvd1RvU1FMRmllbGQobmFtZTogc3RyaW5nLCB0eXBlOiBhcnJvdy5EYXRhVHlwZSk6IFNRTEZpZWxkIHtcbiAgICBjb25zdCB0ID0gYXJyb3dUb1NRTFR5cGUodHlwZSkgYXMgU1FMRmllbGQ7XG4gICAgdC5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdDtcbn1cbiIsICJpbXBvcnQgeyBEdWNrREJNb2R1bGUsIFBUaHJlYWQgfSBmcm9tICcuL2R1Y2tkYl9tb2R1bGUnO1xuaW1wb3J0IHsgRHVja0RCQ29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IEluc3RhbnRpYXRpb25Qcm9ncmVzcyB9IGZyb20gJy4vcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgRHVja0RCQmluZGluZ3MgfSBmcm9tICcuL2JpbmRpbmdzX2ludGVyZmFjZSc7XG5pbXBvcnQgeyBEdWNrREJDb25uZWN0aW9uIH0gZnJvbSAnLi9jb25uZWN0aW9uJztcbmltcG9ydCB7IFN0YXR1c0NvZGUgfSBmcm9tICcuLi9zdGF0dXMnO1xuaW1wb3J0IHsgZHJvcFJlc3BvbnNlQnVmZmVycywgRHVja0RCUnVudGltZSwgcmVhZFN0cmluZywgY2FsbFNSZXQsIGNvcHlCdWZmZXIsIER1Y2tEQkRhdGFQcm90b2NvbCB9IGZyb20gJy4vcnVudGltZSc7XG5pbXBvcnQgeyBDU1ZJbnNlcnRPcHRpb25zLCBKU09OSW5zZXJ0T3B0aW9ucywgQXJyb3dJbnNlcnRPcHRpb25zIH0gZnJvbSAnLi9pbnNlcnRfb3B0aW9ucyc7XG5pbXBvcnQgeyBTY3JpcHRUb2tlbnMgfSBmcm9tICcuL3Rva2Vucyc7XG5pbXBvcnQgeyBGaWxlU3RhdGlzdGljcyB9IGZyb20gJy4vZmlsZV9zdGF0cyc7XG5pbXBvcnQgeyBhcnJvd1RvU1FMRmllbGQsIGFycm93VG9TUUxUeXBlIH0gZnJvbSAnLi4vanNvbl90eXBlZGVmJztcbmltcG9ydCB7IFdlYkZpbGUgfSBmcm9tICcuL3dlYl9maWxlJztcbmltcG9ydCB7IFVERkZ1bmN0aW9uLCBVREZGdW5jdGlvbkRlY2xhcmF0aW9uIH0gZnJvbSAnLi91ZGZfZnVuY3Rpb24nO1xuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcblxuY29uc3QgVEVYVF9FTkNPREVSID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXG4gICAgdmFyIERVQ0tEQl9SVU5USU1FOiBhbnk7XG59XG5cbi8qKiBBIER1Y2tEQiBGZWF0dXJlICovXG5leHBvcnQgZW51bSBEdWNrREJGZWF0dXJlIHtcbiAgICBXQVNNX0VYQ0VQVElPTlMgPSAxIDw8IDAsXG4gICAgV0FTTV9USFJFQURTID0gMSA8PCAxLFxuICAgIFdBU01fU0lNRCA9IDEgPDwgMixcbiAgICBXQVNNX0JVTEtfTUVNT1JZID0gMSA8PCAzLFxuICAgIEVNSVRfQklHSU5UID0gMSA8PCA0LFxufVxuXG4vKiogVGhlIHByb3h5IGZvciBlaXRoZXIgdGhlIGJyb3dzZXItIG9yZGVyIG5vZGUtYmFzZWQgRHVja0RCIEFQSSAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIER1Y2tEQkJpbmRpbmdzQmFzZSBpbXBsZW1lbnRzIER1Y2tEQkJpbmRpbmdzIHtcbiAgICAvKiogVGhlIGxvZ2dlciAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfbG9nZ2VyOiBMb2dnZXI7XG4gICAgLyoqIEJhY2tlbmQtZGVwZW5kZW50IG5hdGl2ZS1nbHVlIGNvZGUgZm9yIER1Y2tEQiAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfcnVudGltZTogRHVja0RCUnVudGltZTtcbiAgICAvKiogVGhlIGluc3RhbmNlICovXG4gICAgcHJvdGVjdGVkIF9pbnN0YW5jZTogRHVja0RCTW9kdWxlIHwgbnVsbCA9IG51bGw7XG4gICAgLyoqIFRoZSBsb2FkaW5nIHByb21pc2UgKi9cbiAgICBwcm90ZWN0ZWQgX2luaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gICAgLyoqIFRoZSByZXNvbHZlciBmb3IgdGhlIG9wZW4gcHJvbWlzZSAoY2FsbGVkIGJ5IG9uUnVudGltZUluaXRpYWxpemVkKSAqL1xuICAgIHByb3RlY3RlZCBfaW5pdFByb21pc2VSZXNvbHZlcjogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAgIC8qKiBUaGUgbmV4dCBVREYgaWQgKi9cbiAgICBwcm90ZWN0ZWQgX25leHRVREZJZDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXIsIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUpIHtcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICB0aGlzLl9ydW50aW1lID0gcnVudGltZTtcbiAgICAgICAgdGhpcy5fbmV4dFVERklkID0gMTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBsb2dnZXIgKi9cbiAgICBwdWJsaWMgZ2V0IGxvZ2dlcigpOiBMb2dnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyO1xuICAgIH1cbiAgICAvKiogR2V0IHRoZSBpbnN0YW5jZSAqL1xuICAgIHB1YmxpYyBnZXQgbW9kKCk6IER1Y2tEQk1vZHVsZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSE7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGluc3RhbmNlICovXG4gICAgcHVibGljIGdldCBwdGhyZWFkKCk6IFBUaHJlYWQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kLlBUaHJlYWQgfHwgbnVsbDtcbiAgICB9XG5cbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIG1vZHVsZSAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbnN0YW50aWF0ZUltcGwobW9kdWxlT3ZlcnJpZGVzOiBQYXJ0aWFsPER1Y2tEQk1vZHVsZT4pOiBQcm9taXNlPER1Y2tEQk1vZHVsZT47XG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSBtb2R1bGUgKi9cbiAgICBwcm90ZWN0ZWQgb25JbnN0YW50aWF0aW9uUHJvZ3Jlc3M6ICgocDogSW5zdGFudGlhdGlvblByb2dyZXNzKSA9PiB2b2lkKVtdID0gW107XG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSBkYXRhYmFzZSAqL1xuICAgIHB1YmxpYyBhc3luYyBpbnN0YW50aWF0ZShvblByb2dyZXNzOiAocHJvZ3Jlc3M6IEluc3RhbnRpYXRpb25Qcm9ncmVzcykgPT4gdm9pZCA9IF8gPT4ge30pOiBQcm9taXNlPHRoaXM+IHtcbiAgICAgICAgLy8gQWxyZWFkeSBvcGVuZWQ/XG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBPcGVuIGluIHByb2dyZXNzP1xuICAgICAgICBpZiAodGhpcy5faW5pdFByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbkluc3RhbnRpYXRpb25Qcm9ncmVzcy5wdXNoKG9uUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHdlIGNhbiBhd2FpdFxuICAgICAgICB0aGlzLl9pbml0UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW5pdFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWdpc3RlciBwcm9ncmVzcyBoYW5kbGVyXG4gICAgICAgIHRoaXMub25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSBbb25Qcm9ncmVzc107XG4gICAgICAgIC8vIEluaXRpYWxpemUgZHVja2RiXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gYXdhaXQgdGhpcy5pbnN0YW50aWF0ZUltcGwoe1xuICAgICAgICAgICAgcHJpbnQ6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXG4gICAgICAgICAgICBwcmludEVycjogY29uc29sZS5sb2cuYmluZChjb25zb2xlKSxcbiAgICAgICAgICAgIG9uUnVudGltZUluaXRpYWxpemVkOiB0aGlzLl9pbml0UHJvbWlzZVJlc29sdmVyLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2FpdCBmb3Igb25SdW50aW1lSW5pdGlhbGl6ZWRcbiAgICAgICAgYXdhaXQgdGhpcy5faW5pdFByb21pc2U7XG4gICAgICAgIHRoaXMuX2luaXRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgLy8gUmVtb3ZlIG93biBwcm9ncmVzcyBjYWxsYmFja1xuICAgICAgICB0aGlzLm9uSW5zdGFudGlhdGlvblByb2dyZXNzID0gdGhpcy5vbkluc3RhbnRpYXRpb25Qcm9ncmVzcy5maWx0ZXIoeCA9PiB4ICE9IG9uUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIE9wZW4gYSBkYXRhYmFzZSB3aXRoIGEgY29uZmlnICovXG4gICAgcHVibGljIG9wZW4oY29uZmlnOiBEdWNrREJDb25maWcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX29wZW4nLCBbJ3N0cmluZyddLCBbSlNPTi5zdHJpbmdpZnkoY29uZmlnKV0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xuICAgIH1cblxuICAgIC8qKiBSZXNldCB0aGUgZGF0YWJhc2UgKi9cbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9yZXNldCcsIFtdLCBbXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgdmVyc2lvbiAqL1xuICAgIHB1YmxpYyBnZXRWZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9nZXRfdmVyc2lvbicsIFtdLCBbXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pO1xuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGZlYXR1cmUgZmxhZ3MgKi9cbiAgICBwdWJsaWMgZ2V0RmVhdHVyZUZsYWdzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZC5jY2FsbCgnZHVja2RiX3dlYl9nZXRfZmVhdHVyZV9mbGFncycsICdudW1iZXInLCBbXSwgW10pO1xuICAgIH1cblxuICAgIC8qKiBUb2tlbml6ZSBhIHNjcmlwdCAqL1xuICAgIHB1YmxpYyB0b2tlbml6ZSh0ZXh0OiBzdHJpbmcpOiBTY3JpcHRUb2tlbnMge1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfdG9rZW5pemUnLCBbJ3N0cmluZyddLCBbdGV4dF0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pO1xuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzKSBhcyBTY3JpcHRUb2tlbnM7XG4gICAgfVxuXG4gICAgLyoqIENvbm5lY3QgdG8gZGF0YWJhc2UgKi9cbiAgICBwdWJsaWMgY29ubmVjdCgpOiBEdWNrREJDb25uZWN0aW9uIHtcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2Nvbm5lY3QnLCAnbnVtYmVyJywgW10sIFtdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEdWNrREJDb25uZWN0aW9uKHRoaXMsIGNvbm4pO1xuICAgIH1cbiAgICAvKiogRGlzY29ubmVjdCBmcm9tIGRhdGFiYXNlICovXG4gICAgcHVibGljIGRpc2Nvbm5lY3QoY29ubjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2Rpc2Nvbm5lY3QnLCBudWxsLCBbJ251bWJlciddLCBbY29ubl0pO1xuICAgICAgICBpZiAodGhpcy5wdGhyZWFkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdvcmtlciBvZiBbLi4udGhpcy5wdGhyZWFkLnJ1bm5pbmdXb3JrZXJzLCAuLi50aGlzLnB0aHJlYWQudW51c2VkV29ya2Vyc10pIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdkcm9wVURGRnVuY3Rpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBjb25uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNlbmQgYSBxdWVyeSBhbmQgcmV0dXJuIHRoZSBmdWxsIHJlc3VsdCAqL1xuICAgIHB1YmxpYyBydW5RdWVyeShjb25uOiBudW1iZXIsIHRleHQ6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcXVlcnlfcnVuJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gY29weUJ1ZmZlcih0aGlzLm1vZCwgZCwgbik7XG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgU3RhcnQgYSBwZW5kaW5nIHF1ZXJ5IGFzeW5jaHJvbm91c2x5LlxuICAgICAqICBUaGlzIG1ldGhvZCByZXR1cm5zIGVpdGhlciB0aGUgYXJyb3cgaXBjIHNjaGVtYSBvciBudWxsLlxuICAgICAqICBPbiBudWxsLCB0aGUgcXVlcnkgaGFzIHRvIGJlIGV4ZWN1dGVkIHVzaW5nIGBwb2xsUGVuZGluZ1F1ZXJ5YCB1bnRpbCB0aGF0IHJldHVybnMgIT0gbnVsbC5cbiAgICAgKiAgUmVzdWx0cyBjYW4gdGhlbiBiZSBmZXRjaGVkIHVzaW5nIGBmZXRjaFF1ZXJ5UmVzdWx0c2BcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRQZW5kaW5nUXVlcnkoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0JywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQgPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gY29weUJ1ZmZlcih0aGlzLm1vZCwgZCwgbik7XG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKiogUG9sbCBhIHBlbmRpbmcgcXVlcnkgKi9cbiAgICBwdWJsaWMgcG9sbFBlbmRpbmdRdWVyeShjb25uOiBudW1iZXIpOiBVaW50OEFycmF5IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3BvbGwnLCBbJ251bWJlciddLCBbY29ubl0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvcHlCdWZmZXIodGhpcy5tb2QsIGQsIG4pO1xuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqIENhbmNlbCBhIHBlbmRpbmcgcXVlcnkgKi9cbiAgICBwdWJsaWMgY2FuY2VsUGVuZGluZ1F1ZXJ5KGNvbm46IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWwnLCAnYm9vbGVhbicsIFsnbnVtYmVyJ10sIFtjb25uXSk7XG4gICAgfVxuICAgIC8qKiBGZXRjaCBxdWVyeSByZXN1bHRzICovXG4gICAgcHVibGljIGZldGNoUXVlcnlSZXN1bHRzKGNvbm46IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0cycsIFsnbnVtYmVyJ10sIFtjb25uXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gY29weUJ1ZmZlcih0aGlzLm1vZCwgZCwgbik7XG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvKiogR2V0IHRhYmxlIG5hbWVzICovXG4gICAgcHVibGljIGdldFRhYmxlTmFtZXMoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9nZXRfdGFibGVuYW1lcycsIFsnbnVtYmVyJywgJ3N0cmluZyddLCBbY29ubiwgdGV4dF0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pO1xuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzKSBhcyBzdHJpbmdbXTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc2NhbGFyIGZ1bmN0aW9uICovXG4gICAgcHVibGljIGNyZWF0ZVNjYWxhckZ1bmN0aW9uKFxuICAgICAgICBjb25uOiBudW1iZXIsXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgcmV0dXJuczogYXJyb3cuRGF0YVR5cGUsXG4gICAgICAgIGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGVjbDogVURGRnVuY3Rpb25EZWNsYXJhdGlvbiA9IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHRoaXMuX25leHRVREZJZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZXR1cm5UeXBlOiBhcnJvd1RvU1FMVHlwZShyZXR1cm5zKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVmOiBVREZGdW5jdGlvbiA9IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IGRlY2wuZnVuY3Rpb25JZCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZXR1cm5UeXBlOiByZXR1cm5zLFxuICAgICAgICAgICAgZnVuYyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbmV4dFVERklkICs9IDE7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxuICAgICAgICAgICAgdGhpcy5tb2QsXG4gICAgICAgICAgICAnZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZScsXG4gICAgICAgICAgICBbJ251bWJlcicsICdzdHJpbmcnXSxcbiAgICAgICAgICAgIFtjb25uLCBKU09OLnN0cmluZ2lmeShkZWNsKV0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgICAgIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuX3VkZkZ1bmN0aW9ucyA9IChnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLl91ZGZGdW5jdGlvbnMgfHwgbmV3IE1hcCgpKS5zZXQoXG4gICAgICAgICAgICBkZWYuZnVuY3Rpb25JZCxcbiAgICAgICAgICAgIGRlZixcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMucHRocmVhZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB3b3JrZXIgb2YgWy4uLnRoaXMucHRocmVhZC5ydW5uaW5nV29ya2VycywgLi4udGhpcy5wdGhyZWFkLnVudXNlZFdvcmtlcnNdKSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgY21kOiAncmVnaXN0ZXJVREZGdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHVkZjogZGVmLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByZXBhcmUgYSBzdGF0ZW1lbnQgYW5kIHJldHVybiBpdHMgaWRlbnRpZmllciAqL1xuICAgIHB1YmxpYyBjcmVhdGVQcmVwYXJlZChjb25uOiBudW1iZXIsIHRleHQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9wcmVwYXJlZF9jcmVhdGUnLCBbJ251bWJlcicsICdzdHJpbmcnXSwgW2Nvbm4sIHRleHRdKTtcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcbiAgICAgICAgfVxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgLyoqIENsb3NlIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXG4gICAgcHVibGljIGNsb3NlUHJlcGFyZWQoY29ubjogbnVtYmVyLCBzdGF0ZW1lbnQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2UnLCBbJ251bWJlcicsICdudW1iZXInXSwgW2Nvbm4sIHN0YXRlbWVudF0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xuICAgIH1cblxuICAgIC8qKiBFeGVjdXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50IGFuZCByZXR1cm4gdGhlIGZ1bGwgcmVzdWx0ICovXG4gICAgcHVibGljIHJ1blByZXBhcmVkKGNvbm46IG51bWJlciwgc3RhdGVtZW50OiBudW1iZXIsIHBhcmFtczogYW55W10pOiBVaW50OEFycmF5IHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXG4gICAgICAgICAgICB0aGlzLm1vZCxcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX3ByZXBhcmVkX3J1bicsXG4gICAgICAgICAgICBbJ251bWJlcicsICdudW1iZXInLCAnc3RyaW5nJ10sXG4gICAgICAgICAgICBbY29ubiwgc3RhdGVtZW50LCBKU09OLnN0cmluZ2lmeShwYXJhbXMpXSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqIEV4ZWN1dGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgYW5kIHN0cmVhbSB0aGUgcmVzdWx0ICovXG4gICAgcHVibGljIHNlbmRQcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogVWludDhBcnJheSB7XG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxuICAgICAgICAgICAgdGhpcy5tb2QsXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kJyxcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ251bWJlcicsICdzdHJpbmcnXSxcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnQsIEpTT04uc3RyaW5naWZ5KHBhcmFtcyldLFxuICAgICAgICApO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGNvcHlCdWZmZXIodGhpcy5tb2QsIGQsIG4pO1xuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKiogSW5zZXJ0IHJlY29yZCBiYXRjaGVzIGZyb20gYW4gYXJyb3cgaXBjIHN0cmVhbSAqL1xuICAgIHB1YmxpYyBpbnNlcnRBcnJvd0Zyb21JUENTdHJlYW0oY29ubjogbnVtYmVyLCBidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM/OiBBcnJvd0luc2VydE9wdGlvbnMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgICAvLyBTdG9yZSBidWZmZXJcbiAgICAgICAgY29uc3QgYnVmZmVyUHRyID0gdGhpcy5tb2QuX21hbGxvYyhidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT2ZzID0gdGhpcy5tb2QuSEVBUFU4LnN1YmFycmF5KGJ1ZmZlclB0ciwgYnVmZmVyUHRyICsgYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGJ1ZmZlck9mcy5zZXQoYnVmZmVyKTtcbiAgICAgICAgY29uc3Qgb3B0SlNPTiA9IG9wdGlvbnMgPyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSA6ICcnO1xuXG4gICAgICAgIC8vIENhbGwgd2FzbSBmdW5jdGlvblxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcbiAgICAgICAgICAgIHRoaXMubW9kLFxuICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbScsXG4gICAgICAgICAgICBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ3N0cmluZyddLFxuICAgICAgICAgICAgW2Nvbm4sIGJ1ZmZlclB0ciwgYnVmZmVyLmxlbmd0aCwgb3B0SlNPTl0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogSW5zZXJ0IGNzdiBmcm9tIHBhdGggKi9cbiAgICBwdWJsaWMgaW5zZXJ0Q1NWRnJvbVBhdGgoY29ubjogbnVtYmVyLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IENTVkluc2VydE9wdGlvbnMpOiB2b2lkIHtcbiAgICAgICAgLy8gU3RyaW5naWZ5IG9wdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbHVtbnNGbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdC5wdXNoKGFycm93VG9TUUxGaWVsZChrLCBvcHRpb25zLmNvbHVtbnNba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSB7IC4uLm9wdGlvbnMgfSBhcyBhbnk7XG4gICAgICAgIG9wdC5jb2x1bW5zID0gb3B0LmNvbHVtbnNGbGF0O1xuICAgICAgICBkZWxldGUgb3B0LmNvbHVtbnNGbGF0O1xuICAgICAgICBjb25zdCBvcHRKU09OID0gSlNPTi5zdHJpbmdpZnkob3B0KTtcblxuICAgICAgICAvLyBDYWxsIHdhc20gZnVuY3Rpb25cbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXG4gICAgICAgICAgICB0aGlzLm1vZCxcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2luc2VydF9jc3ZfZnJvbV9wYXRoJyxcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ3N0cmluZycsICdzdHJpbmcnXSxcbiAgICAgICAgICAgIFtjb25uLCBwYXRoLCBvcHRKU09OXSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogSW5zZXJ0IGpzb24gZnJvbSBwYXRoICovXG4gICAgcHVibGljIGluc2VydEpTT05Gcm9tUGF0aChjb25uOiBudW1iZXIsIHBhdGg6IHN0cmluZywgb3B0aW9uczogSlNPTkluc2VydE9wdGlvbnMpOiB2b2lkIHtcbiAgICAgICAgLy8gU3RyaW5naWZ5IG9wdGlvbnNcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvbHVtbnNGbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdC5wdXNoKGFycm93VG9TUUxGaWVsZChrLCBvcHRpb25zLmNvbHVtbnNba10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSB7IC4uLm9wdGlvbnMgfSBhcyBhbnk7XG4gICAgICAgIG9wdC5jb2x1bW5zID0gb3B0LmNvbHVtbnNGbGF0O1xuICAgICAgICBkZWxldGUgb3B0LmNvbHVtbnNGbGF0O1xuICAgICAgICBjb25zdCBvcHRKU09OID0gSlNPTi5zdHJpbmdpZnkob3B0KTtcblxuICAgICAgICAvLyBDYWxsIHdhc20gZnVuY3Rpb25cbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXG4gICAgICAgICAgICB0aGlzLm1vZCxcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aCcsXG4gICAgICAgICAgICBbJ251bWJlcicsICdzdHJpbmcnLCAnc3RyaW5nJ10sXG4gICAgICAgICAgICBbY29ubiwgcGF0aCwgb3B0SlNPTl0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEdsb2IgZmlsZSBpbmZvcyAqL1xuICAgIHB1YmxpYyBnbG9iRmlsZXMocGF0aDogc3RyaW5nKTogV2ViRmlsZVtdIHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvcycsIFsnc3RyaW5nJ10sIFtwYXRoXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5mb1N0ciA9IHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pO1xuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UoaW5mb1N0cikgYXMgV2ViRmlsZVtdO1xuICAgICAgICBpZiAoaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgb2JqZWN0IFVSTCAqL1xuICAgIHB1YmxpYyByZWdpc3RlckZpbGVVUkwobmFtZTogc3RyaW5nLCB1cmw6IHN0cmluZywgcHJvdG86IER1Y2tEQkRhdGFQcm90b2NvbCwgZGlyZWN0SU8gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVybCA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXG4gICAgICAgICAgICB0aGlzLm1vZCxcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsJyxcbiAgICAgICAgICAgIFsnc3RyaW5nJywgJ3N0cmluZyddLFxuICAgICAgICAgICAgW25hbWUsIHVybCwgcHJvdG8sIGRpcmVjdElPXSxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcbiAgICAgICAgfVxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGZpbGUgdGV4dCAqL1xuICAgIHB1YmxpYyByZWdpc3RlckZpbGVUZXh0KG5hbWU6IHN0cmluZywgdGV4dDogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRFWFRfRU5DT0RFUi5lbmNvZGUodGV4dCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaWxlQnVmZmVyKG5hbWUsIGJ1ZmZlcik7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgYnVmZmVyICovXG4gICAgcHVibGljIHJlZ2lzdGVyRmlsZUJ1ZmZlcihuYW1lOiBzdHJpbmcsIGJ1ZmZlcjogVWludDhBcnJheSk6IHZvaWQge1xuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLm1vZC5fbWFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICBjb25zdCBkc3QgPSB0aGlzLm1vZC5IRUFQVTguc3ViYXJyYXkocHRyLCBwdHIgKyBidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgZHN0LnNldChidWZmZXIpO1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcbiAgICAgICAgICAgIHRoaXMubW9kLFxuICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXInLFxuICAgICAgICAgICAgWydzdHJpbmcnLCAnbnVtYmVyJywgJ251bWJlciddLFxuICAgICAgICAgICAgW25hbWUsIHB0ciwgYnVmZmVyLmxlbmd0aF0sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgb2JqZWN0IFVSTCAqL1xuICAgIHB1YmxpYyByZWdpc3RlckZpbGVIYW5kbGU8SGFuZGxlVHlwZT4oXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgaGFuZGxlOiBIYW5kbGVUeXBlLFxuICAgICAgICBwcm90b2NvbDogRHVja0RCRGF0YVByb3RvY29sLFxuICAgICAgICBkaXJlY3RJTzogYm9vbGVhbixcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXG4gICAgICAgICAgICB0aGlzLm1vZCxcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsJyxcbiAgICAgICAgICAgIFsnc3RyaW5nJywgJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddLFxuICAgICAgICAgICAgW25hbWUsIG5hbWUsIHByb3RvY29sLCBkaXJlY3RJT10sXG4gICAgICAgICk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgICAgIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuX2ZpbGVzID0gKGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuX2ZpbGVzIHx8IG5ldyBNYXAoKSkuc2V0KG5hbWUsIGhhbmRsZSk7XG4gICAgICAgIGlmICh0aGlzLnB0aHJlYWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIHRoaXMucHRocmVhZC5ydW5uaW5nV29ya2Vycykge1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3JlZ2lzdGVyRmlsZUhhbmRsZScsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWxlSGFuZGxlOiBoYW5kbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdvcmtlciBvZiB0aGlzLnB0aHJlYWQudW51c2VkV29ya2Vycykge1xuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ2Ryb3BGaWxlSGFuZGxlJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIERyb3AgZmlsZSAqL1xuICAgIHB1YmxpYyBkcm9wRmlsZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZScsIFsnc3RyaW5nJ10sIFtuYW1lXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgfVxuICAgIC8qKiBEcm9wIGZpbGVzICovXG4gICAgcHVibGljIGRyb3BGaWxlcygpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXMnLCBbXSwgW10pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xuICAgIH1cbiAgICAvKiogRmx1c2ggYWxsIGZpbGVzICovXG4gICAgcHVibGljIGZsdXNoRmlsZXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzJywgbnVsbCwgW10sIFtdKTtcbiAgICB9XG4gICAgLyoqIFdyaXRlIGEgZmlsZSB0byBhIHBhdGggKi9cbiAgICBwdWJsaWMgY29weUZpbGVUb1BhdGgobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoJywgWydzdHJpbmcnLCAnc3RyaW5nJ10sIFtuYW1lLCBwYXRoXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgfVxuICAgIC8qKiBXcml0ZSBhIGZpbGUgdG8gYSBidWZmZXIgKi9cbiAgICBwdWJsaWMgY29weUZpbGVUb0J1ZmZlcihuYW1lOiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXInLCBbJ3N0cmluZyddLCBbbmFtZV0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMubW9kLkhFQVBVOC5zdWJhcnJheShkLCBkICsgbik7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShidWZmZXIubGVuZ3RoKTtcbiAgICAgICAgY29weS5zZXQoYnVmZmVyKTtcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cblxuICAgIC8qKiBFbmFibGUgdHJhY2tpbmcgb2YgZmlsZSBzdGF0aXN0aWNzICovXG4gICAgcHVibGljIGNvbGxlY3RGaWxlU3RhdGlzdGljcyhmaWxlOiBzdHJpbmcsIGVuYWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzJywgWydzdHJpbmcnLCAnYm9vbGVhbiddLCBbZmlsZSwgZW5hYmxlXSk7XG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEV4cG9ydCBmaWxlIHN0YXRpc3RpY3MgKi9cbiAgICBwdWJsaWMgZXhwb3J0RmlsZVN0YXRpc3RpY3MoZmlsZTogc3RyaW5nKTogRmlsZVN0YXRpc3RpY3Mge1xuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHMnLCBbJ3N0cmluZyddLCBbZmlsZV0pO1xuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmlsZVN0YXRpc3RpY3ModGhpcy5tb2QuSEVBUFU4LnN1YmFycmF5KGQsIGQgKyBuKSk7XG4gICAgfVxufVxuIiwgImV4cG9ydCBlbnVtIExvZ0xldmVsIHtcbiAgICBOT05FID0gMCxcbiAgICBERUJVRyA9IDEsXG4gICAgSU5GTyA9IDIsXG4gICAgV0FSTklORyA9IDMsXG4gICAgRVJST1IgPSA0LFxufVxuXG5leHBvcnQgZW51bSBMb2dUb3BpYyB7XG4gICAgTk9ORSA9IDAsXG4gICAgQ09OTkVDVCA9IDEsXG4gICAgRElTQ09OTkVDVCA9IDIsXG4gICAgT1BFTiA9IDMsXG4gICAgUVVFUlkgPSA0LFxuICAgIElOU1RBTlRJQVRFID0gNSxcbn1cblxuZXhwb3J0IGVudW0gTG9nRXZlbnQge1xuICAgIE5PTkUgPSAwLFxuICAgIE9LID0gMSxcbiAgICBFUlJPUiA9IDIsXG4gICAgU1RBUlQgPSAzLFxuICAgIFJVTiA9IDQsXG4gICAgQ0FQVFVSRSA9IDUsXG59XG5cbmV4cG9ydCBlbnVtIExvZ09yaWdpbiB7XG4gICAgTk9ORSA9IDAsXG4gICAgV0VCX1dPUktFUiA9IDEsXG4gICAgTk9ERV9XT1JLRVIgPSAyLFxuICAgIEJJTkRJTkdTID0gMyxcbiAgICBBU1lOQ19EVUNLREIgPSA0LFxufVxuXG5leHBvcnQgdHlwZSBMb2dFbnRyeTxPLCBULCBFLCBWPiA9IHtcbiAgICByZWFkb25seSB0aW1lc3RhbXA6IERhdGU7XG4gICAgcmVhZG9ubHkgbGV2ZWw6IExvZ0xldmVsO1xuICAgIHJlYWRvbmx5IG9yaWdpbjogTztcbiAgICByZWFkb25seSB0b3BpYzogVDtcbiAgICByZWFkb25seSBldmVudDogRTtcbiAgICByZWFkb25seSB2YWx1ZTogVjtcbn07XG5cbmV4cG9ydCB0eXBlIExvZ0VudHJ5VmFyaWFudCA9XG4gICAgfCBMb2dFbnRyeTxMb2dPcmlnaW4uQklORElOR1MsIExvZ1RvcGljLklOU1RBTlRJQVRFLCBMb2dFdmVudC5FUlJPUiwgc3RyaW5nPlxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5RVUVSWSwgTG9nRXZlbnQuU1RBUlQsIHZvaWQ+XG4gICAgfCBMb2dFbnRyeTxMb2dPcmlnaW4uQklORElOR1MsIExvZ1RvcGljLlFVRVJZLCBMb2dFdmVudC5PSywgdm9pZD5cbiAgICB8IExvZ0VudHJ5PExvZ09yaWdpbi5CSU5ESU5HUywgTG9nVG9waWMuUVVFUlksIExvZ0V2ZW50LkVSUk9SLCB2b2lkPlxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5DT05ORUNULCBMb2dFdmVudC5PSywgdm9pZD5cbiAgICB8IExvZ0VudHJ5PExvZ09yaWdpbi5CSU5ESU5HUywgTG9nVG9waWMuQ09OTkVDVCwgTG9nRXZlbnQuRVJST1IsIHZvaWQ+XG4gICAgfCBMb2dFbnRyeTxMb2dPcmlnaW4uQklORElOR1MsIExvZ1RvcGljLkRJU0NPTk5FQ1QsIExvZ0V2ZW50Lk9LLCB2b2lkPlxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5ESVNDT05ORUNULCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cbiAgICB8IExvZ0VudHJ5PExvZ09yaWdpbi5CSU5ESU5HUywgTG9nVG9waWMuT1BFTiwgTG9nRXZlbnQuU1RBUlQsIHZvaWQ+XG4gICAgfCBMb2dFbnRyeTxMb2dPcmlnaW4uQklORElOR1MsIExvZ1RvcGljLk9QRU4sIExvZ0V2ZW50Lk9LLCB2b2lkPlxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cbiAgICB8IExvZ0VudHJ5PExvZ09yaWdpbi5BU1lOQ19EVUNLREIsIExvZ1RvcGljLlFVRVJZLCBMb2dFdmVudC5SVU4sIHN0cmluZz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyIHtcbiAgICBsb2coZW50cnk6IExvZ0VudHJ5VmFyaWFudCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBWb2lkTG9nZ2VyIGltcGxlbWVudHMgTG9nZ2VyIHtcbiAgICBwdWJsaWMgbG9nKF9lbnRyeTogTG9nRW50cnlWYXJpYW50KTogdm9pZCB7fVxufVxuXG5leHBvcnQgY2xhc3MgQ29uc29sZUxvZ2dlciBpbXBsZW1lbnRzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk8pIHt9XG4gICAgcHVibGljIGxvZyhlbnRyeTogTG9nRW50cnlWYXJpYW50KTogdm9pZCB7XG4gICAgICAgIGlmIChlbnRyeS5sZXZlbCA+PSB0aGlzLmxldmVsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlbnRyeSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dMZXZlbExhYmVsKGxldmVsOiBMb2dMZXZlbCk6IHN0cmluZyB7XG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgICBjYXNlIExvZ0xldmVsLk5PTkU6XG4gICAgICAgICAgICByZXR1cm4gJ05PTkUnO1xuICAgICAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxuICAgICAgICAgICAgcmV0dXJuICdERUJVRyc7XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuSU5GTzpcbiAgICAgICAgICAgIHJldHVybiAnSU5GTyc7XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuV0FSTklORzpcbiAgICAgICAgICAgIHJldHVybiAnV0FSTklORyc7XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gJ0VSUk9SJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnPyc7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9nRXZlbnRMYWJlbChldmVudDogTG9nRXZlbnQpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoZXZlbnQpIHtcbiAgICAgICAgY2FzZSBMb2dFdmVudC5OT05FOlxuICAgICAgICAgICAgcmV0dXJuICdOT05FJztcbiAgICAgICAgY2FzZSBMb2dFdmVudC5PSzpcbiAgICAgICAgICAgIHJldHVybiAnT0snO1xuICAgICAgICBjYXNlIExvZ0V2ZW50LkVSUk9SOlxuICAgICAgICAgICAgcmV0dXJuICdFUlJPUic7XG4gICAgICAgIGNhc2UgTG9nRXZlbnQuU1RBUlQ6XG4gICAgICAgICAgICByZXR1cm4gJ1NUQVJUJztcbiAgICAgICAgY2FzZSBMb2dFdmVudC5SVU46XG4gICAgICAgICAgICByZXR1cm4gJ1JVTic7XG4gICAgICAgIGNhc2UgTG9nRXZlbnQuQ0FQVFVSRTpcbiAgICAgICAgICAgIHJldHVybiAnQ0FQVFVSRSc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJz8nO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ1RvcGljTGFiZWwodG9waWM6IExvZ1RvcGljKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHRvcGljKSB7XG4gICAgICAgIGNhc2UgTG9nVG9waWMuQ09OTkVDVDpcbiAgICAgICAgICAgIHJldHVybiAnQ09OTkVDVCc7XG4gICAgICAgIGNhc2UgTG9nVG9waWMuRElTQ09OTkVDVDpcbiAgICAgICAgICAgIHJldHVybiAnRElTQ09OTkVDVCc7XG4gICAgICAgIGNhc2UgTG9nVG9waWMuSU5TVEFOVElBVEU6XG4gICAgICAgICAgICByZXR1cm4gJ0lOU1RBTlRJQVRFJztcbiAgICAgICAgY2FzZSBMb2dUb3BpYy5PUEVOOlxuICAgICAgICAgICAgcmV0dXJuICdPUEVOJztcbiAgICAgICAgY2FzZSBMb2dUb3BpYy5RVUVSWTpcbiAgICAgICAgICAgIHJldHVybiAnUVVFUlknO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICc/JztcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dPcmlnaW5MYWJlbChvcmlnaW46IExvZ09yaWdpbik6IHN0cmluZyB7XG4gICAgc3dpdGNoIChvcmlnaW4pIHtcbiAgICAgICAgY2FzZSBMb2dPcmlnaW4uTk9ORTpcbiAgICAgICAgICAgIHJldHVybiAnTk9ORSc7XG4gICAgICAgIGNhc2UgTG9nT3JpZ2luLldFQl9XT1JLRVI6XG4gICAgICAgICAgICByZXR1cm4gJ1dFQiBXT1JLRVInO1xuICAgICAgICBjYXNlIExvZ09yaWdpbi5OT0RFX1dPUktFUjpcbiAgICAgICAgICAgIHJldHVybiAnTk9ERSBXT1JLRVInO1xuICAgICAgICBjYXNlIExvZ09yaWdpbi5CSU5ESU5HUzpcbiAgICAgICAgICAgIHJldHVybiAnRFVDS0RCIEJJTkRJTkdTJztcbiAgICAgICAgY2FzZSBMb2dPcmlnaW4uQVNZTkNfRFVDS0RCOlxuICAgICAgICAgICAgcmV0dXJuICdEVUNLREInO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICc/JztcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGJpZ0ludD0oKT0+KGFzeW5jIGU9Pnt0cnl7cmV0dXJuKGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGUpKS5pbnN0YW5jZS5leHBvcnRzLmIoQmlnSW50KDApKT09PUJpZ0ludCgwKX1jYXRjaChlKXtyZXR1cm4hMX19KShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw2LDEsOTYsMSwxMjYsMSwxMjYsMywyLDEsMCw3LDUsMSwxLDk4LDAsMCwxMCw2LDEsNCwwLDMyLDAsMTFdKSksYnVsa01lbW9yeT1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSwzLDEsMCwxLDEwLDE0LDEsMTIsMCw2NSwwLDY1LDAsNjUsMCwyNTIsMTAsMCwwLDExXSkpLGV4Y2VwdGlvbnM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDgsMSw2LDAsNiw2NCwyNSwxMSwxMV0pKSxleHRlbmRlZENvbnN0PWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCw1LDMsMSwwLDEsMTEsOSwxLDAsNjUsMSw2NSwyLDEwNiwxMSwwXSkpLGdjPWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDEwLDIsOTUsMSwxMjUsMCw5NiwwLDEsMTA3LDAsMywyLDEsMSwxMCwxMiwxLDEwLDAsNjcsMCwwLDAsMCwyNTEsNywwLDExXSkpLG1lbW9yeTY0PWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCw1LDMsMSw0LDFdKSksbXVsdGlWYWx1ZT1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw2LDEsOTYsMCwyLDEyNywxMjcsMywyLDEsMCwxMCw4LDEsNiwwLDY1LDAsNjUsMCwxMV0pKSxtdXRhYmxlR2xvYmFscz1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMiw4LDEsMSw5NywxLDk4LDMsMTI3LDEsNiw2LDEsMTI3LDEsNjUsMCwxMSw3LDUsMSwxLDk3LDMsMV0pKSxyZWZlcmVuY2VUeXBlcz1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsNywxLDUsMCwyMDgsMTEyLDI2LDExXSkpLHJlbGF4ZWRTaW1kPWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDUsMSw5NiwwLDEsMTIzLDMsMiwxLDAsMTAsMTUsMSwxMywwLDY1LDEsMjUzLDE1LDY1LDIsMjUzLDE1LDI1MywxMjgsMiwxMV0pKSxzYXR1cmF0ZWRGbG9hdFRvSW50PWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwxMiwxLDEwLDAsNjcsMCwwLDAsMCwyNTIsMCwyNiwxMV0pKSxzaWduRXh0ZW5zaW9ucz1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsOCwxLDYsMCw2NSwwLDE5MiwyNiwxMV0pKSxzaW1kPWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDUsMSw5NiwwLDEsMTIzLDMsMiwxLDAsMTAsMTAsMSw4LDAsNjUsMCwyNTMsMTUsMjUzLDk4LDExXSkpLHN0cmVhbWluZ0NvbXBpbGF0aW9uPSgpPT4oYXN5bmMoKT0+XCJjb21waWxlU3RyZWFtaW5nXCJpbiBXZWJBc3NlbWJseSkoKSx0YWlsQ2FsbD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsNiwxLDQsMCwxOCwwLDExXSkpLHRocmVhZHM9KCk9Pihhc3luYyBlPT57dHJ5e3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBNZXNzYWdlQ2hhbm5lbCYmKG5ldyBNZXNzYWdlQ2hhbm5lbCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShlKX1jYXRjaChlKXtyZXR1cm4hMX19KShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpO1xuIiwgImltcG9ydCAqIGFzIGNoZWNrIGZyb20gJ3dhc20tZmVhdHVyZS1kZXRlY3QnO1xuaW1wb3J0IHsgUEFDS0FHRV9OQU1FLCBQQUNLQUdFX1ZFUlNJT04gfSBmcm9tICcuL3ZlcnNpb24nO1xuXG4vLyBQbGF0Zm9ybSBjaGVjayB0YWtlbiBmcm9tIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20veHRlcm1qcy94dGVybS5qcy9ibG9iL21hc3Rlci9zcmMvY29tbW9uL1BsYXRmb3JtLnRzI0wyMVxuXG5pbnRlcmZhY2UgSU5hdmlnYXRvciB7XG4gICAgdXNlckFnZW50OiBzdHJpbmc7XG4gICAgbGFuZ3VhZ2U6IHN0cmluZztcbiAgICBwbGF0Zm9ybTogc3RyaW5nO1xufVxuXG4vLyBXZSdyZSBkZWNsYXJpbmcgYSBuYXZpZ2F0b3IgZ2xvYmFsIGhlcmUgYXMgd2UgZXhwZWN0IGl0IGluIGFsbCBydW50aW1lcyAobm9kZSBhbmQgYnJvd3NlciksIGJ1dFxuLy8gd2Ugd2FudCB0aGlzIG1vZHVsZSB0byBsaXZlIGluIGNvbW1vbi5cbmRlY2xhcmUgY29uc3QgbmF2aWdhdG9yOiBJTmF2aWdhdG9yO1xuXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGZhbHNlKTtcbmNvbnN0IHVzZXJBZ2VudCA9ICgpID0+IChpc05vZGUoKSA/ICdub2RlJyA6IG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZXhwb3J0IGNvbnN0IGlzRmlyZWZveCA9ICgpID0+IHVzZXJBZ2VudCgpLmluY2x1ZGVzKCdGaXJlZm94Jyk7XG5leHBvcnQgY29uc3QgaXNTYWZhcmkgPSAoKSA9PiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCgpKTtcblxuZXhwb3J0IGludGVyZmFjZSBEdWNrREJCdW5kbGVzIHtcbiAgICBtdnA6IHtcbiAgICAgICAgbWFpbk1vZHVsZTogc3RyaW5nO1xuICAgICAgICBtYWluV29ya2VyOiBzdHJpbmc7XG4gICAgfTtcbiAgICBlaD86IHtcbiAgICAgICAgbWFpbk1vZHVsZTogc3RyaW5nO1xuICAgICAgICBtYWluV29ya2VyOiBzdHJpbmc7XG4gICAgfTtcbiAgICBjb2k/OiB7XG4gICAgICAgIG1haW5Nb2R1bGU6IHN0cmluZztcbiAgICAgICAgbWFpbldvcmtlcjogc3RyaW5nO1xuICAgICAgICBwdGhyZWFkV29ya2VyOiBzdHJpbmc7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEpzRGVsaXZyQnVuZGxlcygpOiBEdWNrREJCdW5kbGVzIHtcbiAgICBjb25zdCBqc2RlbGl2cl9kaXN0X3VybCA9IGBodHRwczovL2Nkbi5qc2RlbGl2ci5uZXQvbnBtLyR7UEFDS0FHRV9OQU1FfUAke1BBQ0tBR0VfVkVSU0lPTn0vZGlzdC9gO1xuICAgIHJldHVybiB7XG4gICAgICAgIG12cDoge1xuICAgICAgICAgICAgbWFpbk1vZHVsZTogYCR7anNkZWxpdnJfZGlzdF91cmx9ZHVja2RiLW12cC53YXNtYCxcbiAgICAgICAgICAgIG1haW5Xb3JrZXI6IGAke2pzZGVsaXZyX2Rpc3RfdXJsfWR1Y2tkYi1icm93c2VyLW12cC53b3JrZXIuanNgLFxuICAgICAgICB9LFxuICAgICAgICBlaDoge1xuICAgICAgICAgICAgbWFpbk1vZHVsZTogYCR7anNkZWxpdnJfZGlzdF91cmx9ZHVja2RiLWVoLndhc21gLFxuICAgICAgICAgICAgbWFpbldvcmtlcjogYCR7anNkZWxpdnJfZGlzdF91cmx9ZHVja2RiLWJyb3dzZXItZWgud29ya2VyLmpzYCxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ09JIGlzIHN0aWxsIGV4cGVyaW1lbnRhbCwgbGV0IHRoZSB1c2VyIG9wdCBpbiBleHBsaWNpdGx5XG4gICAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEdWNrREJCdW5kbGUge1xuICAgIG1haW5Nb2R1bGU6IHN0cmluZztcbiAgICBtYWluV29ya2VyOiBzdHJpbmcgfCBudWxsO1xuICAgIHB0aHJlYWRXb3JrZXI6IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGxhdGZvcm1GZWF0dXJlcyB7XG4gICAgYmlnSW50NjRBcnJheTogYm9vbGVhbjtcbiAgICBjcm9zc09yaWdpbklzb2xhdGVkOiBib29sZWFuO1xuICAgIHdhc21FeGNlcHRpb25zOiBib29sZWFuO1xuICAgIHdhc21TSU1EOiBib29sZWFuO1xuICAgIHdhc21CdWxrTWVtb3J5OiBib29sZWFuO1xuICAgIHdhc21UaHJlYWRzOiBib29sZWFuO1xufVxuXG5sZXQgYmlnSW50NjRBcnJheTogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xubGV0IHdhc21FeGNlcHRpb25zOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG5sZXQgd2FzbVRocmVhZHM6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcbmxldCB3YXNtU0lNRDogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xubGV0IHdhc21CdWxrTWVtb3J5OiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXG5kZWNsYXJlIG5hbWVzcGFjZSBnbG9iYWxUaGlzIHtcbiAgICBsZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBsYXRmb3JtRmVhdHVyZXMoKTogUHJvbWlzZTxQbGF0Zm9ybUZlYXR1cmVzPiB7XG4gICAgaWYgKGJpZ0ludDY0QXJyYXkgPT0gbnVsbCkge1xuICAgICAgICBiaWdJbnQ2NEFycmF5ID0gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIGlmICh3YXNtRXhjZXB0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHdhc21FeGNlcHRpb25zID0gYXdhaXQgY2hlY2suZXhjZXB0aW9ucygpO1xuICAgIH1cbiAgICBpZiAod2FzbVRocmVhZHMgPT0gbnVsbCkge1xuICAgICAgICB3YXNtVGhyZWFkcyA9IGF3YWl0IGNoZWNrLnRocmVhZHMoKTtcbiAgICB9XG4gICAgaWYgKHdhc21TSU1EID09IG51bGwpIHtcbiAgICAgICAgd2FzbVNJTUQgPSBhd2FpdCBjaGVjay5zaW1kKCk7XG4gICAgfVxuICAgIGlmICh3YXNtQnVsa01lbW9yeSA9PSBudWxsKSB7XG4gICAgICAgIHdhc21CdWxrTWVtb3J5ID0gYXdhaXQgY2hlY2suYnVsa01lbW9yeSgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiaWdJbnQ2NEFycmF5OiBiaWdJbnQ2NEFycmF5ISxcbiAgICAgICAgY3Jvc3NPcmlnaW5Jc29sYXRlZDogaXNOb2RlKCkgfHwgZ2xvYmFsVGhpcy5jcm9zc09yaWdpbklzb2xhdGVkIHx8IGZhbHNlLFxuICAgICAgICB3YXNtRXhjZXB0aW9uczogd2FzbUV4Y2VwdGlvbnMhLFxuICAgICAgICB3YXNtU0lNRDogd2FzbVNJTUQhLFxuICAgICAgICB3YXNtVGhyZWFkczogd2FzbVRocmVhZHMhLFxuICAgICAgICB3YXNtQnVsa01lbW9yeTogd2FzbUJ1bGtNZW1vcnkhLFxuICAgIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWxlY3RCdW5kbGUoYnVuZGxlczogRHVja0RCQnVuZGxlcyk6IFByb21pc2U8RHVja0RCQnVuZGxlPiB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBnZXRQbGF0Zm9ybUZlYXR1cmVzKCk7XG4gICAgaWYgKHBsYXRmb3JtLndhc21FeGNlcHRpb25zKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS53YXNtU0lNRCAmJiBwbGF0Zm9ybS53YXNtVGhyZWFkcyAmJiBwbGF0Zm9ybS5jcm9zc09yaWdpbklzb2xhdGVkICYmIGJ1bmRsZXMuY29pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1haW5Nb2R1bGU6IGJ1bmRsZXMuY29pLm1haW5Nb2R1bGUsXG4gICAgICAgICAgICAgICAgbWFpbldvcmtlcjogYnVuZGxlcy5jb2kubWFpbldvcmtlcixcbiAgICAgICAgICAgICAgICBwdGhyZWFkV29ya2VyOiBidW5kbGVzLmNvaS5wdGhyZWFkV29ya2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVuZGxlcy5laCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYWluTW9kdWxlOiBidW5kbGVzLmVoLm1haW5Nb2R1bGUsXG4gICAgICAgICAgICAgICAgbWFpbldvcmtlcjogYnVuZGxlcy5laC5tYWluV29ya2VyLFxuICAgICAgICAgICAgICAgIHB0aHJlYWRXb3JrZXI6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1haW5Nb2R1bGU6IGJ1bmRsZXMubXZwLm1haW5Nb2R1bGUsXG4gICAgICAgIG1haW5Xb3JrZXI6IGJ1bmRsZXMubXZwLm1haW5Xb3JrZXIsXG4gICAgICAgIHB0aHJlYWRXb3JrZXI6IG51bGwsXG4gICAgfTtcbn1cbiIsICJpbXBvcnQge1MzQ29uZmlnfSBmcm9tIFwiLi4vYmluZGluZ3NcIjtcbmltcG9ydCB7c2hhMjU2fSBmcm9tIFwianMtc2hhMjU2XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUzNQYXJhbXMge1xuICAgIHVybDogc3RyaW5nLFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgaG9zdDogc3RyaW5nLFxuICAgIHJlZ2lvbjogc3RyaW5nLFxuICAgIHNlcnZpY2U6IHN0cmluZyxcbiAgICBtZXRob2Q6IHN0cmluZyxcbiAgICBhY2Nlc3NLZXlJZDogc3RyaW5nLFxuICAgIHNlY3JldEFjY2Vzc0tleTogc3RyaW5nLFxuICAgIHNlc3Npb25Ub2tlbjogc3RyaW5nLFxuICAgIGRhdGVOb3c6IHN0cmluZyxcbiAgICBkYXRldGltZU5vdzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUzNQYXlsb2FkUGFyYW1zIHtcbiAgICBjb250ZW50SGFzaDogc3RyaW5nIHwgbnVsbCxcbiAgICBjb250ZW50VHlwZTogc3RyaW5nIHwgbnVsbFxufVxuXG5jb25zdCBnZXRIVFRQSG9zdCA9IGZ1bmN0aW9uIChjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCwgdXJsIDogc3RyaW5nLCBidWNrZXQgOiBzdHJpbmcpIDogc3RyaW5nIHtcbiAgICBpZiAoY29uZmlnPy5lbmRwb2ludD8uc3RhcnRzV2l0aChcImh0dHBcIikpIHtcbiAgICAgICAgLy8gRW5kcG9pbnQgaXMgYSBmdWxsIHVybCwgd2UgYXBwZW5kIHRoZSBidWNrZXRcbiAgICAgICAgY29uc3QgaHR0cEhvc3QgPSBgJHtjb25maWc/LmVuZHBvaW50fWA7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGh0dHBIb3N0LmluZGV4T2YoXCI6Ly9cIikrMztcbiAgICAgICAgcmV0dXJuIGh0dHBIb3N0LnN1YnN0cmluZyhvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnPy5lbmRwb2ludCkge1xuICAgICAgICAvLyBFbmRwb2ludCBpcyBub3QgYSBmdWxsIHVybCBhbmQgdGhlIGh0dHBzOi8ve2J1Y2tldH0ue2RvbWFpbn0gZm9ybWF0IHdpbGwgYmUgdXNlZFxuICAgICAgICByZXR1cm4gYCR7YnVja2V0fS4ke2NvbmZpZz8uZW5kcG9pbnR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWZhdWx0IGF3cyBzMyB1cmxcbiAgICAgICAgcmV0dXJuIGAke2J1Y2tldH0uczMuYW1hem9uYXdzLmNvbWA7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UzNQYXJhbXMgKGNvbmZpZyA6IFMzQ29uZmlnIHwgdW5kZWZpbmVkLCB1cmw6IHN0cmluZywgbWV0aG9kIDogc3RyaW5nKSA6IFMzUGFyYW1zIHtcbiAgICBjb25zdCBwYXJzZWRTM1VybCA9IHBhcnNlUzNVcmwodXJsKTtcblxuICAgIC8vIHdoZW4gdXNpbmcgUzMgcGF0aC1zdHlsZSBhY2Nlc3MsIHRoZSBzaWduZWQgVVJMIHNob3VsZCBhbHNvIGluY2x1ZGUgdGhlIGJ1Y2tldCBuYW1lLCBcbiAgICAvLyAgYXMgaXQgaXMgcHJlc2VudCBpbiB0aGUgSFRUUCBVUkwgcGF0aC5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvdXNlcmd1aWRlL2FjY2Vzcy1idWNrZXQtaW50cm8uaHRtbCNwYXRoLXN0eWxlLXVybC1leFxuICAgIGxldCBwYXRoID0gIHBhcnNlZFMzVXJsLnBhdGg7XG4gICAgaWYgKGlzUGF0aFN0eWxlQWNjZXNzKGNvbmZpZykpIHtcbiAgICAgICAgcGF0aCA9IGAvJHtwYXJzZWRTM1VybC5idWNrZXR9JHtwYXRofWA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgcXVlcnk6IFwiXCIsXG4gICAgICAgIGhvc3Q6IGdldEhUVFBIb3N0KGNvbmZpZywgdXJsLCBwYXJzZWRTM1VybC5idWNrZXQpLFxuICAgICAgICByZWdpb246IChjb25maWc/LnJlZ2lvbikgPz8gXCJcIixcbiAgICAgICAgc2VydmljZTogXCJzM1wiLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgYWNjZXNzS2V5SWQ6IChjb25maWc/LmFjY2Vzc0tleUlkKSA/PyBcIlwiLFxuICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6IChjb25maWc/LnNlY3JldEFjY2Vzc0tleSkgPz8gXCJcIixcbiAgICAgICAgc2Vzc2lvblRva2VuOiAoY29uZmlnPy5zZXNzaW9uVG9rZW4pID8/IFwiXCIsXG4gICAgICAgIGRhdGVOb3c6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC8tL2csJycpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgIGRhdGV0aW1lTm93OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvLS9nLCcnKS5yZXBsYWNlKC86L2csJycpLnNwbGl0KCcuJylbMF0rICdaJyxcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJpRW5jb2RlKGlucHV0IDogc3RyaW5nLCBlbmNvZGVfc2xhc2ggPSBmYWxzZSkge1xuICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25TMy9sYXRlc3QvQVBJL3NpZ3Y0LXF1ZXJ5LXN0cmluZy1hdXRoLmh0bWxcblxuICAgIGNvbnN0IGhleERpZ2l0ID0gXCIwMTIzNDU2Nzg5QUJDREVGXCI7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoIDogc3RyaW5nID0gaW5wdXRbaV07XG5cbiAgICAgICAgaWYgKChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fCAoY2ggPj0gJ2EnICYmIGNoIDw9ICd6JykgfHwgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHx8IGNoID09ICdfJyB8fFxuICAgICAgICAgICAgY2ggPT0gJy0nIHx8IGNoID09ICd+JyB8fCBjaCA9PSAnLicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaDtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSAnLycpIHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVfc2xhc2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIlMkZcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJVwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhleERpZ2l0W2NoLmNoYXJDb2RlQXQoMCkgPj4gNF07XG4gICAgICAgICAgICByZXN1bHQgKz0gaGV4RGlnaXRbY2guY2hhckNvZGVBdCgwKSAmIDE1XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUzNIZWFkZXJzKHBhcmFtczogUzNQYXJhbXMsIHBheWxvYWRQYXJhbXMgOiBTM1BheWxvYWRQYXJhbXMgfCBudWxsID0gbnVsbCkgOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICAvLyB0aGlzIGlzIHRoZSBzaGEyNTYgb2YgdGhlIGVtcHR5IHN0cmluZywgaXRzIHVzZWZ1bCBzaW5jZSB3ZSBoYXZlIG5vIHBheWxvYWQgZm9yIEdFVCByZXF1ZXN0c1xuICAgIGNvbnN0IHBheWxvYWRIYXNoID0gKHBheWxvYWRQYXJhbXM/LmNvbnRlbnRIYXNoKSA/PyBcImUzYjBjNDQyOThmYzFjMTQ5YWZiZjRjODk5NmZiOTI0MjdhZTQxZTQ2NDliOTM0Y2E0OTU5OTFiNzg1MmI4NTVcIjtcblxuICAgIGNvbnN0IHJlcyA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG4gICAgLy8gcmVzLnNldChcImhvc3RcIiwgcGFyYW1zLmhvc3QpXG4gICAgcmVzLnNldChcIngtYW16LWRhdGVcIiwgcGFyYW1zLmRhdGV0aW1lTm93KTtcbiAgICByZXMuc2V0KFwieC1hbXotY29udGVudC1zaGEyNTZcIiwgcGF5bG9hZEhhc2gpO1xuXG4gICAgaWYgKHBhcmFtcy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgcmVzLnNldChcIngtYW16LXNlY3VyaXR5LXRva2VuXCIsIHBhcmFtcy5zZXNzaW9uVG9rZW4pO1xuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdCBzdHJpbmcgdG8gc2lnblxuICAgIGxldCBzaWduZWRIZWFkZXJzID0gXCJcIjtcbiAgICBpZiAocGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGUpIHtcbiAgICAgICAgc2lnbmVkSGVhZGVycyArPSBcImNvbnRlbnQtdHlwZTtcIjtcbiAgICB9XG4gICAgc2lnbmVkSGVhZGVycyArPSBcImhvc3Q7eC1hbXotY29udGVudC1zaGEyNTY7eC1hbXotZGF0ZVwiO1xuICAgIGlmIChwYXJhbXMuc2Vzc2lvblRva2VuKSB7XG4gICAgICAgIHNpZ25lZEhlYWRlcnMgKz0gXCI7eC1hbXotc2VjdXJpdHktdG9rZW5cIjtcbiAgICB9XG5cbiAgICBsZXQgY2Fub25pY2FsUmVxdWVzdCA9IHBhcmFtcy5tZXRob2QgKyBcIlxcblwiICsgdXJpRW5jb2RlKHBhcmFtcy51cmwpICsgXCJcXG5cIiArIHBhcmFtcy5xdWVyeTtcbiAgICBpZiAocGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGUpIHtcbiAgICAgICAgY2Fub25pY2FsUmVxdWVzdCArPSBcIlxcbmNvbnRlbnQtdHlwZTpcIiArIHBheWxvYWRQYXJhbXM/LmNvbnRlbnRUeXBlO1xuICAgIH1cbiAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxuaG9zdDpcIiArIHBhcmFtcy5ob3N0ICtcbiAgICAgICAgXCJcXG54LWFtei1jb250ZW50LXNoYTI1NjpcIiArIHBheWxvYWRIYXNoICsgXCJcXG54LWFtei1kYXRlOlwiICsgcGFyYW1zLmRhdGV0aW1lTm93O1xuICAgIGlmIChwYXJhbXMuc2Vzc2lvblRva2VuICYmIHBhcmFtcy5zZXNzaW9uVG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxueC1hbXotc2VjdXJpdHktdG9rZW46XCIgKyBwYXJhbXMuc2Vzc2lvblRva2VuO1xuICAgIH1cblxuICAgIGNhbm9uaWNhbFJlcXVlc3QgKz0gXCJcXG5cXG5cIiArIHNpZ25lZEhlYWRlcnMgKyBcIlxcblwiICsgcGF5bG9hZEhhc2g7XG4gICAgY29uc3QgY2Fub25pY2FsUmVxdWVzdEhhc2hTdHIgPSBzaGEyNTYoY2Fub25pY2FsUmVxdWVzdCk7XG5cbiAgICBjb25zdCBzdHJpbmdUb1NpZ24gPSBcIkFXUzQtSE1BQy1TSEEyNTZcXG5cIiArIHBhcmFtcy5kYXRldGltZU5vdyArIFwiXFxuXCIgKyBwYXJhbXMuZGF0ZU5vdyArIFwiL1wiICsgcGFyYW1zLnJlZ2lvbiArIFwiL1wiICsgcGFyYW1zLnNlcnZpY2UgK1xuICAgICAgICBcIi9hd3M0X3JlcXVlc3RcXG5cIiArIGNhbm9uaWNhbFJlcXVlc3RIYXNoU3RyO1xuXG4gICAgLy8gdHMtaWdub3JlJ3MgYmVjYXVzZSBsaWJyYXJ5IGNhbiBhY2NlcHQgYXJyYXkgYnVmZmVyIGFzIGtleSwgYnV0IFRTIGFyZyBpcyBpbmNvcnJlY3RcbiAgICBjb25zdCBzaWduS2V5ID0gXCJBV1M0XCIgKyBwYXJhbXMuc2VjcmV0QWNjZXNzS2V5O1xuICAgIGNvbnN0IGtEYXRlID0gc2hhMjU2LmhtYWMuYXJyYXlCdWZmZXIoc2lnbktleSwgcGFyYW1zLmRhdGVOb3cpO1xuXG4gICAgLy8gTm90ZSwganMtc2hhMjU2IGhhcyBhIGJ1ZyBpbiB0aGUgVFMgaW50ZXJmYWNlIHRoYXQgb25seSBzdXBwb3J0cyBzdHJpbmdzIGFzIGtleXMsIHdoaWxlIHdlIG5lZWQgYSBieXRlYXJyYXlcbiAgICAvLyBhcyBrZXkuIFBSIGlzIG9wZW4gYnV0IHVubWVyZ2VkOiBodHRwczovL2dpdGh1Yi5jb20vZW1uMTc4L2pzLXNoYTI1Ni9wdWxsLzI1XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGtSZWdpb24gPSBzaGEyNTYuaG1hYy5hcnJheUJ1ZmZlcihrRGF0ZSwgcGFyYW1zLnJlZ2lvbik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGtTZXJ2aWNlID0gc2hhMjU2LmhtYWMuYXJyYXlCdWZmZXIoa1JlZ2lvbiwgcGFyYW1zLnNlcnZpY2UsKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2lnbmluZ0tleSA9IHNoYTI1Ni5obWFjLmFycmF5QnVmZmVyKGtTZXJ2aWNlLCBcImF3czRfcmVxdWVzdFwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gc2hhMjU2LmhtYWMoc2lnbmluZ0tleSwgc3RyaW5nVG9TaWduKTtcblxuICAgIHJlcy5zZXQoXCJBdXRob3JpemF0aW9uXCIsIFwiQVdTNC1ITUFDLVNIQTI1NiBDcmVkZW50aWFsPVwiICsgcGFyYW1zLmFjY2Vzc0tleUlkICsgXCIvXCIgKyBwYXJhbXMuZGF0ZU5vdyArIFwiL1wiICsgcGFyYW1zLnJlZ2lvbiArIFwiL1wiICtcbiAgICAgICAgcGFyYW1zLnNlcnZpY2UgKyBcIi9hd3M0X3JlcXVlc3QsIFNpZ25lZEhlYWRlcnM9XCIgKyBzaWduZWRIZWFkZXJzICtcbiAgICAgICAgXCIsIFNpZ25hdHVyZT1cIiArIHNpZ25hdHVyZSk7XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5jb25zdCBjcmVhdGVTM0hlYWRlcnNGcm9tUzNDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZywgbWV0aG9kIDogc3RyaW5nLCBjb250ZW50VHlwZTogc3RyaW5nIHwgbnVsbCA9IG51bGwsIHBheWxvYWQgOiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGwpIDogTWFwPHN0cmluZywgc3RyaW5nPiB7XG4gICAgY29uc3QgcGFyYW1zID0gZ2V0UzNQYXJhbXMoY29uZmlnLCB1cmwsIG1ldGhvZCk7XG4gICAgY29uc3QgcGF5bG9hZFBhcmFtcyA9IHtcbiAgICAgICAgY29udGVudFR5cGU6IGNvbnRlbnRUeXBlLFxuICAgICAgICBjb250ZW50SGFzaDogcGF5bG9hZCA/IHNoYTI1Ni5oZXgocGF5bG9hZCEpIDogbnVsbFxuICAgIH0gYXMgUzNQYXlsb2FkUGFyYW1zO1xuICAgIHJldHVybiBjcmVhdGVTM0hlYWRlcnMocGFyYW1zLCBwYXlsb2FkUGFyYW1zKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFMzSGVhZGVycyh4aHI6IFhNTEh0dHBSZXF1ZXN0LCBjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCwgdXJsIDogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgY29udGVudFR5cGU6IHN0cmluZyB8IG51bGwgPSBudWxsLCBwYXlsb2FkIDogVWludDhBcnJheSB8IG51bGwgPSBudWxsKSB7XG4gICAgaWYgKGNvbmZpZz8uYWNjZXNzS2V5SWQgfHwgY29uZmlnPy5zZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGNyZWF0ZVMzSGVhZGVyc0Zyb21TM0NvbmZpZyhjb25maWcsIHVybCwgbWV0aG9kLCBjb250ZW50VHlwZSwgcGF5bG9hZCk7XG4gICAgICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWU6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiY29udGVudC10eXBlXCIsIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUzNVcmwgKHVybDogc3RyaW5nKSA6IHtidWNrZXQgOiBzdHJpbmcsIHBhdGggOiBzdHJpbmd9IHtcbiAgICBpZiAodXJsLmluZGV4T2YoXCJzMzovL1wiKSAhPSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBuZWVkcyB0byBzdGFydCB3aXRoIHMzOi8vXCIpO1xuICAgIH1cbiAgICBjb25zdCBzbGFzaFBvcyA9IHVybC5pbmRleE9mKCcvJywgNSk7XG5cbiAgICBpZiAoc2xhc2hQb3MgPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIG5lZWRzIHRvIGNvbnRhaW4gYSAnLycgYWZ0ZXIgdGhlIGhvc3RcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYnVja2V0ID0gdXJsLnN1YnN0cmluZyg1LCBzbGFzaFBvcyk7XG4gICAgaWYgKCFidWNrZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIG5lZWRzIHRvIGNvbnRhaW4gYSBidWNrZXQgbmFtZVwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IHVybC5zdWJzdHJpbmcoc2xhc2hQb3MpO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgbmVlZHMgdG8gY29udGFpbiBrZXlcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtidWNrZXQ6IGJ1Y2tldCwgcGF0aDogcGF0aH1cbn1cblxuZnVuY3Rpb24gaXNQYXRoU3R5bGVBY2Nlc3MoY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQpIDogYm9vbGVhbiB7XG4gICAgaWYgKGNvbmZpZz8uZW5kcG9pbnQ/LnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SFRUUFVybChjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCwgdXJsIDogc3RyaW5nKSA6IHN0cmluZyB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gcGFyc2VTM1VybCh1cmwpO1xuICAgIGlmIChpc1BhdGhTdHlsZUFjY2Vzcyhjb25maWcpKSB7XG4gICAgICAgIC8vIEVuZHBvaW50IGlzIGEgZnVsbCB1cmwsIHdlIGFwcGVuZCB0aGUgYnVja2V0XG4gICAgICAgIHJldHVybiBgJHtjb25maWc/LmVuZHBvaW50fS8ke3BhcnNlZFVybC5idWNrZXR9YCArIHBhcnNlZFVybC5wYXRoO1xuICAgIH1cbiAgICByZXR1cm4gJ2h0dHBzOi8vJyArIGdldEhUVFBIb3N0KGNvbmZpZywgdXJsLCBwYXJzZWRVcmwuYnVja2V0KSArIHBhcnNlZFVybC5wYXRoO1xufSIsICJpbXBvcnQgeyBTdGF0dXNDb2RlIH0gZnJvbSAnLi4vc3RhdHVzJztcbmltcG9ydCB7IGFkZFMzSGVhZGVycywgZ2V0SFRUUFVybCB9IGZyb20gJy4uL3V0aWxzJztcblxuaW1wb3J0IHtcbiAgICBjYWxsU1JldCxcbiAgICBkcm9wUmVzcG9uc2VCdWZmZXJzLFxuICAgIER1Y2tEQkRhdGFQcm90b2NvbCxcbiAgICBEdWNrREJGaWxlSW5mbyxcbiAgICBEdWNrREJHbG9iYWxGaWxlSW5mbyxcbiAgICBEdWNrREJSdW50aW1lLFxuICAgIGZhaWxXaXRoLFxuICAgIEZpbGVGbGFncyxcbiAgICByZWFkU3RyaW5nLFxufSBmcm9tICcuL3J1bnRpbWUnO1xuaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcbmltcG9ydCAqIGFzIHVkZiBmcm9tICcuL3VkZl9ydW50aW1lJztcblxuZXhwb3J0IGNvbnN0IEJST1dTRVJfUlVOVElNRTogRHVja0RCUnVudGltZSAmIHtcbiAgICBfZmlsZUluZm9DYWNoZTogTWFwPG51bWJlciwgRHVja0RCRmlsZUluZm8+O1xuICAgIF9nbG9iYWxGaWxlSW5mbzogRHVja0RCR2xvYmFsRmlsZUluZm8gfCBudWxsO1xuXG4gICAgZ2V0RmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKTogRHVja0RCRmlsZUluZm8gfCBudWxsO1xuICAgIGdldEdsb2JhbEZpbGVJbmZvKG1vZDogRHVja0RCTW9kdWxlKTogRHVja0RCR2xvYmFsRmlsZUluZm8gfCBudWxsO1xufSA9IHtcbiAgICBfZmlsZXM6IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCksXG4gICAgX2ZpbGVJbmZvQ2FjaGU6IG5ldyBNYXA8bnVtYmVyLCBEdWNrREJGaWxlSW5mbz4oKSxcbiAgICBfdWRmRnVuY3Rpb25zOiBuZXcgTWFwKCksXG4gICAgX2dsb2JhbEZpbGVJbmZvOiBudWxsLFxuXG4gICAgZ2V0RmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKTogRHVja0RCRmlsZUluZm8gfCBudWxsIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZCA9IEJST1dTRVJfUlVOVElNRS5fZmlsZUluZm9DYWNoZS5nZXQoZmlsZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxuICAgICAgICAgICAgICAgIG1vZCxcbiAgICAgICAgICAgICAgICAnZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkJyxcbiAgICAgICAgICAgICAgICBbJ251bWJlcicsICdudW1iZXInXSxcbiAgICAgICAgICAgICAgICBbZmlsZUlkLCBjYWNoZWQ/LmNhY2hlRXBvY2ggfHwgMF0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRXBvY2ggaXMgdXAgdG8gZGF0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5mb1N0ciA9IHJlYWRTdHJpbmcobW9kLCBkLCBuKTtcbiAgICAgICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnMobW9kKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKGluZm9TdHIpO1xuICAgICAgICAgICAgaWYgKGluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IHsgLi4uaW5mbywgYmxvYjogbnVsbCB9IGFzIER1Y2tEQkZpbGVJbmZvO1xuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLnNldChmaWxlSWQsIGZpbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0R2xvYmFsRmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUpOiBEdWNrREJHbG9iYWxGaWxlSW5mbyB8IG51bGwge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXG4gICAgICAgICAgICAgICAgbW9kLFxuICAgICAgICAgICAgICAgICdkdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvJyxcbiAgICAgICAgICAgICAgICBbJ251bWJlciddLFxuICAgICAgICAgICAgICAgIFtCUk9XU0VSX1JVTlRJTUUuX2dsb2JhbEZpbGVJbmZvPy5jYWNoZUVwb2NoIHx8IDBdLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEVwb2NoIGlzIHVwIHRvIGRhdGVcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJPV1NFUl9SVU5USU1FLl9nbG9iYWxGaWxlSW5mbyE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmZvU3RyID0gcmVhZFN0cmluZyhtb2QsIGQsIG4pO1xuICAgICAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyhtb2QpO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UoaW5mb1N0cik7XG4gICAgICAgICAgICBpZiAoaW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBCUk9XU0VSX1JVTlRJTUUuX2dsb2JhbEZpbGVJbmZvID0geyAuLi5pbmZvLCBibG9iOiBudWxsIH0gYXMgRHVja0RCR2xvYmFsRmlsZUluZm87XG5cbiAgICAgICAgICAgIHJldHVybiBCUk9XU0VSX1JVTlRJTUUuX2dsb2JhbEZpbGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRlc3RQbGF0Zm9ybUZlYXR1cmU6IChfbW9kOiBEdWNrREJNb2R1bGUsIGZlYXR1cmU6IG51bWJlcik6IGJvb2xlYW4gPT4ge1xuICAgICAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIEJpZ0ludDY0QXJyYXkgIT09ICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHRlc3QgZm9yIHVua25vd24gZmVhdHVyZTogJHtmZWF0dXJlfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0RGF0YVByb3RvY29sKG1vZDogRHVja0RCTW9kdWxlKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI7XG4gICAgfSxcblxuICAgIG9wZW5GaWxlOiAobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyLCBmbGFnczogRmlsZUZsYWdzKTogbnVtYmVyID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEJST1dTRVJfUlVOVElNRS5fZmlsZUluZm9DYWNoZS5kZWxldGUoZmlsZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5IVFRQOlxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLlMzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbGFncyAmIEZpbGVGbGFncy5GSUxFX0ZMQUdTX1JFQUQgJiYgZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19XUklURSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPcGVuaW5nIGZpbGUgJHtmaWxlLmZpbGVOYW1lfSBmYWlsZWQ6IGNhbm5vdCBvcGVuIGZpbGUgd2l0aCBib3RoIHJlYWQgYW5kIHdyaXRlIGZsYWdzIHNldGAsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICYgRmlsZUZsYWdzLkZJTEVfRkxBR1NfQVBQRU5EKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogYXBwZW5kaW5nIHRvIEhUVFAvUzMgZmlsZXMgaXMgbm90IHN1cHBvcnRlZGAsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICYgRmlsZUZsYWdzLkZJTEVfRkxBR1NfV1JJVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNlbmQgYSBIRUFEIHJlcXVlc3QgdG8gdHJ5IHRvIGRldGVybWluZSBpZiB3ZSBjYW4gd3JpdGUgdG8gZGF0YV91cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZGF0YVByb3RvY29sID09IER1Y2tEQkRhdGFQcm90b2NvbC5TMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZ2V0SFRUUFVybChmaWxlLnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIsIGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdIRUFEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZmlsZS5kYXRhVXJsISwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGVjdCAyMDAgZm9yIGV4aXN0aW5nIGZpbGVzIHRoYXQgd2Ugd2lsbCBvdmVyd3JpdGUgb3IgNDA0IGZvciBub24tZXhpc3RlbnQgZmlsZXMgY2FuIGJlIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9IDIwMCAmJiB4aHIuc3RhdHVzICE9IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogVW5leHBlY3RlZCByZXR1cm4gc3RhdHVzIGZyb20gc2VydmVyICgke3hoci5zdGF0dXN9KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA9PSA0MDQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKGZsYWdzICYgRmlsZUZsYWdzLkZJTEVfRkxBR1NfRklMRV9DUkVBVEUgfHwgZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19GSUxFX0NSRUFURV9ORVcpXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPcGVuaW5nIGZpbGUgJHtmaWxlLmZpbGVOYW1lfSBmYWlsZWQ6IENhbm5vdCB3cml0ZSB0byBub24tZXhpc3RlbnQgZmlsZSB3aXRob3V0IEZJTEVfRkxBR1NfRklMRV9DUkVBVEUgb3IgRklMRV9GTEFHU19GSUxFX0NSRUFURV9ORVcgZmxhZy5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgYnVmZmVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gYnVmZmVyIHRoZSB3cml0ZXMgdG8gdGhpcyBzMy9odHRwIGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2QuX21hbGxvYygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUFU4LnNldChzcmMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDBdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAxXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICE9IEZpbGVGbGFncy5GSUxFX0ZMQUdTX1JFQUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlbmluZyBmaWxlICR7ZmlsZS5maWxlTmFtZX0gZmFpbGVkOiB1bnN1cHBvcnRlZCBmaWxlIGZsYWdzOiAke2ZsYWdzfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydHMgcmFuZ2VzP1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudExlbmd0aCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcjogYW55IHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZW5kIGEgZHVtbXkgSEVBRCByZXF1ZXN0IHdpdGggcmFuZ2UgcHJvdG9jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIC0+IGdvb2QgSUZGIHN0YXR1cyBpcyAyMDYgYW5kIGNvbnRlbnRMZW5naHQgaXMgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBnZXRIVFRQVXJsKGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISwgJ0hFQUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBmaWxlLmRhdGFVcmwhLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCBgYnl0ZXM9MC1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0cyByYW5nZSByZXF1ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIHhoci5zdGF0dXMgPT0gMjA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9ICtjb250ZW50TGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAxXSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEhFQUQgcmVxdWVzdCB3aXRoIHJhbmdlIGhlYWRlciBmYWlsZWQ6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmYWxsYmFjayB0byBmdWxsIHJlYWQ/XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLmFsbG93RnVsbEh0dHBSZWFkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb250ZW50TGVuZ3RoICE9PSBudWxsKSAmJiAoK2NvbnRlbnRMZW5ndGggPiAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIFNlbmQgYSBkdW1teSBHRVQgcmFuZ2UgcmVxdWVzdCBxdWVyeWluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIC0+IGdvb2QgSUZGIHN0YXR1cyBpcyAyMDYgYW5kIGNvbnRlbnRMZW5naHQyIGlzIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAtPiBvdGhlcndpc2UsIGlmZiAyMDAgYW5kIGNvbnRlbnRMZW5naHQyID09IGNvbnRlbnRMZW5naHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgd2UganVzdCBkb3dubG9hZGVkIHRoZSBmaWxlLCBzYXZlIGl0IGFuZCBtb3ZlIGZ1cnRoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBnZXRIVFRQVXJsKGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIsIGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdHRVQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgZmlsZS5kYXRhVXJsISwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCBgYnl0ZXM9MC0wYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aDIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDYgJiYgY29udGVudExlbmd0aDIgIT09IG51bGwgJiYgK2NvbnRlbnRMZW5ndGgyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSArY29udGVudExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwICYmIGNvbnRlbnRMZW5ndGgyICE9PSBudWxsICYmICtjb250ZW50TGVuZ3RoMiA9PSArY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGZhbGwgYmFjayB0byBmdWxsIEhUVFAgcmVhZCBmb3I6ICR7ZmlsZS5kYXRhVXJsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbW9kLl9tYWxsb2MoeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UsIDAsIHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoc3JjLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSB4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGZhbGxpbmcgYmFjayB0byBmdWxsIEhUVFAgcmVhZCBmb3I6ICR7ZmlsZS5kYXRhVXJsfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gU2VuZCBub24tcmFuZ2UgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGdldEhUVFBVcmwoZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBmaWxlLnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhLCAnR0VUJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLmRhdGFVcmwhLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbW9kLl9tYWxsb2MoeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSwgMCwgeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQVTguc2V0KHNyYywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9IHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAxXSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJhaXNlIGVycm9yP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFkaW5nIGZpbGUgJHtmaWxlLmZpbGVOYW1lfSBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRmlsZSByZWFkZXIgRmlsZVxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9IGhhbmRsZS5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gZW1wdHkgYnVmZmVyZWQgZmlsZSBpbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEJ1ZmZlcmluZyBtaXNzaW5nIGZpbGU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbW9kLl9tYWxsb2MoMiAqIDgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBtb2QuX21hbGxvYygxKTsgLy8gbWFsbG9jKDApIGlzIGFsbG93ZWQgdG8gcmV0dXJuIGEgbnVsbHB0clxuICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMV0gPSBidWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gKHNhbWFuc21pbmspOiB0aGlzIHBhdGggY2F1c2VzIHRoZSBXQVNNIGNvZGUgdG8gaGFuZ1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZ2xvYjogKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHJlYWRTdHJpbmcobW9kLCBwYXRoUHRyLCBwYXRoTGVuKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0cyB3aXRoIGh0dHA/XG4gICAgICAgICAgICAvLyBUcnkgYSBIVFRQIEhFQUQgcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnaHR0cCcpIHx8IHBhdGguc3RhcnRzV2l0aCgnczM6Ly8nKSkge1xuICAgICAgICAgICAgICAgIC8vIFNlbmQgYSBkdW1teSByYW5nZSByZXF1ZXN0IHF1ZXJ5aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBmaWxlXG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnczM6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxJbmZvID0gQlJPV1NFUl9SVU5USU1FLmdldEdsb2JhbEZpbGVJbmZvKG1vZCk7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZ2V0SFRUUFVybChnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZ2xvYmFsSW5mbz8uczNDb25maWcsIHBhdGgsICdIRUFEJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBwYXRoISwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPSAyMDAgJiYgeGhyLnN0YXR1cyAhPT0gMjA2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1zaWduZWQgcmVzb3VyY2VzIG9uIFMzIGluIGNvbW1vbiBjb25maWd1cmF0aW9ucyBmYWlsIG9uIGFueSBIRUFEIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3Nkay1mb3ItZ28vdjEvZGV2ZWxvcGVyLWd1aWRlL3MzLWV4YW1wbGUtcHJlc2lnbmVkLXVybHMuaHRtbFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIChpZiBlbmFibGVkKSB0byBidW1wIHRvIGEgcmFuZ2VkIEdFVFxuICAgICAgICAgICAgICAgICAgICBpZiAoIUJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpPy5hbGxvd0Z1bGxIdHRwUmVhZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgYEhFQUQgcmVxdWVzdCBmYWlsZWQ6ICR7cGF0aH0sIHdpdGggZnVsbCBodHRwIHJlYWRzIGFyZSBkaXNhYmxlZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhocjIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnczM6Ly8nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsSW5mbyA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyMi5vcGVuKCdHRVQnLCBnZXRIVFRQVXJsKGdsb2JhbEluZm8/LnMzQ29uZmlnLCBwYXRoKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhocjIsIGdsb2JhbEluZm8/LnMzQ29uZmlnLCBwYXRoLCAnSEVBRCcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyMi5vcGVuKCdHRVQnLCBwYXRoISwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHhocjIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCBgYnl0ZXM9MC0wYCk7XG4gICAgICAgICAgICAgICAgICAgIHhocjIuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhocjIuc3RhdHVzICE9IDIwMCAmJiB4aHIyLnN0YXR1cyAhPT0gMjA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBIRUFEIGFuZCBHRVQgcmVxdWVzdHMgZmFpbGVkOiAke3BhdGh9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHhocjIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50TGVuZ3RoICYmICgrY29udGVudExlbmd0aCA+IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFJhbmdlIHJlcXVlc3QgZm9yICR7cGF0aH0gZGlkIG5vdCByZXR1cm4gYSBwYXJ0aWFsIHJlc3BvbnNlOiAke3hocjIuc3RhdHVzfSBcIiR7eGhyMi5zdGF0dXNUZXh0fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kLmNjYWxsKCdkdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGgnLCBudWxsLCBbJ3N0cmluZyddLCBbcGF0aF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjaGVja0ZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiBib29sZWFuID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSByZWFkU3RyaW5nKG1vZCwgcGF0aFB0ciwgcGF0aExlbik7XG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBodHRwIG9yIFMzP1xuICAgICAgICAgICAgLy8gVHJ5IGEgSFRUUCBIRUFEIHJlcXVlc3RcbiAgICAgICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ2h0dHAnKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ3MzOi8vJykpIHtcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGEgZHVtbXkgcmFuZ2UgcmVxdWVzdCBxdWVyeWluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ3MzOi8vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsSW5mbyA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpO1xuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIGdldEhUVFBVcmwoZ2xvYmFsSW5mbz8uczNDb25maWcsIHBhdGgpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIsIGdsb2JhbEluZm8/LnMzQ29uZmlnLCBwYXRoLCAnSEVBRCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgcGF0aCEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT0gMjA2IHx8IHhoci5zdGF0dXMgPT0gMjAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzeW5jRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2ZpbGVJZDogbnVtYmVyKSA9PiB7fSxcbiAgICBjbG9zZUZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IEJST1dTRVJfUlVOVElNRS5nZXRGaWxlSW5mbyhtb2QsIGZpbGVJZCk7XG4gICAgICAgIEJST1dTRVJfUlVOVElNRS5fZmlsZUluZm9DYWNoZS5kZWxldGUoZmlsZUlkKTtcbiAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJVRkZFUjpcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLk5PREVfRlM6XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6XG4gICAgICAgICAgICAgICAgLy8gWFhYIFJlbW92ZSBmcm9tIHJlZ2lzdHJ5XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GU0FDQ0VTUzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE9QRlMgYWNjZXNzIGhhbmRsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLmZsdXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRydW5jYXRlRmlsZTogKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgbmV3U2l6ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xuICAgICAgICBzd2l0Y2ggKGZpbGU/LmRhdGFQcm90b2NvbCkge1xuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuSFRUUDpcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBDYW5ub3QgdHJ1bmNhdGUgYSBodHRwIGZpbGVgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBDYW5ub3QgdHJ1bmNhdGUgYW4gczMgZmlsZWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJVRkZFUjpcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLk5PREVfRlM6XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6XG4gICAgICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBgdHJ1bmNhdGVGaWxlIG5vdCBpbXBsZW1lbnRlZGApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRlNBQ0NFU1M6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBPUEZTIGFjY2VzcyBoYW5kbGUgcmVnaXN0ZXJlZCB3aXRoIG5hbWU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS50cnVuY2F0ZShuZXdTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHJlYWRGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgYnVmOiBudW1iZXIsIGJ5dGVzOiBudW1iZXIsIGxvY2F0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKGJ5dGVzID09IDApIHtcbiAgICAgICAgICAgIC8vIEJlIHJvYnVzdCB0byBlbXB0eSByZWFkc1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xuICAgICAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAvLyBGaWxlIHJlYWRpbmcgZnJvbSBCTE9CIG9yIEhUVFAgTVVTVCBiZSBkb25lIHdpdGggcmFuZ2UgcmVxdWVzdHMuXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBjaGVjayBpbiBPUEVOIGlmIHN1Y2ggZmlsZSBzdXBwb3J0cyByYW5nZSByZXF1ZXN0cyBhbmQgdXBncmFkZSB0byBCVUZGRVIgaWYgbm90LlxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuUzM6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLmRhdGFVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBkYXRhIFVSTCBmb3IgZmlsZSAke2ZpbGVJZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGdldEhUVFBVcmwoZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdHRVQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGZpbGUuZGF0YVVybCEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgYGJ5dGVzPSR7bG9jYXRpb259LSR7bG9jYXRpb24gKyBieXRlcyAtIDF9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzID09IDIwNiAvKiBQYXJ0aWFsIGNvbnRlbnQgKi8gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeGhyLnN0YXR1cyA9PSAyMDAgJiYgYnl0ZXMgPT0geGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGggJiYgbG9jYXRpb24gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSwgMCwgTWF0aC5taW4oeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgsIGJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoc3JjLCBidWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcmMuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBoZXJlIHdlIGFyZSBhY3R1YWxseSB0aHJvd2luZyBhd2F5IGFsbCBub24tcmVsZXZhbnQgYnl0ZXMsIGJ1dCB0aGlzIGlzIHN0aWxsIGJldHRlciB0aGFuIGZhaWxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBwcm9wZXIgc29sdXRpb24gd291bGQgcmVxdWlyZSBub3RpZnlpbmcgZHVja2RiLXdhc20gY2FjaGUsIHdoaWxlIHdlIGFyZSBwaWdneWJhY2tpZ24gb24gYnJvd3NlciBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUmFuZ2UgcmVxdWVzdCBmb3IgJHtmaWxlLmRhdGFVcmx9IGRpZCBub3QgcmV0dXJuIGEgcGFydGlhbCByZXNwb25zZTogJHt4aHIuc3RhdHVzfSBcIiR7eGhyLnN0YXR1c1RleHR9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UsIGxvY2F0aW9uLCBNYXRoLm1pbih4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aC1sb2NhdGlvbiwgYnl0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUFU4LnNldChzcmMsIGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyYy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBSYW5nZSByZXF1ZXN0IGZvciAke2ZpbGUuZGF0YVVybH0gZGlkIHJldHVybmVkIG5vbi1zdWNjZXNzIHN0YXR1czogJHt4aHIuc3RhdHVzfSBcIiR7eGhyLnN0YXR1c1RleHR9XCJgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmFuZ2UgcmVxdWVzdCBmb3IgJHtmaWxlLmRhdGFVcmx9IGZhaWxlZCB3aXRoIGVycm9yOiAke2V9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gQlJPV1NFUl9SVU5USU1FLl9maWxlcz8uZ2V0KGZpbGUuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBIVE1MNSBmaWxlIHJlZ2lzdGVyZWQgd2l0aCBuYW1lOiAke2ZpbGUuZmlsZU5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpY2VkID0gaGFuZGxlIS5zbGljZShsb2NhdGlvbiwgbG9jYXRpb24gKyBieXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShuZXcgRmlsZVJlYWRlclN5bmMoKS5yZWFkQXNBcnJheUJ1ZmZlcihzbGljZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoZGF0YSwgYnVmKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GU0FDQ0VTUzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE9QRlMgYWNjZXNzIGhhbmRsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGUucmVhZChvdXQsIHsgYXQ6IGxvY2F0aW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3cml0ZUZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGJ1ZjogbnVtYmVyLCBieXRlczogbnVtYmVyLCBsb2NhdGlvbjogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xuICAgICAgICBzd2l0Y2ggKGZpbGU/LmRhdGFQcm90b2NvbCkge1xuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuSFRUUDpcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsICdDYW5ub3Qgd3JpdGUgdG8gSFRUUCBmaWxlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oJ1BVVCcsIGdldEhUVFBVcmwoZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdQVVQnLCAnJywgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICB4aHIuc2VuZChidWZmZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUjpcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsICdjYW5ub3Qgd3JpdGUgdXNpbmcgdGhlIGh0bWw1IGZpbGUgcmVhZGVyIGFwaScpO1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GU0FDQ0VTUzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE9QRlMgYWNjZXNzIGhhbmRsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS53cml0ZShpbnB1dCwgeyBhdDogbG9jYXRpb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBnZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IEJST1dTRVJfUlVOVElNRS5nZXRGaWxlSW5mbyhtb2QsIGZpbGVJZCk7XG4gICAgICAgIHN3aXRjaCAoZmlsZT8uZGF0YVByb3RvY29sKSB7XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE5vIGhhbmRsZSBhdmFpbGFibGUgZm9yIGZpbGU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBjaGVja0RpcmVjdG9yeTogKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgY2hlY2tEaXJlY3Rvcnk6ICR7cGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY3JlYXRlRGlyZWN0b3J5OiAobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdGggPSByZWFkU3RyaW5nKG1vZCwgcGF0aFB0ciwgcGF0aExlbik7XG4gICAgICAgIGNvbnNvbGUubG9nKGBjcmVhdGVEaXJlY3Rvcnk6ICR7cGF0aH1gKTtcbiAgICB9LFxuICAgIHJlbW92ZURpcmVjdG9yeTogKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgcmVtb3ZlRGlyZWN0b3J5OiAke3BhdGh9YCk7XG4gICAgfSxcbiAgICBsaXN0RGlyZWN0b3J5RW50cmllczogKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcikgPT4ge1xuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xuICAgICAgICBjb25zb2xlLmxvZyhgbGlzdERpcmVjdG9yeUVudHJpZXM6ICR7cGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbW92ZUZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZnJvbVB0cjogbnVtYmVyLCBmcm9tTGVuOiBudW1iZXIsIHRvUHRyOiBudW1iZXIsIHRvTGVuOiBudW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHJlYWRTdHJpbmcobW9kLCBmcm9tUHRyLCBmcm9tTGVuKTtcbiAgICAgICAgY29uc3QgdG8gPSByZWFkU3RyaW5nKG1vZCwgdG9QdHIsIHRvTGVuKTtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gQlJPV1NFUl9SVU5USU1FLl9maWxlcz8uZ2V0KGZyb20pO1xuICAgICAgICBpZiAoaGFuZGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIEJST1dTRVJfUlVOVElNRS5fZmlsZXMhLmRlbGV0ZShoYW5kbGUpO1xuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlcyEuc2V0KHRvLCBoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIEJST1dTRVJfUlVOVElNRS5fZmlsZUluZm9DYWNoZT8uZW50cmllcygpIHx8IFtdKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUuZGF0YVVybCA9PSBmcm9tKSB7XG4gICAgICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcmVtb3ZlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcikgPT4ge30sXG4gICAgY2FsbFNjYWxhclVERjogKFxuICAgICAgICBtb2Q6IER1Y2tEQk1vZHVsZSxcbiAgICAgICAgcmVzcG9uc2U6IG51bWJlcixcbiAgICAgICAgZnVuY0lkOiBudW1iZXIsXG4gICAgICAgIGRlc2NQdHI6IG51bWJlcixcbiAgICAgICAgZGVzY1NpemU6IG51bWJlcixcbiAgICAgICAgcHRyc1B0cjogbnVtYmVyLFxuICAgICAgICBwdHJzU2l6ZTogbnVtYmVyLFxuICAgICk6IHZvaWQgPT4ge1xuICAgICAgICB1ZGYuY2FsbFNjYWxhclVERihCUk9XU0VSX1JVTlRJTUUsIG1vZCwgcmVzcG9uc2UsIGZ1bmNJZCwgZGVzY1B0ciwgZGVzY1NpemUsIHB0cnNQdHIsIHB0cnNTaXplKTtcbiAgICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQlJPV1NFUl9SVU5USU1FO1xuIiwgIlxudmFyIER1Y2tEQiA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0RGlyID0gaW1wb3J0Lm1ldGEudXJsO1xuICBcbiAgcmV0dXJuIChcbmFzeW5jIGZ1bmN0aW9uKER1Y2tEQiA9IHt9KSAge1xuXG52YXIgTW9kdWxlID0gdHlwZW9mIER1Y2tEQiAhPSBcInVuZGVmaW5lZFwiID8gRHVja0RCIDoge307XG5cbnZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG5cbk1vZHVsZVtcInJlYWR5XCJdID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbn0pO1xuXG5bIFwiX21haW5cIiwgXCJfbWFsbG9jXCIsIFwiX2ZyZWVcIiwgXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiLCBcIl9kdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0c1wiLCBcIl9kdWNrZGJfd2ViX2Nvbm5lY3RcIiwgXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyXCIsIFwiX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9kaXNjb25uZWN0XCIsIFwiX2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHNcIiwgXCJfZHVja2RiX3dlYl9mYWlsX3dpdGhcIiwgXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlXCIsIFwiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIiwgXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVcIiwgXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZFwiLCBcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZVwiLCBcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9mc19nbG9iX2ZpbGVfaW5mb3NcIiwgXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX2J1ZmZlclwiLCBcIl9kdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsXCIsIFwiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIiwgXCJfZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mb1wiLCBcIl9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCIsIFwiX2R1Y2tkYl93ZWJfZ2V0X3ZlcnNpb25cIiwgXCJfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCIsIFwiX2R1Y2tkYl93ZWJfaW5zZXJ0X2Nzdl9mcm9tX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9pbnNlcnRfanNvbl9mcm9tX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9vcGVuXCIsIFwiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIiwgXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3BvbGxcIiwgXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0XCIsIFwiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2VcIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jcmVhdGVcIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9ydW5cIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCIsIFwiX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0c1wiLCBcIl9kdWNrZGJfd2ViX3F1ZXJ5X3J1blwiLCBcIl9kdWNrZGJfd2ViX3Jlc2V0XCIsIFwiX2R1Y2tkYl93ZWJfdG9rZW5pemVcIiwgXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiLCBcIl9mZmx1c2hcIiwgXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiIF0uZm9yRWFjaChwcm9wID0+IHtcbiBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlW1wicmVhZHlcIl0sIHByb3ApKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbXCJyZWFkeVwiXSwgcHJvcCwge1xuICAgZ2V0OiAoKSA9PiBhYm9ydChcIllvdSBhcmUgZ2V0dGluZyBcIiArIHByb3AgKyBcIiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qc1wiKSxcbiAgIHNldDogKCkgPT4gYWJvcnQoXCJZb3UgYXJlIHNldHRpbmcgXCIgKyBwcm9wICsgXCIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanNcIilcbiAgfSk7XG4gfVxufSk7XG5cbnZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuXG52YXIgYXJndW1lbnRzXyA9IFtdO1xuXG52YXIgdGhpc1Byb2dyYW0gPSBcIi4vdGhpcy5wcm9ncmFtXCI7XG5cbnZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiB0aHJvdyB0b1Rocm93O1xufTtcblxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIjtcblxudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09IFwiZnVuY3Rpb25cIjtcblxudmFyIEVOVklST05NRU5UX0lTX05PREUgPSB0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSBcInN0cmluZ1wiO1xuXG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cbmlmIChNb2R1bGVbXCJFTlZJUk9OTUVOVFwiXSkge1xuIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZS5FTlZJUk9OTUVOVCBoYXMgYmVlbiBkZXByZWNhdGVkLiBUbyBmb3JjZSB0aGUgZW52aXJvbm1lbnQsIHVzZSB0aGUgRU5WSVJPTk1FTlQgY29tcGlsZS10aW1lIG9wdGlvbiAoZm9yIGV4YW1wbGUsIC1zRU5WSVJPTk1FTlQ9d2ViIG9yIC1zRU5WSVJPTk1FTlQ9bm9kZSlcIik7XG59XG5cbnZhciBzY3JpcHREaXJlY3RvcnkgPSBcIlwiO1xuXG5mdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiBpZiAoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSkge1xuICByZXR1cm4gTW9kdWxlW1wibG9jYXRlRmlsZVwiXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuIH1cbiByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbn1cblxudmFyIHJlYWRfLCByZWFkQXN5bmMsIHJlYWRCaW5hcnksIHNldFdpbmRvd1RpdGxlO1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuIGlmICh0eXBlb2YgcHJvY2VzcyA9PSBcInVuZGVmaW5lZFwiIHx8ICFwcm9jZXNzLnJlbGVhc2UgfHwgcHJvY2Vzcy5yZWxlYXNlLm5hbWUgIT09IFwibm9kZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KVwiKTtcbiB2YXIgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gdmFyIG51bWVyaWNWZXJzaW9uID0gbm9kZVZlcnNpb24uc3BsaXQoXCIuXCIpLnNsaWNlKDAsIDMpO1xuIG51bWVyaWNWZXJzaW9uID0gbnVtZXJpY1ZlcnNpb25bMF0gKiAxZTQgKyBudW1lcmljVmVyc2lvblsxXSAqIDEwMCArIG51bWVyaWNWZXJzaW9uWzJdLnNwbGl0KFwiLVwiKVswXSAqIDE7XG4gdmFyIG1pblZlcnNpb24gPSAxMDE5MDA7XG4gaWYgKG51bWVyaWNWZXJzaW9uIDwgMTAxOTAwKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZW1zY3JpcHRlbi1nZW5lcmF0ZWQgY29kZSByZXF1aXJlcyBub2RlIHYxMC4xOS4xOS4wIChkZXRlY3RlZCB2XCIgKyBub2RlVmVyc2lvbiArIFwiKVwiKTtcbiB9XG4gY29uc3Qge2NyZWF0ZVJlcXVpcmU6IGNyZWF0ZVJlcXVpcmV9ID0gYXdhaXQgaW1wb3J0KFwibW9kdWxlXCIpO1xuIHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiB2YXIgbm9kZVBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IG5vZGVQYXRoLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KSArIFwiL1wiO1xuIH0gZWxzZSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IHJlcXVpcmUoXCJ1cmxcIikuZmlsZVVSTFRvUGF0aChuZXcgVVJMKFwiLi9cIiwgaW1wb3J0Lm1ldGEudXJsKSk7XG4gfVxuIHJlYWRfID0gKGZpbGVuYW1lLCBiaW5hcnkpID0+IHtcbiAgZmlsZW5hbWUgPSBpc0ZpbGVVUkkoZmlsZW5hbWUpID8gbmV3IFVSTChmaWxlbmFtZSkgOiBub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO1xuICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCBiaW5hcnkgPyB1bmRlZmluZWQgOiBcInV0ZjhcIik7XG4gfTtcbiByZWFkQmluYXJ5ID0gZmlsZW5hbWUgPT4ge1xuICB2YXIgcmV0ID0gcmVhZF8oZmlsZW5hbWUsIHRydWUpO1xuICBpZiAoIXJldC5idWZmZXIpIHtcbiAgIHJldCA9IG5ldyBVaW50OEFycmF5KHJldCk7XG4gIH1cbiAgYXNzZXJ0KHJldC5idWZmZXIpO1xuICByZXR1cm4gcmV0O1xuIH07XG4gcmVhZEFzeW5jID0gKGZpbGVuYW1lLCBvbmxvYWQsIG9uZXJyb3IsIGJpbmFyeSA9IHRydWUpID0+IHtcbiAgZmlsZW5hbWUgPSBpc0ZpbGVVUkkoZmlsZW5hbWUpID8gbmV3IFVSTChmaWxlbmFtZSkgOiBub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO1xuICBmcy5yZWFkRmlsZShmaWxlbmFtZSwgYmluYXJ5ID8gdW5kZWZpbmVkIDogXCJ1dGY4XCIsIChlcnIsIGRhdGEpID0+IHtcbiAgIGlmIChlcnIpIG9uZXJyb3IoZXJyKTsgZWxzZSBvbmxvYWQoYmluYXJ5ID8gZGF0YS5idWZmZXIgOiBkYXRhKTtcbiAgfSk7XG4gfTtcbiBpZiAoIU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gIHRoaXNQcm9ncmFtID0gcHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuIH1cbiBhcmd1bWVudHNfID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICBwcm9jZXNzLmV4aXRDb2RlID0gc3RhdHVzO1xuICB0aHJvdyB0b1Rocm93O1xuIH07XG4gTW9kdWxlW1wiaW5zcGVjdFwiXSA9ICgpID0+IFwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjtcbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfU0hFTEwpIHtcbiBpZiAodHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIpO1xuIGlmICh0eXBlb2YgcmVhZCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlYWRfID0gZiA9PiB7XG4gICByZXR1cm4gcmVhZChmKTtcbiAgfTtcbiB9XG4gcmVhZEJpbmFyeSA9IGYgPT4ge1xuICBsZXQgZGF0YTtcbiAgaWYgKHR5cGVvZiByZWFkYnVmZmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpO1xuICB9XG4gIGRhdGEgPSByZWFkKGYsIFwiYmluYXJ5XCIpO1xuICBhc3NlcnQodHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIik7XG4gIHJldHVybiBkYXRhO1xuIH07XG4gcmVhZEFzeW5jID0gKGYsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IG9ubG9hZChyZWFkQmluYXJ5KGYpKSwgMCk7XG4gfTtcbiBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0ID0gaWQgPT4ge307XG4gfVxuIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBzY3JpcHRBcmdzO1xuIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50cyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBhcmd1bWVudHM7XG4gfVxuIGlmICh0eXBlb2YgcXVpdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoISh0b1Rocm93IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHtcbiAgICAgbGV0IHRvTG9nID0gdG9UaHJvdztcbiAgICAgaWYgKHRvVGhyb3cgJiYgdHlwZW9mIHRvVGhyb3cgPT0gXCJvYmplY3RcIiAmJiB0b1Rocm93LnN0YWNrKSB7XG4gICAgICB0b0xvZyA9IFsgdG9UaHJvdywgdG9UaHJvdy5zdGFjayBdO1xuICAgICB9XG4gICAgIGVycihgZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiAke3RvTG9nfWApO1xuICAgIH1cbiAgICBxdWl0KHN0YXR1cyk7XG4gICB9KTtcbiAgIHRocm93IHRvVGhyb3c7XG4gIH07XG4gfVxuIGlmICh0eXBlb2YgcHJpbnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZSA9IHt9O1xuICBjb25zb2xlLmxvZyA9IHByaW50O1xuICBjb25zb2xlLndhcm4gPSBjb25zb2xlLmVycm9yID0gdHlwZW9mIHByaW50RXJyICE9IFwidW5kZWZpbmVkXCIgPyBwcmludEVyciA6IHByaW50O1xuIH1cbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiB9XG4gaWYgKF9zY3JpcHREaXIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiB9XG4gaWYgKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKFwiYmxvYjpcIikgIT09IDApIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLCBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgXCJcIikubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gfSBlbHNlIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gXCJcIjtcbiB9XG4gaWYgKCEodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIpO1xuIHtcbiAgcmVhZF8gPSB1cmwgPT4ge1xuICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gICB4aHIuc2VuZChudWxsKTtcbiAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICB9O1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICByZWFkQmluYXJ5ID0gdXJsID0+IHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgIH07XG4gIH1cbiAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgb25lcnJvcigpO1xuICAgfTtcbiAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgIHhoci5zZW5kKG51bGwpO1xuICB9O1xuIH1cbiBzZXRXaW5kb3dUaXRsZSA9IHRpdGxlID0+IGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG59IGVsc2Uge1xuIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IGRldGVjdGlvbiBlcnJvclwiKTtcbn1cblxudmFyIG91dCA9IE1vZHVsZVtcInByaW50XCJdIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5cbnZhciBlcnIgPSBNb2R1bGVbXCJwcmludEVyclwiXSB8fCBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cbk9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG5tb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuXG5jaGVja0luY29taW5nTW9kdWxlQVBJKCk7XG5cbmlmIChNb2R1bGVbXCJhcmd1bWVudHNcIl0pIGFyZ3VtZW50c18gPSBNb2R1bGVbXCJhcmd1bWVudHNcIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJhcmd1bWVudHNcIiwgXCJhcmd1bWVudHNfXCIpO1xuXG5pZiAoTW9kdWxlW1widGhpc1Byb2dyYW1cIl0pIHRoaXNQcm9ncmFtID0gTW9kdWxlW1widGhpc1Byb2dyYW1cIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJ0aGlzUHJvZ3JhbVwiLCBcInRoaXNQcm9ncmFtXCIpO1xuXG5pZiAoTW9kdWxlW1wicXVpdFwiXSkgcXVpdF8gPSBNb2R1bGVbXCJxdWl0XCJdO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwicXVpdFwiLCBcInF1aXRfXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcIm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWRcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wicHRocmVhZE1haW5QcmVmaXhVUkxcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucHRocmVhZE1haW5QcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJjZEluaXRpYWxpemVyUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLmNkSW5pdGlhbGl6ZXJQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJmaWxlUGFja2FnZVByZWZpeFVSTFwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5maWxlUGFja2FnZVByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucmVhZCBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkXyBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wicmVhZEFzeW5jXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLnJlYWRBc3luYyBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQXN5bmMgaW4gSlMpXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRCaW5hcnlcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucmVhZEJpbmFyeSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQmluYXJ5IGluIEpTKVwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJzZXRXaW5kb3dUaXRsZVwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5zZXRXaW5kb3dUaXRsZSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSBzZXRXaW5kb3dUaXRsZSBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wiVE9UQUxfTUVNT1JZXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLlRPVEFMX01FTU9SWSBoYXMgYmVlbiByZW5hbWVkIE1vZHVsZS5JTklUSUFMX01FTU9SWVwiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRcIiwgXCJyZWFkX1wiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRBc3luY1wiLCBcInJlYWRBc3luY1wiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRCaW5hcnlcIiwgXCJyZWFkQmluYXJ5XCIpO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwic2V0V2luZG93VGl0bGVcIiwgXCJzZXRXaW5kb3dUaXRsZVwiKTtcblxudmFyIElEQkZTID0gXCJJREJGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbGlkYmZzLmpzXCI7XG5cbnZhciBQUk9YWUZTID0gXCJQUk9YWUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1scHJveHlmcy5qc1wiO1xuXG52YXIgV09SS0VSRlMgPSBcIldPUktFUkZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sd29ya2VyZnMuanNcIjtcblxudmFyIE5PREVGUyA9IFwiTk9ERUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sbm9kZWZzLmpzXCI7XG5cbmFzc2VydCghRU5WSVJPTk1FTlRfSVNfU0hFTEwsIFwic2hlbGwgZW52aXJvbm1lbnQgZGV0ZWN0ZWQgYnV0IG5vdCBlbmFibGVkIGF0IGJ1aWxkIHRpbWUuICBBZGQgJ3NoZWxsJyB0byBgLXNFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiKTtcblxudmFyIHdhc21CaW5hcnk7XG5cbmlmIChNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKSB3YXNtQmluYXJ5ID0gTW9kdWxlW1wid2FzbUJpbmFyeVwiXTtcblxubGVnYWN5TW9kdWxlUHJvcChcIndhc21CaW5hcnlcIiwgXCJ3YXNtQmluYXJ5XCIpO1xuXG52YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl0gfHwgdHJ1ZTtcblxubGVnYWN5TW9kdWxlUHJvcChcIm5vRXhpdFJ1bnRpbWVcIiwgXCJub0V4aXRSdW50aW1lXCIpO1xuXG5pZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9IFwib2JqZWN0XCIpIHtcbiBhYm9ydChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7XG59XG5cbnZhciB3YXNtTWVtb3J5O1xuXG52YXIgQUJPUlQgPSBmYWxzZTtcblxudmFyIEVYSVRTVEFUVVM7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiBpZiAoIWNvbmRpdGlvbikge1xuICBhYm9ydChcIkFzc2VydGlvbiBmYWlsZWRcIiArICh0ZXh0ID8gXCI6IFwiICsgdGV4dCA6IFwiXCIpKTtcbiB9XG59XG5cbnZhciBIRUFQLCBIRUFQOCwgSEVBUFU4LCBIRUFQMTYsIEhFQVBVMTYsIEhFQVAzMiwgSEVBUFUzMiwgSEVBUEYzMiwgSEVBUEY2NDtcblxuZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKSB7XG4gdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiBNb2R1bGVbXCJIRUFQOFwiXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQMTZcIl0gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQMzJcIl0gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVThcIl0gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVTE2XCJdID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVTMyXCJdID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQRjMyXCJdID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUEY2NFwiXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xufVxuXG5hc3NlcnQoIU1vZHVsZVtcIlNUQUNLX1NJWkVcIl0sIFwiU1RBQ0tfU0laRSBjYW4gbm8gbG9uZ2VyIGJlIHNldCBhdCBydW50aW1lLiAgVXNlIC1zU1RBQ0tfU0laRSBhdCBsaW5rIHRpbWVcIik7XG5cbmFzc2VydCh0eXBlb2YgSW50MzJBcnJheSAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgSW50MzJBcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgIT0gdW5kZWZpbmVkICYmIEludDMyQXJyYXkucHJvdG90eXBlLnNldCAhPSB1bmRlZmluZWQsIFwiSlMgZW5naW5lIGRvZXMgbm90IHByb3ZpZGUgZnVsbCB0eXBlZCBhcnJheSBzdXBwb3J0XCIpO1xuXG5hc3NlcnQoIU1vZHVsZVtcIndhc21NZW1vcnlcIl0sIFwiVXNlIG9mIGB3YXNtTWVtb3J5YCBkZXRlY3RlZC4gIFVzZSAtc0lNUE9SVEVEX01FTU9SWSB0byBkZWZpbmUgd2FzbU1lbW9yeSBleHRlcm5hbGx5XCIpO1xuXG5hc3NlcnQoIU1vZHVsZVtcIklOSVRJQUxfTUVNT1JZXCJdLCBcIkRldGVjdGVkIHJ1bnRpbWUgSU5JVElBTF9NRU1PUlkgc2V0dGluZy4gIFVzZSAtc0lNUE9SVEVEX01FTU9SWSB0byBkZWZpbmUgd2FzbU1lbW9yeSBkeW5hbWljYWxseVwiKTtcblxudmFyIHdhc21UYWJsZTtcblxuZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcbiB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuIGFzc2VydCgobWF4ICYgMykgPT0gMCk7XG4gaWYgKG1heCA9PSAwKSB7XG4gIG1heCArPSA0O1xuIH1cbiBIRUFQVTMyW21heCA+Pj4gMl0gPSAzNDgyMTIyMztcbiBIRUFQVTMyW21heCArIDQgPj4+IDJdID0gMjMxMDcyMTAyMjtcbiBIRUFQVTMyWzAgPj4+IDJdID0gMTY2ODUwOTAyOTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGFja0Nvb2tpZSgpIHtcbiBpZiAoQUJPUlQpIHJldHVybjtcbiB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuIGlmIChtYXggPT0gMCkge1xuICBtYXggKz0gNDtcbiB9XG4gdmFyIGNvb2tpZTEgPSBIRUFQVTMyW21heCA+Pj4gMl07XG4gdmFyIGNvb2tpZTIgPSBIRUFQVTMyW21heCArIDQgPj4+IDJdO1xuIGlmIChjb29raWUxICE9IDM0ODIxMjIzIHx8IGNvb2tpZTIgIT0gMjMxMDcyMTAyMikge1xuICBhYm9ydChgU3RhY2sgb3ZlcmZsb3chIFN0YWNrIGNvb2tpZSBoYXMgYmVlbiBvdmVyd3JpdHRlbiBhdCAke3B0clRvU3RyaW5nKG1heCl9LCBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MjEzNTQ2NywgYnV0IHJlY2VpdmVkICR7cHRyVG9TdHJpbmcoY29va2llMil9ICR7cHRyVG9TdHJpbmcoY29va2llMSl9YCk7XG4gfVxuIGlmIChIRUFQVTMyWzAgPj4+IDJdICE9IDE2Njg1MDkwMjkpIHtcbiAgYWJvcnQoXCJSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSFcIik7XG4gfVxufVxuXG4oZnVuY3Rpb24oKSB7XG4gdmFyIGgxNiA9IG5ldyBJbnQxNkFycmF5KDEpO1xuIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XG4gaDE2WzBdID0gMjU0NTk7XG4gaWYgKGg4WzBdICE9PSAxMTUgfHwgaDhbMV0gIT09IDk5KSB0aHJvdyBcIlJ1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEgKFJ1biB3aXRoIC1zU1VQUE9SVF9CSUdfRU5ESUFOIHRvIGJ5cGFzcylcIjtcbn0pKCk7XG5cbnZhciBfX0FUUFJFUlVOX18gPSBbXTtcblxudmFyIF9fQVRJTklUX18gPSBbXTtcblxudmFyIF9fQVRNQUlOX18gPSBbXTtcblxudmFyIF9fQVRFWElUX18gPSBbXTtcblxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTtcblxudmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG52YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuIHJldHVybiBub0V4aXRSdW50aW1lIHx8IHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID4gMDtcbn1cblxuZnVuY3Rpb24gcHJlUnVuKCkge1xuIGlmIChNb2R1bGVbXCJwcmVSdW5cIl0pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl0gPT0gXCJmdW5jdGlvblwiKSBNb2R1bGVbXCJwcmVSdW5cIl0gPSBbIE1vZHVsZVtcInByZVJ1blwiXSBdO1xuICB3aGlsZSAoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCkge1xuICAgYWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpO1xuICB9XG4gfVxuIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuIGFzc2VydCghcnVudGltZUluaXRpYWxpemVkKTtcbiBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xuIGNoZWNrU3RhY2tDb29raWUoKTtcbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbn1cblxuZnVuY3Rpb24gcHJlTWFpbigpIHtcbiBjaGVja1N0YWNrQ29va2llKCk7XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RSdW4oKSB7XG4gY2hlY2tTdGFja0Nvb2tpZSgpO1xuIGlmIChNb2R1bGVbXCJwb3N0UnVuXCJdKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXSA9PSBcImZ1bmN0aW9uXCIpIE1vZHVsZVtcInBvc3RSdW5cIl0gPSBbIE1vZHVsZVtcInBvc3RSdW5cIl0gXTtcbiAgd2hpbGUgKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKSB7XG4gICBhZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKTtcbiAgfVxuIH1cbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuIF9fQVRJTklUX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlTWFpbihjYikge1xuIF9fQVRNQUlOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge31cblxuZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuYXNzZXJ0KE1hdGguaW11bCwgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmltdWwoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGxcIik7XG5cbmFzc2VydChNYXRoLmZyb3VuZCwgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmZyb3VuZCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxuYXNzZXJ0KE1hdGguY2x6MzIsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5jbHozMigpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxuYXNzZXJ0KE1hdGgudHJ1bmMsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC50cnVuYygpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG5cbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG5cbnZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuXG52YXIgcnVuRGVwZW5kZW5jeVRyYWNraW5nID0ge307XG5cbmZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiB2YXIgb3JpZyA9IGlkO1xuIHdoaWxlICgxKSB7XG4gIGlmICghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSkgcmV0dXJuIGlkO1xuICBpZCA9IG9yaWcgKyBNYXRoLnJhbmRvbSgpO1xuIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcysrO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKGlkKSB7XG4gIGFzc2VydCghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSAxO1xuICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgPT09IG51bGwgJiYgdHlwZW9mIHNldEludGVydmFsICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmIChBQk9SVCkge1xuICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaG93biA9IGZhbHNlO1xuICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgaWYgKCFzaG93bikge1xuICAgICAgc2hvd24gPSB0cnVlO1xuICAgICAgZXJyKFwic3RpbGwgd2FpdGluZyBvbiBydW4gZGVwZW5kZW5jaWVzOlwiKTtcbiAgICAgfVxuICAgICBlcnIoXCJkZXBlbmRlbmN5OiBcIiArIGRlcCk7XG4gICAgfVxuICAgIGlmIChzaG93bikge1xuICAgICBlcnIoXCIoZW5kIG9mIGxpc3QpXCIpO1xuICAgIH1cbiAgIH0sIDFlNCk7XG4gIH1cbiB9IGVsc2Uge1xuICBlcnIoXCJ3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSBhZGRlZCB3aXRob3V0IElEXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcy0tO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKGlkKSB7XG4gIGFzc2VydChydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcbiAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gfSBlbHNlIHtcbiAgZXJyKFwid2FybmluZzogcnVuIGRlcGVuZGVuY3kgcmVtb3ZlZCB3aXRob3V0IElEXCIpO1xuIH1cbiBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XG4gICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgY2FsbGJhY2soKTtcbiAgfVxuIH1cbn1cblxuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuIGlmIChNb2R1bGVbXCJvbkFib3J0XCJdKSB7XG4gIE1vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCk7XG4gfVxuIHdoYXQgPSBcIkFib3J0ZWQoXCIgKyB3aGF0ICsgXCIpXCI7XG4gZXJyKHdoYXQpO1xuIEFCT1JUID0gdHJ1ZTtcbiBFWElUU1RBVFVTID0gMTtcbiB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG4gcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuIHRocm93IGU7XG59XG5cbnZhciBkYXRhVVJJUHJlZml4ID0gXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7XG5cbmZ1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSkge1xuIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpIHtcbiByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4cG9ydFdyYXBwZXIobmFtZSwgZml4ZWRhc20pIHtcbiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG5hbWU7XG4gIHZhciBhc20gPSBmaXhlZGFzbTtcbiAgaWYgKCFmaXhlZGFzbSkge1xuICAgYXNtID0gTW9kdWxlW1wiYXNtXCJdO1xuICB9XG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsIFwibmF0aXZlIGZ1bmN0aW9uIGBcIiArIGRpc3BsYXlOYW1lICsgXCJgIGNhbGxlZCBiZWZvcmUgcnVudGltZSBpbml0aWFsaXphdGlvblwiKTtcbiAgaWYgKCFhc21bbmFtZV0pIHtcbiAgIGFzc2VydChhc21bbmFtZV0sIFwiZXhwb3J0ZWQgbmF0aXZlIGZ1bmN0aW9uIGBcIiArIGRpc3BsYXlOYW1lICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgfVxuICByZXR1cm4gYXNtW25hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gfTtcbn1cblxudmFyIHdhc21CaW5hcnlGaWxlO1xuXG5pZiAoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSkge1xuIHdhc21CaW5hcnlGaWxlID0gXCIuL2R1Y2tkYi1tdnAud2FzbVwiO1xuIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICB3YXNtQmluYXJ5RmlsZSA9IGxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO1xuIH1cbn0gZWxzZSB7XG4gd2FzbUJpbmFyeUZpbGUgPSBuZXcgVVJMKFwiLi9kdWNrZGItbXZwLndhc21cIiwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSkge1xuIHRyeSB7XG4gIGlmIChmaWxlID09IHdhc21CaW5hcnlGaWxlICYmIHdhc21CaW5hcnkpIHtcbiAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgfVxuICBpZiAocmVhZEJpbmFyeSkge1xuICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gIH1cbiAgdGhyb3cgXCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO1xuIH0gY2F0Y2ggKGVycikge1xuICBhYm9ydChlcnIpO1xuIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKSB7XG4gaWYgKCF3YXNtQmluYXJ5ICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSkge1xuICBpZiAodHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIGZldGNoKGJpbmFyeUZpbGUsIHtcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAoIXJlc3BvbnNlW1wib2tcIl0pIHtcbiAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIGJpbmFyeUZpbGUgKyBcIidcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlW1wiYXJyYXlCdWZmZXJcIl0oKTtcbiAgIH0pLmNhdGNoKCgpID0+IGdldEJpbmFyeShiaW5hcnlGaWxlKSk7XG4gIH1cbiB9XG4gcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2V0QmluYXJ5KGJpbmFyeUZpbGUpKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCByZWNlaXZlcikge1xuIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5ID0+IHtcbiAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW1wb3J0cyk7XG4gfSkudGhlbihpbnN0YW5jZSA9PiB7XG4gIHJldHVybiBpbnN0YW5jZTtcbiB9KS50aGVuKHJlY2VpdmVyLCByZWFzb24gPT4ge1xuICBlcnIoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIiArIHJlYXNvbik7XG4gIGlmIChpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICBlcnIoXCJ3YXJuaW5nOiBMb2FkaW5nIGZyb20gYSBmaWxlIFVSSSAoXCIgKyB3YXNtQmluYXJ5RmlsZSArIFwiKSBpcyBub3Qgc3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMuIFNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvZ2V0dGluZ19zdGFydGVkL0ZBUS5odG1sI2hvdy1kby1pLXJ1bi1hLWxvY2FsLXdlYnNlcnZlci1mb3ItdGVzdGluZy13aHktZG9lcy1teS1wcm9ncmFtLXN0YWxsLWluLWRvd25sb2FkaW5nLW9yLXByZXBhcmluZ1wiKTtcbiAgfVxuICBhYm9ydChyZWFzb24pO1xuIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSwgYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spIHtcbiBpZiAoIWJpbmFyeSAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gXCJmdW5jdGlvblwiICYmICFpc0RhdGFVUkkoYmluYXJ5RmlsZSkgJiYgIUVOVklST05NRU5UX0lTX05PREUgJiYgdHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIikge1xuICByZXR1cm4gZmV0Y2goYmluYXJ5RmlsZSwge1xuICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW1wb3J0cyk7XG4gICByZXR1cm4gcmVzdWx0LnRoZW4oY2FsbGJhY2ssIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGVycihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIiArIHJlYXNvbik7XG4gICAgZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7XG4gICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuICAgfSk7XG4gIH0pO1xuIH0gZWxzZSB7XG4gIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIGNhbGxiYWNrKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhc20oKSB7XG4gdmFyIGluZm8gPSB7XG4gIFwiZW52XCI6IHdhc21JbXBvcnRzLFxuICBcIndhc2lfc25hcHNob3RfcHJldmlldzFcIjogd2FzbUltcG9ydHNcbiB9O1xuIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gIHZhciBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgTW9kdWxlW1wiYXNtXCJdID0gZXhwb3J0cztcbiAgd2FzbU1lbW9yeSA9IE1vZHVsZVtcImFzbVwiXVtcIm1lbW9yeVwiXTtcbiAgYXNzZXJ0KHdhc21NZW1vcnksIFwibWVtb3J5IG5vdCBmb3VuZCBpbiB3YXNtIGV4cG9ydHNcIik7XG4gIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gIHdhc21UYWJsZSA9IE1vZHVsZVtcImFzbVwiXVtcIl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGVcIl07XG4gIGFzc2VydCh3YXNtVGFibGUsIFwidGFibGUgbm90IGZvdW5kIGluIHdhc20gZXhwb3J0c1wiKTtcbiAgYWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcIl9fd2FzbV9jYWxsX2N0b3JzXCJdKTtcbiAgcmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7XG4gIHJldHVybiBleHBvcnRzO1xuIH1cbiBhZGRSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtcbiB2YXIgdHJ1ZU1vZHVsZSA9IE1vZHVsZTtcbiBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgYXNzZXJ0KE1vZHVsZSA9PT0gdHJ1ZU1vZHVsZSwgXCJ0aGUgTW9kdWxlIG9iamVjdCBzaG91bGQgbm90IGJlIHJlcGxhY2VkIGR1cmluZyBhc3luYyBjb21waWxhdGlvbiAtIHBlcmhhcHMgdGhlIG9yZGVyIG9mIEhUTUwgZWxlbWVudHMgaXMgd3Jvbmc/XCIpO1xuICB0cnVlTW9kdWxlID0gbnVsbDtcbiAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdKTtcbiB9XG4gaWYgKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSkge1xuICB0cnkge1xuICAgcmV0dXJuIE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICBlcnIoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIiArIGUpO1xuICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICB9XG4gfVxuIGluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSwgd2FzbUJpbmFyeUZpbGUsIGluZm8sIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuIHJldHVybiB7fTtcbn1cblxudmFyIHRlbXBEb3VibGU7XG5cbnZhciB0ZW1wSTY0O1xuXG5mdW5jdGlvbiBsZWdhY3lNb2R1bGVQcm9wKHByb3AsIG5ld05hbWUpIHtcbiBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBwcm9wLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGFib3J0KFwiTW9kdWxlLlwiICsgcHJvcCArIFwiIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggcGxhaW4gXCIgKyBuZXdOYW1lICsgXCIgKHRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBwcm92aWRlZCBvbiBNb2R1bGUsIGJ1dCBhZnRlciBzdGFydHVwIHRoZSB2YWx1ZSBpcyBvbmx5IGxvb2tlZCBmb3Igb24gYSBsb2NhbCB2YXJpYWJsZSBvZiB0aGF0IG5hbWUpXCIpO1xuICAgfVxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRNb2R1bGVQcm9wKHByb3ApIHtcbiBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gIGFib3J0KFwiYE1vZHVsZS5cIiArIHByb3AgKyBcImAgd2FzIHN1cHBsaWVkIGJ1dCBgXCIgKyBwcm9wICsgXCJgIG5vdCBpbmNsdWRlZCBpbiBJTkNPTUlOR19NT0RVTEVfSlNfQVBJXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKG5hbWUpIHtcbiByZXR1cm4gbmFtZSA9PT0gXCJGU19jcmVhdGVQYXRoXCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVEYXRhRmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfdW5saW5rXCIgfHwgbmFtZSA9PT0gXCJhZGRSdW5EZXBlbmRlbmN5XCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVMYXp5RmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfY3JlYXRlRGV2aWNlXCIgfHwgbmFtZSA9PT0gXCJyZW1vdmVSdW5EZXBlbmRlbmN5XCI7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdHbG9iYWwoc3ltLCBtc2cpIHtcbiBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHN5bSwge1xuICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB3YXJuT25jZShcImBcIiArIHN5bSArIFwiYCBpcyBub3QgbG9uZ2VyIGRlZmluZWQgYnkgZW1zY3JpcHRlbi4gXCIgKyBtc2cpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICB9XG4gIH0pO1xuIH1cbn1cblxubWlzc2luZ0dsb2JhbChcImJ1ZmZlclwiLCBcIlBsZWFzZSB1c2UgSEVBUDguYnVmZmVyIG9yIHdhc21NZW1vcnkuYnVmZmVyXCIpO1xuXG5mdW5jdGlvbiBtaXNzaW5nTGlicmFyeVN5bWJvbChzeW0pIHtcbiBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywgc3ltKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSBcImBcIiArIHN5bSArIFwiYCBpcyBhIGxpYnJhcnkgc3ltYm9sIGFuZCBub3QgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYWRkIGl0IHRvIHlvdXIgbGlicmFyeS5qcyBfX2RlcHMgb3IgdG8gREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREUgb24gdGhlIGNvbW1hbmQgbGluZVwiO1xuICAgIHZhciBsaWJyYXJ5U3ltYm9sID0gc3ltO1xuICAgIGlmICghbGlicmFyeVN5bWJvbC5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICBsaWJyYXJ5U3ltYm9sID0gXCIkXCIgKyBzeW07XG4gICAgfVxuICAgIG1zZyArPSBcIiAoZS5nLiAtc0RFRkFVTFRfTElCUkFSWV9GVU5DU19UT19JTkNMVURFPVwiICsgbGlicmFyeVN5bWJvbCArIFwiKVwiO1xuICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xuICAgICBtc2cgKz0gXCIuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtc0ZPUkNFX0ZJTEVTWVNURU0pIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCI7XG4gICAgfVxuICAgIHdhcm5PbmNlKG1zZyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgIH1cbiAgfSk7XG4gfVxuIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSk7XG59XG5cbmZ1bmN0aW9uIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSkge1xuIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHN5bSkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSBcIidcIiArIHN5bSArIFwiJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIjtcbiAgICBpZiAoaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKHN5bSkpIHtcbiAgICAgbXNnICs9IFwiLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXNGT1JDRV9GSUxFU1lTVEVNKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiO1xuICAgIH1cbiAgICBhYm9ydChtc2cpO1xuICAgfVxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGRiZyh0ZXh0KSB7XG4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gdGhpcy5uYW1lID0gXCJFeGl0U3RhdHVzXCI7XG4gdGhpcy5tZXNzYWdlID0gYFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzdGF0dXN9KWA7XG4gdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG59XG5cbmZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlID0gXCJpOFwiKSB7XG4gaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB0eXBlID0gXCIqXCI7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSBcImkxXCI6XG4gIHJldHVybiBIRUFQOFtwdHIgPj4+IDBdO1xuXG4gY2FzZSBcImk4XCI6XG4gIHJldHVybiBIRUFQOFtwdHIgPj4+IDBdO1xuXG4gY2FzZSBcImkxNlwiOlxuICByZXR1cm4gSEVBUDE2W3B0ciA+Pj4gMV07XG5cbiBjYXNlIFwiaTMyXCI6XG4gIHJldHVybiBIRUFQMzJbcHRyID4+PiAyXTtcblxuIGNhc2UgXCJpNjRcIjpcbiAgYWJvcnQoXCJ0byBkbyBnZXRWYWx1ZShpNjQpIHVzZSBXQVNNX0JJR0lOVFwiKTtcblxuIGNhc2UgXCJmbG9hdFwiOlxuICByZXR1cm4gSEVBUEYzMltwdHIgPj4+IDJdO1xuXG4gY2FzZSBcImRvdWJsZVwiOlxuICByZXR1cm4gSEVBUEY2NFtwdHIgPj4+IDNdO1xuXG4gY2FzZSBcIipcIjpcbiAgcmV0dXJuIEhFQVBVMzJbcHRyID4+PiAyXTtcblxuIGRlZmF1bHQ6XG4gIGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAke3R5cGV9YCk7XG4gfVxufVxuXG5mdW5jdGlvbiBwdHJUb1N0cmluZyhwdHIpIHtcbiBhc3NlcnQodHlwZW9mIHB0ciA9PT0gXCJudW1iZXJcIik7XG4gcmV0dXJuIFwiMHhcIiArIHB0ci50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gXCJpOFwiKSB7XG4gaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB0eXBlID0gXCIqXCI7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSBcImkxXCI6XG4gIEhFQVA4W3B0ciA+Pj4gMF0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaThcIjpcbiAgSEVBUDhbcHRyID4+PiAwXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJpMTZcIjpcbiAgSEVBUDE2W3B0ciA+Pj4gMV0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaTMyXCI6XG4gIEhFQVAzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcImk2NFwiOlxuICBhYm9ydChcInRvIGRvIHNldFZhbHVlKGk2NCkgdXNlIFdBU01fQklHSU5UXCIpO1xuXG4gY2FzZSBcImZsb2F0XCI6XG4gIEhFQVBGMzJbcHRyID4+PiAyXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJkb3VibGVcIjpcbiAgSEVBUEY2NFtwdHIgPj4+IDNdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcIipcIjpcbiAgSEVBUFUzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgYWJvcnQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7dHlwZX1gKTtcbiB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKHRleHQpIHtcbiBpZiAoIXdhcm5PbmNlLnNob3duKSB3YXJuT25jZS5zaG93biA9IHt9O1xuIGlmICghd2Fybk9uY2Uuc2hvd25bdGV4dF0pIHtcbiAgd2Fybk9uY2Uuc2hvd25bdGV4dF0gPSAxO1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkgdGV4dCA9IFwid2FybmluZzogXCIgKyB0ZXh0O1xuICBlcnIodGV4dCk7XG4gfVxufVxuXG5mdW5jdGlvbiBfWE1MX0dldEJ1ZmZlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfR2V0QnVmZmVyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9HZXRFcnJvckNvZGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX0dldEVycm9yQ29kZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfUGFyc2UoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1BhcnNlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZUJ1ZmZlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VCdWZmZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1BhcnNlckNyZWF0ZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VyQ3JlYXRlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZXJGcmVlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZXJGcmVlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9SZXN1bWVQYXJzZXIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1Jlc3VtZVBhcnNlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9TZXRFbGVtZW50SGFuZGxlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0RWxlbWVudEhhbmRsZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1NldFVzZXJEYXRhKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9TZXRVc2VyRGF0YVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU3RvcFBhcnNlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU3RvcFBhcnNlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbkluZm8oZXhjUHRyKSB7XG4gdGhpcy5leGNQdHIgPSBleGNQdHI7XG4gdGhpcy5wdHIgPSBleGNQdHIgLSAyNDtcbiB0aGlzLnNldF90eXBlID0gZnVuY3Rpb24odHlwZSkge1xuICBIRUFQVTMyW3RoaXMucHRyICsgNCA+Pj4gMl0gPSB0eXBlO1xuIH07XG4gdGhpcy5nZXRfdHlwZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSEVBUFUzMlt0aGlzLnB0ciArIDQgPj4+IDJdO1xuIH07XG4gdGhpcy5zZXRfZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKGRlc3RydWN0b3IpIHtcbiAgSEVBUFUzMlt0aGlzLnB0ciArIDggPj4+IDJdID0gZGVzdHJ1Y3RvcjtcbiB9O1xuIHRoaXMuZ2V0X2Rlc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIgKyA4ID4+PiAyXTtcbiB9O1xuIHRoaXMuc2V0X2NhdWdodCA9IGZ1bmN0aW9uKGNhdWdodCkge1xuICBjYXVnaHQgPSBjYXVnaHQgPyAxIDogMDtcbiAgSEVBUDhbdGhpcy5wdHIgKyAxMiA+Pj4gMF0gPSBjYXVnaHQ7XG4gfTtcbiB0aGlzLmdldF9jYXVnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEhFQVA4W3RoaXMucHRyICsgMTIgPj4+IDBdICE9IDA7XG4gfTtcbiB0aGlzLnNldF9yZXRocm93biA9IGZ1bmN0aW9uKHJldGhyb3duKSB7XG4gIHJldGhyb3duID0gcmV0aHJvd24gPyAxIDogMDtcbiAgSEVBUDhbdGhpcy5wdHIgKyAxMyA+Pj4gMF0gPSByZXRocm93bjtcbiB9O1xuIHRoaXMuZ2V0X3JldGhyb3duID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBIRUFQOFt0aGlzLnB0ciArIDEzID4+PiAwXSAhPSAwO1xuIH07XG4gdGhpcy5pbml0ID0gZnVuY3Rpb24odHlwZSwgZGVzdHJ1Y3Rvcikge1xuICB0aGlzLnNldF9hZGp1c3RlZF9wdHIoMCk7XG4gIHRoaXMuc2V0X3R5cGUodHlwZSk7XG4gIHRoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcik7XG4gfTtcbiB0aGlzLnNldF9hZGp1c3RlZF9wdHIgPSBmdW5jdGlvbihhZGp1c3RlZFB0cikge1xuICBIRUFQVTMyW3RoaXMucHRyICsgMTYgPj4+IDJdID0gYWRqdXN0ZWRQdHI7XG4gfTtcbiB0aGlzLmdldF9hZGp1c3RlZF9wdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIgKyAxNiA+Pj4gMl07XG4gfTtcbiB0aGlzLmdldF9leGNlcHRpb25fcHRyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1BvaW50ZXIgPSBfX19jeGFfaXNfcG9pbnRlcl90eXBlKHRoaXMuZ2V0X3R5cGUoKSk7XG4gIGlmIChpc1BvaW50ZXIpIHtcbiAgIHJldHVybiBIRUFQVTMyW3RoaXMuZXhjUHRyID4+PiAyXTtcbiAgfVxuICB2YXIgYWRqdXN0ZWQgPSB0aGlzLmdldF9hZGp1c3RlZF9wdHIoKTtcbiAgaWYgKGFkanVzdGVkICE9PSAwKSByZXR1cm4gYWRqdXN0ZWQ7XG4gIHJldHVybiB0aGlzLmV4Y1B0cjtcbiB9O1xufVxuXG52YXIgZXhjZXB0aW9uTGFzdCA9IDA7XG5cbnZhciB1bmNhdWdodEV4Y2VwdGlvbkNvdW50ID0gMDtcblxuZnVuY3Rpb24gX19fY3hhX3Rocm93KHB0ciwgdHlwZSwgZGVzdHJ1Y3Rvcikge1xuIHZhciBpbmZvID0gbmV3IEV4Y2VwdGlvbkluZm8ocHRyKTtcbiBpbmZvLmluaXQodHlwZSwgZGVzdHJ1Y3Rvcik7XG4gZXhjZXB0aW9uTGFzdCA9IHB0cjtcbiB1bmNhdWdodEV4Y2VwdGlvbkNvdW50Kys7XG4gYXNzZXJ0KGZhbHNlLCBcIkV4Y2VwdGlvbiB0aHJvd24sIGJ1dCBleGNlcHRpb24gY2F0Y2hpbmcgaXMgbm90IGVuYWJsZWQuIENvbXBpbGUgd2l0aCAtc05PX0RJU0FCTEVfRVhDRVBUSU9OX0NBVENISU5HIG9yIC1zRVhDRVBUSU9OX0NBVENISU5HX0FMTE9XRUQ9Wy4uXSB0byBjYXRjaC5cIik7XG59XG5cbnZhciBkbG9wZW5NaXNzaW5nRXJyb3IgPSBcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvY29tcGlsaW5nL0R5bmFtaWMtTGlua2luZy5odG1sXCI7XG5cbmZ1bmN0aW9uIF9fX2Rsc3ltKGhhbmRsZSwgc3ltYm9sLCByYSkge1xuIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG59XG5cbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSBcInVuZGVmaW5lZFwiID8gbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcoaGVhcE9yQXJyYXksIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiBpZHggPj4+PSAwO1xuIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiB2YXIgZW5kUHRyID0gaWR4O1xuIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuIH1cbiB2YXIgc3RyID0gXCJcIjtcbiB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgaWYgKCEodTAgJiAxMjgpKSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICBjb250aW51ZTtcbiAgfVxuICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgaWYgKCh1MCAmIDIyNCkgPT0gMTkyKSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodTAgJiAzMSkgPDwgNiB8IHUxKTtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICBpZiAoKHUwICYgMjQwKSA9PSAyMjQpIHtcbiAgIHUwID0gKHUwICYgMTUpIDw8IDEyIHwgdTEgPDwgNiB8IHUyO1xuICB9IGVsc2Uge1xuICAgaWYgKCh1MCAmIDI0OCkgIT0gMjQwKSB3YXJuT25jZShcIkludmFsaWQgVVRGLTggbGVhZGluZyBieXRlIFwiICsgcHRyVG9TdHJpbmcodTApICsgXCIgZW5jb3VudGVyZWQgd2hlbiBkZXNlcmlhbGl6aW5nIGEgVVRGLTggc3RyaW5nIGluIHdhc20gbWVtb3J5IHRvIGEgSlMgc3RyaW5nIVwiKTtcbiAgIHUwID0gKHUwICYgNykgPDwgMTggfCB1MSA8PCAxMiB8IHUyIDw8IDYgfCBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgfVxuICBpZiAodTAgPCA2NTUzNikge1xuICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICB9IGVsc2Uge1xuICAgdmFyIGNoID0gdTAgLSA2NTUzNjtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgY2ggPj4gMTAsIDU2MzIwIHwgY2ggJiAxMDIzKTtcbiAgfVxuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkge1xuIGFzc2VydCh0eXBlb2YgcHRyID09IFwibnVtYmVyXCIpO1xuIHB0ciA+Pj49IDA7XG4gcmV0dXJuIHB0ciA/IFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiBcIlwiO1xufVxuXG52YXIgU1lTQ0FMTFMgPSB7XG4gdmFyYXJnczogdW5kZWZpbmVkLFxuIGdldDogZnVuY3Rpb24oKSB7XG4gIGFzc2VydChTWVNDQUxMUy52YXJhcmdzICE9IHVuZGVmaW5lZCk7XG4gIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgdmFyIHJldCA9IEhFQVAzMltTWVNDQUxMUy52YXJhcmdzIC0gNCA+Pj4gMl07XG4gIHJldHVybiByZXQ7XG4gfSxcbiBnZXRTdHI6IGZ1bmN0aW9uKHB0cikge1xuICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gIHJldHVybiByZXQ7XG4gfVxufTtcblxuZnVuY3Rpb24gX19fc3lzY2FsbF9fbmV3c2VsZWN0KG5mZHMsIHJlYWRmZHMsIHdyaXRlZmRzLCBleGNlcHRmZHMsIHRpbWVvdXQpIHtcbiBhc3NlcnQobmZkcyA8PSA2NCwgXCJuZmRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDY0XCIpO1xuIGFzc2VydCghZXhjZXB0ZmRzLCBcImV4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkXCIpO1xuIHZhciB0b3RhbCA9IDA7XG4gdmFyIHNyY1JlYWRMb3cgPSByZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgPj4+IDJdIDogMCwgc3JjUmVhZEhpZ2ggPSByZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIHNyY1dyaXRlTG93ID0gd3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdIDogMCwgc3JjV3JpdGVIaWdoID0gd3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIHNyY0V4Y2VwdExvdyA9IGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgPj4+IDJdIDogMCwgc3JjRXhjZXB0SGlnaCA9IGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIGRzdFJlYWRMb3cgPSAwLCBkc3RSZWFkSGlnaCA9IDA7XG4gdmFyIGRzdFdyaXRlTG93ID0gMCwgZHN0V3JpdGVIaWdoID0gMDtcbiB2YXIgZHN0RXhjZXB0TG93ID0gMCwgZHN0RXhjZXB0SGlnaCA9IDA7XG4gdmFyIGFsbExvdyA9IChyZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgPj4+IDJdIDogMCkgfCAod3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdIDogMCkgfCAoZXhjZXB0ZmRzID8gSEVBUDMyW2V4Y2VwdGZkcyA+Pj4gMl0gOiAwKTtcbiB2YXIgYWxsSGlnaCA9IChyZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA6IDApIHwgKHdyaXRlZmRzID8gSEVBUDMyW3dyaXRlZmRzICsgNCA+Pj4gMl0gOiAwKSB8IChleGNlcHRmZHMgPyBIRUFQMzJbZXhjZXB0ZmRzICsgNCA+Pj4gMl0gOiAwKTtcbiB2YXIgY2hlY2sgPSBmdW5jdGlvbihmZCwgbG93LCBoaWdoLCB2YWwpIHtcbiAgcmV0dXJuIGZkIDwgMzIgPyBsb3cgJiB2YWwgOiBoaWdoICYgdmFsO1xuIH07XG4gZm9yICh2YXIgZmQgPSAwOyBmZCA8IG5mZHM7IGZkKyspIHtcbiAgdmFyIG1hc2sgPSAxIDw8IGZkICUgMzI7XG4gIGlmICghY2hlY2soZmQsIGFsbExvdywgYWxsSGlnaCwgbWFzaykpIHtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICB2YXIgZmxhZ3MgPSBTWVNDQUxMUy5ERUZBVUxUX1BPTExNQVNLO1xuICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMucG9sbCkge1xuICAgZmxhZ3MgPSBzdHJlYW0uc3RyZWFtX29wcy5wb2xsKHN0cmVhbSk7XG4gIH1cbiAgaWYgKGZsYWdzICYgMSAmJiBjaGVjayhmZCwgc3JjUmVhZExvdywgc3JjUmVhZEhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0UmVhZExvdyA9IGRzdFJlYWRMb3cgfCBtYXNrIDogZHN0UmVhZEhpZ2ggPSBkc3RSZWFkSGlnaCB8IG1hc2s7XG4gICB0b3RhbCsrO1xuICB9XG4gIGlmIChmbGFncyAmIDQgJiYgY2hlY2soZmQsIHNyY1dyaXRlTG93LCBzcmNXcml0ZUhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0V3JpdGVMb3cgPSBkc3RXcml0ZUxvdyB8IG1hc2sgOiBkc3RXcml0ZUhpZ2ggPSBkc3RXcml0ZUhpZ2ggfCBtYXNrO1xuICAgdG90YWwrKztcbiAgfVxuICBpZiAoZmxhZ3MgJiAyICYmIGNoZWNrKGZkLCBzcmNFeGNlcHRMb3csIHNyY0V4Y2VwdEhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0RXhjZXB0TG93ID0gZHN0RXhjZXB0TG93IHwgbWFzayA6IGRzdEV4Y2VwdEhpZ2ggPSBkc3RFeGNlcHRIaWdoIHwgbWFzaztcbiAgIHRvdGFsKys7XG4gIH1cbiB9XG4gaWYgKHJlYWRmZHMpIHtcbiAgSEVBUDMyW3JlYWRmZHMgPj4+IDJdID0gZHN0UmVhZExvdztcbiAgSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA9IGRzdFJlYWRIaWdoO1xuIH1cbiBpZiAod3JpdGVmZHMpIHtcbiAgSEVBUDMyW3dyaXRlZmRzID4+PiAyXSA9IGRzdFdyaXRlTG93O1xuICBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA9IGRzdFdyaXRlSGlnaDtcbiB9XG4gaWYgKGV4Y2VwdGZkcykge1xuICBIRUFQMzJbZXhjZXB0ZmRzID4+PiAyXSA9IGRzdEV4Y2VwdExvdztcbiAgSEVBUDMyW2V4Y2VwdGZkcyArIDQgPj4+IDJdID0gZHN0RXhjZXB0SGlnaDtcbiB9XG4gcmV0dXJuIHRvdGFsO1xufVxuXG5mdW5jdGlvbiBTT0NLRlMoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogJFNPQ0tGU1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIEZTKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246ICRGU1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvY2tldEZyb21GRChmZCkge1xuIHZhciBzb2NrZXQgPSBTT0NLRlMuZ2V0U29ja2V0KGZkKTtcbiBpZiAoIXNvY2tldCkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gcmV0dXJuIHNvY2tldDtcbn1cblxuZnVuY3Rpb24gc2V0RXJyTm8odmFsdWUpIHtcbiBIRUFQMzJbX19fZXJybm9fbG9jYXRpb24oKSA+Pj4gMl0gPSB2YWx1ZTtcbiByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBTb2NrZXRzID0ge1xuIEJVRkZFUl9TSVpFOiAxMDI0MCxcbiBNQVhfQlVGRkVSX1NJWkU6IDEwNDg1NzYwLFxuIG5leHRGZDogMSxcbiBmZHM6IHt9LFxuIG5leHRwb3J0OiAxLFxuIG1heHBvcnQ6IDY1NTM1LFxuIHBlZXI6IG51bGwsXG4gY29ubmVjdGlvbnM6IHt9LFxuIHBvcnRtYXA6IHt9LFxuIGxvY2FsQWRkcjogNDI2MTQxMjg3NCxcbiBhZGRyUG9vbDogWyAzMzU1NDQ0MiwgNTAzMzE2NTgsIDY3MTA4ODc0LCA4Mzg4NjA5MCwgMTAwNjYzMzA2LCAxMTc0NDA1MjIsIDEzNDIxNzczOCwgMTUwOTk0OTU0LCAxNjc3NzIxNzAsIDE4NDU0OTM4NiwgMjAxMzI2NjAyLCAyMTgxMDM4MTgsIDIzNDg4MTAzNCBdXG59O1xuXG5mdW5jdGlvbiBpbmV0TnRvcDQoYWRkcikge1xuIHJldHVybiAoYWRkciAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDggJiAyNTUpICsgXCIuXCIgKyAoYWRkciA+PiAxNiAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDI0ICYgMjU1KTtcbn1cblxuZnVuY3Rpb24gaW5ldE50b3A2KGludHMpIHtcbiB2YXIgc3RyID0gXCJcIjtcbiB2YXIgd29yZCA9IDA7XG4gdmFyIGxvbmdlc3QgPSAwO1xuIHZhciBsYXN0emVybyA9IDA7XG4gdmFyIHpzdGFydCA9IDA7XG4gdmFyIGxlbiA9IDA7XG4gdmFyIGkgPSAwO1xuIHZhciBwYXJ0cyA9IFsgaW50c1swXSAmIDY1NTM1LCBpbnRzWzBdID4+IDE2LCBpbnRzWzFdICYgNjU1MzUsIGludHNbMV0gPj4gMTYsIGludHNbMl0gJiA2NTUzNSwgaW50c1syXSA+PiAxNiwgaW50c1szXSAmIDY1NTM1LCBpbnRzWzNdID4+IDE2IF07XG4gdmFyIGhhc2lwdjQgPSB0cnVlO1xuIHZhciB2NHBhcnQgPSBcIlwiO1xuIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgaWYgKHBhcnRzW2ldICE9PSAwKSB7XG4gICBoYXNpcHY0ID0gZmFsc2U7XG4gICBicmVhaztcbiAgfVxuIH1cbiBpZiAoaGFzaXB2NCkge1xuICB2NHBhcnQgPSBpbmV0TnRvcDQocGFydHNbNl0gfCBwYXJ0c1s3XSA8PCAxNik7XG4gIGlmIChwYXJ0c1s1XSA9PT0gLTEpIHtcbiAgIHN0ciA9IFwiOjpmZmZmOlwiO1xuICAgc3RyICs9IHY0cGFydDtcbiAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKHBhcnRzWzVdID09PSAwKSB7XG4gICBzdHIgPSBcIjo6XCI7XG4gICBpZiAodjRwYXJ0ID09PSBcIjAuMC4wLjBcIikgdjRwYXJ0ID0gXCJcIjtcbiAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMVwiKSB2NHBhcnQgPSBcIjFcIjtcbiAgIHN0ciArPSB2NHBhcnQ7XG4gICByZXR1cm4gc3RyO1xuICB9XG4gfVxuIGZvciAod29yZCA9IDA7IHdvcmQgPCA4OyB3b3JkKyspIHtcbiAgaWYgKHBhcnRzW3dvcmRdID09PSAwKSB7XG4gICBpZiAod29yZCAtIGxhc3R6ZXJvID4gMSkge1xuICAgIGxlbiA9IDA7XG4gICB9XG4gICBsYXN0emVybyA9IHdvcmQ7XG4gICBsZW4rKztcbiAgfVxuICBpZiAobGVuID4gbG9uZ2VzdCkge1xuICAgbG9uZ2VzdCA9IGxlbjtcbiAgIHpzdGFydCA9IHdvcmQgLSBsb25nZXN0ICsgMTtcbiAgfVxuIH1cbiBmb3IgKHdvcmQgPSAwOyB3b3JkIDwgODsgd29yZCsrKSB7XG4gIGlmIChsb25nZXN0ID4gMSkge1xuICAgaWYgKHBhcnRzW3dvcmRdID09PSAwICYmIHdvcmQgPj0genN0YXJ0ICYmIHdvcmQgPCB6c3RhcnQgKyBsb25nZXN0KSB7XG4gICAgaWYgKHdvcmQgPT09IHpzdGFydCkge1xuICAgICBzdHIgKz0gXCI6XCI7XG4gICAgIGlmICh6c3RhcnQgPT09IDApIHN0ciArPSBcIjpcIjtcbiAgICB9XG4gICAgY29udGludWU7XG4gICB9XG4gIH1cbiAgc3RyICs9IE51bWJlcihfbnRvaHMocGFydHNbd29yZF0gJiA2NTUzNSkpLnRvU3RyaW5nKDE2KTtcbiAgc3RyICs9IHdvcmQgPCA3ID8gXCI6XCIgOiBcIlwiO1xuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiByZWFkU29ja2FkZHIoc2EsIHNhbGVuKSB7XG4gdmFyIGZhbWlseSA9IEhFQVAxNltzYSA+Pj4gMV07XG4gdmFyIHBvcnQgPSBfbnRvaHMoSEVBUFUxNltzYSArIDIgPj4+IDFdKTtcbiB2YXIgYWRkcjtcbiBzd2l0Y2ggKGZhbWlseSkge1xuIGNhc2UgMjpcbiAgaWYgKHNhbGVuICE9PSAxNikge1xuICAgcmV0dXJuIHtcbiAgICBlcnJubzogMjhcbiAgIH07XG4gIH1cbiAgYWRkciA9IEhFQVAzMltzYSArIDQgPj4+IDJdO1xuICBhZGRyID0gaW5ldE50b3A0KGFkZHIpO1xuICBicmVhaztcblxuIGNhc2UgMTA6XG4gIGlmIChzYWxlbiAhPT0gMjgpIHtcbiAgIHJldHVybiB7XG4gICAgZXJybm86IDI4XG4gICB9O1xuICB9XG4gIGFkZHIgPSBbIEhFQVAzMltzYSArIDggPj4+IDJdLCBIRUFQMzJbc2EgKyAxMiA+Pj4gMl0sIEhFQVAzMltzYSArIDE2ID4+PiAyXSwgSEVBUDMyW3NhICsgMjAgPj4+IDJdIF07XG4gIGFkZHIgPSBpbmV0TnRvcDYoYWRkcik7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgcmV0dXJuIHtcbiAgIGVycm5vOiA1XG4gIH07XG4gfVxuIHJldHVybiB7XG4gIGZhbWlseTogZmFtaWx5LFxuICBhZGRyOiBhZGRyLFxuICBwb3J0OiBwb3J0XG4gfTtcbn1cblxuZnVuY3Rpb24gaW5ldFB0b240KHN0cikge1xuIHZhciBiID0gc3RyLnNwbGl0KFwiLlwiKTtcbiBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICB2YXIgdG1wID0gTnVtYmVyKGJbaV0pO1xuICBpZiAoaXNOYU4odG1wKSkgcmV0dXJuIG51bGw7XG4gIGJbaV0gPSB0bXA7XG4gfVxuIHJldHVybiAoYlswXSB8IGJbMV0gPDwgOCB8IGJbMl0gPDwgMTYgfCBiWzNdIDw8IDI0KSA+Pj4gMDtcbn1cblxuZnVuY3Rpb24ganN0b2lfcShzdHIpIHtcbiByZXR1cm4gcGFyc2VJbnQoc3RyKTtcbn1cblxuZnVuY3Rpb24gaW5ldFB0b242KHN0cikge1xuIHZhciB3b3JkcztcbiB2YXIgdywgb2Zmc2V0LCB6LCBpO1xuIHZhciB2YWxpZDZyZWd4ID0gL14oKD89Lio6OikoPyEuKjo6Lis6OikoOjopPyhbXFxkQS1GXXsxLDR9Oig6fFxcYil8KXs1fXwoW1xcZEEtRl17MSw0fTopezZ9KSgoKFtcXGRBLUZdezEsNH0oKD8hXFwzKTo6fDpcXGJ8JCkpfCg/IVxcMlxcMykpezJ9fCgoKDJbMC00XXwxXFxkfFsxLTldKT9cXGR8MjVbMC01XSlcXC4/XFxiKXs0fSkkL2k7XG4gdmFyIHBhcnRzID0gW107XG4gaWYgKCF2YWxpZDZyZWd4LnRlc3Qoc3RyKSkge1xuICByZXR1cm4gbnVsbDtcbiB9XG4gaWYgKHN0ciA9PT0gXCI6OlwiKSB7XG4gIHJldHVybiBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXTtcbiB9XG4gaWYgKHN0ci5zdGFydHNXaXRoKFwiOjpcIikpIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UoXCI6OlwiLCBcIlo6XCIpO1xuIH0gZWxzZSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKFwiOjpcIiwgXCI6WjpcIik7XG4gfVxuIGlmIChzdHIuaW5kZXhPZihcIi5cIikgPiAwKSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbLl1cIiwgXCJnXCIpLCBcIjpcIik7XG4gIHdvcmRzID0gc3RyLnNwbGl0KFwiOlwiKTtcbiAgd29yZHNbd29yZHMubGVuZ3RoIC0gNF0gPSBqc3RvaV9xKHdvcmRzW3dvcmRzLmxlbmd0aCAtIDRdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gM10pICogMjU2O1xuICB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAzXSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gMl0pICsganN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSkgKiAyNTY7XG4gIHdvcmRzID0gd29yZHMuc2xpY2UoMCwgd29yZHMubGVuZ3RoIC0gMik7XG4gfSBlbHNlIHtcbiAgd29yZHMgPSBzdHIuc3BsaXQoXCI6XCIpO1xuIH1cbiBvZmZzZXQgPSAwO1xuIHogPSAwO1xuIGZvciAodyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICBpZiAodHlwZW9mIHdvcmRzW3ddID09IFwic3RyaW5nXCIpIHtcbiAgIGlmICh3b3Jkc1t3XSA9PT0gXCJaXCIpIHtcbiAgICBmb3IgKHogPSAwOyB6IDwgOCAtIHdvcmRzLmxlbmd0aCArIDE7IHorKykge1xuICAgICBwYXJ0c1t3ICsgel0gPSAwO1xuICAgIH1cbiAgICBvZmZzZXQgPSB6IC0gMTtcbiAgIH0gZWxzZSB7XG4gICAgcGFydHNbdyArIG9mZnNldF0gPSBfaHRvbnMocGFyc2VJbnQod29yZHNbd10sIDE2KSk7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBwYXJ0c1t3ICsgb2Zmc2V0XSA9IHdvcmRzW3ddO1xuICB9XG4gfVxuIHJldHVybiBbIHBhcnRzWzFdIDw8IDE2IHwgcGFydHNbMF0sIHBhcnRzWzNdIDw8IDE2IHwgcGFydHNbMl0sIHBhcnRzWzVdIDw8IDE2IHwgcGFydHNbNF0sIHBhcnRzWzddIDw8IDE2IHwgcGFydHNbNl0gXTtcbn1cblxudmFyIEROUyA9IHtcbiBhZGRyZXNzX21hcDoge1xuICBpZDogMSxcbiAgYWRkcnM6IHt9LFxuICBuYW1lczoge31cbiB9LFxuIGxvb2t1cF9uYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciByZXMgPSBpbmV0UHRvbjQobmFtZSk7XG4gIGlmIChyZXMgIT09IG51bGwpIHtcbiAgIHJldHVybiBuYW1lO1xuICB9XG4gIHJlcyA9IGluZXRQdG9uNihuYW1lKTtcbiAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgdmFyIGFkZHI7XG4gIGlmIChETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV0pIHtcbiAgIGFkZHIgPSBETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV07XG4gIH0gZWxzZSB7XG4gICB2YXIgaWQgPSBETlMuYWRkcmVzc19tYXAuaWQrKztcbiAgIGFzc2VydChpZCA8IDY1NTM1LCBcImV4Y2VlZGVkIG1heCBhZGRyZXNzIG1hcHBpbmdzIG9mIDY1NTM1XCIpO1xuICAgYWRkciA9IFwiMTcyLjI5LlwiICsgKGlkICYgMjU1KSArIFwiLlwiICsgKGlkICYgNjUyODApO1xuICAgRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdID0gbmFtZTtcbiAgIEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSA9IGFkZHI7XG4gIH1cbiAgcmV0dXJuIGFkZHI7XG4gfSxcbiBsb29rdXBfYWRkcjogZnVuY3Rpb24oYWRkcikge1xuICBpZiAoRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdKSB7XG4gICByZXR1cm4gRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdO1xuICB9XG4gIHJldHVybiBudWxsO1xuIH1cbn07XG5cbmZ1bmN0aW9uIGdldFNvY2tldEFkZHJlc3MoYWRkcnAsIGFkZHJsZW4sIGFsbG93TnVsbCkge1xuIGlmIChhbGxvd051bGwgJiYgYWRkcnAgPT09IDApIHJldHVybiBudWxsO1xuIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKGFkZHJwLCBhZGRybGVuKTtcbiBpZiAoaW5mby5lcnJubykgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoaW5mby5lcnJubyk7XG4gaW5mby5hZGRyID0gRE5TLmxvb2t1cF9hZGRyKGluZm8uYWRkcikgfHwgaW5mby5hZGRyO1xuIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2JpbmQoZmQsIGFkZHIsIGFkZHJsZW4sIGQxLCBkMiwgZDMpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gdmFyIGluZm8gPSBnZXRTb2NrZXRBZGRyZXNzKGFkZHIsIGFkZHJsZW4pO1xuIHNvY2suc29ja19vcHMuYmluZChzb2NrLCBpbmZvLmFkZHIsIGluZm8ucG9ydCk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfY29ubmVjdChmZCwgYWRkciwgYWRkcmxlbiwgZDEsIGQyLCBkMykge1xuIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiB2YXIgaW5mbyA9IGdldFNvY2tldEFkZHJlc3MoYWRkciwgYWRkcmxlbik7XG4gc29jay5zb2NrX29wcy5jb25uZWN0KHNvY2ssIGluZm8uYWRkciwgaW5mby5wb3J0KTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsIGNtZCwgdmFyYXJncykge1xuIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZChsbywgaGkpIHtcbiBhc3NlcnQobG8gPT0gbG8gPj4+IDAgfHwgbG8gPT0gKGxvIHwgMCkpO1xuIGFzc2VydChoaSA9PT0gKGhpIHwgMCkpO1xuIHJldHVybiBoaSArIDIwOTcxNTIgPj4+IDAgPCA0MTk0MzA1IC0gISFsbyA/IChsbyA+Pj4gMCkgKyBoaSAqIDQyOTQ5NjcyOTYgOiBOYU47XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZnRydW5jYXRlNjQoZmQsIGxlbmd0aF9sb3csIGxlbmd0aF9oaWdoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiBvdXRJZHggPj4+PSAwO1xuIGFzc2VydCh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKTtcbiBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDA7XG4gdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHtcbiAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICB1ID0gNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkgfCB1MSAmIDEwMjM7XG4gIH1cbiAgaWYgKHUgPD0gMTI3KSB7XG4gICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IHU7XG4gIH0gZWxzZSBpZiAodSA8PSAyMDQ3KSB7XG4gICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxOTIgfCB1ID4+IDY7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDEyOCB8IHUgJiA2MztcbiAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7XG4gICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAyMjQgfCB1ID4+IDEyO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9IGVsc2Uge1xuICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgIGlmICh1ID4gMTExNDExMSkgd2Fybk9uY2UoXCJJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCBcIiArIHB0clRvU3RyaW5nKHUpICsgXCIgZW5jb3VudGVyZWQgd2hlbiBzZXJpYWxpemluZyBhIEpTIHN0cmluZyB0byBhIFVURi04IHN0cmluZyBpbiB3YXNtIG1lbW9yeSEgKFZhbGlkIHVuaWNvZGUgY29kZSBwb2ludHMgc2hvdWxkIGJlIGluIHJhbmdlIDAtMHgxMEZGRkYpLlwiKTtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMjQwIHwgdSA+PiAxODtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSA+PiAxMiAmIDYzO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9XG4gfVxuIGhlYXBbb3V0SWR4ID4+PiAwXSA9IDA7XG4gcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09IFwibnVtYmVyXCIsIFwic3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIVwiKTtcbiByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRkZW50czY0KGZkLCBkaXJwLCBjb3VudCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3MsIHNpemUpIHtcbiBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gcmV0dXJuIGFkZHJlc3M7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCwgYWRkcmxlbikge1xuIHN3aXRjaCAoZmFtaWx5KSB7XG4gY2FzZSAyOlxuICBhZGRyID0gaW5ldFB0b240KGFkZHIpO1xuICB6ZXJvTWVtb3J5KHNhLCAxNik7XG4gIGlmIChhZGRybGVuKSB7XG4gICBIRUFQMzJbYWRkcmxlbiA+Pj4gMl0gPSAxNjtcbiAgfVxuICBIRUFQMTZbc2EgPj4+IDFdID0gZmFtaWx5O1xuICBIRUFQMzJbc2EgKyA0ID4+PiAyXSA9IGFkZHI7XG4gIEhFQVAxNltzYSArIDIgPj4+IDFdID0gX2h0b25zKHBvcnQpO1xuICBicmVhaztcblxuIGNhc2UgMTA6XG4gIGFkZHIgPSBpbmV0UHRvbjYoYWRkcik7XG4gIHplcm9NZW1vcnkoc2EsIDI4KTtcbiAgaWYgKGFkZHJsZW4pIHtcbiAgIEhFQVAzMlthZGRybGVuID4+PiAyXSA9IDI4O1xuICB9XG4gIEhFQVAzMltzYSA+Pj4gMl0gPSBmYW1pbHk7XG4gIEhFQVAzMltzYSArIDggPj4+IDJdID0gYWRkclswXTtcbiAgSEVBUDMyW3NhICsgMTIgPj4+IDJdID0gYWRkclsxXTtcbiAgSEVBUDMyW3NhICsgMTYgPj4+IDJdID0gYWRkclsyXTtcbiAgSEVBUDMyW3NhICsgMjAgPj4+IDJdID0gYWRkclszXTtcbiAgSEVBUDE2W3NhICsgMiA+Pj4gMV0gPSBfaHRvbnMocG9ydCk7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgcmV0dXJuIDU7XG4gfVxuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldHBlZXJuYW1lKGZkLCBhZGRyLCBhZGRybGVuLCBkMSwgZDIsIGQzKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIGlmICghc29jay5kYWRkcikge1xuICByZXR1cm4gLTUzO1xuIH1cbiB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIHNvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUoc29jay5kYWRkciksIHNvY2suZHBvcnQsIGFkZHJsZW4pO1xuIGFzc2VydCghZXJybm8pO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldHNvY2tvcHQoZmQsIGxldmVsLCBvcHRuYW1lLCBvcHR2YWwsIG9wdGxlbiwgZDEpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gaWYgKGxldmVsID09PSAxKSB7XG4gIGlmIChvcHRuYW1lID09PSA0KSB7XG4gICBIRUFQMzJbb3B0dmFsID4+PiAyXSA9IHNvY2suZXJyb3I7XG4gICBIRUFQMzJbb3B0bGVuID4+PiAyXSA9IDQ7XG4gICBzb2NrLmVycm9yID0gbnVsbDtcbiAgIHJldHVybiAwO1xuICB9XG4gfVxuIHJldHVybiAtNTA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9ta2RpcmF0KGRpcmZkLCBwYXRoLCBtb2RlKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfbmV3ZnN0YXRhdChkaXJmZCwgcGF0aCwgYnVmLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9yZWN2ZnJvbShmZCwgYnVmLCBsZW4sIGZsYWdzLCBhZGRyLCBhZGRybGVuKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIHZhciBtc2cgPSBzb2NrLnNvY2tfb3BzLnJlY3Ztc2coc29jaywgbGVuKTtcbiBpZiAoIW1zZykgcmV0dXJuIDA7XG4gaWYgKGFkZHIpIHtcbiAgdmFyIGVycm5vID0gd3JpdGVTb2NrYWRkcihhZGRyLCBzb2NrLmZhbWlseSwgRE5TLmxvb2t1cF9uYW1lKG1zZy5hZGRyKSwgbXNnLnBvcnQsIGFkZHJsZW4pO1xuICBhc3NlcnQoIWVycm5vKTtcbiB9XG4gSEVBUFU4LnNldChtc2cuYnVmZmVyLCBidWYgPj4+IDApO1xuIHJldHVybiBtc2cuYnVmZmVyLmJ5dGVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVuYW1lYXQob2xkZGlyZmQsIG9sZHBhdGgsIG5ld2RpcmZkLCBuZXdwYXRoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3NlbmR0byhmZCwgbWVzc2FnZSwgbGVuZ3RoLCBmbGFncywgYWRkciwgYWRkcl9sZW4pIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9zb2NrZXQoZG9tYWluLCB0eXBlLCBwcm90b2NvbCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3N0YXQ2NChwYXRoLCBidWYpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF91bmxpbmthdChkaXJmZCwgcGF0aCwgZmxhZ3MpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxudmFyIG5vd0lzTW9ub3RvbmljID0gdHJ1ZTtcblxuZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCkge1xuIHJldHVybiBub3dJc01vbm90b25pYztcbn1cblxuZnVuY3Rpb24gcmVhZEk1M0Zyb21JNjQocHRyKSB7XG4gcmV0dXJuIEhFQVBVMzJbcHRyID4+PiAyXSArIEhFQVAzMltwdHIgKyA0ID4+PiAyXSAqIDQyOTQ5NjcyOTY7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxudmFyIE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFID0gWyAwLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNSBdO1xuXG52YXIgTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUgPSBbIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0IF07XG5cbmZ1bmN0aW9uIHlkYXlGcm9tRGF0ZShkYXRlKSB7XG4gdmFyIGxlYXAgPSBpc0xlYXBZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gdmFyIG1vbnRoRGF5c0N1bXVsYXRpdmUgPSBsZWFwID8gTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUgOiBNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRTtcbiB2YXIgeWRheSA9IG1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXSArIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbiByZXR1cm4geWRheTtcbn1cblxuZnVuY3Rpb24gX19sb2NhbHRpbWVfanModGltZSwgdG1QdHIpIHtcbiB2YXIgZGF0ZSA9IG5ldyBEYXRlKHJlYWRJNTNGcm9tSTY0KHRpbWUpICogMWUzKTtcbiBIRUFQMzJbdG1QdHIgPj4+IDJdID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gSEVBUDMyW3RtUHRyICsgNCA+Pj4gMl0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiBIRUFQMzJbdG1QdHIgKyA4ID4+PiAyXSA9IGRhdGUuZ2V0SG91cnMoKTtcbiBIRUFQMzJbdG1QdHIgKyAxMiA+Pj4gMl0gPSBkYXRlLmdldERhdGUoKTtcbiBIRUFQMzJbdG1QdHIgKyAxNiA+Pj4gMl0gPSBkYXRlLmdldE1vbnRoKCk7XG4gSEVBUDMyW3RtUHRyICsgMjAgPj4+IDJdID0gZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTkwMDtcbiBIRUFQMzJbdG1QdHIgKyAyNCA+Pj4gMl0gPSBkYXRlLmdldERheSgpO1xuIHZhciB5ZGF5ID0geWRheUZyb21EYXRlKGRhdGUpIHwgMDtcbiBIRUFQMzJbdG1QdHIgKyAyOCA+Pj4gMl0gPSB5ZGF5O1xuIEhFQVAzMlt0bVB0ciArIDM2ID4+PiAyXSA9IC0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjApO1xuIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgZHN0ID0gKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiYgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KSkgfCAwO1xuIEhFQVAzMlt0bVB0ciArIDMyID4+PiAyXSA9IGRzdDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cikge1xuIHZhciBsZW4gPSAwO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIGlmIChjIDw9IDEyNykge1xuICAgbGVuKys7XG4gIH0gZWxzZSBpZiAoYyA8PSAyMDQ3KSB7XG4gICBsZW4gKz0gMjtcbiAgfSBlbHNlIGlmIChjID49IDU1Mjk2ICYmIGMgPD0gNTczNDMpIHtcbiAgIGxlbiArPSA0O1xuICAgKytpO1xuICB9IGVsc2Uge1xuICAgbGVuICs9IDM7XG4gIH1cbiB9XG4gcmV0dXJuIGxlbjtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9OZXdVVEY4KHN0cikge1xuIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xuIGlmIChyZXQpIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgc2l6ZSk7XG4gcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gX190enNldF9qcyh0aW1lem9uZSwgZGF5bGlnaHQsIHR6bmFtZSkge1xuIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiB2YXIgd2ludGVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDAsIDEpO1xuIHZhciBzdW1tZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgNiwgMSk7XG4gdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuIHZhciBzdW1tZXJPZmZzZXQgPSBzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7XG4gSEVBUFUzMlt0aW1lem9uZSA+Pj4gMl0gPSBzdGRUaW1lem9uZU9mZnNldCAqIDYwO1xuIEhFQVAzMltkYXlsaWdodCA+Pj4gMl0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG4gZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSkge1xuICB2YXIgbWF0Y2ggPSBkYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogXCJHTVRcIjtcbiB9XG4gdmFyIHdpbnRlck5hbWUgPSBleHRyYWN0Wm9uZSh3aW50ZXIpO1xuIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyKTtcbiB2YXIgd2ludGVyTmFtZVB0ciA9IHN0cmluZ1RvTmV3VVRGOCh3aW50ZXJOYW1lKTtcbiB2YXIgc3VtbWVyTmFtZVB0ciA9IHN0cmluZ1RvTmV3VVRGOChzdW1tZXJOYW1lKTtcbiBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gIEhFQVBVMzJbdHpuYW1lID4+PiAyXSA9IHdpbnRlck5hbWVQdHI7XG4gIEhFQVBVMzJbdHpuYW1lICsgNCA+Pj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuIH0gZWxzZSB7XG4gIEhFQVBVMzJbdHpuYW1lID4+PiAyXSA9IHN1bW1lck5hbWVQdHI7XG4gIEhFQVBVMzJbdHpuYW1lICsgNCA+Pj4gMl0gPSB3aW50ZXJOYW1lUHRyO1xuIH1cbn1cblxuZnVuY3Rpb24gX2Fib3J0KCkge1xuIGFib3J0KFwibmF0aXZlIGNvZGUgY2FsbGVkIGFib3J0KClcIik7XG59XG5cbmZ1bmN0aW9uIF9kbG9wZW4oZmlsZW5hbWUsIGZsYWdzKSB7XG4gYWJvcnQoZGxvcGVuTWlzc2luZ0Vycm9yKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2NyZWF0ZShwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY3JlYXRlRGlyZWN0b3J5KE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9leGlzdHMocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNoZWNrRGlyZWN0b3J5KE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9saXN0X2ZpbGVzKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5saXN0RGlyZWN0b3J5RW50cmllcyhNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfcmVtb3ZlKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5yZW1vdmVEaXJlY3RvcnkoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9jbG9zZShmaWxlSWQpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jbG9zZUZpbGUoTW9kdWxlLCBmaWxlSWQpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2V4aXN0cyhwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2hlY2tGaWxlKE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZ2V0X2xhc3RfbW9kaWZpZWRfdGltZShmaWxlSWQpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWUoTW9kdWxlLCBmaWxlSWQpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX21vdmUoZnJvbSwgZnJvbUxlbiwgdG8sIHRvTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUubW92ZUZpbGUoTW9kdWxlLCBmcm9tLCBmcm9tTGVuLCB0bywgdG9MZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX29wZW4oZmlsZUlkLCBmbGFncykge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLm9wZW5GaWxlKE1vZHVsZSwgZmlsZUlkLCBmbGFncyk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfcmVhZChmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5yZWFkRmlsZShNb2R1bGUsIGZpbGVJZCwgYnVmLCBzaXplLCBsb2NhdGlvbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfdHJ1bmNhdGUoZmlsZUlkLCBuZXdTaXplKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUudHJ1bmNhdGVGaWxlKE1vZHVsZSwgZmlsZUlkLCBuZXdTaXplKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZShmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS53cml0ZUZpbGUoTW9kdWxlLCBmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19nZXRfZGVmYXVsdF9kYXRhX3Byb3RvY29sKE1vZHVsZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmdldERlZmF1bHREYXRhUHJvdG9jb2woTW9kdWxlKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZ2xvYihwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuZ2xvYihNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmUoZmVhdHVyZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnRlc3RQbGF0Zm9ybUZlYXR1cmUoTW9kdWxlLCBmZWF0dXJlKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jYWxsKGZ1bmNJZCwgZGVzY1B0ciwgZGVzY1NpemUsIHB0cnNQdHIsIHB0cnNTaXplLCByZXNwb25zZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNhbGxTY2FsYXJVREYoTW9kdWxlLCBmdW5jSWQsIGRlc2NQdHIsIGRlc2NTaXplLCBwdHJzUHRyLCBwdHJzU2l6ZSwgcmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9jb25zb2xlX2Vycm9yKHN0cikge1xuIGFzc2VydCh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpO1xuIGNvbnNvbGUuZXJyb3IoVVRGOFRvU3RyaW5nKHN0cikpO1xufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9kYXRlX25vdygpIHtcbiByZXR1cm4gRGF0ZS5ub3coKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiByZXR1cm4gNDI5NDkwMTc2MDtcbn1cblxuZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4KCkge1xuIHJldHVybiBnZXRIZWFwTWF4KCk7XG59XG5cbnZhciBfZW1zY3JpcHRlbl9nZXRfbm93O1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuIGdsb2JhbC5wZXJmb3JtYW5jZSA9IHJlcXVpcmUoXCJwZXJmX2hvb2tzXCIpLnBlcmZvcm1hbmNlO1xufVxuXG5fZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG5cbmZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcbiBIRUFQVTguY29weVdpdGhpbihkZXN0ID4+PiAwLCBzcmMgPj4+IDAsIHNyYyArIG51bSA+Pj4gMCk7XG59XG5cbmZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSkge1xuIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gdmFyIHBhZ2VzID0gc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1ID4+PiAxNjtcbiB0cnkge1xuICB3YXNtTWVtb3J5Lmdyb3cocGFnZXMpO1xuICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuICByZXR1cm4gMTtcbiB9IGNhdGNoIChlKSB7XG4gIGVycihgZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcjogQXR0ZW1wdGVkIHRvIGdyb3cgaGVhcCBmcm9tICR7Yi5ieXRlTGVuZ3RofSBieXRlcyB0byAke3NpemV9IGJ5dGVzLCBidXQgZ290IGVycm9yOiAke2V9YCk7XG4gfVxufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcChyZXF1ZXN0ZWRTaXplKSB7XG4gdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuIGFzc2VydChyZXF1ZXN0ZWRTaXplID4gb2xkU2l6ZSk7XG4gdmFyIG1heEhlYXBTaXplID0gZ2V0SGVhcE1heCgpO1xuIGlmIChyZXF1ZXN0ZWRTaXplID4gbWF4SGVhcFNpemUpIHtcbiAgZXJyKGBDYW5ub3QgZW5sYXJnZSBtZW1vcnksIGFza2VkIHRvIGdvIHVwIHRvICR7cmVxdWVzdGVkU2l6ZX0gYnl0ZXMsIGJ1dCB0aGUgbGltaXQgaXMgJHttYXhIZWFwU2l6ZX0gYnl0ZXMhYCk7XG4gIHJldHVybiBmYWxzZTtcbiB9XG4gdmFyIGFsaWduVXAgPSAoeCwgbXVsdGlwbGUpID0+IHggKyAobXVsdGlwbGUgLSB4ICUgbXVsdGlwbGUpICUgbXVsdGlwbGU7XG4gZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gIHZhciBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIC4yIC8gY3V0RG93bik7XG4gIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUsIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYpO1xuICB2YXIgbmV3U2l6ZSA9IE1hdGgubWluKG1heEhlYXBTaXplLCBhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpKTtcbiAgdmFyIHJlcGxhY2VtZW50ID0gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtcbiAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfVxuIH1cbiBlcnIoYEZhaWxlZCB0byBncm93IHRoZSBoZWFwIGZyb20gJHtvbGRTaXplfSBieXRlcyB0byAke25ld1NpemV9IGJ5dGVzLCBub3QgZW5vdWdoIG1lbW9yeSFgKTtcbiByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBFTlYgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKSB7XG4gcmV0dXJuIHRoaXNQcm9ncmFtIHx8IFwiLi90aGlzLnByb2dyYW1cIjtcbn1cblxuZnVuY3Rpb24gZ2V0RW52U3RyaW5ncygpIHtcbiBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICB2YXIgbGFuZyA9ICh0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IFwiQ1wiKS5yZXBsYWNlKFwiLVwiLCBcIl9cIikgKyBcIi5VVEYtOFwiO1xuICB2YXIgZW52ID0ge1xuICAgXCJVU0VSXCI6IFwid2ViX3VzZXJcIixcbiAgIFwiTE9HTkFNRVwiOiBcIndlYl91c2VyXCIsXG4gICBcIlBBVEhcIjogXCIvXCIsXG4gICBcIlBXRFwiOiBcIi9cIixcbiAgIFwiSE9NRVwiOiBcIi9ob21lL3dlYl91c2VyXCIsXG4gICBcIkxBTkdcIjogbGFuZyxcbiAgIFwiX1wiOiBnZXRFeGVjdXRhYmxlTmFtZSgpXG4gIH07XG4gIGZvciAodmFyIHggaW4gRU5WKSB7XG4gICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07IGVsc2UgZW52W3hdID0gRU5WW3hdO1xuICB9XG4gIHZhciBzdHJpbmdzID0gW107XG4gIGZvciAodmFyIHggaW4gZW52KSB7XG4gICBzdHJpbmdzLnB1c2goYCR7eH09JHtlbnZbeF19YCk7XG4gIH1cbiAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiB9XG4gcmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5ncztcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9Bc2NpaShzdHIsIGJ1ZmZlcikge1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIGFzc2VydChzdHIuY2hhckNvZGVBdChpKSA9PT0gKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KSk7XG4gIEhFQVA4W2J1ZmZlcisrID4+PiAwXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuIH1cbiBIRUFQOFtidWZmZXIgPj4+IDBdID0gMDtcbn1cblxuZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbiwgZW52aXJvbl9idWYpIHtcbiB2YXIgYnVmU2l6ZSA9IDA7XG4gZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLCBpKSB7XG4gIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gIEhFQVBVMzJbX19lbnZpcm9uICsgaSAqIDQgPj4+IDJdID0gcHRyO1xuICBzdHJpbmdUb0FzY2lpKHN0cmluZywgcHRyKTtcbiAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiB9KTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2Vudmlyb25fc2l6ZXNfZ2V0KHBlbnZpcm9uX2NvdW50LCBwZW52aXJvbl9idWZfc2l6ZSkge1xuIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuIEhFQVBVMzJbcGVudmlyb25fY291bnQgPj4+IDJdID0gc3RyaW5ncy5sZW5ndGg7XG4gdmFyIGJ1ZlNpemUgPSAwO1xuIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpIHtcbiAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiB9KTtcbiBIRUFQVTMyW3BlbnZpcm9uX2J1Zl9zaXplID4+PiAyXSA9IGJ1ZlNpemU7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuIGFib3J0KFwiZmRfY2xvc2UgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCwgcGJ1Zikge1xuIHZhciByaWdodHNCYXNlID0gMDtcbiB2YXIgcmlnaHRzSW5oZXJpdGluZyA9IDA7XG4gdmFyIGZsYWdzID0gMDtcbiB7XG4gIGFzc2VydChmZCA9PSAwIHx8IGZkID09IDEgfHwgZmQgPT0gMik7XG4gIHZhciB0eXBlID0gMjtcbiAgaWYgKGZkID09IDApIHtcbiAgIHJpZ2h0c0Jhc2UgPSAyO1xuICB9IGVsc2UgaWYgKGZkID09IDEgfHwgZmQgPT0gMikge1xuICAgcmlnaHRzQmFzZSA9IDY0O1xuICB9XG4gIGZsYWdzID0gMTtcbiB9XG4gSEVBUDhbcGJ1ZiA+Pj4gMF0gPSB0eXBlO1xuIEhFQVAxNltwYnVmICsgMiA+Pj4gMV0gPSBmbGFncztcbiB0ZW1wSTY0ID0gWyByaWdodHNCYXNlID4+PiAwLCAodGVtcERvdWJsZSA9IHJpZ2h0c0Jhc2UsICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxID8gdGVtcERvdWJsZSA+IDAgPyArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5NikgPj4+IDAgOiB+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5NikgPj4+IDAgOiAwKSBdLCBcbiBIRUFQMzJbcGJ1ZiArIDggPj4+IDJdID0gdGVtcEk2NFswXSwgSEVBUDMyW3BidWYgKyAxMiA+Pj4gMl0gPSB0ZW1wSTY0WzFdO1xuIHRlbXBJNjQgPSBbIHJpZ2h0c0luaGVyaXRpbmcgPj4+IDAsICh0ZW1wRG91YmxlID0gcmlnaHRzSW5oZXJpdGluZywgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEgPyB0ZW1wRG91YmxlID4gMCA/ICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCA6IH5+K01hdGguY2VpbCgodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCA6IDApIF0sIFxuIEhFQVAzMltwYnVmICsgMTYgPj4+IDJdID0gdGVtcEk2NFswXSwgSEVBUDMyW3BidWYgKyAyMCA+Pj4gMl0gPSB0ZW1wSTY0WzFdO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZmRfcHJlYWQoZmQsIGlvdiwgaW92Y250LCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgcG51bSkge1xuIGFib3J0KFwiZmRfcHJlYWQgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfZmRfcHdyaXRlKGZkLCBpb3YsIGlvdmNudCwgb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsIHBudW0pIHtcbiBhYm9ydChcImZkX3B3cml0ZSBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9mZF9yZWFkKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuIGFib3J0KFwiZmRfcmVhZCBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9mZF9zZWVrKGZkLCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgd2hlbmNlLCBuZXdPZmZzZXQpIHtcbiByZXR1cm4gNzA7XG59XG5cbmZ1bmN0aW9uIF9mZF9zeW5jKGZkKSB7XG4gYWJvcnQoXCJmZF9zeW5jIGNhbGxlZCB3aXRob3V0IFNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxudmFyIHByaW50Q2hhckJ1ZmZlcnMgPSBbIG51bGwsIFtdLCBbXSBdO1xuXG5mdW5jdGlvbiBwcmludENoYXIoc3RyZWFtLCBjdXJyKSB7XG4gdmFyIGJ1ZmZlciA9IHByaW50Q2hhckJ1ZmZlcnNbc3RyZWFtXTtcbiBhc3NlcnQoYnVmZmVyKTtcbiBpZiAoY3VyciA9PT0gMCB8fCBjdXJyID09PSAxMCkge1xuICAoc3RyZWFtID09PSAxID8gb3V0IDogZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsIDApKTtcbiAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gfSBlbHNlIHtcbiAgYnVmZmVyLnB1c2goY3Vycik7XG4gfVxufVxuXG5mdW5jdGlvbiBmbHVzaF9OT19GSUxFU1lTVEVNKCkge1xuIF9mZmx1c2goMCk7XG4gaWYgKHByaW50Q2hhckJ1ZmZlcnNbMV0ubGVuZ3RoKSBwcmludENoYXIoMSwgMTApO1xuIGlmIChwcmludENoYXJCdWZmZXJzWzJdLmxlbmd0aCkgcHJpbnRDaGFyKDIsIDEwKTtcbn1cblxuZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuIHZhciBudW0gPSAwO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+PiAyXTtcbiAgdmFyIGxlbiA9IEhFQVBVMzJbaW92ICsgNCA+Pj4gMl07XG4gIGlvdiArPSA4O1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICBwcmludENoYXIoZmQsIEhFQVBVOFtwdHIgKyBqID4+PiAwXSk7XG4gIH1cbiAgbnVtICs9IGxlbjtcbiB9XG4gSEVBUFUzMltwbnVtID4+PiAyXSA9IG51bTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2dldGFkZHJpbmZvKG5vZGUsIHNlcnZpY2UsIGhpbnQsIG91dCkge1xuIHZhciBhZGRycyA9IFtdO1xuIHZhciBjYW5vbiA9IG51bGw7XG4gdmFyIGFkZHIgPSAwO1xuIHZhciBwb3J0ID0gMDtcbiB2YXIgZmxhZ3MgPSAwO1xuIHZhciBmYW1pbHkgPSAwO1xuIHZhciB0eXBlID0gMDtcbiB2YXIgcHJvdG8gPSAwO1xuIHZhciBhaSwgbGFzdDtcbiBmdW5jdGlvbiBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIGNhbm9uLCBhZGRyLCBwb3J0KSB7XG4gIHZhciBzYSwgc2FsZW4sIGFpO1xuICB2YXIgZXJybm87XG4gIHNhbGVuID0gZmFtaWx5ID09PSAxMCA/IDI4IDogMTY7XG4gIGFkZHIgPSBmYW1pbHkgPT09IDEwID8gaW5ldE50b3A2KGFkZHIpIDogaW5ldE50b3A0KGFkZHIpO1xuICBzYSA9IF9tYWxsb2Moc2FsZW4pO1xuICBlcnJubyA9IHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCk7XG4gIGFzc2VydCghZXJybm8pO1xuICBhaSA9IF9tYWxsb2MoMzIpO1xuICBIRUFQMzJbYWkgKyA0ID4+PiAyXSA9IGZhbWlseTtcbiAgSEVBUDMyW2FpICsgOCA+Pj4gMl0gPSB0eXBlO1xuICBIRUFQMzJbYWkgKyAxMiA+Pj4gMl0gPSBwcm90bztcbiAgSEVBUFUzMlthaSArIDI0ID4+PiAyXSA9IGNhbm9uO1xuICBIRUFQVTMyW2FpICsgMjAgPj4+IDJdID0gc2E7XG4gIGlmIChmYW1pbHkgPT09IDEwKSB7XG4gICBIRUFQMzJbYWkgKyAxNiA+Pj4gMl0gPSAyODtcbiAgfSBlbHNlIHtcbiAgIEhFQVAzMlthaSArIDE2ID4+PiAyXSA9IDE2O1xuICB9XG4gIEhFQVAzMlthaSArIDI4ID4+PiAyXSA9IDA7XG4gIHJldHVybiBhaTtcbiB9XG4gaWYgKGhpbnQpIHtcbiAgZmxhZ3MgPSBIRUFQMzJbaGludCA+Pj4gMl07XG4gIGZhbWlseSA9IEhFQVAzMltoaW50ICsgNCA+Pj4gMl07XG4gIHR5cGUgPSBIRUFQMzJbaGludCArIDggPj4+IDJdO1xuICBwcm90byA9IEhFQVAzMltoaW50ICsgMTIgPj4+IDJdO1xuIH1cbiBpZiAodHlwZSAmJiAhcHJvdG8pIHtcbiAgcHJvdG8gPSB0eXBlID09PSAyID8gMTcgOiA2O1xuIH1cbiBpZiAoIXR5cGUgJiYgcHJvdG8pIHtcbiAgdHlwZSA9IHByb3RvID09PSAxNyA/IDIgOiAxO1xuIH1cbiBpZiAocHJvdG8gPT09IDApIHtcbiAgcHJvdG8gPSA2O1xuIH1cbiBpZiAodHlwZSA9PT0gMCkge1xuICB0eXBlID0gMTtcbiB9XG4gaWYgKCFub2RlICYmICFzZXJ2aWNlKSB7XG4gIHJldHVybiAtMjtcbiB9XG4gaWYgKGZsYWdzICYgfigxIHwgMiB8IDQgfCAxMDI0IHwgOCB8IDE2IHwgMzIpKSB7XG4gIHJldHVybiAtMTtcbiB9XG4gaWYgKGhpbnQgIT09IDAgJiYgSEVBUDMyW2hpbnQgPj4+IDJdICYgMiAmJiAhbm9kZSkge1xuICByZXR1cm4gLTE7XG4gfVxuIGlmIChmbGFncyAmIDMyKSB7XG4gIHJldHVybiAtMjtcbiB9XG4gaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSAmJiB0eXBlICE9PSAyKSB7XG4gIHJldHVybiAtNztcbiB9XG4gaWYgKGZhbWlseSAhPT0gMCAmJiBmYW1pbHkgIT09IDIgJiYgZmFtaWx5ICE9PSAxMCkge1xuICByZXR1cm4gLTY7XG4gfVxuIGlmIChzZXJ2aWNlKSB7XG4gIHNlcnZpY2UgPSBVVEY4VG9TdHJpbmcoc2VydmljZSk7XG4gIHBvcnQgPSBwYXJzZUludChzZXJ2aWNlLCAxMCk7XG4gIGlmIChpc05hTihwb3J0KSkge1xuICAgaWYgKGZsYWdzICYgMTAyNCkge1xuICAgIHJldHVybiAtMjtcbiAgIH1cbiAgIHJldHVybiAtODtcbiAgfVxuIH1cbiBpZiAoIW5vZGUpIHtcbiAgaWYgKGZhbWlseSA9PT0gMCkge1xuICAgZmFtaWx5ID0gMjtcbiAgfVxuICBpZiAoKGZsYWdzICYgMSkgPT09IDApIHtcbiAgIGlmIChmYW1pbHkgPT09IDIpIHtcbiAgICBhZGRyID0gX2h0b25sKDIxMzA3MDY0MzMpO1xuICAgfSBlbHNlIHtcbiAgICBhZGRyID0gWyAwLCAwLCAwLCAxIF07XG4gICB9XG4gIH1cbiAgYWkgPSBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIG51bGwsIGFkZHIsIHBvcnQpO1xuICBIRUFQVTMyW291dCA+Pj4gMl0gPSBhaTtcbiAgcmV0dXJuIDA7XG4gfVxuIG5vZGUgPSBVVEY4VG9TdHJpbmcobm9kZSk7XG4gYWRkciA9IGluZXRQdG9uNChub2RlKTtcbiBpZiAoYWRkciAhPT0gbnVsbCkge1xuICBpZiAoZmFtaWx5ID09PSAwIHx8IGZhbWlseSA9PT0gMikge1xuICAgZmFtaWx5ID0gMjtcbiAgfSBlbHNlIGlmIChmYW1pbHkgPT09IDEwICYmIGZsYWdzICYgOCkge1xuICAgYWRkciA9IFsgMCwgMCwgX2h0b25sKDY1NTM1KSwgYWRkciBdO1xuICAgZmFtaWx5ID0gMTA7XG4gIH0gZWxzZSB7XG4gICByZXR1cm4gLTI7XG4gIH1cbiB9IGVsc2Uge1xuICBhZGRyID0gaW5ldFB0b242KG5vZGUpO1xuICBpZiAoYWRkciAhPT0gbnVsbCkge1xuICAgaWYgKGZhbWlseSA9PT0gMCB8fCBmYW1pbHkgPT09IDEwKSB7XG4gICAgZmFtaWx5ID0gMTA7XG4gICB9IGVsc2Uge1xuICAgIHJldHVybiAtMjtcbiAgIH1cbiAgfVxuIH1cbiBpZiAoYWRkciAhPSBudWxsKSB7XG4gIGFpID0gYWxsb2NhZGRyaW5mbyhmYW1pbHksIHR5cGUsIHByb3RvLCBub2RlLCBhZGRyLCBwb3J0KTtcbiAgSEVBUFUzMltvdXQgPj4+IDJdID0gYWk7XG4gIHJldHVybiAwO1xuIH1cbiBpZiAoZmxhZ3MgJiA0KSB7XG4gIHJldHVybiAtMjtcbiB9XG4gbm9kZSA9IEROUy5sb29rdXBfbmFtZShub2RlKTtcbiBhZGRyID0gaW5ldFB0b240KG5vZGUpO1xuIGlmIChmYW1pbHkgPT09IDApIHtcbiAgZmFtaWx5ID0gMjtcbiB9IGVsc2UgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgYWRkciA9IFsgMCwgMCwgX2h0b25sKDY1NTM1KSwgYWRkciBdO1xuIH1cbiBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbnVsbCwgYWRkciwgcG9ydCk7XG4gSEVBUFUzMltvdXQgPj4+IDJdID0gYWk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluaXRSYW5kb21GaWxsKCkge1xuIGlmICh0eXBlb2YgY3J5cHRvID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNyeXB0b1tcImdldFJhbmRvbVZhbHVlc1wiXSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgcmV0dXJuIHZpZXcgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2aWV3KTtcbiB9IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcbiAgdHJ5IHtcbiAgIHZhciBjcnlwdG9fbW9kdWxlID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgIHZhciByYW5kb21GaWxsU3luYyA9IGNyeXB0b19tb2R1bGVbXCJyYW5kb21GaWxsU3luY1wiXTtcbiAgIGlmIChyYW5kb21GaWxsU3luYykge1xuICAgIHJldHVybiB2aWV3ID0+IGNyeXB0b19tb2R1bGVbXCJyYW5kb21GaWxsU3luY1wiXSh2aWV3KTtcbiAgIH1cbiAgIHZhciByYW5kb21CeXRlcyA9IGNyeXB0b19tb2R1bGVbXCJyYW5kb21CeXRlc1wiXTtcbiAgIHJldHVybiB2aWV3ID0+ICh2aWV3LnNldChyYW5kb21CeXRlcyh2aWV3LmJ5dGVMZW5ndGgpKSwgdmlldyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gfVxuIGFib3J0KFwibm8gY3J5cHRvZ3JhcGhpYyBzdXBwb3J0IGZvdW5kIGZvciByYW5kb21EZXZpY2UuIGNvbnNpZGVyIHBvbHlmaWxsaW5nIGl0IGlmIHlvdSB3YW50IHRvIHVzZSBzb21ldGhpbmcgaW5zZWN1cmUgbGlrZSBNYXRoLnJhbmRvbSgpLCBlLmcuIHB1dCB0aGlzIGluIGEgLS1wcmUtanM6IHZhciBjcnlwdG8gPSB7IGdldFJhbmRvbVZhbHVlczogZnVuY3Rpb24oYXJyYXkpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgYXJyYXlbaV0gPSAoTWF0aC5yYW5kb20oKSoyNTYpfDAgfSB9O1wiKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tRmlsbCh2aWV3KSB7XG4gcmV0dXJuIChyYW5kb21GaWxsID0gaW5pdFJhbmRvbUZpbGwoKSkodmlldyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRlbnRyb3B5KGJ1ZmZlciwgc2l6ZSkge1xuIHJhbmRvbUZpbGwoSEVBUFU4LnN1YmFycmF5KGJ1ZmZlciA+Pj4gMCwgYnVmZmVyICsgc2l6ZSA+Pj4gMCkpO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZ2V0bmFtZWluZm8oc2EsIHNhbGVuLCBub2RlLCBub2RlbGVuLCBzZXJ2LCBzZXJ2bGVuLCBmbGFncykge1xuIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKHNhLCBzYWxlbik7XG4gaWYgKGluZm8uZXJybm8pIHtcbiAgcmV0dXJuIC02O1xuIH1cbiB2YXIgcG9ydCA9IGluZm8ucG9ydDtcbiB2YXIgYWRkciA9IGluZm8uYWRkcjtcbiB2YXIgb3ZlcmZsb3dlZCA9IGZhbHNlO1xuIGlmIChub2RlICYmIG5vZGVsZW4pIHtcbiAgdmFyIGxvb2t1cDtcbiAgaWYgKGZsYWdzICYgMSB8fCAhKGxvb2t1cCA9IEROUy5sb29rdXBfYWRkcihhZGRyKSkpIHtcbiAgIGlmIChmbGFncyAmIDgpIHtcbiAgICByZXR1cm4gLTI7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBhZGRyID0gbG9va3VwO1xuICB9XG4gIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IHN0cmluZ1RvVVRGOChhZGRyLCBub2RlLCBub2RlbGVuKTtcbiAgaWYgKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsICsgMSA+PSBub2RlbGVuKSB7XG4gICBvdmVyZmxvd2VkID0gdHJ1ZTtcbiAgfVxuIH1cbiBpZiAoc2VydiAmJiBzZXJ2bGVuKSB7XG4gIHBvcnQgPSBcIlwiICsgcG9ydDtcbiAgdmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsID0gc3RyaW5nVG9VVEY4KHBvcnQsIHNlcnYsIHNlcnZsZW4pO1xuICBpZiAobnVtQnl0ZXNXcml0dGVuRXhjbE51bGwgKyAxID49IHNlcnZsZW4pIHtcbiAgIG92ZXJmbG93ZWQgPSB0cnVlO1xuICB9XG4gfVxuIGlmIChvdmVyZmxvd2VkKSB7XG4gIHJldHVybiAtMTI7XG4gfVxuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhcnJheVN1bShhcnJheSwgaW5kZXgpIHtcbiB2YXIgc3VtID0gMDtcbiBmb3IgKHZhciBpID0gMDsgaSA8PSBpbmRleDsgc3VtICs9IGFycmF5W2krK10pIHt9XG4gcmV0dXJuIHN1bTtcbn1cblxudmFyIE1PTlRIX0RBWVNfTEVBUCA9IFsgMzEsIDI5LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMSBdO1xuXG52YXIgTU9OVEhfREFZU19SRUdVTEFSID0gWyAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxIF07XG5cbmZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgZGF5cykge1xuIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuIHdoaWxlIChkYXlzID4gMCkge1xuICB2YXIgbGVhcCA9IGlzTGVhcFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgdmFyIGN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcbiAgdmFyIGRheXNJbkN1cnJlbnRNb250aCA9IChsZWFwID8gTU9OVEhfREFZU19MRUFQIDogTU9OVEhfREFZU19SRUdVTEFSKVtjdXJyZW50TW9udGhdO1xuICBpZiAoZGF5cyA+IGRheXNJbkN1cnJlbnRNb250aCAtIG5ld0RhdGUuZ2V0RGF0ZSgpKSB7XG4gICBkYXlzIC09IGRheXNJbkN1cnJlbnRNb250aCAtIG5ld0RhdGUuZ2V0RGF0ZSgpICsgMTtcbiAgIG5ld0RhdGUuc2V0RGF0ZSgxKTtcbiAgIGlmIChjdXJyZW50TW9udGggPCAxMSkge1xuICAgIG5ld0RhdGUuc2V0TW9udGgoY3VycmVudE1vbnRoICsgMSk7XG4gICB9IGVsc2Uge1xuICAgIG5ld0RhdGUuc2V0TW9udGgoMCk7XG4gICAgbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgIH1cbiAgfSBlbHNlIHtcbiAgIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGRheXMpO1xuICAgcmV0dXJuIG5ld0RhdGU7XG4gIH1cbiB9XG4gcmV0dXJuIG5ld0RhdGU7XG59XG5cbmZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XG4gdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkgKyAxO1xuIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gdmFyIG51bUJ5dGVzV3JpdHRlbiA9IHN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksIHU4YXJyYXksIDAsIHU4YXJyYXkubGVuZ3RoKTtcbiBpZiAoZG9udEFkZE51bGwpIHU4YXJyYXkubGVuZ3RoID0gbnVtQnl0ZXNXcml0dGVuO1xuIHJldHVybiB1OGFycmF5O1xufVxuXG5mdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksIGJ1ZmZlcikge1xuIGFzc2VydChhcnJheS5sZW5ndGggPj0gMCwgXCJ3cml0ZUFycmF5VG9NZW1vcnkgYXJyYXkgbXVzdCBoYXZlIGEgbGVuZ3RoIChzaG91bGQgYmUgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkpXCIpO1xuIEhFQVA4LnNldChhcnJheSwgYnVmZmVyID4+PiAwKTtcbn1cblxuZnVuY3Rpb24gX3N0cmZ0aW1lKHMsIG1heHNpemUsIGZvcm1hdCwgdG0pIHtcbiB2YXIgdG1fem9uZSA9IEhFQVAzMlt0bSArIDQwID4+PiAyXTtcbiB2YXIgZGF0ZSA9IHtcbiAgdG1fc2VjOiBIRUFQMzJbdG0gPj4+IDJdLFxuICB0bV9taW46IEhFQVAzMlt0bSArIDQgPj4+IDJdLFxuICB0bV9ob3VyOiBIRUFQMzJbdG0gKyA4ID4+PiAyXSxcbiAgdG1fbWRheTogSEVBUDMyW3RtICsgMTIgPj4+IDJdLFxuICB0bV9tb246IEhFQVAzMlt0bSArIDE2ID4+PiAyXSxcbiAgdG1feWVhcjogSEVBUDMyW3RtICsgMjAgPj4+IDJdLFxuICB0bV93ZGF5OiBIRUFQMzJbdG0gKyAyNCA+Pj4gMl0sXG4gIHRtX3lkYXk6IEhFQVAzMlt0bSArIDI4ID4+PiAyXSxcbiAgdG1faXNkc3Q6IEhFQVAzMlt0bSArIDMyID4+PiAyXSxcbiAgdG1fZ210b2ZmOiBIRUFQMzJbdG0gKyAzNiA+Pj4gMl0sXG4gIHRtX3pvbmU6IHRtX3pvbmUgPyBVVEY4VG9TdHJpbmcodG1fem9uZSkgOiBcIlwiXG4gfTtcbiB2YXIgcGF0dGVybiA9IFVURjhUb1N0cmluZyhmb3JtYXQpO1xuIHZhciBFWFBBTlNJT05fUlVMRVNfMSA9IHtcbiAgXCIlY1wiOiBcIiVhICViICVkICVIOiVNOiVTICVZXCIsXG4gIFwiJURcIjogXCIlbS8lZC8leVwiLFxuICBcIiVGXCI6IFwiJVktJW0tJWRcIixcbiAgXCIlaFwiOiBcIiViXCIsXG4gIFwiJXJcIjogXCIlSTolTTolUyAlcFwiLFxuICBcIiVSXCI6IFwiJUg6JU1cIixcbiAgXCIlVFwiOiBcIiVIOiVNOiVTXCIsXG4gIFwiJXhcIjogXCIlbS8lZC8leVwiLFxuICBcIiVYXCI6IFwiJUg6JU06JVNcIixcbiAgXCIlRWNcIjogXCIlY1wiLFxuICBcIiVFQ1wiOiBcIiVDXCIsXG4gIFwiJUV4XCI6IFwiJW0vJWQvJXlcIixcbiAgXCIlRVhcIjogXCIlSDolTTolU1wiLFxuICBcIiVFeVwiOiBcIiV5XCIsXG4gIFwiJUVZXCI6IFwiJVlcIixcbiAgXCIlT2RcIjogXCIlZFwiLFxuICBcIiVPZVwiOiBcIiVlXCIsXG4gIFwiJU9IXCI6IFwiJUhcIixcbiAgXCIlT0lcIjogXCIlSVwiLFxuICBcIiVPbVwiOiBcIiVtXCIsXG4gIFwiJU9NXCI6IFwiJU1cIixcbiAgXCIlT1NcIjogXCIlU1wiLFxuICBcIiVPdVwiOiBcIiV1XCIsXG4gIFwiJU9VXCI6IFwiJVVcIixcbiAgXCIlT1ZcIjogXCIlVlwiLFxuICBcIiVPd1wiOiBcIiV3XCIsXG4gIFwiJU9XXCI6IFwiJVdcIixcbiAgXCIlT3lcIjogXCIleVwiXG4gfTtcbiBmb3IgKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18xKSB7XG4gIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLCBcImdcIiksIEVYUEFOU0lPTl9SVUxFU18xW3J1bGVdKTtcbiB9XG4gdmFyIFdFRUtEQVlTID0gWyBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIgXTtcbiB2YXIgTU9OVEhTID0gWyBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIgXTtcbiBmdW5jdGlvbiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLCBkaWdpdHMsIGNoYXJhY3Rlcikge1xuICB2YXIgc3RyID0gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgfHwgXCJcIjtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCBkaWdpdHMpIHtcbiAgIHN0ciA9IGNoYXJhY3RlclswXSArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xuIH1cbiBmdW5jdGlvbiBsZWFkaW5nTnVsbHModmFsdWUsIGRpZ2l0cykge1xuICByZXR1cm4gbGVhZGluZ1NvbWV0aGluZyh2YWx1ZSwgZGlnaXRzLCBcIjBcIik7XG4gfVxuIGZ1bmN0aW9uIGNvbXBhcmVCeURheShkYXRlMSwgZGF0ZTIpIHtcbiAgZnVuY3Rpb24gc2duKHZhbHVlKSB7XG4gICByZXR1cm4gdmFsdWUgPCAwID8gLTEgOiB2YWx1ZSA+IDAgPyAxIDogMDtcbiAgfVxuICB2YXIgY29tcGFyZTtcbiAgaWYgKChjb21wYXJlID0gc2duKGRhdGUxLmdldEZ1bGxZZWFyKCkgLSBkYXRlMi5nZXRGdWxsWWVhcigpKSkgPT09IDApIHtcbiAgIGlmICgoY29tcGFyZSA9IHNnbihkYXRlMS5nZXRNb250aCgpIC0gZGF0ZTIuZ2V0TW9udGgoKSkpID09PSAwKSB7XG4gICAgY29tcGFyZSA9IHNnbihkYXRlMS5nZXREYXRlKCkgLSBkYXRlMi5nZXREYXRlKCkpO1xuICAgfVxuICB9XG4gIHJldHVybiBjb21wYXJlO1xuIH1cbiBmdW5jdGlvbiBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoKSB7XG4gIHN3aXRjaCAoamFuRm91cnRoLmdldERheSgpKSB7XG4gIGNhc2UgMDpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAyOSk7XG5cbiAgY2FzZSAxOlxuICAgcmV0dXJuIGphbkZvdXJ0aDtcblxuICBjYXNlIDI6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksIDAsIDMpO1xuXG4gIGNhc2UgMzpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwgMCwgMik7XG5cbiAgY2FzZSA0OlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcblxuICBjYXNlIDU6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCkgLSAxLCAxMSwgMzEpO1xuXG4gIGNhc2UgNjpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAzMCk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKSB7XG4gIHZhciB0aGlzRGF0ZSA9IGFkZERheXMobmV3IERhdGUoZGF0ZS50bV95ZWFyICsgMTkwMCwgMCwgMSksIGRhdGUudG1feWRheSk7XG4gIHZhciBqYW5Gb3VydGhUaGlzWWVhciA9IG5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuICB2YXIgamFuRm91cnRoTmV4dFllYXIgPSBuZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpICsgMSwgMCwgNCk7XG4gIHZhciBmaXJzdFdlZWtTdGFydFRoaXNZZWFyID0gZ2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aFRoaXNZZWFyKTtcbiAgdmFyIGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIgPSBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoTmV4dFllYXIpO1xuICBpZiAoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIsIHRoaXNEYXRlKSA8PSAwKSB7XG4gICBpZiAoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIsIHRoaXNEYXRlKSA8PSAwKSB7XG4gICAgcmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkgKyAxO1xuICAgfVxuICAgcmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkgLSAxO1xuIH1cbiB2YXIgRVhQQU5TSU9OX1JVTEVTXzIgPSB7XG4gIFwiJWFcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV0uc3Vic3RyaW5nKDAsIDMpO1xuICB9LFxuICBcIiVBXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldO1xuICB9LFxuICBcIiViXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBNT05USFNbZGF0ZS50bV9tb25dLnN1YnN0cmluZygwLCAzKTtcbiAgfSxcbiAgXCIlQlwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXTtcbiAgfSxcbiAgXCIlQ1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgeWVhciA9IGRhdGUudG1feWVhciArIDE5MDA7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKHllYXIgLyAxMDAgfCAwLCAyKTtcbiAgfSxcbiAgXCIlZFwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheSwgMik7XG4gIH0sXG4gIFwiJWVcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdTb21ldGhpbmcoZGF0ZS50bV9tZGF5LCAyLCBcIiBcIik7XG4gIH0sXG4gIFwiJWdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMik7XG4gIH0sXG4gIFwiJUdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSk7XG4gIH0sXG4gIFwiJUhcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX2hvdXIsIDIpO1xuICB9LFxuICBcIiVJXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciB0d2VsdmVIb3VyID0gZGF0ZS50bV9ob3VyO1xuICAgaWYgKHR3ZWx2ZUhvdXIgPT0gMCkgdHdlbHZlSG91ciA9IDEyOyBlbHNlIGlmICh0d2VsdmVIb3VyID4gMTIpIHR3ZWx2ZUhvdXIgLT0gMTI7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKHR3ZWx2ZUhvdXIsIDIpO1xuICB9LFxuICBcIiVqXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5ICsgYXJyYXlTdW0oaXNMZWFwWWVhcihkYXRlLnRtX3llYXIgKyAxOTAwKSA/IE1PTlRIX0RBWVNfTEVBUCA6IE1PTlRIX0RBWVNfUkVHVUxBUiwgZGF0ZS50bV9tb24gLSAxKSwgMyk7XG4gIH0sXG4gIFwiJW1cIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21vbiArIDEsIDIpO1xuICB9LFxuICBcIiVNXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9taW4sIDIpO1xuICB9LFxuICBcIiVuXCI6IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIFwiXFxuXCI7XG4gIH0sXG4gIFwiJXBcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgaWYgKGRhdGUudG1faG91ciA+PSAwICYmIGRhdGUudG1faG91ciA8IDEyKSB7XG4gICAgcmV0dXJuIFwiQU1cIjtcbiAgIH1cbiAgIHJldHVybiBcIlBNXCI7XG4gIH0sXG4gIFwiJVNcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX3NlYywgMik7XG4gIH0sXG4gIFwiJXRcIjogZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gXCJcXHRcIjtcbiAgfSxcbiAgXCIldVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV93ZGF5IHx8IDc7XG4gIH0sXG4gIFwiJVVcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIGRheXMgPSBkYXRlLnRtX3lkYXkgKyA3IC0gZGF0ZS50bV93ZGF5O1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMgLyA3KSwgMik7XG4gIH0sXG4gIFwiJVZcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIHZhbCA9IE1hdGguZmxvb3IoKGRhdGUudG1feWRheSArIDcgLSAoZGF0ZS50bV93ZGF5ICsgNikgJSA3KSAvIDcpO1xuICAgaWYgKChkYXRlLnRtX3dkYXkgKyAzNzEgLSBkYXRlLnRtX3lkYXkgLSAyKSAlIDcgPD0gMikge1xuICAgIHZhbCsrO1xuICAgfVxuICAgaWYgKCF2YWwpIHtcbiAgICB2YWwgPSA1MjtcbiAgICB2YXIgZGVjMzEgPSAoZGF0ZS50bV93ZGF5ICsgNyAtIGRhdGUudG1feWRheSAtIDEpICUgNztcbiAgICBpZiAoZGVjMzEgPT0gNCB8fCBkZWMzMSA9PSA1ICYmIGlzTGVhcFllYXIoZGF0ZS50bV95ZWFyICUgNDAwIC0gMSkpIHtcbiAgICAgdmFsKys7XG4gICAgfVxuICAgfSBlbHNlIGlmICh2YWwgPT0gNTMpIHtcbiAgICB2YXIgamFuMSA9IChkYXRlLnRtX3dkYXkgKyAzNzEgLSBkYXRlLnRtX3lkYXkpICUgNztcbiAgICBpZiAoamFuMSAhPSA0ICYmIChqYW4xICE9IDMgfHwgIWlzTGVhcFllYXIoZGF0ZS50bV95ZWFyKSkpIHZhbCA9IDE7XG4gICB9XG4gICByZXR1cm4gbGVhZGluZ051bGxzKHZhbCwgMik7XG4gIH0sXG4gIFwiJXdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGRhdGUudG1fd2RheTtcbiAgfSxcbiAgXCIlV1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgZGF5cyA9IGRhdGUudG1feWRheSArIDcgLSAoZGF0ZS50bV93ZGF5ICsgNikgJSA3O1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMgLyA3KSwgMik7XG4gIH0sXG4gIFwiJXlcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIChkYXRlLnRtX3llYXIgKyAxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKTtcbiAgfSxcbiAgXCIlWVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV95ZWFyICsgMTkwMDtcbiAgfSxcbiAgXCIlelwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgb2ZmID0gZGF0ZS50bV9nbXRvZmY7XG4gICB2YXIgYWhlYWQgPSBvZmYgPj0gMDtcbiAgIG9mZiA9IE1hdGguYWJzKG9mZikgLyA2MDtcbiAgIG9mZiA9IG9mZiAvIDYwICogMTAwICsgb2ZmICUgNjA7XG4gICByZXR1cm4gKGFoZWFkID8gXCIrXCIgOiBcIi1cIikgKyBTdHJpbmcoXCIwMDAwXCIgKyBvZmYpLnNsaWNlKC00KTtcbiAgfSxcbiAgXCIlWlwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV96b25lO1xuICB9LFxuICBcIiUlXCI6IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIFwiJVwiO1xuICB9XG4gfTtcbiBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC8lJS9nLCBcIlxcMFxcMFwiKTtcbiBmb3IgKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18yKSB7XG4gIGlmIChwYXR0ZXJuLmluY2x1ZGVzKHJ1bGUpKSB7XG4gICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSwgXCJnXCIpLCBFWFBBTlNJT05fUlVMRVNfMltydWxlXShkYXRlKSk7XG4gIH1cbiB9XG4gcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwwXFwwL2csIFwiJVwiKTtcbiB2YXIgYnl0ZXMgPSBpbnRBcnJheUZyb21TdHJpbmcocGF0dGVybiwgZmFsc2UpO1xuIGlmIChieXRlcy5sZW5ndGggPiBtYXhzaXplKSB7XG4gIHJldHVybiAwO1xuIH1cbiB3cml0ZUFycmF5VG9NZW1vcnkoYnl0ZXMsIHMpO1xuIHJldHVybiBieXRlcy5sZW5ndGggLSAxO1xufVxuXG5mdW5jdGlvbiBfc3RyZnRpbWVfbChzLCBtYXhzaXplLCBmb3JtYXQsIHRtLCBsb2MpIHtcbiByZXR1cm4gX3N0cmZ0aW1lKHMsIG1heHNpemUsIGZvcm1hdCwgdG0pO1xufVxuXG5mdW5jdGlvbiBfdWNudl9jbG9zZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X2Nsb3NlXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VjbnZfY29udmVydEV4XzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfY29udmVydEV4XzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VjbnZfb3Blbl82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X29wZW5fNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNudl90b0FsZ29yaXRobWljXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfdG9BbGdvcml0aG1pY182NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfY2xvc2VfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2Nsb3NlXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9kZXRlY3RfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2RldGVjdF82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfZ2V0TmFtZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZ2V0TmFtZV82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfb3Blbl82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfb3Blbl82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfc2V0VGV4dF82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfc2V0VGV4dF82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpDbG9zZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpDbG9zZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpDbG9zZUN1cnJlbnRGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekNsb3NlQ3VycmVudEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R2V0Q3VycmVudEZpbGVJbmZvKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdldEN1cnJlbnRGaWxlSW5mb1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHZXRDdXJyZW50RmlsZUluZm82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHZXRDdXJyZW50RmlsZUluZm82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHZXRHbG9iYWxJbmZvKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdldEdsb2JhbEluZm9cIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R29Ub0ZpcnN0RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHb1RvRmlyc3RGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekdvVG9OZXh0RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHb1RvTmV4dEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56TG9jYXRlRmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpMb2NhdGVGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vuek9wZW4oKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlblwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpPcGVuMigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuMlwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpPcGVuQ3VycmVudEZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlbkN1cnJlbnRGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuelJlYWRDdXJyZW50RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpSZWFkQ3VycmVudEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfcHJvY19leGl0KGNvZGUpIHtcbiBFWElUU1RBVFVTID0gY29kZTtcbiBpZiAoIWtlZXBSdW50aW1lQWxpdmUoKSkge1xuICBpZiAoTW9kdWxlW1wib25FeGl0XCJdKSBNb2R1bGVbXCJvbkV4aXRcIl0oY29kZSk7XG4gIEFCT1JUID0gdHJ1ZTtcbiB9XG4gcXVpdF8oY29kZSwgbmV3IEV4aXRTdGF0dXMoY29kZSkpO1xufVxuXG5mdW5jdGlvbiBleGl0SlMoc3RhdHVzLCBpbXBsaWNpdCkge1xuIEVYSVRTVEFUVVMgPSBzdGF0dXM7XG4gY2hlY2tVbmZsdXNoZWRDb250ZW50KCk7XG4gaWYgKGtlZXBSdW50aW1lQWxpdmUoKSAmJiAhaW1wbGljaXQpIHtcbiAgdmFyIG1zZyA9IGBwcm9ncmFtIGV4aXRlZCAod2l0aCBzdGF0dXM6ICR7c3RhdHVzfSksIGJ1dCBrZWVwUnVudGltZUFsaXZlKCkgaXMgc2V0IChjb3VudGVyPSR7cnVudGltZUtlZXBhbGl2ZUNvdW50ZXJ9KSBkdWUgdG8gYW4gYXN5bmMgb3BlcmF0aW9uLCBzbyBoYWx0aW5nIGV4ZWN1dGlvbiBidXQgbm90IGV4aXRpbmcgdGhlIHJ1bnRpbWUgb3IgcHJldmVudGluZyBmdXJ0aGVyIGFzeW5jIGV4ZWN1dGlvbiAoeW91IGNhbiB1c2UgZW1zY3JpcHRlbl9mb3JjZV9leGl0LCBpZiB5b3Ugd2FudCB0byBmb3JjZSBhIHRydWUgc2h1dGRvd24pYDtcbiAgcmVhZHlQcm9taXNlUmVqZWN0KG1zZyk7XG4gIGVycihtc2cpO1xuIH1cbiBfcHJvY19leGl0KHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV4Y2VwdGlvbihlKSB7XG4gaWYgKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzIHx8IGUgPT0gXCJ1bndpbmRcIikge1xuICByZXR1cm4gRVhJVFNUQVRVUztcbiB9XG4gY2hlY2tTdGFja0Nvb2tpZSgpO1xuIGlmIChlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKSB7XG4gIGlmIChfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCgpIDw9IDApIHtcbiAgIGVycihcIlN0YWNrIG92ZXJmbG93IGRldGVjdGVkLiAgWW91IGNhbiB0cnkgaW5jcmVhc2luZyAtc1NUQUNLX1NJWkUgKGN1cnJlbnRseSBzZXQgdG8gNjU1MzYpXCIpO1xuICB9XG4gfVxuIHF1aXRfKDEsIGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDRnVuYyhpZGVudCkge1xuIHZhciBmdW5jID0gTW9kdWxlW1wiX1wiICsgaWRlbnRdO1xuIGFzc2VydChmdW5jLCBcIkNhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gXCIgKyBpZGVudCArIFwiLCBtYWtlIHN1cmUgaXQgaXMgZXhwb3J0ZWRcIik7XG4gcmV0dXJuIGZ1bmM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKSB7XG4gdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gdmFyIHJldCA9IHN0YWNrQWxsb2Moc2l6ZSk7XG4gc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBzaXplKTtcbiByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjY2FsbChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpIHtcbiB2YXIgdG9DID0ge1xuICBcInN0cmluZ1wiOiBzdHIgPT4ge1xuICAgdmFyIHJldCA9IDA7XG4gICBpZiAoc3RyICE9PSBudWxsICYmIHN0ciAhPT0gdW5kZWZpbmVkICYmIHN0ciAhPT0gMCkge1xuICAgIHJldCA9IHN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKTtcbiAgIH1cbiAgIHJldHVybiByZXQ7XG4gIH0sXG4gIFwiYXJyYXlcIjogYXJyID0+IHtcbiAgIHZhciByZXQgPSBzdGFja0FsbG9jKGFyci5sZW5ndGgpO1xuICAgd3JpdGVBcnJheVRvTWVtb3J5KGFyciwgcmV0KTtcbiAgIHJldHVybiByZXQ7XG4gIH1cbiB9O1xuIGZ1bmN0aW9uIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpIHtcbiAgaWYgKHJldHVyblR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgIHJldHVybiBVVEY4VG9TdHJpbmcocmV0KTtcbiAgfVxuICBpZiAocmV0dXJuVHlwZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiBCb29sZWFuKHJldCk7XG4gIHJldHVybiByZXQ7XG4gfVxuIHZhciBmdW5jID0gZ2V0Q0Z1bmMoaWRlbnQpO1xuIHZhciBjQXJncyA9IFtdO1xuIHZhciBzdGFjayA9IDA7XG4gYXNzZXJ0KHJldHVyblR5cGUgIT09IFwiYXJyYXlcIiwgJ1JldHVybiB0eXBlIHNob3VsZCBub3QgYmUgXCJhcnJheVwiLicpO1xuIGlmIChhcmdzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgdmFyIGNvbnZlcnRlciA9IHRvQ1thcmdUeXBlc1tpXV07XG4gICBpZiAoY29udmVydGVyKSB7XG4gICAgaWYgKHN0YWNrID09PSAwKSBzdGFjayA9IHN0YWNrU2F2ZSgpO1xuICAgIGNBcmdzW2ldID0gY29udmVydGVyKGFyZ3NbaV0pO1xuICAgfSBlbHNlIHtcbiAgICBjQXJnc1tpXSA9IGFyZ3NbaV07XG4gICB9XG4gIH1cbiB9XG4gdmFyIHJldCA9IGZ1bmMuYXBwbHkobnVsbCwgY0FyZ3MpO1xuIGZ1bmN0aW9uIG9uRG9uZShyZXQpIHtcbiAgaWYgKHN0YWNrICE9PSAwKSBzdGFja1Jlc3RvcmUoc3RhY2spO1xuICByZXR1cm4gY29udmVydFJldHVyblZhbHVlKHJldCk7XG4gfVxuIHJldCA9IG9uRG9uZShyZXQpO1xuIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5jb21pbmdNb2R1bGVBUEkoKSB7XG4gaWdub3JlZE1vZHVsZVByb3AoXCJmZXRjaFNldHRpbmdzXCIpO1xufVxuXG52YXIgd2FzbUltcG9ydHMgPSB7XG4gXCJYTUxfR2V0QnVmZmVyXCI6IF9YTUxfR2V0QnVmZmVyLFxuIFwiWE1MX0dldEVycm9yQ29kZVwiOiBfWE1MX0dldEVycm9yQ29kZSxcbiBcIlhNTF9QYXJzZVwiOiBfWE1MX1BhcnNlLFxuIFwiWE1MX1BhcnNlQnVmZmVyXCI6IF9YTUxfUGFyc2VCdWZmZXIsXG4gXCJYTUxfUGFyc2VyQ3JlYXRlXCI6IF9YTUxfUGFyc2VyQ3JlYXRlLFxuIFwiWE1MX1BhcnNlckZyZWVcIjogX1hNTF9QYXJzZXJGcmVlLFxuIFwiWE1MX1Jlc3VtZVBhcnNlclwiOiBfWE1MX1Jlc3VtZVBhcnNlcixcbiBcIlhNTF9TZXRDaGFyYWN0ZXJEYXRhSGFuZGxlclwiOiBfWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyLFxuIFwiWE1MX1NldEVsZW1lbnRIYW5kbGVyXCI6IF9YTUxfU2V0RWxlbWVudEhhbmRsZXIsXG4gXCJYTUxfU2V0VXNlckRhdGFcIjogX1hNTF9TZXRVc2VyRGF0YSxcbiBcIlhNTF9TdG9wUGFyc2VyXCI6IF9YTUxfU3RvcFBhcnNlcixcbiBcIl9fY3hhX3Rocm93XCI6IF9fX2N4YV90aHJvdyxcbiBcIl9fZGxzeW1cIjogX19fZGxzeW0sXG4gXCJfX3N5c2NhbGxfX25ld3NlbGVjdFwiOiBfX19zeXNjYWxsX19uZXdzZWxlY3QsXG4gXCJfX3N5c2NhbGxfYmluZFwiOiBfX19zeXNjYWxsX2JpbmQsXG4gXCJfX3N5c2NhbGxfY29ubmVjdFwiOiBfX19zeXNjYWxsX2Nvbm5lY3QsXG4gXCJfX3N5c2NhbGxfZmFjY2Vzc2F0XCI6IF9fX3N5c2NhbGxfZmFjY2Vzc2F0LFxuIFwiX19zeXNjYWxsX2ZjbnRsNjRcIjogX19fc3lzY2FsbF9mY250bDY0LFxuIFwiX19zeXNjYWxsX2ZzdGF0NjRcIjogX19fc3lzY2FsbF9mc3RhdDY0LFxuIFwiX19zeXNjYWxsX2Z0cnVuY2F0ZTY0XCI6IF9fX3N5c2NhbGxfZnRydW5jYXRlNjQsXG4gXCJfX3N5c2NhbGxfZ2V0ZGVudHM2NFwiOiBfX19zeXNjYWxsX2dldGRlbnRzNjQsXG4gXCJfX3N5c2NhbGxfZ2V0cGVlcm5hbWVcIjogX19fc3lzY2FsbF9nZXRwZWVybmFtZSxcbiBcIl9fc3lzY2FsbF9nZXRzb2Nrb3B0XCI6IF9fX3N5c2NhbGxfZ2V0c29ja29wdCxcbiBcIl9fc3lzY2FsbF9pb2N0bFwiOiBfX19zeXNjYWxsX2lvY3RsLFxuIFwiX19zeXNjYWxsX2xzdGF0NjRcIjogX19fc3lzY2FsbF9sc3RhdDY0LFxuIFwiX19zeXNjYWxsX21rZGlyYXRcIjogX19fc3lzY2FsbF9ta2RpcmF0LFxuIFwiX19zeXNjYWxsX25ld2ZzdGF0YXRcIjogX19fc3lzY2FsbF9uZXdmc3RhdGF0LFxuIFwiX19zeXNjYWxsX29wZW5hdFwiOiBfX19zeXNjYWxsX29wZW5hdCxcbiBcIl9fc3lzY2FsbF9yZWN2ZnJvbVwiOiBfX19zeXNjYWxsX3JlY3Zmcm9tLFxuIFwiX19zeXNjYWxsX3JlbmFtZWF0XCI6IF9fX3N5c2NhbGxfcmVuYW1lYXQsXG4gXCJfX3N5c2NhbGxfcm1kaXJcIjogX19fc3lzY2FsbF9ybWRpcixcbiBcIl9fc3lzY2FsbF9zZW5kdG9cIjogX19fc3lzY2FsbF9zZW5kdG8sXG4gXCJfX3N5c2NhbGxfc29ja2V0XCI6IF9fX3N5c2NhbGxfc29ja2V0LFxuIFwiX19zeXNjYWxsX3N0YXQ2NFwiOiBfX19zeXNjYWxsX3N0YXQ2NCxcbiBcIl9fc3lzY2FsbF91bmxpbmthdFwiOiBfX19zeXNjYWxsX3VubGlua2F0LFxuIFwiX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWNcIjogX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFxuIFwiX2xvY2FsdGltZV9qc1wiOiBfX2xvY2FsdGltZV9qcyxcbiBcIl90enNldF9qc1wiOiBfX3R6c2V0X2pzLFxuIFwiYWJvcnRcIjogX2Fib3J0LFxuIFwiZGxvcGVuXCI6IF9kbG9wZW4sXG4gXCJkdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGVcIjogX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2NyZWF0ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0c1wiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfZXhpc3RzLFxuIFwiZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlc1wiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlcyxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X3JlbW92ZVwiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfcmVtb3ZlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2Nsb3NlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfY2xvc2UsXG4gXCJkdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2dldF9sYXN0X21vZGlmaWVkX3RpbWVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9nZXRfbGFzdF9tb2RpZmllZF90aW1lLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX21vdmVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX29wZW5cIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9vcGVuLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3JlYWRcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfdHJ1bmNhdGUsXG4gXCJkdWNrZGJfd2ViX2ZzX2ZpbGVfd3JpdGVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZ2V0X2RlZmF1bHRfZGF0YV9wcm90b2NvbFwiOiBfZHVja2RiX3dlYl9mc19nZXRfZGVmYXVsdF9kYXRhX3Byb3RvY29sLFxuIFwiZHVja2RiX3dlYl9mc19nbG9iXCI6IF9kdWNrZGJfd2ViX2ZzX2dsb2IsXG4gXCJkdWNrZGJfd2ViX3Rlc3RfcGxhdGZvcm1fZmVhdHVyZVwiOiBfZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmUsXG4gXCJkdWNrZGJfd2ViX3VkZl9zY2FsYXJfY2FsbFwiOiBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGwsXG4gXCJlbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3JcIjogX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcixcbiBcImVtc2NyaXB0ZW5fZGF0ZV9ub3dcIjogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gXCJlbXNjcmlwdGVuX2dldF9oZWFwX21heFwiOiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gXCJlbXNjcmlwdGVuX2dldF9ub3dcIjogX2Vtc2NyaXB0ZW5fZ2V0X25vdyxcbiBcImVtc2NyaXB0ZW5fbWVtY3B5X2JpZ1wiOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFxuIFwiZW1zY3JpcHRlbl9yZXNpemVfaGVhcFwiOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiBcImVudmlyb25fZ2V0XCI6IF9lbnZpcm9uX2dldCxcbiBcImVudmlyb25fc2l6ZXNfZ2V0XCI6IF9lbnZpcm9uX3NpemVzX2dldCxcbiBcImZkX2Nsb3NlXCI6IF9mZF9jbG9zZSxcbiBcImZkX2Zkc3RhdF9nZXRcIjogX2ZkX2Zkc3RhdF9nZXQsXG4gXCJmZF9wcmVhZFwiOiBfZmRfcHJlYWQsXG4gXCJmZF9wd3JpdGVcIjogX2ZkX3B3cml0ZSxcbiBcImZkX3JlYWRcIjogX2ZkX3JlYWQsXG4gXCJmZF9zZWVrXCI6IF9mZF9zZWVrLFxuIFwiZmRfc3luY1wiOiBfZmRfc3luYyxcbiBcImZkX3dyaXRlXCI6IF9mZF93cml0ZSxcbiBcImdldGFkZHJpbmZvXCI6IF9nZXRhZGRyaW5mbyxcbiBcImdldGVudHJvcHlcIjogX2dldGVudHJvcHksXG4gXCJnZXRuYW1laW5mb1wiOiBfZ2V0bmFtZWluZm8sXG4gXCJzdHJmdGltZV9sXCI6IF9zdHJmdGltZV9sLFxuIFwidWNudl9jbG9zZV82NFwiOiBfdWNudl9jbG9zZV82NCxcbiBcInVjbnZfY29udmVydEV4XzY0XCI6IF91Y252X2NvbnZlcnRFeF82NCxcbiBcInVjbnZfb3Blbl82NFwiOiBfdWNudl9vcGVuXzY0LFxuIFwidWNudl90b0FsZ29yaXRobWljXzY0XCI6IF91Y252X3RvQWxnb3JpdGhtaWNfNjQsXG4gXCJ1Y3NkZXRfY2xvc2VfNjRcIjogX3Vjc2RldF9jbG9zZV82NCxcbiBcInVjc2RldF9kZXRlY3RfNjRcIjogX3Vjc2RldF9kZXRlY3RfNjQsXG4gXCJ1Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NFwiOiBfdWNzZGV0X2dldENvbmZpZGVuY2VfNjQsXG4gXCJ1Y3NkZXRfZ2V0TmFtZV82NFwiOiBfdWNzZGV0X2dldE5hbWVfNjQsXG4gXCJ1Y3NkZXRfb3Blbl82NFwiOiBfdWNzZGV0X29wZW5fNjQsXG4gXCJ1Y3NkZXRfc2V0VGV4dF82NFwiOiBfdWNzZGV0X3NldFRleHRfNjQsXG4gXCJ1bnpDbG9zZVwiOiBfdW56Q2xvc2UsXG4gXCJ1bnpDbG9zZUN1cnJlbnRGaWxlXCI6IF91bnpDbG9zZUN1cnJlbnRGaWxlLFxuIFwidW56R2V0Q3VycmVudEZpbGVJbmZvXCI6IF91bnpHZXRDdXJyZW50RmlsZUluZm8sXG4gXCJ1bnpHZXRDdXJyZW50RmlsZUluZm82NFwiOiBfdW56R2V0Q3VycmVudEZpbGVJbmZvNjQsXG4gXCJ1bnpHZXRHbG9iYWxJbmZvXCI6IF91bnpHZXRHbG9iYWxJbmZvLFxuIFwidW56R29Ub0ZpcnN0RmlsZVwiOiBfdW56R29Ub0ZpcnN0RmlsZSxcbiBcInVuekdvVG9OZXh0RmlsZVwiOiBfdW56R29Ub05leHRGaWxlLFxuIFwidW56TG9jYXRlRmlsZVwiOiBfdW56TG9jYXRlRmlsZSxcbiBcInVuek9wZW5cIjogX3Vuek9wZW4sXG4gXCJ1bnpPcGVuMlwiOiBfdW56T3BlbjIsXG4gXCJ1bnpPcGVuQ3VycmVudEZpbGVcIjogX3Vuek9wZW5DdXJyZW50RmlsZSxcbiBcInVuelJlYWRDdXJyZW50RmlsZVwiOiBfdW56UmVhZEN1cnJlbnRGaWxlXG59O1xuXG52YXIgYXNtID0gY3JlYXRlV2FzbSgpO1xuXG52YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fd2FzbV9jYWxsX2N0b3JzXCIpO1xuXG52YXIgX21haW4gPSBNb2R1bGVbXCJfbWFpblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtYWluXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2UgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NsZWFyX3Jlc3BvbnNlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmFpbF93aXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmFpbF93aXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZmFpbF93aXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcmVzZXQgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3Jlc2V0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29ubmVjdCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2Nvbm5lY3RcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb25uZWN0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZGlzY29ubmVjdCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3RcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9kaXNjb25uZWN0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mbHVzaF9maWxlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfb3BlbiA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX29wZW5cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9vcGVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X2dsb2JhbF9maWxlX2luZm8gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mb1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9leHBvcnRfZmlsZV9zdGF0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlcyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV91cmwgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXIgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX2J1ZmZlclwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlciA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X3ZlcnNpb24gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF92ZXJzaW9uXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3MgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfZmVhdHVyZV9mbGFnc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF9mZWF0dXJlX2ZsYWdzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfdG9rZW5pemUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl90b2tlbml6ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3Rva2VuaXplXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3VkZl9zY2FsYXJfY3JlYXRlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2UgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3ByZXBhcmVkX2Nsb3NlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcXVlcnlfcnVuID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfcnVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcXVlcnlfcnVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWwgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X2NhbmNlbFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0cyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X3RhYmxlbmFtZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdGFibGVuYW1lc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW1cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2Nzdl9mcm9tX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2luc2VydF9jc3ZfZnJvbV9wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCIpO1xuXG52YXIgX19fZXJybm9fbG9jYXRpb24gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19lcnJub19sb2NhdGlvblwiKTtcblxudmFyIF9mZmx1c2ggPSBNb2R1bGVbXCJfZmZsdXNoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZmbHVzaFwiKTtcblxudmFyIF9odG9ubCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJodG9ubFwiKTtcblxudmFyIF9odG9ucyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJodG9uc1wiKTtcblxudmFyIF9udG9ocyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJudG9oc1wiKTtcblxudmFyIF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1hbGxvY1wiKTtcblxudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZnJlZVwiKTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2luaXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgc3RhY2tTYXZlID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrU2F2ZVwiKTtcblxudmFyIHN0YWNrUmVzdG9yZSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdGFja1Jlc3RvcmVcIik7XG5cbnZhciBzdGFja0FsbG9jID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrQWxsb2NcIik7XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9fX2N4YV9pc19wb2ludGVyX3R5cGUgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19jeGFfaXNfcG9pbnRlcl90eXBlXCIpO1xuXG52YXIgZHluQ2FsbF9qaWppID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamppXCIpO1xuXG52YXIgZHluQ2FsbF9paWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqaVwiKTtcblxudmFyIGR5bkNhbGxfamkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpalwiKTtcblxudmFyIGR5bkNhbGxfdmpqaWppaiA9IE1vZHVsZVtcImR5bkNhbGxfdmpqaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZqamlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpampqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqamppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqamppXCIpO1xuXG52YXIgZHluQ2FsbF92amppaSA9IE1vZHVsZVtcImR5bkNhbGxfdmpqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92amppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpalwiKTtcblxudmFyIGR5bkNhbGxfamlqamlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqaWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWpqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpqalwiKTtcblxudmFyIGR5bkNhbGxfdmlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpampcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlqaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWppaVwiKTtcblxudmFyIGR5bkNhbGxfamlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlpaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlpalwiKTtcblxudmFyIGR5bkNhbGxfdmlqaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpamlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWppaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWpqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlpXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWppID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9paWppaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlcIik7XG5cbnZhciBkeW5DYWxsX2lpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpampcIik7XG5cbnZhciBkeW5DYWxsX2ppamogPSBNb2R1bGVbXCJkeW5DYWxsX2ppampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlcIik7XG5cbnZhciBkeW5DYWxsX2ppaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2ogPSBNb2R1bGVbXCJkeW5DYWxsX2pcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfamlpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2pqID0gTW9kdWxlW1wiZHluQ2FsbF9qalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2pqXCIpO1xuXG52YXIgZHluQ2FsbF9paiA9IE1vZHVsZVtcImR5bkNhbGxfaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9palwiKTtcblxudmFyIGR5bkNhbGxfaWpqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWpqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lqampcIik7XG5cbnZhciBkeW5DYWxsX2pqamQgPSBNb2R1bGVbXCJkeW5DYWxsX2pqamRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qampkXCIpO1xuXG52YXIgZHluQ2FsbF9qampqampkID0gTW9kdWxlW1wiZHluQ2FsbF9qampqampkXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfampqampqZFwiKTtcblxudmFyIGR5bkNhbGxfamlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqaWlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpamlpaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWlpamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWppaWlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlqaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpXCIpO1xuXG5Nb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gc3RhY2tBbGxvYztcblxuTW9kdWxlW1wic3RhY2tTYXZlXCJdID0gc3RhY2tTYXZlO1xuXG5Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl0gPSBzdGFja1Jlc3RvcmU7XG5cbk1vZHVsZVtcImNjYWxsXCJdID0gY2NhbGw7XG5cbnZhciBtaXNzaW5nTGlicmFyeVN5bWJvbHMgPSBbIFwiZ2V0SG9zdEJ5TmFtZVwiLCBcInRyYXZlcnNlU3RhY2tcIiwgXCJnZXRDYWxsc3RhY2tcIiwgXCJlbXNjcmlwdGVuTG9nXCIsIFwiY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvblwiLCBcInJlYWRFbUFzbUFyZ3NcIiwgXCJqc3RvaV9zXCIsIFwibGlzdGVuT25jZVwiLCBcImF1dG9SZXN1bWVBdWRpb0NvbnRleHRcIiwgXCJkeW5DYWxsTGVnYWN5XCIsIFwiZ2V0RHluQ2FsbGVyXCIsIFwiZHluQ2FsbFwiLCBcInJ1bnRpbWVLZWVwYWxpdmVQdXNoXCIsIFwicnVudGltZUtlZXBhbGl2ZVBvcFwiLCBcImNhbGxVc2VyQ2FsbGJhY2tcIiwgXCJtYXliZUV4aXRcIiwgXCJzYWZlU2V0VGltZW91dFwiLCBcImFzbWpzTWFuZ2xlXCIsIFwiYXN5bmNMb2FkXCIsIFwiYWxpZ25NZW1vcnlcIiwgXCJtbWFwQWxsb2NcIiwgXCJIYW5kbGVBbGxvY2F0b3JcIiwgXCJnZXROYXRpdmVUeXBlU2l6ZVwiLCBcIlNUQUNLX1NJWkVcIiwgXCJTVEFDS19BTElHTlwiLCBcIlBPSU5URVJfU0laRVwiLCBcIkFTU0VSVElPTlNcIiwgXCJ3cml0ZUk1M1RvSTY0XCIsIFwid3JpdGVJNTNUb0k2NENsYW1wZWRcIiwgXCJ3cml0ZUk1M1RvSTY0U2lnbmFsaW5nXCIsIFwid3JpdGVJNTNUb1U2NENsYW1wZWRcIiwgXCJ3cml0ZUk1M1RvVTY0U2lnbmFsaW5nXCIsIFwicmVhZEk1M0Zyb21VNjRcIiwgXCJjb252ZXJ0STMyUGFpclRvSTUzXCIsIFwiY29udmVydFUzMlBhaXJUb0k1M1wiLCBcImN3cmFwXCIsIFwidWxlYjEyOEVuY29kZVwiLCBcInNpZ1RvV2FzbVR5cGVzXCIsIFwiZ2VuZXJhdGVGdW5jVHlwZVwiLCBcImNvbnZlcnRKc0Z1bmN0aW9uVG9XYXNtXCIsIFwiZ2V0RW1wdHlUYWJsZVNsb3RcIiwgXCJ1cGRhdGVUYWJsZU1hcFwiLCBcImdldEZ1bmN0aW9uQWRkcmVzc1wiLCBcImFkZEZ1bmN0aW9uXCIsIFwicmVtb3ZlRnVuY3Rpb25cIiwgXCJyZWFsbHlOZWdhdGl2ZVwiLCBcInVuU2lnblwiLCBcInN0ckxlblwiLCBcInJlU2lnblwiLCBcImZvcm1hdFN0cmluZ1wiLCBcImludEFycmF5VG9TdHJpbmdcIiwgXCJBc2NpaVRvU3RyaW5nXCIsIFwiVVRGMTZUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGMTZcIiwgXCJsZW5ndGhCeXRlc1VURjE2XCIsIFwiVVRGMzJUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGMzJcIiwgXCJsZW5ndGhCeXRlc1VURjMyXCIsIFwicmVnaXN0ZXJLZXlFdmVudENhbGxiYWNrXCIsIFwibWF5YmVDU3RyaW5nVG9Kc1N0cmluZ1wiLCBcImZpbmRFdmVudFRhcmdldFwiLCBcImZpbmRDYW52YXNFdmVudFRhcmdldFwiLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiLCBcImZpbGxNb3VzZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJXaGVlbEV2ZW50Q2FsbGJhY2tcIiwgXCJyZWdpc3RlclVpRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyRm9jdXNFdmVudENhbGxiYWNrXCIsIFwiZmlsbERldmljZU9yaWVudGF0aW9uRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJEZXZpY2VPcmllbnRhdGlvbkV2ZW50Q2FsbGJhY2tcIiwgXCJmaWxsRGV2aWNlTW90aW9uRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJEZXZpY2VNb3Rpb25FdmVudENhbGxiYWNrXCIsIFwic2NyZWVuT3JpZW50YXRpb25cIiwgXCJmaWxsT3JpZW50YXRpb25DaGFuZ2VFdmVudERhdGFcIiwgXCJyZWdpc3Rlck9yaWVudGF0aW9uQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcImZpbGxGdWxsc2NyZWVuQ2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcIkpTRXZlbnRzX3JlcXVlc3RGdWxsc2NyZWVuXCIsIFwiSlNFdmVudHNfcmVzaXplQ2FudmFzRm9yRnVsbHNjcmVlblwiLCBcInJlZ2lzdGVyUmVzdG9yZU9sZFN0eWxlXCIsIFwiaGlkZUV2ZXJ5dGhpbmdFeGNlcHRHaXZlbkVsZW1lbnRcIiwgXCJyZXN0b3JlSGlkZGVuRWxlbWVudHNcIiwgXCJzZXRMZXR0ZXJib3hcIiwgXCJzb2Z0RnVsbHNjcmVlblJlc2l6ZVdlYkdMUmVuZGVyVGFyZ2V0XCIsIFwiZG9SZXF1ZXN0RnVsbHNjcmVlblwiLCBcImZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyUG9pbnRlcmxvY2tDaGFuZ2VFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJQb2ludGVybG9ja0Vycm9yRXZlbnRDYWxsYmFja1wiLCBcInJlcXVlc3RQb2ludGVyTG9ja1wiLCBcImZpbGxWaXNpYmlsaXR5Q2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyVG91Y2hFdmVudENhbGxiYWNrXCIsIFwiZmlsbEdhbWVwYWRFdmVudERhdGFcIiwgXCJyZWdpc3RlckdhbWVwYWRFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJCZWZvcmVVbmxvYWRFdmVudENhbGxiYWNrXCIsIFwiZmlsbEJhdHRlcnlFdmVudERhdGFcIiwgXCJiYXR0ZXJ5XCIsIFwicmVnaXN0ZXJCYXR0ZXJ5RXZlbnRDYWxsYmFja1wiLCBcInNldENhbnZhc0VsZW1lbnRTaXplXCIsIFwiZ2V0Q2FudmFzRWxlbWVudFNpemVcIiwgXCJkZW1hbmdsZVwiLCBcImRlbWFuZ2xlQWxsXCIsIFwianNTdGFja1RyYWNlXCIsIFwic3RhY2tUcmFjZVwiLCBcImNoZWNrV2FzaUNsb2NrXCIsIFwid2FzaVJpZ2h0c1RvTXVzbE9GbGFnc1wiLCBcIndhc2lPRmxhZ3NUb011c2xPRmxhZ3NcIiwgXCJjcmVhdGVEeW5jYWxsV3JhcHBlclwiLCBcInNldEltbWVkaWF0ZVdyYXBwZWRcIiwgXCJjbGVhckltbWVkaWF0ZVdyYXBwZWRcIiwgXCJwb2x5ZmlsbFNldEltbWVkaWF0ZVwiLCBcImdldFByb21pc2VcIiwgXCJtYWtlUHJvbWlzZVwiLCBcImlkc1RvUHJvbWlzZXNcIiwgXCJtYWtlUHJvbWlzZUNhbGxiYWNrXCIsIFwic2V0TWFpbkxvb3BcIiwgXCJoZWFwT2JqZWN0Rm9yV2ViR0xUeXBlXCIsIFwiaGVhcEFjY2Vzc1NoaWZ0Rm9yV2ViR0xIZWFwXCIsIFwid2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXNcIiwgXCJ3ZWJnbF9lbmFibGVfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiwgXCJ3ZWJnbF9lbmFibGVfV0VCR0xfZHJhd19idWZmZXJzXCIsIFwid2ViZ2xfZW5hYmxlX1dFQkdMX211bHRpX2RyYXdcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRcIiwgXCJjb21wdXRlVW5wYWNrQWxpZ25lZEltYWdlU2l6ZVwiLCBcImNvbG9yQ2hhbm5lbHNJbkdsVGV4dHVyZUZvcm1hdFwiLCBcImVtc2NyaXB0ZW5XZWJHTEdldFRleFBpeGVsRGF0YVwiLCBcIl9fZ2xHZW5PYmplY3RcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRVbmlmb3JtXCIsIFwid2ViZ2xHZXRVbmlmb3JtTG9jYXRpb25cIiwgXCJ3ZWJnbFByZXBhcmVVbmlmb3JtTG9jYXRpb25zQmVmb3JlRmlyc3RVc2VcIiwgXCJ3ZWJnbEdldExlZnRCcmFjZVBvc1wiLCBcImVtc2NyaXB0ZW5XZWJHTEdldFZlcnRleEF0dHJpYlwiLCBcIl9fZ2xHZXRBY3RpdmVBdHRyaWJPclVuaWZvcm1cIiwgXCJ3cml0ZUdMQXJyYXlcIiwgXCJyZWdpc3RlcldlYkdsRXZlbnRDYWxsYmFja1wiLCBcInJ1bkFuZEFib3J0SWZFcnJvclwiLCBcIlNETF91bmljb2RlXCIsIFwiU0RMX3R0ZkNvbnRleHRcIiwgXCJTRExfYXVkaW9cIiwgXCJHTEZXX1dpbmRvd1wiLCBcIkFMTE9DX05PUk1BTFwiLCBcIkFMTE9DX1NUQUNLXCIsIFwiYWxsb2NhdGVcIiwgXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XCIsIFwid3JpdGVBc2NpaVRvTWVtb3J5XCIgXTtcblxubWlzc2luZ0xpYnJhcnlTeW1ib2xzLmZvckVhY2gobWlzc2luZ0xpYnJhcnlTeW1ib2wpO1xuXG52YXIgdW5leHBvcnRlZFN5bWJvbHMgPSBbIFwicnVuXCIsIFwiYWRkT25QcmVSdW5cIiwgXCJhZGRPbkluaXRcIiwgXCJhZGRPblByZU1haW5cIiwgXCJhZGRPbkV4aXRcIiwgXCJhZGRPblBvc3RSdW5cIiwgXCJhZGRSdW5EZXBlbmRlbmN5XCIsIFwicmVtb3ZlUnVuRGVwZW5kZW5jeVwiLCBcIkZTX2NyZWF0ZUZvbGRlclwiLCBcIkZTX2NyZWF0ZVBhdGhcIiwgXCJGU19jcmVhdGVEYXRhRmlsZVwiLCBcIkZTX2NyZWF0ZUxhenlGaWxlXCIsIFwiRlNfY3JlYXRlTGlua1wiLCBcIkZTX2NyZWF0ZURldmljZVwiLCBcIkZTX3VubGlua1wiLCBcIm91dFwiLCBcImVyclwiLCBcImNhbGxNYWluXCIsIFwiYWJvcnRcIiwgXCJrZWVwUnVudGltZUFsaXZlXCIsIFwid2FzbU1lbW9yeVwiLCBcImdldFRlbXBSZXQwXCIsIFwic2V0VGVtcFJldDBcIiwgXCJ3cml0ZVN0YWNrQ29va2llXCIsIFwiY2hlY2tTdGFja0Nvb2tpZVwiLCBcInB0clRvU3RyaW5nXCIsIFwiemVyb01lbW9yeVwiLCBcImV4aXRKU1wiLCBcImdldEhlYXBNYXhcIiwgXCJlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyXCIsIFwiRU5WXCIsIFwiTU9OVEhfREFZU19SRUdVTEFSXCIsIFwiTU9OVEhfREFZU19MRUFQXCIsIFwiTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkVcIiwgXCJNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVwiLCBcImlzTGVhcFllYXJcIiwgXCJ5ZGF5RnJvbURhdGVcIiwgXCJhcnJheVN1bVwiLCBcImFkZERheXNcIiwgXCJFUlJOT19DT0RFU1wiLCBcIkVSUk5PX01FU1NBR0VTXCIsIFwic2V0RXJyTm9cIiwgXCJpbmV0UHRvbjRcIiwgXCJpbmV0TnRvcDRcIiwgXCJpbmV0UHRvbjZcIiwgXCJpbmV0TnRvcDZcIiwgXCJyZWFkU29ja2FkZHJcIiwgXCJ3cml0ZVNvY2thZGRyXCIsIFwiRE5TXCIsIFwiUHJvdG9jb2xzXCIsIFwiU29ja2V0c1wiLCBcImluaXRSYW5kb21GaWxsXCIsIFwicmFuZG9tRmlsbFwiLCBcInRpbWVyc1wiLCBcIndhcm5PbmNlXCIsIFwiVU5XSU5EX0NBQ0hFXCIsIFwicmVhZEVtQXNtQXJnc0FycmF5XCIsIFwianN0b2lfcVwiLCBcImdldEV4ZWN1dGFibGVOYW1lXCIsIFwiaGFuZGxlRXhjZXB0aW9uXCIsIFwicmVhZEk1M0Zyb21JNjRcIiwgXCJjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZFwiLCBcImdldENGdW5jXCIsIFwiZnJlZVRhYmxlSW5kZXhlc1wiLCBcImZ1bmN0aW9uc0luVGFibGVNYXBcIiwgXCJzZXRWYWx1ZVwiLCBcImdldFZhbHVlXCIsIFwiUEFUSFwiLCBcIlBBVEhfRlNcIiwgXCJVVEY4RGVjb2RlclwiLCBcIlVURjhBcnJheVRvU3RyaW5nXCIsIFwiVVRGOFRvU3RyaW5nXCIsIFwic3RyaW5nVG9VVEY4QXJyYXlcIiwgXCJzdHJpbmdUb1VURjhcIiwgXCJsZW5ndGhCeXRlc1VURjhcIiwgXCJpbnRBcnJheUZyb21TdHJpbmdcIiwgXCJzdHJpbmdUb0FzY2lpXCIsIFwiVVRGMTZEZWNvZGVyXCIsIFwic3RyaW5nVG9OZXdVVEY4XCIsIFwic3RyaW5nVG9VVEY4T25TdGFja1wiLCBcIndyaXRlQXJyYXlUb01lbW9yeVwiLCBcIkpTRXZlbnRzXCIsIFwic3BlY2lhbEhUTUxUYXJnZXRzXCIsIFwiY3VycmVudEZ1bGxzY3JlZW5TdHJhdGVneVwiLCBcInJlc3RvcmVPbGRXaW5kb3dlZFN0eWxlXCIsIFwiRXhpdFN0YXR1c1wiLCBcImdldEVudlN0cmluZ3NcIiwgXCJmbHVzaF9OT19GSUxFU1lTVEVNXCIsIFwiZGxvcGVuTWlzc2luZ0Vycm9yXCIsIFwicHJvbWlzZU1hcFwiLCBcInVuY2F1Z2h0RXhjZXB0aW9uQ291bnRcIiwgXCJleGNlcHRpb25MYXN0XCIsIFwiZXhjZXB0aW9uQ2F1Z2h0XCIsIFwiRXhjZXB0aW9uSW5mb1wiLCBcIkJyb3dzZXJcIiwgXCJ3Z2V0XCIsIFwiU1lTQ0FMTFNcIiwgXCJnZXRTb2NrZXRGcm9tRkRcIiwgXCJnZXRTb2NrZXRBZGRyZXNzXCIsIFwidGVtcEZpeGVkTGVuZ3RoQXJyYXlcIiwgXCJtaW5pVGVtcFdlYkdMRmxvYXRCdWZmZXJzXCIsIFwibWluaVRlbXBXZWJHTEludEJ1ZmZlcnNcIiwgXCJHTFwiLCBcImVtc2NyaXB0ZW5fd2ViZ2xfcG93ZXJfcHJlZmVyZW5jZXNcIiwgXCJBTFwiLCBcIkdMVVRcIiwgXCJFR0xcIiwgXCJHTEVXXCIsIFwiSURCU3RvcmVcIiwgXCJTRExcIiwgXCJTRExfZ2Z4XCIsIFwiR0xGV1wiLCBcImFsbG9jYXRlVVRGOFwiLCBcImFsbG9jYXRlVVRGOE9uU3RhY2tcIiwgXCJTT0NLRlNcIiwgXCJGU1wiIF07XG5cbnVuZXhwb3J0ZWRTeW1ib2xzLmZvckVhY2godW5leHBvcnRlZFJ1bnRpbWVTeW1ib2wpO1xuXG52YXIgY2FsbGVkUnVuO1xuXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7XG59O1xuXG5mdW5jdGlvbiBjYWxsTWFpbigpIHtcbiBhc3NlcnQocnVuRGVwZW5kZW5jaWVzID09IDAsICdjYW5ub3QgY2FsbCBtYWluIHdoZW4gYXN5bmMgZGVwZW5kZW5jaWVzIHJlbWFpbiEgKGxpc3RlbiBvbiBNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSknKTtcbiBhc3NlcnQoX19BVFBSRVJVTl9fLmxlbmd0aCA9PSAwLCBcImNhbm5vdCBjYWxsIG1haW4gd2hlbiBwcmVSdW4gZnVuY3Rpb25zIHJlbWFpbiB0byBiZSBjYWxsZWRcIik7XG4gdmFyIGVudHJ5RnVuY3Rpb24gPSBfbWFpbjtcbiB2YXIgYXJnYyA9IDA7XG4gdmFyIGFyZ3YgPSAwO1xuIHRyeSB7XG4gIHZhciByZXQgPSBlbnRyeUZ1bmN0aW9uKGFyZ2MsIGFyZ3YpO1xuICBleGl0SlMocmV0LCB0cnVlKTtcbiAgcmV0dXJuIHJldDtcbiB9IGNhdGNoIChlKSB7XG4gIHJldHVybiBoYW5kbGVFeGNlcHRpb24oZSk7XG4gfVxufVxuXG5mdW5jdGlvbiBzdGFja0NoZWNrSW5pdCgpIHtcbiBfZW1zY3JpcHRlbl9zdGFja19pbml0KCk7XG4gd3JpdGVTdGFja0Nvb2tpZSgpO1xufVxuXG5mdW5jdGlvbiBydW4oKSB7XG4gaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgcmV0dXJuO1xuIH1cbiBzdGFja0NoZWNrSW5pdCgpO1xuIHByZVJ1bigpO1xuIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gIHJldHVybjtcbiB9XG4gZnVuY3Rpb24gZG9SdW4oKSB7XG4gIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgTW9kdWxlW1wiY2FsbGVkUnVuXCJdID0gdHJ1ZTtcbiAgaWYgKEFCT1JUKSByZXR1cm47XG4gIGluaXRSdW50aW1lKCk7XG4gIHByZU1haW4oKTtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xuICBpZiAoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7XG4gIGlmIChzaG91bGRSdW5Ob3cpIGNhbGxNYWluKCk7XG4gIHBvc3RSdW4oKTtcbiB9XG4gaWYgKE1vZHVsZVtcInNldFN0YXR1c1wiXSkge1xuICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJcIik7XG4gICB9LCAxKTtcbiAgIGRvUnVuKCk7XG4gIH0sIDEpO1xuIH0gZWxzZSB7XG4gIGRvUnVuKCk7XG4gfVxuIGNoZWNrU3RhY2tDb29raWUoKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tVbmZsdXNoZWRDb250ZW50KCkge1xuIHZhciBvbGRPdXQgPSBvdXQ7XG4gdmFyIG9sZEVyciA9IGVycjtcbiB2YXIgaGFzID0gZmFsc2U7XG4gb3V0ID0gZXJyID0geCA9PiB7XG4gIGhhcyA9IHRydWU7XG4gfTtcbiB0cnkge1xuICBmbHVzaF9OT19GSUxFU1lTVEVNKCk7XG4gfSBjYXRjaCAoZSkge31cbiBvdXQgPSBvbGRPdXQ7XG4gZXJyID0gb2xkRXJyO1xuIGlmIChoYXMpIHtcbiAgd2Fybk9uY2UoXCJzdGRpbyBzdHJlYW1zIGhhZCBjb250ZW50IGluIHRoZW0gdGhhdCB3YXMgbm90IGZsdXNoZWQuIHlvdSBzaG91bGQgc2V0IEVYSVRfUlVOVElNRSB0byAxIChzZWUgdGhlIEZBUSksIG9yIG1ha2Ugc3VyZSB0byBlbWl0IGEgbmV3bGluZSB3aGVuIHlvdSBwcmludGYgZXRjLlwiKTtcbiAgd2Fybk9uY2UoXCIodGhpcyBtYXkgYWxzbyBiZSBkdWUgdG8gbm90IGluY2x1ZGluZyBmdWxsIGZpbGVzeXN0ZW0gc3VwcG9ydCAtIHRyeSBidWlsZGluZyB3aXRoIC1zRk9SQ0VfRklMRVNZU1RFTSlcIik7XG4gfVxufVxuXG5pZiAoTW9kdWxlW1wicHJlSW5pdFwiXSkge1xuIGlmICh0eXBlb2YgTW9kdWxlW1wicHJlSW5pdFwiXSA9PSBcImZ1bmN0aW9uXCIpIE1vZHVsZVtcInByZUluaXRcIl0gPSBbIE1vZHVsZVtcInByZUluaXRcIl0gXTtcbiB3aGlsZSAoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGggPiAwKSB7XG4gIE1vZHVsZVtcInByZUluaXRcIl0ucG9wKCkoKTtcbiB9XG59XG5cbnZhciBzaG91bGRSdW5Ob3cgPSB0cnVlO1xuXG5pZiAoTW9kdWxlW1wibm9Jbml0aWFsUnVuXCJdKSBzaG91bGRSdW5Ob3cgPSBmYWxzZTtcblxucnVuKCk7XG5cblxuICByZXR1cm4gRHVja0RCLnJlYWR5XG59XG5cbik7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgRHVja0RCOyIsICJpbXBvcnQgeyBEdWNrREJNb2R1bGUgfSBmcm9tICcuL2R1Y2tkYl9tb2R1bGUnO1xuaW1wb3J0IHsgRHVja0RCQmluZGluZ3NCYXNlIH0gZnJvbSAnLi9iaW5kaW5nc19iYXNlJztcbmltcG9ydCB7IER1Y2tEQlJ1bnRpbWUgfSBmcm9tICcuL3J1bnRpbWUnO1xuaW1wb3J0IHsgTG9nTGV2ZWwsIExvZ1RvcGljLCBMb2dPcmlnaW4sIExvZ0V2ZW50IH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XG5pbXBvcnQgeyBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MgfSBmcm9tICcuJztcblxuLyoqIER1Y2tEQiBiaW5kaW5ncyBmb3IgdGhlIGJyb3dzZXIgKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEdWNrREJCcm93c2VyQmluZGluZ3MgZXh0ZW5kcyBEdWNrREJCaW5kaW5nc0Jhc2Uge1xuICAgIC8qKiBUaGUgcGF0aCBvZiB0aGUgd2FzbSBtb2R1bGUgKi9cbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgbWFpbk1vZHVsZVVSTDogc3RyaW5nO1xuICAgIC8qKiBUaGUgcGF0aCBvZiB0aGUgcHRocmVhZCB3b3JrZXIgc2NyaXB0ICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGw7XG5cbiAgICAvKiogQ29uc3RydWN0b3IgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXIsIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsIG1haW5Nb2R1bGVVUkw6IHN0cmluZywgcHRocmVhZFdvcmtlclVSTDogc3RyaW5nIHwgbnVsbCkge1xuICAgICAgICBzdXBlcihsb2dnZXIsIHJ1bnRpbWUpO1xuICAgICAgICB0aGlzLm1haW5Nb2R1bGVVUkwgPSBtYWluTW9kdWxlVVJMO1xuICAgICAgICB0aGlzLnB0aHJlYWRXb3JrZXJVUkwgPSBwdGhyZWFkV29ya2VyVVJMO1xuICAgIH1cblxuICAgIC8qKiBMb2NhdGUgYSBmaWxlICovXG4gICAgcHJvdGVjdGVkIGxvY2F0ZUZpbGUocGF0aDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcud2FzbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluTW9kdWxlVVJMO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmVuZHNXaXRoKCcud29ya2VyLmpzJykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wdGhyZWFkV29ya2VyVVJMKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIER1Y2tEQiB3b3JrZXIgVVJMIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHRocmVhZFdvcmtlclVSTCE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXQVNNIGluc3RhbnRpYXRpb24gcmVxdWVzdGVkIHVuZXhwZWN0ZWQgZmlsZTogcHJlZml4PSR7cHJlZml4fSBwYXRoPSR7cGF0aH1gKTtcbiAgICB9XG5cbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIHdhc20gbW9kdWxlICovXG4gICAgcHJvdGVjdGVkIGluc3RhbnRpYXRlV2FzbShcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbiAgICAgICAgaW1wb3J0czogYW55LFxuICAgICAgICBzdWNjZXNzOiAoaW5zdGFuY2U6IFdlYkFzc2VtYmx5Lkluc3RhbmNlLCBtb2R1bGU6IFdlYkFzc2VtYmx5Lk1vZHVsZSkgPT4gdm9pZCxcbiAgICApOiBFbXNjcmlwdGVuLldlYkFzc2VtYmx5RXhwb3J0cyB7XG4gICAgICAgIC8vIFdlIHJlbHkgb24gdGhlIGZvbGxvd2luZyBoZXJlOlxuICAgICAgICAvL1xuICAgICAgICAvLyAuLi53aGVuIGEgUmVxdWVzdCBvYmplY3QgaXMgY3JlYXRlZCB1c2luZyB0aGUgUmVxdWVzdC5SZXF1ZXN0IGNvbnN0cnVjdG9yLFxuICAgICAgICAvLyB0aGUgdmFsdWUgb2YgdGhlIG1vZGUgcHJvcGVydHkgZm9yIHRoYXQgUmVxdWVzdCBpcyBzZXQgdG8gY29ycy5cbiAgICAgICAgLy8gW3JlZjogTUROXVxuICAgICAgICAvL1xuICAgICAgICAvLyBDbG91ZGZsYXJlIHRocm93cyB3aGVuIG1vZGU6ICdjb3JzJyBpcyBzZXRcbiAgICAgICAgLy9cbiAgICAgICAgZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRSA9IHRoaXMuX3J1bnRpbWU7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5vbkluc3RhbnRpYXRpb25Qcm9ncmVzcztcblxuICAgICAgICAvLyBEb2VzIHRoZSBicm93c2VyIHN1cHBvcnQgc3RyZWFtaW5nIGluc3RhbnRpYXRpb24/XG4gICAgICAgIGlmIChXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZykge1xuICAgICAgICAgICAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHRyYW5zZm9ybSBzdHJlYW1zP1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBUcmFuc2Zvcm1TdHJlYW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZXRjaFdpdGhQcm9ncmVzcyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSBmaWxlIHNpemVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMubWFpbk1vZHVsZVVSTCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZHIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGNvbnRlbnRMZW5ndGhIZHIgPyBwYXJzZUludChjb250ZW50TGVuZ3RoSGRyLCAxMCkgfHwgMCA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzczogSW5zdGFudGlhdGlvblByb2dyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZEF0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc1RvdGFsOiBjb250ZW50TGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0xvYWRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuazogYW55LCBjdHJsOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLmJ5dGVzTG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm93LmdldFRpbWUoKSAtIHByb2dyZXNzLnVwZGF0ZWRBdC5nZXRUaW1lKCkgPCAyMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy51cGRhdGVkQXQgPSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0cmwuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHMgPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYWNrZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmJvZHk/LnBpcGVUaHJvdWdoKHRzKSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgc3RyZWFtaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBmZXRjaFdpdGhQcm9ncmVzcygpO1xuICAgICAgICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbXBvcnRzKS50aGVuKG91dHB1dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3Mob3V0cHV0Lmluc3RhbmNlLCBvdXRwdXQubW9kdWxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdpbnN0YW50aWF0aW5nIHdpdGhvdXQgcHJvZ3Jlc3MgaGFuZGxlciBzaW5jZSB0cmFuc2Zvcm0gc3RyZWFtcyBhcmUgdW5hdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5tYWluTW9kdWxlVVJMKTtcbiAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaChyZXF1ZXN0KSwgaW1wb3J0cykudGhlbihvdXRwdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG91dHB1dC5pbnN0YW5jZSwgb3V0cHV0Lm1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBmYWxsIGJhY2sgdG8gWEhSc1xuICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSB0aGlzLm1haW5Nb2R1bGVVUkw7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzczogSW5zdGFudGlhdGlvblByb2dyZXNzID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWRBdDogc3RhcnQsXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBieXRlc1RvdGFsOiAwLFxuICAgICAgICAgICAgICAgIGJ5dGVzTG9hZGVkOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coe1xuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBMb2dPcmlnaW4uQklORElOR1MsXG4gICAgICAgICAgICAgICAgICAgIHRvcGljOiBMb2dUb3BpYy5JTlNUQU5USUFURSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IExvZ0V2ZW50LkVSUk9SLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0ZhaWxlZCB0byBsb2FkIFdBU006ICcgKyBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBlID0+IHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcy5ieXRlc1RvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcy5ieXRlc0xvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdy5nZXRUaW1lKCkgLSBwcm9ncmVzcy51cGRhdGVkQXQuZ2V0VGltZSgpIDwgMjApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MudXBkYXRlZEF0ID0gbm93O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBoYW5kbGVycykge1xuICAgICAgICAgICAgICAgICAgICBwKHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh4aHIucmVzcG9uc2UsIGltcG9ydHMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKG91dHB1dCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG91dHB1dC5pbnN0YW5jZSwgb3V0cHV0Lm1vZHVsZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5sb2coe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWwuRVJST1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBMb2dPcmlnaW4uQklORElOR1MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IExvZ1RvcGljLklOU1RBTlRJQVRFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBMb2dFdmVudC5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJ0ZhaWxlZCB0byBpbnN0YW50aWF0ZSBXQVNNOiAnICsgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5zZW5kKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luc3RhbnRpYXRpbmcgd2l0aCBtYW51YWwgZmV0Y2ggc2luY2Ugc3RyZWFtaW5nIGluc3RhbnRpYXRpb24gYW5kIHhocnMgYXJlIHVuYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICBjb25zdCBydW4gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHRoaXMubWFpbk1vZHVsZVVSTCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ1ZmZlciwgaW1wb3J0cykudGhlbihvdXRwdXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG91dHB1dC5pbnN0YW5jZSwgb3V0cHV0Lm1vZHVsZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8vLyBJbnN0YW50aWF0aW9uIG11c3QgYmUgZG9uZSBieSB0aGUgYnJvd3NlciB2YXJpYW50c1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbnN0YW50aWF0ZUltcGwobW9kdWxlT3ZlcnJpZGVzOiBQYXJ0aWFsPER1Y2tEQk1vZHVsZT4pOiBQcm9taXNlPER1Y2tEQk1vZHVsZT47XG59XG4iLCAiaW1wb3J0IER1Y2tEQldhc20gZnJvbSAnLi9kdWNrZGItbXZwLmpzJztcbmltcG9ydCB7IER1Y2tEQkJyb3dzZXJCaW5kaW5ncyB9IGZyb20gJy4vYmluZGluZ3NfYnJvd3Nlcl9iYXNlJztcbmltcG9ydCB7IER1Y2tEQk1vZHVsZSB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XG5pbXBvcnQgeyBEdWNrREJSdW50aW1lIH0gZnJvbSAnLi9ydW50aW1lJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XG5cbi8qKiBEdWNrREIgYmluZGluZ3MgZm9yIHRoZSBicm93c2VyICovXG5leHBvcnQgY2xhc3MgRHVja0RCIGV4dGVuZHMgRHVja0RCQnJvd3NlckJpbmRpbmdzIHtcbiAgICAvKiogQ29uc3RydWN0b3IgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgICAgICBydW50aW1lOiBEdWNrREJSdW50aW1lLFxuICAgICAgICBtYWluTW9kdWxlVVJMOiBzdHJpbmcsXG4gICAgICAgIHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICAgICkge1xuICAgICAgICBzdXBlcihsb2dnZXIsIHJ1bnRpbWUsIG1haW5Nb2R1bGVVUkwsIHB0aHJlYWRXb3JrZXJVUkwpO1xuICAgIH1cblxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgYmluZGluZ3MgKi9cbiAgICBwcm90ZWN0ZWQgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+IHtcbiAgICAgICAgcmV0dXJuIER1Y2tEQldhc20oe1xuICAgICAgICAgICAgLi4ubW9kdWxlT3ZlcnJpZGVzLFxuICAgICAgICAgICAgaW5zdGFudGlhdGVXYXNtOiB0aGlzLmluc3RhbnRpYXRlV2FzbS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbG9jYXRlRmlsZTogdGhpcy5sb2NhdGVGaWxlLmJpbmQodGhpcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsICJcbnZhciBEdWNrREIgPSAoKCkgPT4ge1xuICB2YXIgX3NjcmlwdERpciA9IGltcG9ydC5tZXRhLnVybDtcbiAgXG4gIHJldHVybiAoXG5hc3luYyBmdW5jdGlvbihEdWNrREIgPSB7fSkgIHtcblxudmFyIE1vZHVsZSA9IHR5cGVvZiBEdWNrREIgIT0gXCJ1bmRlZmluZWRcIiA/IER1Y2tEQiA6IHt9O1xuXG52YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSwgcmVhZHlQcm9taXNlUmVqZWN0O1xuXG5Nb2R1bGVbXCJyZWFkeVwiXSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiByZWFkeVByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiByZWFkeVByb21pc2VSZWplY3QgPSByZWplY3Q7XG59KTtcblxuWyBcIl9tYWluXCIsIFwiX21hbGxvY1wiLCBcIl9mcmVlXCIsIFwiX2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2VcIiwgXCJfZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHNcIiwgXCJfZHVja2RiX3dlYl9jb25uZWN0XCIsIFwiX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlclwiLCBcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCIsIFwiX2R1Y2tkYl93ZWJfZGlzY29ubmVjdFwiLCBcIl9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCIsIFwiX2R1Y2tkYl93ZWJfZmFpbF93aXRoXCIsIFwiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZVwiLCBcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlc1wiLCBcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWRcIiwgXCJfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X25hbWVcIiwgXCJfZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCIsIFwiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXJcIiwgXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiLCBcIl9kdWNrZGJfd2ViX2dldF9mZWF0dXJlX2ZsYWdzXCIsIFwiX2R1Y2tkYl93ZWJfZ2V0X2dsb2JhbF9maWxlX2luZm9cIiwgXCJfZHVja2RiX3dlYl9nZXRfdGFibGVuYW1lc1wiLCBcIl9kdWNrZGJfd2ViX2dldF92ZXJzaW9uXCIsIFwiX2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbVwiLCBcIl9kdWNrZGJfd2ViX2luc2VydF9jc3ZfZnJvbV9wYXRoXCIsIFwiX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCIsIFwiX2R1Y2tkYl93ZWJfb3BlblwiLCBcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsXCIsIFwiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCIsIFwiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydFwiLCBcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX2Nsb3NlXCIsIFwiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCIsIFwiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCIsIFwiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZFwiLCBcIl9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHNcIiwgXCJfZHVja2RiX3dlYl9xdWVyeV9ydW5cIiwgXCJfZHVja2RiX3dlYl9yZXNldFwiLCBcIl9kdWNrZGJfd2ViX3Rva2VuaXplXCIsIFwiX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGVcIiwgXCJnZXRFeGNlcHRpb25NZXNzYWdlXCIsIFwiX19fZ2V0X2V4Y2VwdGlvbl9tZXNzYWdlXCIsIFwiX19fY3BwX2V4Y2VwdGlvblwiLCBcIl9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50XCIsIFwiX19fY3hhX2RlY3JlbWVudF9leGNlcHRpb25fcmVmY291bnRcIiwgXCJfX190aHJvd25fb2JqZWN0X2Zyb21fdW53aW5kX2V4Y2VwdGlvblwiLCBcIl9mZmx1c2hcIiwgXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiIF0uZm9yRWFjaChwcm9wID0+IHtcbiBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlW1wicmVhZHlcIl0sIHByb3ApKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbXCJyZWFkeVwiXSwgcHJvcCwge1xuICAgZ2V0OiAoKSA9PiBhYm9ydChcIllvdSBhcmUgZ2V0dGluZyBcIiArIHByb3AgKyBcIiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qc1wiKSxcbiAgIHNldDogKCkgPT4gYWJvcnQoXCJZb3UgYXJlIHNldHRpbmcgXCIgKyBwcm9wICsgXCIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanNcIilcbiAgfSk7XG4gfVxufSk7XG5cbnZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuXG52YXIgYXJndW1lbnRzXyA9IFtdO1xuXG52YXIgdGhpc1Byb2dyYW0gPSBcIi4vdGhpcy5wcm9ncmFtXCI7XG5cbnZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiB0aHJvdyB0b1Rocm93O1xufTtcblxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIjtcblxudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09IFwiZnVuY3Rpb25cIjtcblxudmFyIEVOVklST05NRU5UX0lTX05PREUgPSB0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSBcInN0cmluZ1wiO1xuXG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cbmlmIChNb2R1bGVbXCJFTlZJUk9OTUVOVFwiXSkge1xuIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZS5FTlZJUk9OTUVOVCBoYXMgYmVlbiBkZXByZWNhdGVkLiBUbyBmb3JjZSB0aGUgZW52aXJvbm1lbnQsIHVzZSB0aGUgRU5WSVJPTk1FTlQgY29tcGlsZS10aW1lIG9wdGlvbiAoZm9yIGV4YW1wbGUsIC1zRU5WSVJPTk1FTlQ9d2ViIG9yIC1zRU5WSVJPTk1FTlQ9bm9kZSlcIik7XG59XG5cbnZhciBzY3JpcHREaXJlY3RvcnkgPSBcIlwiO1xuXG5mdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiBpZiAoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSkge1xuICByZXR1cm4gTW9kdWxlW1wibG9jYXRlRmlsZVwiXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuIH1cbiByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbn1cblxudmFyIHJlYWRfLCByZWFkQXN5bmMsIHJlYWRCaW5hcnksIHNldFdpbmRvd1RpdGxlO1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuIGlmICh0eXBlb2YgcHJvY2VzcyA9PSBcInVuZGVmaW5lZFwiIHx8ICFwcm9jZXNzLnJlbGVhc2UgfHwgcHJvY2Vzcy5yZWxlYXNlLm5hbWUgIT09IFwibm9kZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KVwiKTtcbiB2YXIgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gdmFyIG51bWVyaWNWZXJzaW9uID0gbm9kZVZlcnNpb24uc3BsaXQoXCIuXCIpLnNsaWNlKDAsIDMpO1xuIG51bWVyaWNWZXJzaW9uID0gbnVtZXJpY1ZlcnNpb25bMF0gKiAxZTQgKyBudW1lcmljVmVyc2lvblsxXSAqIDEwMCArIG51bWVyaWNWZXJzaW9uWzJdLnNwbGl0KFwiLVwiKVswXSAqIDE7XG4gdmFyIG1pblZlcnNpb24gPSAxMDE5MDA7XG4gaWYgKG51bWVyaWNWZXJzaW9uIDwgMTAxOTAwKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZW1zY3JpcHRlbi1nZW5lcmF0ZWQgY29kZSByZXF1aXJlcyBub2RlIHYxMC4xOS4xOS4wIChkZXRlY3RlZCB2XCIgKyBub2RlVmVyc2lvbiArIFwiKVwiKTtcbiB9XG4gY29uc3Qge2NyZWF0ZVJlcXVpcmU6IGNyZWF0ZVJlcXVpcmV9ID0gYXdhaXQgaW1wb3J0KFwibW9kdWxlXCIpO1xuIHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiB2YXIgbm9kZVBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IG5vZGVQYXRoLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KSArIFwiL1wiO1xuIH0gZWxzZSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IHJlcXVpcmUoXCJ1cmxcIikuZmlsZVVSTFRvUGF0aChuZXcgVVJMKFwiLi9cIiwgaW1wb3J0Lm1ldGEudXJsKSk7XG4gfVxuIHJlYWRfID0gKGZpbGVuYW1lLCBiaW5hcnkpID0+IHtcbiAgZmlsZW5hbWUgPSBpc0ZpbGVVUkkoZmlsZW5hbWUpID8gbmV3IFVSTChmaWxlbmFtZSkgOiBub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO1xuICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCBiaW5hcnkgPyB1bmRlZmluZWQgOiBcInV0ZjhcIik7XG4gfTtcbiByZWFkQmluYXJ5ID0gZmlsZW5hbWUgPT4ge1xuICB2YXIgcmV0ID0gcmVhZF8oZmlsZW5hbWUsIHRydWUpO1xuICBpZiAoIXJldC5idWZmZXIpIHtcbiAgIHJldCA9IG5ldyBVaW50OEFycmF5KHJldCk7XG4gIH1cbiAgYXNzZXJ0KHJldC5idWZmZXIpO1xuICByZXR1cm4gcmV0O1xuIH07XG4gcmVhZEFzeW5jID0gKGZpbGVuYW1lLCBvbmxvYWQsIG9uZXJyb3IsIGJpbmFyeSA9IHRydWUpID0+IHtcbiAgZmlsZW5hbWUgPSBpc0ZpbGVVUkkoZmlsZW5hbWUpID8gbmV3IFVSTChmaWxlbmFtZSkgOiBub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO1xuICBmcy5yZWFkRmlsZShmaWxlbmFtZSwgYmluYXJ5ID8gdW5kZWZpbmVkIDogXCJ1dGY4XCIsIChlcnIsIGRhdGEpID0+IHtcbiAgIGlmIChlcnIpIG9uZXJyb3IoZXJyKTsgZWxzZSBvbmxvYWQoYmluYXJ5ID8gZGF0YS5idWZmZXIgOiBkYXRhKTtcbiAgfSk7XG4gfTtcbiBpZiAoIU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gIHRoaXNQcm9ncmFtID0gcHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuIH1cbiBhcmd1bWVudHNfID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICBwcm9jZXNzLmV4aXRDb2RlID0gc3RhdHVzO1xuICB0aHJvdyB0b1Rocm93O1xuIH07XG4gTW9kdWxlW1wiaW5zcGVjdFwiXSA9ICgpID0+IFwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjtcbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfU0hFTEwpIHtcbiBpZiAodHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIpO1xuIGlmICh0eXBlb2YgcmVhZCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlYWRfID0gZiA9PiB7XG4gICByZXR1cm4gcmVhZChmKTtcbiAgfTtcbiB9XG4gcmVhZEJpbmFyeSA9IGYgPT4ge1xuICBsZXQgZGF0YTtcbiAgaWYgKHR5cGVvZiByZWFkYnVmZmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpO1xuICB9XG4gIGRhdGEgPSByZWFkKGYsIFwiYmluYXJ5XCIpO1xuICBhc3NlcnQodHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIik7XG4gIHJldHVybiBkYXRhO1xuIH07XG4gcmVhZEFzeW5jID0gKGYsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IG9ubG9hZChyZWFkQmluYXJ5KGYpKSwgMCk7XG4gfTtcbiBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0ID0gaWQgPT4ge307XG4gfVxuIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBzY3JpcHRBcmdzO1xuIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50cyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBhcmd1bWVudHM7XG4gfVxuIGlmICh0eXBlb2YgcXVpdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoISh0b1Rocm93IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHtcbiAgICAgbGV0IHRvTG9nID0gdG9UaHJvdztcbiAgICAgaWYgKHRvVGhyb3cgJiYgdHlwZW9mIHRvVGhyb3cgPT0gXCJvYmplY3RcIiAmJiB0b1Rocm93LnN0YWNrKSB7XG4gICAgICB0b0xvZyA9IFsgdG9UaHJvdywgdG9UaHJvdy5zdGFjayBdO1xuICAgICB9XG4gICAgIGVycihgZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiAke3RvTG9nfWApO1xuICAgIH1cbiAgICBxdWl0KHN0YXR1cyk7XG4gICB9KTtcbiAgIHRocm93IHRvVGhyb3c7XG4gIH07XG4gfVxuIGlmICh0eXBlb2YgcHJpbnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZSA9IHt9O1xuICBjb25zb2xlLmxvZyA9IHByaW50O1xuICBjb25zb2xlLndhcm4gPSBjb25zb2xlLmVycm9yID0gdHlwZW9mIHByaW50RXJyICE9IFwidW5kZWZpbmVkXCIgPyBwcmludEVyciA6IHByaW50O1xuIH1cbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiB9XG4gaWYgKF9zY3JpcHREaXIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiB9XG4gaWYgKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKFwiYmxvYjpcIikgIT09IDApIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLCBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgXCJcIikubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gfSBlbHNlIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gXCJcIjtcbiB9XG4gaWYgKCEodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIpO1xuIHtcbiAgcmVhZF8gPSB1cmwgPT4ge1xuICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gICB4aHIuc2VuZChudWxsKTtcbiAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICB9O1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICByZWFkQmluYXJ5ID0gdXJsID0+IHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgIH07XG4gIH1cbiAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgb25lcnJvcigpO1xuICAgfTtcbiAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgIHhoci5zZW5kKG51bGwpO1xuICB9O1xuIH1cbiBzZXRXaW5kb3dUaXRsZSA9IHRpdGxlID0+IGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG59IGVsc2Uge1xuIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IGRldGVjdGlvbiBlcnJvclwiKTtcbn1cblxudmFyIG91dCA9IE1vZHVsZVtcInByaW50XCJdIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5cbnZhciBlcnIgPSBNb2R1bGVbXCJwcmludEVyclwiXSB8fCBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cbk9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG5tb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuXG5jaGVja0luY29taW5nTW9kdWxlQVBJKCk7XG5cbmlmIChNb2R1bGVbXCJhcmd1bWVudHNcIl0pIGFyZ3VtZW50c18gPSBNb2R1bGVbXCJhcmd1bWVudHNcIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJhcmd1bWVudHNcIiwgXCJhcmd1bWVudHNfXCIpO1xuXG5pZiAoTW9kdWxlW1widGhpc1Byb2dyYW1cIl0pIHRoaXNQcm9ncmFtID0gTW9kdWxlW1widGhpc1Byb2dyYW1cIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJ0aGlzUHJvZ3JhbVwiLCBcInRoaXNQcm9ncmFtXCIpO1xuXG5pZiAoTW9kdWxlW1wicXVpdFwiXSkgcXVpdF8gPSBNb2R1bGVbXCJxdWl0XCJdO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwicXVpdFwiLCBcInF1aXRfXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcIm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWRcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wicHRocmVhZE1haW5QcmVmaXhVUkxcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucHRocmVhZE1haW5QcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJjZEluaXRpYWxpemVyUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLmNkSW5pdGlhbGl6ZXJQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJmaWxlUGFja2FnZVByZWZpeFVSTFwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5maWxlUGFja2FnZVByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucmVhZCBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkXyBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wicmVhZEFzeW5jXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLnJlYWRBc3luYyBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQXN5bmMgaW4gSlMpXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRCaW5hcnlcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucmVhZEJpbmFyeSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQmluYXJ5IGluIEpTKVwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJzZXRXaW5kb3dUaXRsZVwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5zZXRXaW5kb3dUaXRsZSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSBzZXRXaW5kb3dUaXRsZSBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wiVE9UQUxfTUVNT1JZXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLlRPVEFMX01FTU9SWSBoYXMgYmVlbiByZW5hbWVkIE1vZHVsZS5JTklUSUFMX01FTU9SWVwiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRcIiwgXCJyZWFkX1wiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRBc3luY1wiLCBcInJlYWRBc3luY1wiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRCaW5hcnlcIiwgXCJyZWFkQmluYXJ5XCIpO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwic2V0V2luZG93VGl0bGVcIiwgXCJzZXRXaW5kb3dUaXRsZVwiKTtcblxudmFyIElEQkZTID0gXCJJREJGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbGlkYmZzLmpzXCI7XG5cbnZhciBQUk9YWUZTID0gXCJQUk9YWUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1scHJveHlmcy5qc1wiO1xuXG52YXIgV09SS0VSRlMgPSBcIldPUktFUkZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sd29ya2VyZnMuanNcIjtcblxudmFyIE5PREVGUyA9IFwiTk9ERUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sbm9kZWZzLmpzXCI7XG5cbmFzc2VydCghRU5WSVJPTk1FTlRfSVNfU0hFTEwsIFwic2hlbGwgZW52aXJvbm1lbnQgZGV0ZWN0ZWQgYnV0IG5vdCBlbmFibGVkIGF0IGJ1aWxkIHRpbWUuICBBZGQgJ3NoZWxsJyB0byBgLXNFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiKTtcblxudmFyIHdhc21CaW5hcnk7XG5cbmlmIChNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKSB3YXNtQmluYXJ5ID0gTW9kdWxlW1wid2FzbUJpbmFyeVwiXTtcblxubGVnYWN5TW9kdWxlUHJvcChcIndhc21CaW5hcnlcIiwgXCJ3YXNtQmluYXJ5XCIpO1xuXG52YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl0gfHwgdHJ1ZTtcblxubGVnYWN5TW9kdWxlUHJvcChcIm5vRXhpdFJ1bnRpbWVcIiwgXCJub0V4aXRSdW50aW1lXCIpO1xuXG5pZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9IFwib2JqZWN0XCIpIHtcbiBhYm9ydChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7XG59XG5cbnZhciB3YXNtTWVtb3J5O1xuXG52YXIgQUJPUlQgPSBmYWxzZTtcblxudmFyIEVYSVRTVEFUVVM7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiBpZiAoIWNvbmRpdGlvbikge1xuICBhYm9ydChcIkFzc2VydGlvbiBmYWlsZWRcIiArICh0ZXh0ID8gXCI6IFwiICsgdGV4dCA6IFwiXCIpKTtcbiB9XG59XG5cbnZhciBIRUFQLCBIRUFQOCwgSEVBUFU4LCBIRUFQMTYsIEhFQVBVMTYsIEhFQVAzMiwgSEVBUFUzMiwgSEVBUEYzMiwgSEVBUEY2NDtcblxuZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKSB7XG4gdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiBNb2R1bGVbXCJIRUFQOFwiXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQMTZcIl0gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQMzJcIl0gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVThcIl0gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVTE2XCJdID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVTMyXCJdID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQRjMyXCJdID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUEY2NFwiXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xufVxuXG5hc3NlcnQoIU1vZHVsZVtcIlNUQUNLX1NJWkVcIl0sIFwiU1RBQ0tfU0laRSBjYW4gbm8gbG9uZ2VyIGJlIHNldCBhdCBydW50aW1lLiAgVXNlIC1zU1RBQ0tfU0laRSBhdCBsaW5rIHRpbWVcIik7XG5cbmFzc2VydCh0eXBlb2YgSW50MzJBcnJheSAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgSW50MzJBcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgIT0gdW5kZWZpbmVkICYmIEludDMyQXJyYXkucHJvdG90eXBlLnNldCAhPSB1bmRlZmluZWQsIFwiSlMgZW5naW5lIGRvZXMgbm90IHByb3ZpZGUgZnVsbCB0eXBlZCBhcnJheSBzdXBwb3J0XCIpO1xuXG5hc3NlcnQoIU1vZHVsZVtcIndhc21NZW1vcnlcIl0sIFwiVXNlIG9mIGB3YXNtTWVtb3J5YCBkZXRlY3RlZC4gIFVzZSAtc0lNUE9SVEVEX01FTU9SWSB0byBkZWZpbmUgd2FzbU1lbW9yeSBleHRlcm5hbGx5XCIpO1xuXG5hc3NlcnQoIU1vZHVsZVtcIklOSVRJQUxfTUVNT1JZXCJdLCBcIkRldGVjdGVkIHJ1bnRpbWUgSU5JVElBTF9NRU1PUlkgc2V0dGluZy4gIFVzZSAtc0lNUE9SVEVEX01FTU9SWSB0byBkZWZpbmUgd2FzbU1lbW9yeSBkeW5hbWljYWxseVwiKTtcblxudmFyIHdhc21UYWJsZTtcblxuZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcbiB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuIGFzc2VydCgobWF4ICYgMykgPT0gMCk7XG4gaWYgKG1heCA9PSAwKSB7XG4gIG1heCArPSA0O1xuIH1cbiBIRUFQVTMyW21heCA+Pj4gMl0gPSAzNDgyMTIyMztcbiBIRUFQVTMyW21heCArIDQgPj4+IDJdID0gMjMxMDcyMTAyMjtcbiBIRUFQVTMyWzAgPj4+IDJdID0gMTY2ODUwOTAyOTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGFja0Nvb2tpZSgpIHtcbiBpZiAoQUJPUlQpIHJldHVybjtcbiB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuIGlmIChtYXggPT0gMCkge1xuICBtYXggKz0gNDtcbiB9XG4gdmFyIGNvb2tpZTEgPSBIRUFQVTMyW21heCA+Pj4gMl07XG4gdmFyIGNvb2tpZTIgPSBIRUFQVTMyW21heCArIDQgPj4+IDJdO1xuIGlmIChjb29raWUxICE9IDM0ODIxMjIzIHx8IGNvb2tpZTIgIT0gMjMxMDcyMTAyMikge1xuICBhYm9ydChgU3RhY2sgb3ZlcmZsb3chIFN0YWNrIGNvb2tpZSBoYXMgYmVlbiBvdmVyd3JpdHRlbiBhdCAke3B0clRvU3RyaW5nKG1heCl9LCBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MjEzNTQ2NywgYnV0IHJlY2VpdmVkICR7cHRyVG9TdHJpbmcoY29va2llMil9ICR7cHRyVG9TdHJpbmcoY29va2llMSl9YCk7XG4gfVxuIGlmIChIRUFQVTMyWzAgPj4+IDJdICE9IDE2Njg1MDkwMjkpIHtcbiAgYWJvcnQoXCJSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSFcIik7XG4gfVxufVxuXG4oZnVuY3Rpb24oKSB7XG4gdmFyIGgxNiA9IG5ldyBJbnQxNkFycmF5KDEpO1xuIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XG4gaDE2WzBdID0gMjU0NTk7XG4gaWYgKGg4WzBdICE9PSAxMTUgfHwgaDhbMV0gIT09IDk5KSB0aHJvdyBcIlJ1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEgKFJ1biB3aXRoIC1zU1VQUE9SVF9CSUdfRU5ESUFOIHRvIGJ5cGFzcylcIjtcbn0pKCk7XG5cbnZhciBfX0FUUFJFUlVOX18gPSBbXTtcblxudmFyIF9fQVRJTklUX18gPSBbXTtcblxudmFyIF9fQVRNQUlOX18gPSBbXTtcblxudmFyIF9fQVRFWElUX18gPSBbXTtcblxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTtcblxudmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG52YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuIHJldHVybiBub0V4aXRSdW50aW1lIHx8IHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID4gMDtcbn1cblxuZnVuY3Rpb24gcHJlUnVuKCkge1xuIGlmIChNb2R1bGVbXCJwcmVSdW5cIl0pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl0gPT0gXCJmdW5jdGlvblwiKSBNb2R1bGVbXCJwcmVSdW5cIl0gPSBbIE1vZHVsZVtcInByZVJ1blwiXSBdO1xuICB3aGlsZSAoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCkge1xuICAgYWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpO1xuICB9XG4gfVxuIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuIGFzc2VydCghcnVudGltZUluaXRpYWxpemVkKTtcbiBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xuIGNoZWNrU3RhY2tDb29raWUoKTtcbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbn1cblxuZnVuY3Rpb24gcHJlTWFpbigpIHtcbiBjaGVja1N0YWNrQ29va2llKCk7XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RSdW4oKSB7XG4gY2hlY2tTdGFja0Nvb2tpZSgpO1xuIGlmIChNb2R1bGVbXCJwb3N0UnVuXCJdKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXSA9PSBcImZ1bmN0aW9uXCIpIE1vZHVsZVtcInBvc3RSdW5cIl0gPSBbIE1vZHVsZVtcInBvc3RSdW5cIl0gXTtcbiAgd2hpbGUgKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKSB7XG4gICBhZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKTtcbiAgfVxuIH1cbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuIF9fQVRJTklUX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlTWFpbihjYikge1xuIF9fQVRNQUlOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge31cblxuZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuYXNzZXJ0KE1hdGguaW11bCwgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmltdWwoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGxcIik7XG5cbmFzc2VydChNYXRoLmZyb3VuZCwgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmZyb3VuZCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxuYXNzZXJ0KE1hdGguY2x6MzIsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5jbHozMigpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxuYXNzZXJ0KE1hdGgudHJ1bmMsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC50cnVuYygpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG5cbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG5cbnZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuXG52YXIgcnVuRGVwZW5kZW5jeVRyYWNraW5nID0ge307XG5cbmZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiB2YXIgb3JpZyA9IGlkO1xuIHdoaWxlICgxKSB7XG4gIGlmICghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSkgcmV0dXJuIGlkO1xuICBpZCA9IG9yaWcgKyBNYXRoLnJhbmRvbSgpO1xuIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcysrO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKGlkKSB7XG4gIGFzc2VydCghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSAxO1xuICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgPT09IG51bGwgJiYgdHlwZW9mIHNldEludGVydmFsICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmIChBQk9SVCkge1xuICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaG93biA9IGZhbHNlO1xuICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgaWYgKCFzaG93bikge1xuICAgICAgc2hvd24gPSB0cnVlO1xuICAgICAgZXJyKFwic3RpbGwgd2FpdGluZyBvbiBydW4gZGVwZW5kZW5jaWVzOlwiKTtcbiAgICAgfVxuICAgICBlcnIoXCJkZXBlbmRlbmN5OiBcIiArIGRlcCk7XG4gICAgfVxuICAgIGlmIChzaG93bikge1xuICAgICBlcnIoXCIoZW5kIG9mIGxpc3QpXCIpO1xuICAgIH1cbiAgIH0sIDFlNCk7XG4gIH1cbiB9IGVsc2Uge1xuICBlcnIoXCJ3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSBhZGRlZCB3aXRob3V0IElEXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcy0tO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKGlkKSB7XG4gIGFzc2VydChydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcbiAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gfSBlbHNlIHtcbiAgZXJyKFwid2FybmluZzogcnVuIGRlcGVuZGVuY3kgcmVtb3ZlZCB3aXRob3V0IElEXCIpO1xuIH1cbiBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XG4gICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgY2FsbGJhY2soKTtcbiAgfVxuIH1cbn1cblxuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuIGlmIChNb2R1bGVbXCJvbkFib3J0XCJdKSB7XG4gIE1vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCk7XG4gfVxuIHdoYXQgPSBcIkFib3J0ZWQoXCIgKyB3aGF0ICsgXCIpXCI7XG4gZXJyKHdoYXQpO1xuIEFCT1JUID0gdHJ1ZTtcbiBFWElUU1RBVFVTID0gMTtcbiBpZiAocnVudGltZUluaXRpYWxpemVkKSB7XG4gIF9fX3RyYXAoKTtcbiB9XG4gdmFyIGUgPSBuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO1xuIHJlYWR5UHJvbWlzZVJlamVjdChlKTtcbiB0aHJvdyBlO1xufVxuXG52YXIgZGF0YVVSSVByZWZpeCA9IFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO1xuXG5mdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpIHtcbiByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KTtcbn1cblxuZnVuY3Rpb24gaXNGaWxlVVJJKGZpbGVuYW1lKSB7XG4gcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFeHBvcnRXcmFwcGVyKG5hbWUsIGZpeGVkYXNtKSB7XG4gcmV0dXJuIGZ1bmN0aW9uKCkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBuYW1lO1xuICB2YXIgYXNtID0gZml4ZWRhc207XG4gIGlmICghZml4ZWRhc20pIHtcbiAgIGFzbSA9IE1vZHVsZVtcImFzbVwiXTtcbiAgfVxuICBhc3NlcnQocnVudGltZUluaXRpYWxpemVkLCBcIm5hdGl2ZSBmdW5jdGlvbiBgXCIgKyBkaXNwbGF5TmFtZSArIFwiYCBjYWxsZWQgYmVmb3JlIHJ1bnRpbWUgaW5pdGlhbGl6YXRpb25cIik7XG4gIGlmICghYXNtW25hbWVdKSB7XG4gICBhc3NlcnQoYXNtW25hbWVdLCBcImV4cG9ydGVkIG5hdGl2ZSBmdW5jdGlvbiBgXCIgKyBkaXNwbGF5TmFtZSArIFwiYCBub3QgZm91bmRcIik7XG4gIH1cbiAgcmV0dXJuIGFzbVtuYW1lXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuIH07XG59XG5cbnZhciB3YXNtQmluYXJ5RmlsZTtcblxuaWYgKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pIHtcbiB3YXNtQmluYXJ5RmlsZSA9IFwiLi9kdWNrZGItZWgud2FzbVwiO1xuIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICB3YXNtQmluYXJ5RmlsZSA9IGxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO1xuIH1cbn0gZWxzZSB7XG4gd2FzbUJpbmFyeUZpbGUgPSBuZXcgVVJMKFwiLi9kdWNrZGItZWgud2FzbVwiLCBpbXBvcnQubWV0YS51cmwpLmhyZWY7XG59XG5cbmZ1bmN0aW9uIGdldEJpbmFyeShmaWxlKSB7XG4gdHJ5IHtcbiAgaWYgKGZpbGUgPT0gd2FzbUJpbmFyeUZpbGUgJiYgd2FzbUJpbmFyeSkge1xuICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdhc21CaW5hcnkpO1xuICB9XG4gIGlmIChyZWFkQmluYXJ5KSB7XG4gICByZXR1cm4gcmVhZEJpbmFyeShmaWxlKTtcbiAgfVxuICB0aHJvdyBcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCI7XG4gfSBjYXRjaCAoZXJyKSB7XG4gIGFib3J0KGVycik7XG4gfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpIHtcbiBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpKSB7XG4gIGlmICh0eXBlb2YgZmV0Y2ggPT0gXCJmdW5jdGlvblwiKSB7XG4gICByZXR1cm4gZmV0Y2goYmluYXJ5RmlsZSwge1xuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGlmICghcmVzcG9uc2VbXCJva1wiXSkge1xuICAgICB0aHJvdyBcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiICsgYmluYXJ5RmlsZSArIFwiJ1wiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VbXCJhcnJheUJ1ZmZlclwiXSgpO1xuICAgfSkuY2F0Y2goKCkgPT4gZ2V0QmluYXJ5KGJpbmFyeUZpbGUpKTtcbiAgfVxuIH1cbiByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBnZXRCaW5hcnkoYmluYXJ5RmlsZSkpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIHJlY2VpdmVyKSB7XG4gcmV0dXJuIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSkudGhlbihiaW5hcnkgPT4ge1xuICByZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LCBpbXBvcnRzKTtcbiB9KS50aGVuKGluc3RhbmNlID0+IHtcbiAgcmV0dXJuIGluc3RhbmNlO1xuIH0pLnRoZW4ocmVjZWl2ZXIsIHJlYXNvbiA9PiB7XG4gIGVycihcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiICsgcmVhc29uKTtcbiAgaWYgKGlzRmlsZVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgIGVycihcIndhcm5pbmc6IExvYWRpbmcgZnJvbSBhIGZpbGUgVVJJIChcIiArIHdhc21CaW5hcnlGaWxlICsgXCIpIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbW9zdCBicm93c2Vycy4gU2VlIGh0dHBzOi8vZW1zY3JpcHRlbi5vcmcvZG9jcy9nZXR0aW5nX3N0YXJ0ZWQvRkFRLmh0bWwjaG93LWRvLWktcnVuLWEtbG9jYWwtd2Vic2VydmVyLWZvci10ZXN0aW5nLXdoeS1kb2VzLW15LXByb2dyYW0tc3RhbGwtaW4tZG93bmxvYWRpbmctb3ItcHJlcGFyaW5nXCIpO1xuICB9XG4gIGFib3J0KHJlYXNvbik7XG4gfSk7XG59XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoYmluYXJ5LCBiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjaykge1xuIGlmICghYmluYXJ5ICYmIHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PSBcImZ1bmN0aW9uXCIgJiYgIWlzRGF0YVVSSShiaW5hcnlGaWxlKSAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiB0eXBlb2YgZmV0Y2ggPT0gXCJmdW5jdGlvblwiKSB7XG4gIHJldHVybiBmZXRjaChiaW5hcnlGaWxlLCB7XG4gICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gIH0pLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgdmFyIHJlc3VsdCA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLCBpbXBvcnRzKTtcbiAgIHJldHVybiByZXN1bHQudGhlbihjYWxsYmFjaywgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgZXJyKFwid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6IFwiICsgcmVhc29uKTtcbiAgICBlcnIoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtcbiAgICByZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCBjYWxsYmFjayk7XG4gICB9KTtcbiAgfSk7XG4gfSBlbHNlIHtcbiAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiB2YXIgaW5mbyA9IHtcbiAgXCJlbnZcIjogd2FzbUltcG9ydHMsXG4gIFwid2FzaV9zbmFwc2hvdF9wcmV2aWV3MVwiOiB3YXNtSW1wb3J0c1xuIH07XG4gZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgdmFyIGV4cG9ydHMgPSBpbnN0YW5jZS5leHBvcnRzO1xuICBNb2R1bGVbXCJhc21cIl0gPSBleHBvcnRzO1xuICB3YXNtTWVtb3J5ID0gTW9kdWxlW1wiYXNtXCJdW1wibWVtb3J5XCJdO1xuICBhc3NlcnQod2FzbU1lbW9yeSwgXCJtZW1vcnkgbm90IGZvdW5kIGluIHdhc20gZXhwb3J0c1wiKTtcbiAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcbiAgd2FzbVRhYmxlID0gTW9kdWxlW1wiYXNtXCJdW1wiX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZVwiXTtcbiAgYXNzZXJ0KHdhc21UYWJsZSwgXCJ0YWJsZSBub3QgZm91bmQgaW4gd2FzbSBleHBvcnRzXCIpO1xuICBhZGRPbkluaXQoTW9kdWxlW1wiYXNtXCJdW1wiX193YXNtX2NhbGxfY3RvcnNcIl0pO1xuICByZW1vdmVSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtcbiAgcmV0dXJuIGV4cG9ydHM7XG4gfVxuIGFkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO1xuIHZhciB0cnVlTW9kdWxlID0gTW9kdWxlO1xuIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCkge1xuICBhc3NlcnQoTW9kdWxlID09PSB0cnVlTW9kdWxlLCBcInRoZSBNb2R1bGUgb2JqZWN0IHNob3VsZCBub3QgYmUgcmVwbGFjZWQgZHVyaW5nIGFzeW5jIGNvbXBpbGF0aW9uIC0gcGVyaGFwcyB0aGUgb3JkZXIgb2YgSFRNTCBlbGVtZW50cyBpcyB3cm9uZz9cIik7XG4gIHRydWVNb2R1bGUgPSBudWxsO1xuICByZWNlaXZlSW5zdGFuY2UocmVzdWx0W1wiaW5zdGFuY2VcIl0pO1xuIH1cbiBpZiAoTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKSB7XG4gIHRyeSB7XG4gICByZXR1cm4gTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKGluZm8sIHJlY2VpdmVJbnN0YW5jZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgIGVycihcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiICsgZSk7XG4gICByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gIH1cbiB9XG4gaW5zdGFudGlhdGVBc3luYyh3YXNtQmluYXJ5LCB3YXNtQmluYXJ5RmlsZSwgaW5mbywgcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpLmNhdGNoKHJlYWR5UHJvbWlzZVJlamVjdCk7XG4gcmV0dXJuIHt9O1xufVxuXG52YXIgdGVtcERvdWJsZTtcblxudmFyIHRlbXBJNjQ7XG5cbmZ1bmN0aW9uIGxlZ2FjeU1vZHVsZVByb3AocHJvcCwgbmV3TmFtZSkge1xuIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGUsIHByb3AsIHtcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgYWJvcnQoXCJNb2R1bGUuXCIgKyBwcm9wICsgXCIgaGFzIGJlZW4gcmVwbGFjZWQgd2l0aCBwbGFpbiBcIiArIG5ld05hbWUgKyBcIiAodGhlIGluaXRpYWwgdmFsdWUgY2FuIGJlIHByb3ZpZGVkIG9uIE1vZHVsZSwgYnV0IGFmdGVyIHN0YXJ0dXAgdGhlIHZhbHVlIGlzIG9ubHkgbG9va2VkIGZvciBvbiBhIGxvY2FsIHZhcmlhYmxlIG9mIHRoYXQgbmFtZSlcIik7XG4gICB9XG4gIH0pO1xuIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlZE1vZHVsZVByb3AocHJvcCkge1xuIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgcHJvcCkpIHtcbiAgYWJvcnQoXCJgTW9kdWxlLlwiICsgcHJvcCArIFwiYCB3YXMgc3VwcGxpZWQgYnV0IGBcIiArIHByb3AgKyBcImAgbm90IGluY2x1ZGVkIGluIElOQ09NSU5HX01PRFVMRV9KU19BUElcIik7XG4gfVxufVxuXG5mdW5jdGlvbiBpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0obmFtZSkge1xuIHJldHVybiBuYW1lID09PSBcIkZTX2NyZWF0ZVBhdGhcIiB8fCBuYW1lID09PSBcIkZTX2NyZWF0ZURhdGFGaWxlXCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVQcmVsb2FkZWRGaWxlXCIgfHwgbmFtZSA9PT0gXCJGU191bmxpbmtcIiB8fCBuYW1lID09PSBcImFkZFJ1bkRlcGVuZGVuY3lcIiB8fCBuYW1lID09PSBcIkZTX2NyZWF0ZUxhenlGaWxlXCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVEZXZpY2VcIiB8fCBuYW1lID09PSBcInJlbW92ZVJ1bkRlcGVuZGVuY3lcIjtcbn1cblxuZnVuY3Rpb24gbWlzc2luZ0dsb2JhbChzeW0sIG1zZykge1xuIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHdhcm5PbmNlKFwiYFwiICsgc3ltICsgXCJgIGlzIG5vdCBsb25nZXIgZGVmaW5lZCBieSBlbXNjcmlwdGVuLiBcIiArIG1zZyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgIH1cbiAgfSk7XG4gfVxufVxuXG5taXNzaW5nR2xvYmFsKFwiYnVmZmVyXCIsIFwiUGxlYXNlIHVzZSBIRUFQOC5idWZmZXIgb3Igd2FzbU1lbW9yeS5idWZmZXJcIik7XG5cbmZ1bmN0aW9uIG1pc3NpbmdMaWJyYXJ5U3ltYm9sKHN5bSkge1xuIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWxUaGlzLCBzeW0pKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBzeW0sIHtcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1zZyA9IFwiYFwiICsgc3ltICsgXCJgIGlzIGEgbGlicmFyeSBzeW1ib2wgYW5kIG5vdCBpbmNsdWRlZCBieSBkZWZhdWx0OyBhZGQgaXQgdG8geW91ciBsaWJyYXJ5LmpzIF9fZGVwcyBvciB0byBERUZBVUxUX0xJQlJBUllfRlVOQ1NfVE9fSU5DTFVERSBvbiB0aGUgY29tbWFuZCBsaW5lXCI7XG4gICAgdmFyIGxpYnJhcnlTeW1ib2wgPSBzeW07XG4gICAgaWYgKCFsaWJyYXJ5U3ltYm9sLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgIGxpYnJhcnlTeW1ib2wgPSBcIiRcIiArIHN5bTtcbiAgICB9XG4gICAgbXNnICs9IFwiIChlLmcuIC1zREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREU9XCIgKyBsaWJyYXJ5U3ltYm9sICsgXCIpXCI7XG4gICAgaWYgKGlzRXhwb3J0ZWRCeUZvcmNlRmlsZXN5c3RlbShzeW0pKSB7XG4gICAgIG1zZyArPSBcIi4gQWx0ZXJuYXRpdmVseSwgZm9yY2luZyBmaWxlc3lzdGVtIHN1cHBvcnQgKC1zRk9SQ0VfRklMRVNZU1RFTSkgY2FuIGV4cG9ydCB0aGlzIGZvciB5b3VcIjtcbiAgICB9XG4gICAgd2Fybk9uY2UobXNnKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgfVxuICB9KTtcbiB9XG4gdW5leHBvcnRlZFJ1bnRpbWVTeW1ib2woc3ltKTtcbn1cblxuZnVuY3Rpb24gdW5leHBvcnRlZFJ1bnRpbWVTeW1ib2woc3ltKSB7XG4gaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZSwgc3ltKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBzeW0sIHtcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1zZyA9IFwiJ1wiICsgc3ltICsgXCInIHdhcyBub3QgZXhwb3J0ZWQuIGFkZCBpdCB0byBFWFBPUlRFRF9SVU5USU1FX01FVEhPRFMgKHNlZSB0aGUgRkFRKVwiO1xuICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xuICAgICBtc2cgKz0gXCIuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtc0ZPUkNFX0ZJTEVTWVNURU0pIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCI7XG4gICAgfVxuICAgIGFib3J0KG1zZyk7XG4gICB9XG4gIH0pO1xuIH1cbn1cblxuZnVuY3Rpb24gZGJnKHRleHQpIHtcbiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiB0aGlzLm5hbWUgPSBcIkV4aXRTdGF0dXNcIjtcbiB0aGlzLm1lc3NhZ2UgPSBgUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgke3N0YXR1c30pYDtcbiB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbn1cblxuZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7XG4gd2hpbGUgKGNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XG4gIGNhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSk7XG4gfVxufVxuXG5mdW5jdGlvbiBnZXRDcHBFeGNlcHRpb25UYWcoKSB7XG4gcmV0dXJuIE1vZHVsZVtcImFzbVwiXVtcIl9fY3BwX2V4Y2VwdGlvblwiXTtcbn1cblxuZnVuY3Rpb24gZ2V0Q3BwRXhjZXB0aW9uVGhyb3duT2JqZWN0RnJvbVdlYkFzc2VtYmx5RXhjZXB0aW9uKGV4KSB7XG4gdmFyIHVud2luZF9oZWFkZXIgPSBleC5nZXRBcmcoZ2V0Q3BwRXhjZXB0aW9uVGFnKCksIDApO1xuIHJldHVybiBfX190aHJvd25fb2JqZWN0X2Zyb21fdW53aW5kX2V4Y2VwdGlvbih1bndpbmRfaGVhZGVyKTtcbn1cblxuZnVuY3Rpb24gZGVjcmVtZW50RXhjZXB0aW9uUmVmY291bnQoZXgpIHtcbiB2YXIgcHRyID0gZ2V0Q3BwRXhjZXB0aW9uVGhyb3duT2JqZWN0RnJvbVdlYkFzc2VtYmx5RXhjZXB0aW9uKGV4KTtcbiBfX19jeGFfZGVjcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudChwdHIpO1xufVxuXG5mdW5jdGlvbiB3aXRoU3RhY2tTYXZlKGYpIHtcbiB2YXIgc3RhY2sgPSBzdGFja1NhdmUoKTtcbiB2YXIgcmV0ID0gZigpO1xuIHN0YWNrUmVzdG9yZShzdGFjayk7XG4gcmV0dXJuIHJldDtcbn1cblxudmFyIFVURjhEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9IFwidW5kZWZpbmVkXCIgPyBuZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBVVEY4QXJyYXlUb1N0cmluZyhoZWFwT3JBcnJheSwgaWR4LCBtYXhCeXRlc1RvUmVhZCkge1xuIGlkeCA+Pj49IDA7XG4gdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuIHZhciBlbmRQdHIgPSBpZHg7XG4gd2hpbGUgKGhlYXBPckFycmF5W2VuZFB0cl0gJiYgIShlbmRQdHIgPj0gZW5kSWR4KSkgKytlbmRQdHI7XG4gaWYgKGVuZFB0ciAtIGlkeCA+IDE2ICYmIGhlYXBPckFycmF5LmJ1ZmZlciAmJiBVVEY4RGVjb2Rlcikge1xuICByZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCwgZW5kUHRyKSk7XG4gfVxuIHZhciBzdHIgPSBcIlwiO1xuIHdoaWxlIChpZHggPCBlbmRQdHIpIHtcbiAgdmFyIHUwID0gaGVhcE9yQXJyYXlbaWR4KytdO1xuICBpZiAoISh1MCAmIDEyOCkpIHtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciB1MSA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICBpZiAoKHUwICYgMjI0KSA9PSAxOTIpIHtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCh1MCAmIDMxKSA8PCA2IHwgdTEpO1xuICAgY29udGludWU7XG4gIH1cbiAgdmFyIHUyID0gaGVhcE9yQXJyYXlbaWR4KytdICYgNjM7XG4gIGlmICgodTAgJiAyNDApID09IDIyNCkge1xuICAgdTAgPSAodTAgJiAxNSkgPDwgMTIgfCB1MSA8PCA2IHwgdTI7XG4gIH0gZWxzZSB7XG4gICBpZiAoKHUwICYgMjQ4KSAhPSAyNDApIHdhcm5PbmNlKFwiSW52YWxpZCBVVEYtOCBsZWFkaW5nIGJ5dGUgXCIgKyBwdHJUb1N0cmluZyh1MCkgKyBcIiBlbmNvdW50ZXJlZCB3aGVuIGRlc2VyaWFsaXppbmcgYSBVVEYtOCBzdHJpbmcgaW4gd2FzbSBtZW1vcnkgdG8gYSBKUyBzdHJpbmchXCIpO1xuICAgdTAgPSAodTAgJiA3KSA8PCAxOCB8IHUxIDw8IDEyIHwgdTIgPDwgNiB8IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICB9XG4gIGlmICh1MCA8IDY1NTM2KSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gIH0gZWxzZSB7XG4gICB2YXIgY2ggPSB1MCAtIDY1NTM2O1xuICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCBjaCA+PiAxMCwgNTYzMjAgfCBjaCAmIDEwMjMpO1xuICB9XG4gfVxuIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gYXNzZXJ0KHR5cGVvZiBwdHIgPT0gXCJudW1iZXJcIik7XG4gcHRyID4+Pj0gMDtcbiByZXR1cm4gcHRyID8gVVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LCBwdHIsIG1heEJ5dGVzVG9SZWFkKSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2VwdGlvbk1lc3NhZ2VDb21tb24ocHRyKSB7XG4gcmV0dXJuIHdpdGhTdGFja1NhdmUoZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlX2FkZHJfYWRkciA9IHN0YWNrQWxsb2MoNCk7XG4gIHZhciBtZXNzYWdlX2FkZHJfYWRkciA9IHN0YWNrQWxsb2MoNCk7XG4gIF9fX2dldF9leGNlcHRpb25fbWVzc2FnZShwdHIsIHR5cGVfYWRkcl9hZGRyLCBtZXNzYWdlX2FkZHJfYWRkcik7XG4gIHZhciB0eXBlX2FkZHIgPSBIRUFQVTMyW3R5cGVfYWRkcl9hZGRyID4+PiAyXTtcbiAgdmFyIG1lc3NhZ2VfYWRkciA9IEhFQVBVMzJbbWVzc2FnZV9hZGRyX2FkZHIgPj4+IDJdO1xuICB2YXIgdHlwZSA9IFVURjhUb1N0cmluZyh0eXBlX2FkZHIpO1xuICBfZnJlZSh0eXBlX2FkZHIpO1xuICB2YXIgbWVzc2FnZTtcbiAgaWYgKG1lc3NhZ2VfYWRkcikge1xuICAgbWVzc2FnZSA9IFVURjhUb1N0cmluZyhtZXNzYWdlX2FkZHIpO1xuICAgX2ZyZWUobWVzc2FnZV9hZGRyKTtcbiAgfVxuICByZXR1cm4gWyB0eXBlLCBtZXNzYWdlIF07XG4gfSk7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2VwdGlvbk1lc3NhZ2UoZXgpIHtcbiB2YXIgcHRyID0gZ2V0Q3BwRXhjZXB0aW9uVGhyb3duT2JqZWN0RnJvbVdlYkFzc2VtYmx5RXhjZXB0aW9uKGV4KTtcbiByZXR1cm4gZ2V0RXhjZXB0aW9uTWVzc2FnZUNvbW1vbihwdHIpO1xufVxuXG5Nb2R1bGVbXCJnZXRFeGNlcHRpb25NZXNzYWdlXCJdID0gZ2V0RXhjZXB0aW9uTWVzc2FnZTtcblxuZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlID0gXCJpOFwiKSB7XG4gaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB0eXBlID0gXCIqXCI7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSBcImkxXCI6XG4gIHJldHVybiBIRUFQOFtwdHIgPj4+IDBdO1xuXG4gY2FzZSBcImk4XCI6XG4gIHJldHVybiBIRUFQOFtwdHIgPj4+IDBdO1xuXG4gY2FzZSBcImkxNlwiOlxuICByZXR1cm4gSEVBUDE2W3B0ciA+Pj4gMV07XG5cbiBjYXNlIFwiaTMyXCI6XG4gIHJldHVybiBIRUFQMzJbcHRyID4+PiAyXTtcblxuIGNhc2UgXCJpNjRcIjpcbiAgYWJvcnQoXCJ0byBkbyBnZXRWYWx1ZShpNjQpIHVzZSBXQVNNX0JJR0lOVFwiKTtcblxuIGNhc2UgXCJmbG9hdFwiOlxuICByZXR1cm4gSEVBUEYzMltwdHIgPj4+IDJdO1xuXG4gY2FzZSBcImRvdWJsZVwiOlxuICByZXR1cm4gSEVBUEY2NFtwdHIgPj4+IDNdO1xuXG4gY2FzZSBcIipcIjpcbiAgcmV0dXJuIEhFQVBVMzJbcHRyID4+PiAyXTtcblxuIGRlZmF1bHQ6XG4gIGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAke3R5cGV9YCk7XG4gfVxufVxuXG5mdW5jdGlvbiBpbmNyZW1lbnRFeGNlcHRpb25SZWZjb3VudChleCkge1xuIHZhciBwdHIgPSBnZXRDcHBFeGNlcHRpb25UaHJvd25PYmplY3RGcm9tV2ViQXNzZW1ibHlFeGNlcHRpb24oZXgpO1xuIF9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50KHB0cik7XG59XG5cbmZ1bmN0aW9uIHB0clRvU3RyaW5nKHB0cikge1xuIGFzc2VydCh0eXBlb2YgcHRyID09PSBcIm51bWJlclwiKTtcbiByZXR1cm4gXCIweFwiICsgcHRyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG59XG5cbmZ1bmN0aW9uIHNldFZhbHVlKHB0ciwgdmFsdWUsIHR5cGUgPSBcImk4XCIpIHtcbiBpZiAodHlwZS5lbmRzV2l0aChcIipcIikpIHR5cGUgPSBcIipcIjtcbiBzd2l0Y2ggKHR5cGUpIHtcbiBjYXNlIFwiaTFcIjpcbiAgSEVBUDhbcHRyID4+PiAwXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJpOFwiOlxuICBIRUFQOFtwdHIgPj4+IDBdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcImkxNlwiOlxuICBIRUFQMTZbcHRyID4+PiAxXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJpMzJcIjpcbiAgSEVBUDMyW3B0ciA+Pj4gMl0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaTY0XCI6XG4gIGFib3J0KFwidG8gZG8gc2V0VmFsdWUoaTY0KSB1c2UgV0FTTV9CSUdJTlRcIik7XG5cbiBjYXNlIFwiZmxvYXRcIjpcbiAgSEVBUEYzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcImRvdWJsZVwiOlxuICBIRUFQRjY0W3B0ciA+Pj4gM10gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiKlwiOlxuICBIRUFQVTMyW3B0ciA+Pj4gMl0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBkZWZhdWx0OlxuICBhYm9ydChgaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJHt0eXBlfWApO1xuIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uY2UodGV4dCkge1xuIGlmICghd2Fybk9uY2Uuc2hvd24pIHdhcm5PbmNlLnNob3duID0ge307XG4gaWYgKCF3YXJuT25jZS5zaG93blt0ZXh0XSkge1xuICB3YXJuT25jZS5zaG93blt0ZXh0XSA9IDE7XG4gIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB0ZXh0ID0gXCJ3YXJuaW5nOiBcIiArIHRleHQ7XG4gIGVycih0ZXh0KTtcbiB9XG59XG5cbmZ1bmN0aW9uIF9YTUxfR2V0QnVmZmVyKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9HZXRCdWZmZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX0dldEVycm9yQ29kZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfR2V0RXJyb3JDb2RlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1BhcnNlQnVmZmVyKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZUJ1ZmZlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfUGFyc2VyQ3JlYXRlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZXJDcmVhdGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1BhcnNlckZyZWUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1BhcnNlckZyZWVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1Jlc3VtZVBhcnNlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUmVzdW1lUGFyc2VyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9TZXRDaGFyYWN0ZXJEYXRhSGFuZGxlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1NldEVsZW1lbnRIYW5kbGVyKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9TZXRFbGVtZW50SGFuZGxlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU2V0VXNlckRhdGEoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldFVzZXJEYXRhXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9TdG9wUGFyc2VyKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9TdG9wUGFyc2VyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX19fYXNzZXJ0X2ZhaWwoY29uZGl0aW9uLCBmaWxlbmFtZSwgbGluZSwgZnVuYykge1xuIGFib3J0KGBBc3NlcnRpb24gZmFpbGVkOiAke1VURjhUb1N0cmluZyhjb25kaXRpb24pfSwgYXQ6IGAgKyBbIGZpbGVuYW1lID8gVVRGOFRvU3RyaW5nKGZpbGVuYW1lKSA6IFwidW5rbm93biBmaWxlbmFtZVwiLCBsaW5lLCBmdW5jID8gVVRGOFRvU3RyaW5nKGZ1bmMpIDogXCJ1bmtub3duIGZ1bmN0aW9uXCIgXSk7XG59XG5cbnZhciBkbG9wZW5NaXNzaW5nRXJyb3IgPSBcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvY29tcGlsaW5nL0R5bmFtaWMtTGlua2luZy5odG1sXCI7XG5cbmZ1bmN0aW9uIF9fX2Rsc3ltKGhhbmRsZSwgc3ltYm9sLCByYSkge1xuIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG59XG5cbnZhciBTWVNDQUxMUyA9IHtcbiB2YXJhcmdzOiB1bmRlZmluZWQsXG4gZ2V0OiBmdW5jdGlvbigpIHtcbiAgYXNzZXJ0KFNZU0NBTExTLnZhcmFyZ3MgIT0gdW5kZWZpbmVkKTtcbiAgU1lTQ0FMTFMudmFyYXJncyArPSA0O1xuICB2YXIgcmV0ID0gSEVBUDMyW1NZU0NBTExTLnZhcmFyZ3MgLSA0ID4+PiAyXTtcbiAgcmV0dXJuIHJldDtcbiB9LFxuIGdldFN0cjogZnVuY3Rpb24ocHRyKSB7XG4gIHZhciByZXQgPSBVVEY4VG9TdHJpbmcocHRyKTtcbiAgcmV0dXJuIHJldDtcbiB9XG59O1xuXG5mdW5jdGlvbiBfX19zeXNjYWxsX19uZXdzZWxlY3QobmZkcywgcmVhZGZkcywgd3JpdGVmZHMsIGV4Y2VwdGZkcywgdGltZW91dCkge1xuIGFzc2VydChuZmRzIDw9IDY0LCBcIm5mZHMgbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gNjRcIik7XG4gYXNzZXJ0KCFleGNlcHRmZHMsIFwiZXhjZXB0ZmRzIG5vdCBzdXBwb3J0ZWRcIik7XG4gdmFyIHRvdGFsID0gMDtcbiB2YXIgc3JjUmVhZExvdyA9IHJlYWRmZHMgPyBIRUFQMzJbcmVhZGZkcyA+Pj4gMl0gOiAwLCBzcmNSZWFkSGlnaCA9IHJlYWRmZHMgPyBIRUFQMzJbcmVhZGZkcyArIDQgPj4+IDJdIDogMDtcbiB2YXIgc3JjV3JpdGVMb3cgPSB3cml0ZWZkcyA/IEhFQVAzMlt3cml0ZWZkcyA+Pj4gMl0gOiAwLCBzcmNXcml0ZUhpZ2ggPSB3cml0ZWZkcyA/IEhFQVAzMlt3cml0ZWZkcyArIDQgPj4+IDJdIDogMDtcbiB2YXIgc3JjRXhjZXB0TG93ID0gZXhjZXB0ZmRzID8gSEVBUDMyW2V4Y2VwdGZkcyA+Pj4gMl0gOiAwLCBzcmNFeGNlcHRIaWdoID0gZXhjZXB0ZmRzID8gSEVBUDMyW2V4Y2VwdGZkcyArIDQgPj4+IDJdIDogMDtcbiB2YXIgZHN0UmVhZExvdyA9IDAsIGRzdFJlYWRIaWdoID0gMDtcbiB2YXIgZHN0V3JpdGVMb3cgPSAwLCBkc3RXcml0ZUhpZ2ggPSAwO1xuIHZhciBkc3RFeGNlcHRMb3cgPSAwLCBkc3RFeGNlcHRIaWdoID0gMDtcbiB2YXIgYWxsTG93ID0gKHJlYWRmZHMgPyBIRUFQMzJbcmVhZGZkcyA+Pj4gMl0gOiAwKSB8ICh3cml0ZWZkcyA/IEhFQVAzMlt3cml0ZWZkcyA+Pj4gMl0gOiAwKSB8IChleGNlcHRmZHMgPyBIRUFQMzJbZXhjZXB0ZmRzID4+PiAyXSA6IDApO1xuIHZhciBhbGxIaWdoID0gKHJlYWRmZHMgPyBIRUFQMzJbcmVhZGZkcyArIDQgPj4+IDJdIDogMCkgfCAod3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA6IDApIHwgKGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgKyA0ID4+PiAyXSA6IDApO1xuIHZhciBjaGVjayA9IGZ1bmN0aW9uKGZkLCBsb3csIGhpZ2gsIHZhbCkge1xuICByZXR1cm4gZmQgPCAzMiA/IGxvdyAmIHZhbCA6IGhpZ2ggJiB2YWw7XG4gfTtcbiBmb3IgKHZhciBmZCA9IDA7IGZkIDwgbmZkczsgZmQrKykge1xuICB2YXIgbWFzayA9IDEgPDwgZmQgJSAzMjtcbiAgaWYgKCFjaGVjayhmZCwgYWxsTG93LCBhbGxIaWdoLCBtYXNrKSkge1xuICAgY29udGludWU7XG4gIH1cbiAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gIHZhciBmbGFncyA9IFNZU0NBTExTLkRFRkFVTFRfUE9MTE1BU0s7XG4gIGlmIChzdHJlYW0uc3RyZWFtX29wcy5wb2xsKSB7XG4gICBmbGFncyA9IHN0cmVhbS5zdHJlYW1fb3BzLnBvbGwoc3RyZWFtKTtcbiAgfVxuICBpZiAoZmxhZ3MgJiAxICYmIGNoZWNrKGZkLCBzcmNSZWFkTG93LCBzcmNSZWFkSGlnaCwgbWFzaykpIHtcbiAgIGZkIDwgMzIgPyBkc3RSZWFkTG93ID0gZHN0UmVhZExvdyB8IG1hc2sgOiBkc3RSZWFkSGlnaCA9IGRzdFJlYWRIaWdoIHwgbWFzaztcbiAgIHRvdGFsKys7XG4gIH1cbiAgaWYgKGZsYWdzICYgNCAmJiBjaGVjayhmZCwgc3JjV3JpdGVMb3csIHNyY1dyaXRlSGlnaCwgbWFzaykpIHtcbiAgIGZkIDwgMzIgPyBkc3RXcml0ZUxvdyA9IGRzdFdyaXRlTG93IHwgbWFzayA6IGRzdFdyaXRlSGlnaCA9IGRzdFdyaXRlSGlnaCB8IG1hc2s7XG4gICB0b3RhbCsrO1xuICB9XG4gIGlmIChmbGFncyAmIDIgJiYgY2hlY2soZmQsIHNyY0V4Y2VwdExvdywgc3JjRXhjZXB0SGlnaCwgbWFzaykpIHtcbiAgIGZkIDwgMzIgPyBkc3RFeGNlcHRMb3cgPSBkc3RFeGNlcHRMb3cgfCBtYXNrIDogZHN0RXhjZXB0SGlnaCA9IGRzdEV4Y2VwdEhpZ2ggfCBtYXNrO1xuICAgdG90YWwrKztcbiAgfVxuIH1cbiBpZiAocmVhZGZkcykge1xuICBIRUFQMzJbcmVhZGZkcyA+Pj4gMl0gPSBkc3RSZWFkTG93O1xuICBIRUFQMzJbcmVhZGZkcyArIDQgPj4+IDJdID0gZHN0UmVhZEhpZ2g7XG4gfVxuIGlmICh3cml0ZWZkcykge1xuICBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdID0gZHN0V3JpdGVMb3c7XG4gIEhFQVAzMlt3cml0ZWZkcyArIDQgPj4+IDJdID0gZHN0V3JpdGVIaWdoO1xuIH1cbiBpZiAoZXhjZXB0ZmRzKSB7XG4gIEhFQVAzMltleGNlcHRmZHMgPj4+IDJdID0gZHN0RXhjZXB0TG93O1xuICBIRUFQMzJbZXhjZXB0ZmRzICsgNCA+Pj4gMl0gPSBkc3RFeGNlcHRIaWdoO1xuIH1cbiByZXR1cm4gdG90YWw7XG59XG5cbmZ1bmN0aW9uIFNPQ0tGUygpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiAkU09DS0ZTXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gRlMoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogJEZTXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gZ2V0U29ja2V0RnJvbUZEKGZkKSB7XG4gdmFyIHNvY2tldCA9IFNPQ0tGUy5nZXRTb2NrZXQoZmQpO1xuIGlmICghc29ja2V0KSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiByZXR1cm4gc29ja2V0O1xufVxuXG5mdW5jdGlvbiBzZXRFcnJObyh2YWx1ZSkge1xuIEhFQVAzMltfX19lcnJub19sb2NhdGlvbigpID4+PiAyXSA9IHZhbHVlO1xuIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIFNvY2tldHMgPSB7XG4gQlVGRkVSX1NJWkU6IDEwMjQwLFxuIE1BWF9CVUZGRVJfU0laRTogMTA0ODU3NjAsXG4gbmV4dEZkOiAxLFxuIGZkczoge30sXG4gbmV4dHBvcnQ6IDEsXG4gbWF4cG9ydDogNjU1MzUsXG4gcGVlcjogbnVsbCxcbiBjb25uZWN0aW9uczoge30sXG4gcG9ydG1hcDoge30sXG4gbG9jYWxBZGRyOiA0MjYxNDEyODc0LFxuIGFkZHJQb29sOiBbIDMzNTU0NDQyLCA1MDMzMTY1OCwgNjcxMDg4NzQsIDgzODg2MDkwLCAxMDA2NjMzMDYsIDExNzQ0MDUyMiwgMTM0MjE3NzM4LCAxNTA5OTQ5NTQsIDE2Nzc3MjE3MCwgMTg0NTQ5Mzg2LCAyMDEzMjY2MDIsIDIxODEwMzgxOCwgMjM0ODgxMDM0IF1cbn07XG5cbmZ1bmN0aW9uIGluZXROdG9wNChhZGRyKSB7XG4gcmV0dXJuIChhZGRyICYgMjU1KSArIFwiLlwiICsgKGFkZHIgPj4gOCAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDE2ICYgMjU1KSArIFwiLlwiICsgKGFkZHIgPj4gMjQgJiAyNTUpO1xufVxuXG5mdW5jdGlvbiBpbmV0TnRvcDYoaW50cykge1xuIHZhciBzdHIgPSBcIlwiO1xuIHZhciB3b3JkID0gMDtcbiB2YXIgbG9uZ2VzdCA9IDA7XG4gdmFyIGxhc3R6ZXJvID0gMDtcbiB2YXIgenN0YXJ0ID0gMDtcbiB2YXIgbGVuID0gMDtcbiB2YXIgaSA9IDA7XG4gdmFyIHBhcnRzID0gWyBpbnRzWzBdICYgNjU1MzUsIGludHNbMF0gPj4gMTYsIGludHNbMV0gJiA2NTUzNSwgaW50c1sxXSA+PiAxNiwgaW50c1syXSAmIDY1NTM1LCBpbnRzWzJdID4+IDE2LCBpbnRzWzNdICYgNjU1MzUsIGludHNbM10gPj4gMTYgXTtcbiB2YXIgaGFzaXB2NCA9IHRydWU7XG4gdmFyIHY0cGFydCA9IFwiXCI7XG4gZm9yIChpID0gMDsgaSA8IDU7IGkrKykge1xuICBpZiAocGFydHNbaV0gIT09IDApIHtcbiAgIGhhc2lwdjQgPSBmYWxzZTtcbiAgIGJyZWFrO1xuICB9XG4gfVxuIGlmIChoYXNpcHY0KSB7XG4gIHY0cGFydCA9IGluZXROdG9wNChwYXJ0c1s2XSB8IHBhcnRzWzddIDw8IDE2KTtcbiAgaWYgKHBhcnRzWzVdID09PSAtMSkge1xuICAgc3RyID0gXCI6OmZmZmY6XCI7XG4gICBzdHIgKz0gdjRwYXJ0O1xuICAgcmV0dXJuIHN0cjtcbiAgfVxuICBpZiAocGFydHNbNV0gPT09IDApIHtcbiAgIHN0ciA9IFwiOjpcIjtcbiAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMFwiKSB2NHBhcnQgPSBcIlwiO1xuICAgaWYgKHY0cGFydCA9PT0gXCIwLjAuMC4xXCIpIHY0cGFydCA9IFwiMVwiO1xuICAgc3RyICs9IHY0cGFydDtcbiAgIHJldHVybiBzdHI7XG4gIH1cbiB9XG4gZm9yICh3b3JkID0gMDsgd29yZCA8IDg7IHdvcmQrKykge1xuICBpZiAocGFydHNbd29yZF0gPT09IDApIHtcbiAgIGlmICh3b3JkIC0gbGFzdHplcm8gPiAxKSB7XG4gICAgbGVuID0gMDtcbiAgIH1cbiAgIGxhc3R6ZXJvID0gd29yZDtcbiAgIGxlbisrO1xuICB9XG4gIGlmIChsZW4gPiBsb25nZXN0KSB7XG4gICBsb25nZXN0ID0gbGVuO1xuICAgenN0YXJ0ID0gd29yZCAtIGxvbmdlc3QgKyAxO1xuICB9XG4gfVxuIGZvciAod29yZCA9IDA7IHdvcmQgPCA4OyB3b3JkKyspIHtcbiAgaWYgKGxvbmdlc3QgPiAxKSB7XG4gICBpZiAocGFydHNbd29yZF0gPT09IDAgJiYgd29yZCA+PSB6c3RhcnQgJiYgd29yZCA8IHpzdGFydCArIGxvbmdlc3QpIHtcbiAgICBpZiAod29yZCA9PT0genN0YXJ0KSB7XG4gICAgIHN0ciArPSBcIjpcIjtcbiAgICAgaWYgKHpzdGFydCA9PT0gMCkgc3RyICs9IFwiOlwiO1xuICAgIH1cbiAgICBjb250aW51ZTtcbiAgIH1cbiAgfVxuICBzdHIgKz0gTnVtYmVyKF9udG9ocyhwYXJ0c1t3b3JkXSAmIDY1NTM1KSkudG9TdHJpbmcoMTYpO1xuICBzdHIgKz0gd29yZCA8IDcgPyBcIjpcIiA6IFwiXCI7XG4gfVxuIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHJlYWRTb2NrYWRkcihzYSwgc2FsZW4pIHtcbiB2YXIgZmFtaWx5ID0gSEVBUDE2W3NhID4+PiAxXTtcbiB2YXIgcG9ydCA9IF9udG9ocyhIRUFQVTE2W3NhICsgMiA+Pj4gMV0pO1xuIHZhciBhZGRyO1xuIHN3aXRjaCAoZmFtaWx5KSB7XG4gY2FzZSAyOlxuICBpZiAoc2FsZW4gIT09IDE2KSB7XG4gICByZXR1cm4ge1xuICAgIGVycm5vOiAyOFxuICAgfTtcbiAgfVxuICBhZGRyID0gSEVBUDMyW3NhICsgNCA+Pj4gMl07XG4gIGFkZHIgPSBpbmV0TnRvcDQoYWRkcik7XG4gIGJyZWFrO1xuXG4gY2FzZSAxMDpcbiAgaWYgKHNhbGVuICE9PSAyOCkge1xuICAgcmV0dXJuIHtcbiAgICBlcnJubzogMjhcbiAgIH07XG4gIH1cbiAgYWRkciA9IFsgSEVBUDMyW3NhICsgOCA+Pj4gMl0sIEhFQVAzMltzYSArIDEyID4+PiAyXSwgSEVBUDMyW3NhICsgMTYgPj4+IDJdLCBIRUFQMzJbc2EgKyAyMCA+Pj4gMl0gXTtcbiAgYWRkciA9IGluZXROdG9wNihhZGRyKTtcbiAgYnJlYWs7XG5cbiBkZWZhdWx0OlxuICByZXR1cm4ge1xuICAgZXJybm86IDVcbiAgfTtcbiB9XG4gcmV0dXJuIHtcbiAgZmFtaWx5OiBmYW1pbHksXG4gIGFkZHI6IGFkZHIsXG4gIHBvcnQ6IHBvcnRcbiB9O1xufVxuXG5mdW5jdGlvbiBpbmV0UHRvbjQoc3RyKSB7XG4gdmFyIGIgPSBzdHIuc3BsaXQoXCIuXCIpO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gIHZhciB0bXAgPSBOdW1iZXIoYltpXSk7XG4gIGlmIChpc05hTih0bXApKSByZXR1cm4gbnVsbDtcbiAgYltpXSA9IHRtcDtcbiB9XG4gcmV0dXJuIChiWzBdIHwgYlsxXSA8PCA4IHwgYlsyXSA8PCAxNiB8IGJbM10gPDwgMjQpID4+PiAwO1xufVxuXG5mdW5jdGlvbiBqc3RvaV9xKHN0cikge1xuIHJldHVybiBwYXJzZUludChzdHIpO1xufVxuXG5mdW5jdGlvbiBpbmV0UHRvbjYoc3RyKSB7XG4gdmFyIHdvcmRzO1xuIHZhciB3LCBvZmZzZXQsIHosIGk7XG4gdmFyIHZhbGlkNnJlZ3ggPSAvXigoPz0uKjo6KSg/IS4qOjouKzo6KSg6Oik/KFtcXGRBLUZdezEsNH06KDp8XFxiKXwpezV9fChbXFxkQS1GXXsxLDR9Oil7Nn0pKCgoW1xcZEEtRl17MSw0fSgoPyFcXDMpOjp8OlxcYnwkKSl8KD8hXFwyXFwzKSl7Mn18KCgoMlswLTRdfDFcXGR8WzEtOV0pP1xcZHwyNVswLTVdKVxcLj9cXGIpezR9KSQvaTtcbiB2YXIgcGFydHMgPSBbXTtcbiBpZiAoIXZhbGlkNnJlZ3gudGVzdChzdHIpKSB7XG4gIHJldHVybiBudWxsO1xuIH1cbiBpZiAoc3RyID09PSBcIjo6XCIpIHtcbiAgcmV0dXJuIFsgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCBdO1xuIH1cbiBpZiAoc3RyLnN0YXJ0c1dpdGgoXCI6OlwiKSkge1xuICBzdHIgPSBzdHIucmVwbGFjZShcIjo6XCIsIFwiWjpcIik7XG4gfSBlbHNlIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UoXCI6OlwiLCBcIjpaOlwiKTtcbiB9XG4gaWYgKHN0ci5pbmRleE9mKFwiLlwiKSA+IDApIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChcIlsuXVwiLCBcImdcIiksIFwiOlwiKTtcbiAgd29yZHMgPSBzdHIuc3BsaXQoXCI6XCIpO1xuICB3b3Jkc1t3b3Jkcy5sZW5ndGggLSA0XSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gNF0pICsganN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGggLSAzXSkgKiAyNTY7XG4gIHdvcmRzW3dvcmRzLmxlbmd0aCAtIDNdID0ganN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGggLSAyXSkgKyBqc3RvaV9xKHdvcmRzW3dvcmRzLmxlbmd0aCAtIDFdKSAqIDI1NjtcbiAgd29yZHMgPSB3b3Jkcy5zbGljZSgwLCB3b3Jkcy5sZW5ndGggLSAyKTtcbiB9IGVsc2Uge1xuICB3b3JkcyA9IHN0ci5zcGxpdChcIjpcIik7XG4gfVxuIG9mZnNldCA9IDA7XG4geiA9IDA7XG4gZm9yICh3ID0gMDsgdyA8IHdvcmRzLmxlbmd0aDsgdysrKSB7XG4gIGlmICh0eXBlb2Ygd29yZHNbd10gPT0gXCJzdHJpbmdcIikge1xuICAgaWYgKHdvcmRzW3ddID09PSBcIlpcIikge1xuICAgIGZvciAoeiA9IDA7IHogPCA4IC0gd29yZHMubGVuZ3RoICsgMTsgeisrKSB7XG4gICAgIHBhcnRzW3cgKyB6XSA9IDA7XG4gICAgfVxuICAgIG9mZnNldCA9IHogLSAxO1xuICAgfSBlbHNlIHtcbiAgICBwYXJ0c1t3ICsgb2Zmc2V0XSA9IF9odG9ucyhwYXJzZUludCh3b3Jkc1t3XSwgMTYpKTtcbiAgIH1cbiAgfSBlbHNlIHtcbiAgIHBhcnRzW3cgKyBvZmZzZXRdID0gd29yZHNbd107XG4gIH1cbiB9XG4gcmV0dXJuIFsgcGFydHNbMV0gPDwgMTYgfCBwYXJ0c1swXSwgcGFydHNbM10gPDwgMTYgfCBwYXJ0c1syXSwgcGFydHNbNV0gPDwgMTYgfCBwYXJ0c1s0XSwgcGFydHNbN10gPDwgMTYgfCBwYXJ0c1s2XSBdO1xufVxuXG52YXIgRE5TID0ge1xuIGFkZHJlc3NfbWFwOiB7XG4gIGlkOiAxLFxuICBhZGRyczoge30sXG4gIG5hbWVzOiB7fVxuIH0sXG4gbG9va3VwX25hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHJlcyA9IGluZXRQdG9uNChuYW1lKTtcbiAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgcmVzID0gaW5ldFB0b242KG5hbWUpO1xuICBpZiAocmVzICE9PSBudWxsKSB7XG4gICByZXR1cm4gbmFtZTtcbiAgfVxuICB2YXIgYWRkcjtcbiAgaWYgKEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSkge1xuICAgYWRkciA9IEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXTtcbiAgfSBlbHNlIHtcbiAgIHZhciBpZCA9IEROUy5hZGRyZXNzX21hcC5pZCsrO1xuICAgYXNzZXJ0KGlkIDwgNjU1MzUsIFwiZXhjZWVkZWQgbWF4IGFkZHJlc3MgbWFwcGluZ3Mgb2YgNjU1MzVcIik7XG4gICBhZGRyID0gXCIxNzIuMjkuXCIgKyAoaWQgJiAyNTUpICsgXCIuXCIgKyAoaWQgJiA2NTI4MCk7XG4gICBETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl0gPSBuYW1lO1xuICAgRE5TLmFkZHJlc3NfbWFwLmFkZHJzW25hbWVdID0gYWRkcjtcbiAgfVxuICByZXR1cm4gYWRkcjtcbiB9LFxuIGxvb2t1cF9hZGRyOiBmdW5jdGlvbihhZGRyKSB7XG4gIGlmIChETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl0pIHtcbiAgIHJldHVybiBETlMuYWRkcmVzc19tYXAubmFtZXNbYWRkcl07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG4gfVxufTtcblxuZnVuY3Rpb24gZ2V0U29ja2V0QWRkcmVzcyhhZGRycCwgYWRkcmxlbiwgYWxsb3dOdWxsKSB7XG4gaWYgKGFsbG93TnVsbCAmJiBhZGRycCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gdmFyIGluZm8gPSByZWFkU29ja2FkZHIoYWRkcnAsIGFkZHJsZW4pO1xuIGlmIChpbmZvLmVycm5vKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihpbmZvLmVycm5vKTtcbiBpbmZvLmFkZHIgPSBETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKSB8fCBpbmZvLmFkZHI7XG4gcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfYmluZChmZCwgYWRkciwgYWRkcmxlbiwgZDEsIGQyLCBkMykge1xuIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiB2YXIgaW5mbyA9IGdldFNvY2tldEFkZHJlc3MoYWRkciwgYWRkcmxlbik7XG4gc29jay5zb2NrX29wcy5iaW5kKHNvY2ssIGluZm8uYWRkciwgaW5mby5wb3J0KTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9jb25uZWN0KGZkLCBhZGRyLCBhZGRybGVuLCBkMSwgZDIsIGQzKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIHZhciBpbmZvID0gZ2V0U29ja2V0QWRkcmVzcyhhZGRyLCBhZGRybGVuKTtcbiBzb2NrLnNvY2tfb3BzLmNvbm5lY3Qoc29jaywgaW5mby5hZGRyLCBpbmZvLnBvcnQpO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZhY2Nlc3NhdChkaXJmZCwgcGF0aCwgYW1vZGUsIGZsYWdzKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZmNudGw2NChmZCwgY21kLCB2YXJhcmdzKSB7XG4gU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZnN0YXQ2NChmZCwgYnVmKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRJMzJQYWlyVG9JNTNDaGVja2VkKGxvLCBoaSkge1xuIGFzc2VydChsbyA9PSBsbyA+Pj4gMCB8fCBsbyA9PSAobG8gfCAwKSk7XG4gYXNzZXJ0KGhpID09PSAoaGkgfCAwKSk7XG4gcmV0dXJuIGhpICsgMjA5NzE1MiA+Pj4gMCA8IDQxOTQzMDUgLSAhIWxvID8gKGxvID4+PiAwKSArIGhpICogNDI5NDk2NzI5NiA6IE5hTjtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9mdHJ1bmNhdGU2NChmZCwgbGVuZ3RoX2xvdywgbGVuZ3RoX2hpZ2gpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBoZWFwLCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkge1xuIG91dElkeCA+Pj49IDA7XG4gYXNzZXJ0KHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIpO1xuIGlmICghKG1heEJ5dGVzVG9Xcml0ZSA+IDApKSByZXR1cm4gMDtcbiB2YXIgc3RhcnRJZHggPSBvdXRJZHg7XG4gdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgaWYgKHUgPj0gNTUyOTYgJiYgdSA8PSA1NzM0Mykge1xuICAgdmFyIHUxID0gc3RyLmNoYXJDb2RlQXQoKytpKTtcbiAgIHUgPSA2NTUzNiArICgodSAmIDEwMjMpIDw8IDEwKSB8IHUxICYgMTAyMztcbiAgfVxuICBpZiAodSA8PSAxMjcpIHtcbiAgIGlmIChvdXRJZHggPj0gZW5kSWR4KSBicmVhaztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gdTtcbiAgfSBlbHNlIGlmICh1IDw9IDIwNDcpIHtcbiAgIGlmIChvdXRJZHggKyAxID49IGVuZElkeCkgYnJlYWs7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDE5MiB8IHUgPj4gNjtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9IGVsc2UgaWYgKHUgPD0gNjU1MzUpIHtcbiAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDIyNCB8IHUgPj4gMTI7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDEyOCB8IHUgPj4gNiAmIDYzO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ICYgNjM7XG4gIH0gZWxzZSB7XG4gICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaWYgKHUgPiAxMTE0MTExKSB3YXJuT25jZShcIkludmFsaWQgVW5pY29kZSBjb2RlIHBvaW50IFwiICsgcHRyVG9TdHJpbmcodSkgKyBcIiBlbmNvdW50ZXJlZCB3aGVuIHNlcmlhbGl6aW5nIGEgSlMgc3RyaW5nIHRvIGEgVVRGLTggc3RyaW5nIGluIHdhc20gbWVtb3J5ISAoVmFsaWQgdW5pY29kZSBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW4gcmFuZ2UgMC0weDEwRkZGRikuXCIpO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAyNDAgfCB1ID4+IDE4O1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDEyICYgNjM7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDEyOCB8IHUgPj4gNiAmIDYzO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ICYgNjM7XG4gIH1cbiB9XG4gaGVhcFtvdXRJZHggPj4+IDBdID0gMDtcbiByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKSB7XG4gYXNzZXJ0KHR5cGVvZiBtYXhCeXRlc1RvV3JpdGUgPT0gXCJudW1iZXJcIiwgXCJzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgaXMgbWlzc2luZyB0aGUgdGhpcmQgcGFyYW1ldGVyIHRoYXQgc3BlY2lmaWVzIHRoZSBsZW5ndGggb2YgdGhlIG91dHB1dCBidWZmZXIhXCIpO1xuIHJldHVybiBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVBVOCwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldGRlbnRzNjQoZmQsIGRpcnAsIGNvdW50KSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIHplcm9NZW1vcnkoYWRkcmVzcywgc2l6ZSkge1xuIEhFQVBVOC5maWxsKDAsIGFkZHJlc3MsIGFkZHJlc3MgKyBzaXplKTtcbiByZXR1cm4gYWRkcmVzcztcbn1cblxuZnVuY3Rpb24gd3JpdGVTb2NrYWRkcihzYSwgZmFtaWx5LCBhZGRyLCBwb3J0LCBhZGRybGVuKSB7XG4gc3dpdGNoIChmYW1pbHkpIHtcbiBjYXNlIDI6XG4gIGFkZHIgPSBpbmV0UHRvbjQoYWRkcik7XG4gIHplcm9NZW1vcnkoc2EsIDE2KTtcbiAgaWYgKGFkZHJsZW4pIHtcbiAgIEhFQVAzMlthZGRybGVuID4+PiAyXSA9IDE2O1xuICB9XG4gIEhFQVAxNltzYSA+Pj4gMV0gPSBmYW1pbHk7XG4gIEhFQVAzMltzYSArIDQgPj4+IDJdID0gYWRkcjtcbiAgSEVBUDE2W3NhICsgMiA+Pj4gMV0gPSBfaHRvbnMocG9ydCk7XG4gIGJyZWFrO1xuXG4gY2FzZSAxMDpcbiAgYWRkciA9IGluZXRQdG9uNihhZGRyKTtcbiAgemVyb01lbW9yeShzYSwgMjgpO1xuICBpZiAoYWRkcmxlbikge1xuICAgSEVBUDMyW2FkZHJsZW4gPj4+IDJdID0gMjg7XG4gIH1cbiAgSEVBUDMyW3NhID4+PiAyXSA9IGZhbWlseTtcbiAgSEVBUDMyW3NhICsgOCA+Pj4gMl0gPSBhZGRyWzBdO1xuICBIRUFQMzJbc2EgKyAxMiA+Pj4gMl0gPSBhZGRyWzFdO1xuICBIRUFQMzJbc2EgKyAxNiA+Pj4gMl0gPSBhZGRyWzJdO1xuICBIRUFQMzJbc2EgKyAyMCA+Pj4gMl0gPSBhZGRyWzNdO1xuICBIRUFQMTZbc2EgKyAyID4+PiAxXSA9IF9odG9ucyhwb3J0KTtcbiAgYnJlYWs7XG5cbiBkZWZhdWx0OlxuICByZXR1cm4gNTtcbiB9XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0cGVlcm5hbWUoZmQsIGFkZHIsIGFkZHJsZW4sIGQxLCBkMiwgZDMpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gaWYgKCFzb2NrLmRhZGRyKSB7XG4gIHJldHVybiAtNTM7XG4gfVxuIHZhciBlcnJubyA9IHdyaXRlU29ja2FkZHIoYWRkciwgc29jay5mYW1pbHksIEROUy5sb29rdXBfbmFtZShzb2NrLmRhZGRyKSwgc29jay5kcG9ydCwgYWRkcmxlbik7XG4gYXNzZXJ0KCFlcnJubyk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZ2V0c29ja29wdChmZCwgbGV2ZWwsIG9wdG5hbWUsIG9wdHZhbCwgb3B0bGVuLCBkMSkge1xuIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiBpZiAobGV2ZWwgPT09IDEpIHtcbiAgaWYgKG9wdG5hbWUgPT09IDQpIHtcbiAgIEhFQVAzMltvcHR2YWwgPj4+IDJdID0gc29jay5lcnJvcjtcbiAgIEhFQVAzMltvcHRsZW4gPj4+IDJdID0gNDtcbiAgIHNvY2suZXJyb3IgPSBudWxsO1xuICAgcmV0dXJuIDA7XG4gIH1cbiB9XG4gcmV0dXJuIC01MDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9pb2N0bChmZCwgb3AsIHZhcmFyZ3MpIHtcbiBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9sc3RhdDY0KHBhdGgsIGJ1Zikge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX21rZGlyYXQoZGlyZmQsIHBhdGgsIG1vZGUpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9uZXdmc3RhdGF0KGRpcmZkLCBwYXRoLCBidWYsIGZsYWdzKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfb3BlbmF0KGRpcmZkLCBwYXRoLCBmbGFncywgdmFyYXJncykge1xuIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3JlY3Zmcm9tKGZkLCBidWYsIGxlbiwgZmxhZ3MsIGFkZHIsIGFkZHJsZW4pIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gdmFyIG1zZyA9IHNvY2suc29ja19vcHMucmVjdm1zZyhzb2NrLCBsZW4pO1xuIGlmICghbXNnKSByZXR1cm4gMDtcbiBpZiAoYWRkcikge1xuICB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIHNvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUobXNnLmFkZHIpLCBtc2cucG9ydCwgYWRkcmxlbik7XG4gIGFzc2VydCghZXJybm8pO1xuIH1cbiBIRUFQVTguc2V0KG1zZy5idWZmZXIsIGJ1ZiA+Pj4gMCk7XG4gcmV0dXJuIG1zZy5idWZmZXIuYnl0ZUxlbmd0aDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9yZW5hbWVhdChvbGRkaXJmZCwgb2xkcGF0aCwgbmV3ZGlyZmQsIG5ld3BhdGgpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9ybWRpcihwYXRoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfc2VuZHRvKGZkLCBtZXNzYWdlLCBsZW5ndGgsIGZsYWdzLCBhZGRyLCBhZGRyX2xlbikge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3NvY2tldChkb21haW4sIHR5cGUsIHByb3RvY29sKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfc3RhdDY0KHBhdGgsIGJ1Zikge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3VubGlua2F0KGRpcmZkLCBwYXRoLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX190aHJvd19leGNlcHRpb25fd2l0aF9zdGFja190cmFjZShleCkge1xuIHZhciBlID0gbmV3IFdlYkFzc2VtYmx5LkV4Y2VwdGlvbihnZXRDcHBFeGNlcHRpb25UYWcoKSwgWyBleCBdLCB7XG4gIHRyYWNlU3RhY2s6IHRydWVcbiB9KTtcbiBlLm1lc3NhZ2UgPSBnZXRFeGNlcHRpb25NZXNzYWdlKGUpO1xuIGlmIChlLnN0YWNrKSB7XG4gIHZhciBhcnIgPSBlLnN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICBhcnIuc3BsaWNlKDEsIDEpO1xuICBlLnN0YWNrID0gYXJyLmpvaW4oXCJcXG5cIik7XG4gfVxuIHRocm93IGU7XG59XG5cbnZhciBub3dJc01vbm90b25pYyA9IHRydWU7XG5cbmZ1bmN0aW9uIF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYygpIHtcbiByZXR1cm4gbm93SXNNb25vdG9uaWM7XG59XG5cbmZ1bmN0aW9uIHJlYWRJNTNGcm9tSTY0KHB0cikge1xuIHJldHVybiBIRUFQVTMyW3B0ciA+Pj4gMl0gKyBIRUFQMzJbcHRyICsgNCA+Pj4gMl0gKiA0Mjk0OTY3Mjk2O1xufVxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5cbnZhciBNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA9IFsgMCwgMzEsIDYwLCA5MSwgMTIxLCAxNTIsIDE4MiwgMjEzLCAyNDQsIDI3NCwgMzA1LCAzMzUgXTtcblxudmFyIE1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFID0gWyAwLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNCBdO1xuXG5mdW5jdGlvbiB5ZGF5RnJvbURhdGUoZGF0ZSkge1xuIHZhciBsZWFwID0gaXNMZWFwWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xuIHZhciBtb250aERheXNDdW11bGF0aXZlID0gbGVhcCA/IE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFIDogTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkU7XG4gdmFyIHlkYXkgPSBtb250aERheXNDdW11bGF0aXZlW2RhdGUuZ2V0TW9udGgoKV0gKyBkYXRlLmdldERhdGUoKSAtIDE7XG4gcmV0dXJuIHlkYXk7XG59XG5cbmZ1bmN0aW9uIF9fbG9jYWx0aW1lX2pzKHRpbWUsIHRtUHRyKSB7XG4gdmFyIGRhdGUgPSBuZXcgRGF0ZShyZWFkSTUzRnJvbUk2NCh0aW1lKSAqIDFlMyk7XG4gSEVBUDMyW3RtUHRyID4+PiAyXSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuIEhFQVAzMlt0bVB0ciArIDQgPj4+IDJdID0gZGF0ZS5nZXRNaW51dGVzKCk7XG4gSEVBUDMyW3RtUHRyICsgOCA+Pj4gMl0gPSBkYXRlLmdldEhvdXJzKCk7XG4gSEVBUDMyW3RtUHRyICsgMTIgPj4+IDJdID0gZGF0ZS5nZXREYXRlKCk7XG4gSEVBUDMyW3RtUHRyICsgMTYgPj4+IDJdID0gZGF0ZS5nZXRNb250aCgpO1xuIEhFQVAzMlt0bVB0ciArIDIwID4+PiAyXSA9IGRhdGUuZ2V0RnVsbFllYXIoKSAtIDE5MDA7XG4gSEVBUDMyW3RtUHRyICsgMjQgPj4+IDJdID0gZGF0ZS5nZXREYXkoKTtcbiB2YXIgeWRheSA9IHlkYXlGcm9tRGF0ZShkYXRlKSB8IDA7XG4gSEVBUDMyW3RtUHRyICsgMjggPj4+IDJdID0geWRheTtcbiBIRUFQMzJbdG1QdHIgKyAzNiA+Pj4gMl0gPSAtKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwKTtcbiB2YXIgc3RhcnQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gdmFyIHdpbnRlck9mZnNldCA9IHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gdmFyIGRzdCA9IChzdW1tZXJPZmZzZXQgIT0gd2ludGVyT2Zmc2V0ICYmIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PSBNYXRoLm1pbih3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCkpIHwgMDtcbiBIRUFQMzJbdG1QdHIgKyAzMiA+Pj4gMl0gPSBkc3Q7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHtcbiB2YXIgbGVuID0gMDtcbiBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICBpZiAoYyA8PSAxMjcpIHtcbiAgIGxlbisrO1xuICB9IGVsc2UgaWYgKGMgPD0gMjA0Nykge1xuICAgbGVuICs9IDI7XG4gIH0gZWxzZSBpZiAoYyA+PSA1NTI5NiAmJiBjIDw9IDU3MzQzKSB7XG4gICBsZW4gKz0gNDtcbiAgICsraTtcbiAgfSBlbHNlIHtcbiAgIGxlbiArPSAzO1xuICB9XG4gfVxuIHJldHVybiBsZW47XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvTmV3VVRGOChzdHIpIHtcbiB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcbiB2YXIgcmV0ID0gX21hbGxvYyhzaXplKTtcbiBpZiAocmV0KSBzdHJpbmdUb1VURjgoc3RyLCByZXQsIHNpemUpO1xuIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIF9fdHpzZXRfanModGltZXpvbmUsIGRheWxpZ2h0LCB0em5hbWUpIHtcbiB2YXIgY3VycmVudFllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gdmFyIHdpbnRlciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCAwLCAxKTtcbiB2YXIgc3VtbWVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDYsIDEpO1xuIHZhciB3aW50ZXJPZmZzZXQgPSB3aW50ZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgc3VtbWVyT2Zmc2V0ID0gc3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gdmFyIHN0ZFRpbWV6b25lT2Zmc2V0ID0gTWF0aC5tYXgod2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpO1xuIEhFQVBVMzJbdGltZXpvbmUgPj4+IDJdID0gc3RkVGltZXpvbmVPZmZzZXQgKiA2MDtcbiBIRUFQMzJbZGF5bGlnaHQgPj4+IDJdID0gTnVtYmVyKHdpbnRlck9mZnNldCAhPSBzdW1tZXJPZmZzZXQpO1xuIGZ1bmN0aW9uIGV4dHJhY3Rab25lKGRhdGUpIHtcbiAgdmFyIG1hdGNoID0gZGF0ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXFwoKFtBLVphLXogXSspXFwpJC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IFwiR01UXCI7XG4gfVxuIHZhciB3aW50ZXJOYW1lID0gZXh0cmFjdFpvbmUod2ludGVyKTtcbiB2YXIgc3VtbWVyTmFtZSA9IGV4dHJhY3Rab25lKHN1bW1lcik7XG4gdmFyIHdpbnRlck5hbWVQdHIgPSBzdHJpbmdUb05ld1VURjgod2ludGVyTmFtZSk7XG4gdmFyIHN1bW1lck5hbWVQdHIgPSBzdHJpbmdUb05ld1VURjgoc3VtbWVyTmFtZSk7XG4gaWYgKHN1bW1lck9mZnNldCA8IHdpbnRlck9mZnNldCkge1xuICBIRUFQVTMyW3R6bmFtZSA+Pj4gMl0gPSB3aW50ZXJOYW1lUHRyO1xuICBIRUFQVTMyW3R6bmFtZSArIDQgPj4+IDJdID0gc3VtbWVyTmFtZVB0cjtcbiB9IGVsc2Uge1xuICBIRUFQVTMyW3R6bmFtZSA+Pj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuICBIRUFQVTMyW3R6bmFtZSArIDQgPj4+IDJdID0gd2ludGVyTmFtZVB0cjtcbiB9XG59XG5cbmZ1bmN0aW9uIF9hYm9ydCgpIHtcbiBhYm9ydChcIm5hdGl2ZSBjb2RlIGNhbGxlZCBhYm9ydCgpXCIpO1xufVxuXG5mdW5jdGlvbiBfZGxvcGVuKGZpbGVuYW1lLCBmbGFncykge1xuIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGUocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNyZWF0ZURpcmVjdG9yeShNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfZXhpc3RzKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jaGVja0RpcmVjdG9yeShNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlcyhwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUubGlzdERpcmVjdG9yeUVudHJpZXMoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X3JlbW92ZShwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUucmVtb3ZlRGlyZWN0b3J5KE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfY2xvc2UoZmlsZUlkKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2xvc2VGaWxlKE1vZHVsZSwgZmlsZUlkKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9leGlzdHMocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNoZWNrRmlsZShNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2dldF9sYXN0X21vZGlmaWVkX3RpbWUoZmlsZUlkKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuZ2V0TGFzdEZpbGVNb2RpZmljYXRpb25UaW1lKE1vZHVsZSwgZmlsZUlkKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlKGZyb20sIGZyb21MZW4sIHRvLCB0b0xlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLm1vdmVGaWxlKE1vZHVsZSwgZnJvbSwgZnJvbUxlbiwgdG8sIHRvTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9vcGVuKGZpbGVJZCwgZmxhZ3MpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5vcGVuRmlsZShNb2R1bGUsIGZpbGVJZCwgZmxhZ3MpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX3JlYWQoZmlsZUlkLCBidWYsIHNpemUsIGxvY2F0aW9uKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUucmVhZEZpbGUoTW9kdWxlLCBmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlKGZpbGVJZCwgbmV3U2l6ZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnRydW5jYXRlRmlsZShNb2R1bGUsIGZpbGVJZCwgbmV3U2l6ZSk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfd3JpdGUoZmlsZUlkLCBidWYsIHNpemUsIGxvY2F0aW9uKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUud3JpdGVGaWxlKE1vZHVsZSwgZmlsZUlkLCBidWYsIHNpemUsIGxvY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZ2V0X2RlZmF1bHRfZGF0YV9wcm90b2NvbChNb2R1bGUpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nZXREZWZhdWx0RGF0YVByb3RvY29sKE1vZHVsZSk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2dsb2IocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmdsb2IoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfdGVzdF9wbGF0Zm9ybV9mZWF0dXJlKGZlYXR1cmUpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS50ZXN0UGxhdGZvcm1GZWF0dXJlKE1vZHVsZSwgZmVhdHVyZSk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX3VkZl9zY2FsYXJfY2FsbChmdW5jSWQsIGRlc2NQdHIsIGRlc2NTaXplLCBwdHJzUHRyLCBwdHJzU2l6ZSwgcmVzcG9uc2UpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jYWxsU2NhbGFyVURGKE1vZHVsZSwgZnVuY0lkLCBkZXNjUHRyLCBkZXNjU2l6ZSwgcHRyc1B0ciwgcHRyc1NpemUsIHJlc3BvbnNlKTtcbn1cblxuZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcihzdHIpIHtcbiBhc3NlcnQodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKTtcbiBjb25zb2xlLmVycm9yKFVURjhUb1N0cmluZyhzdHIpKTtcbn1cblxuZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZGF0ZV9ub3coKSB7XG4gcmV0dXJuIERhdGUubm93KCk7XG59XG5cbmZ1bmN0aW9uIGdldEhlYXBNYXgoKSB7XG4gcmV0dXJuIDQyOTQ5MDE3NjA7XG59XG5cbmZ1bmN0aW9uIF9lbXNjcmlwdGVuX2dldF9oZWFwX21heCgpIHtcbiByZXR1cm4gZ2V0SGVhcE1heCgpO1xufVxuXG52YXIgX2Vtc2NyaXB0ZW5fZ2V0X25vdztcblxuaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcbiBnbG9iYWwucGVyZm9ybWFuY2UgPSByZXF1aXJlKFwicGVyZl9ob29rc1wiKS5wZXJmb3JtYW5jZTtcbn1cblxuX2Vtc2NyaXB0ZW5fZ2V0X25vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnKGRlc3QsIHNyYywgbnVtKSB7XG4gSEVBUFU4LmNvcHlXaXRoaW4oZGVzdCA+Pj4gMCwgc3JjID4+PiAwLCBzcmMgKyBudW0gPj4+IDApO1xufVxuXG5mdW5jdGlvbiBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKHNpemUpIHtcbiB2YXIgYiA9IHdhc21NZW1vcnkuYnVmZmVyO1xuIHZhciBwYWdlcyA9IHNpemUgLSBiLmJ5dGVMZW5ndGggKyA2NTUzNSA+Pj4gMTY7XG4gdHJ5IHtcbiAgd2FzbU1lbW9yeS5ncm93KHBhZ2VzKTtcbiAgdXBkYXRlTWVtb3J5Vmlld3MoKTtcbiAgcmV0dXJuIDE7XG4gfSBjYXRjaCAoZSkge1xuICBlcnIoYGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXI6IEF0dGVtcHRlZCB0byBncm93IGhlYXAgZnJvbSAke2IuYnl0ZUxlbmd0aH0gYnl0ZXMgdG8gJHtzaXplfSBieXRlcywgYnV0IGdvdCBlcnJvcjogJHtlfWApO1xuIH1cbn1cblxuZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAocmVxdWVzdGVkU2l6ZSkge1xuIHZhciBvbGRTaXplID0gSEVBUFU4Lmxlbmd0aDtcbiByZXF1ZXN0ZWRTaXplID0gcmVxdWVzdGVkU2l6ZSA+Pj4gMDtcbiBhc3NlcnQocmVxdWVzdGVkU2l6ZSA+IG9sZFNpemUpO1xuIHZhciBtYXhIZWFwU2l6ZSA9IGdldEhlYXBNYXgoKTtcbiBpZiAocmVxdWVzdGVkU2l6ZSA+IG1heEhlYXBTaXplKSB7XG4gIGVycihgQ2Fubm90IGVubGFyZ2UgbWVtb3J5LCBhc2tlZCB0byBnbyB1cCB0byAke3JlcXVlc3RlZFNpemV9IGJ5dGVzLCBidXQgdGhlIGxpbWl0IGlzICR7bWF4SGVhcFNpemV9IGJ5dGVzIWApO1xuICByZXR1cm4gZmFsc2U7XG4gfVxuIHZhciBhbGlnblVwID0gKHgsIG11bHRpcGxlKSA9PiB4ICsgKG11bHRpcGxlIC0geCAlIG11bHRpcGxlKSAlIG11bHRpcGxlO1xuIGZvciAodmFyIGN1dERvd24gPSAxOyBjdXREb3duIDw9IDQ7IGN1dERvd24gKj0gMikge1xuICB2YXIgb3Zlckdyb3duSGVhcFNpemUgPSBvbGRTaXplICogKDEgKyAuMiAvIGN1dERvd24pO1xuICBvdmVyR3Jvd25IZWFwU2l6ZSA9IE1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLCByZXF1ZXN0ZWRTaXplICsgMTAwNjYzMjk2KTtcbiAgdmFyIG5ld1NpemUgPSBNYXRoLm1pbihtYXhIZWFwU2l6ZSwgYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLCBvdmVyR3Jvd25IZWFwU2l6ZSksIDY1NTM2KSk7XG4gIHZhciByZXBsYWNlbWVudCA9IGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIobmV3U2l6ZSk7XG4gIGlmIChyZXBsYWNlbWVudCkge1xuICAgcmV0dXJuIHRydWU7XG4gIH1cbiB9XG4gZXJyKGBGYWlsZWQgdG8gZ3JvdyB0aGUgaGVhcCBmcm9tICR7b2xkU2l6ZX0gYnl0ZXMgdG8gJHtuZXdTaXplfSBieXRlcywgbm90IGVub3VnaCBtZW1vcnkhYCk7XG4gcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRU5WID0ge307XG5cbmZ1bmN0aW9uIGdldEV4ZWN1dGFibGVOYW1lKCkge1xuIHJldHVybiB0aGlzUHJvZ3JhbSB8fCBcIi4vdGhpcy5wcm9ncmFtXCI7XG59XG5cbmZ1bmN0aW9uIGdldEVudlN0cmluZ3MoKSB7XG4gaWYgKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3MpIHtcbiAgdmFyIGxhbmcgPSAodHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgbmF2aWdhdG9yLmxhbmd1YWdlc1swXSB8fCBcIkNcIikucmVwbGFjZShcIi1cIiwgXCJfXCIpICsgXCIuVVRGLThcIjtcbiAgdmFyIGVudiA9IHtcbiAgIFwiVVNFUlwiOiBcIndlYl91c2VyXCIsXG4gICBcIkxPR05BTUVcIjogXCJ3ZWJfdXNlclwiLFxuICAgXCJQQVRIXCI6IFwiL1wiLFxuICAgXCJQV0RcIjogXCIvXCIsXG4gICBcIkhPTUVcIjogXCIvaG9tZS93ZWJfdXNlclwiLFxuICAgXCJMQU5HXCI6IGxhbmcsXG4gICBcIl9cIjogZ2V0RXhlY3V0YWJsZU5hbWUoKVxuICB9O1xuICBmb3IgKHZhciB4IGluIEVOVikge1xuICAgaWYgKEVOVlt4XSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgZW52W3hdOyBlbHNlIGVudlt4XSA9IEVOVlt4XTtcbiAgfVxuICB2YXIgc3RyaW5ncyA9IFtdO1xuICBmb3IgKHZhciB4IGluIGVudikge1xuICAgc3RyaW5ncy5wdXNoKGAke3h9PSR7ZW52W3hdfWApO1xuICB9XG4gIGdldEVudlN0cmluZ3Muc3RyaW5ncyA9IHN0cmluZ3M7XG4gfVxuIHJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3M7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQXNjaWkoc3RyLCBidWZmZXIpIHtcbiBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICBhc3NlcnQoc3RyLmNoYXJDb2RlQXQoaSkgPT09IChzdHIuY2hhckNvZGVBdChpKSAmIDI1NSkpO1xuICBIRUFQOFtidWZmZXIrKyA+Pj4gMF0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiB9XG4gSEVBUDhbYnVmZmVyID4+PiAwXSA9IDA7XG59XG5cbmZ1bmN0aW9uIF9lbnZpcm9uX2dldChfX2Vudmlyb24sIGVudmlyb25fYnVmKSB7XG4gdmFyIGJ1ZlNpemUgPSAwO1xuIGdldEVudlN0cmluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZywgaSkge1xuICB2YXIgcHRyID0gZW52aXJvbl9idWYgKyBidWZTaXplO1xuICBIRUFQVTMyW19fZW52aXJvbiArIGkgKiA0ID4+PiAyXSA9IHB0cjtcbiAgc3RyaW5nVG9Bc2NpaShzdHJpbmcsIHB0cik7XG4gIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gfSk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9lbnZpcm9uX3NpemVzX2dldChwZW52aXJvbl9jb3VudCwgcGVudmlyb25fYnVmX3NpemUpIHtcbiB2YXIgc3RyaW5ncyA9IGdldEVudlN0cmluZ3MoKTtcbiBIRUFQVTMyW3BlbnZpcm9uX2NvdW50ID4+PiAyXSA9IHN0cmluZ3MubGVuZ3RoO1xuIHZhciBidWZTaXplID0gMDtcbiBzdHJpbmdzLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nKSB7XG4gIGJ1ZlNpemUgKz0gc3RyaW5nLmxlbmd0aCArIDE7XG4gfSk7XG4gSEVBUFUzMltwZW52aXJvbl9idWZfc2l6ZSA+Pj4gMl0gPSBidWZTaXplO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZmRfY2xvc2UoZmQpIHtcbiBhYm9ydChcImZkX2Nsb3NlIGNhbGxlZCB3aXRob3V0IFNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX2ZkX2Zkc3RhdF9nZXQoZmQsIHBidWYpIHtcbiB2YXIgcmlnaHRzQmFzZSA9IDA7XG4gdmFyIHJpZ2h0c0luaGVyaXRpbmcgPSAwO1xuIHZhciBmbGFncyA9IDA7XG4ge1xuICBhc3NlcnQoZmQgPT0gMCB8fCBmZCA9PSAxIHx8IGZkID09IDIpO1xuICB2YXIgdHlwZSA9IDI7XG4gIGlmIChmZCA9PSAwKSB7XG4gICByaWdodHNCYXNlID0gMjtcbiAgfSBlbHNlIGlmIChmZCA9PSAxIHx8IGZkID09IDIpIHtcbiAgIHJpZ2h0c0Jhc2UgPSA2NDtcbiAgfVxuICBmbGFncyA9IDE7XG4gfVxuIEhFQVA4W3BidWYgPj4+IDBdID0gdHlwZTtcbiBIRUFQMTZbcGJ1ZiArIDIgPj4+IDFdID0gZmxhZ3M7XG4gdGVtcEk2NCA9IFsgcmlnaHRzQmFzZSA+Pj4gMCwgKHRlbXBEb3VibGUgPSByaWdodHNCYXNlLCArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMSA/IHRlbXBEb3VibGUgPiAwID8gK01hdGguZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYpID4+PiAwIDogfn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYpID4+PiAwIDogMCkgXSwgXG4gSEVBUDMyW3BidWYgKyA4ID4+PiAyXSA9IHRlbXBJNjRbMF0sIEhFQVAzMltwYnVmICsgMTIgPj4+IDJdID0gdGVtcEk2NFsxXTtcbiB0ZW1wSTY0ID0gWyByaWdodHNJbmhlcml0aW5nID4+PiAwLCAodGVtcERvdWJsZSA9IHJpZ2h0c0luaGVyaXRpbmcsICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxID8gdGVtcERvdWJsZSA+IDAgPyArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5NikgPj4+IDAgOiB+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5NikgPj4+IDAgOiAwKSBdLCBcbiBIRUFQMzJbcGJ1ZiArIDE2ID4+PiAyXSA9IHRlbXBJNjRbMF0sIEhFQVAzMltwYnVmICsgMjAgPj4+IDJdID0gdGVtcEk2NFsxXTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2ZkX3ByZWFkKGZkLCBpb3YsIGlvdmNudCwgb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsIHBudW0pIHtcbiBhYm9ydChcImZkX3ByZWFkIGNhbGxlZCB3aXRob3V0IFNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX2ZkX3B3cml0ZShmZCwgaW92LCBpb3ZjbnQsIG9mZnNldF9sb3csIG9mZnNldF9oaWdoLCBwbnVtKSB7XG4gYWJvcnQoXCJmZF9wd3JpdGUgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfZmRfcmVhZChmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiBhYm9ydChcImZkX3JlYWQgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfZmRfc2VlayhmZCwgb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsIHdoZW5jZSwgbmV3T2Zmc2V0KSB7XG4gcmV0dXJuIDcwO1xufVxuXG5mdW5jdGlvbiBfZmRfc3luYyhmZCkge1xuIGFib3J0KFwiZmRfc3luYyBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbnZhciBwcmludENoYXJCdWZmZXJzID0gWyBudWxsLCBbXSwgW10gXTtcblxuZnVuY3Rpb24gcHJpbnRDaGFyKHN0cmVhbSwgY3Vycikge1xuIHZhciBidWZmZXIgPSBwcmludENoYXJCdWZmZXJzW3N0cmVhbV07XG4gYXNzZXJ0KGJ1ZmZlcik7XG4gaWYgKGN1cnIgPT09IDAgfHwgY3VyciA9PT0gMTApIHtcbiAgKHN0cmVhbSA9PT0gMSA/IG91dCA6IGVycikoVVRGOEFycmF5VG9TdHJpbmcoYnVmZmVyLCAwKSk7XG4gIGJ1ZmZlci5sZW5ndGggPSAwO1xuIH0gZWxzZSB7XG4gIGJ1ZmZlci5wdXNoKGN1cnIpO1xuIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hfTk9fRklMRVNZU1RFTSgpIHtcbiBfZmZsdXNoKDApO1xuIGlmIChwcmludENoYXJCdWZmZXJzWzFdLmxlbmd0aCkgcHJpbnRDaGFyKDEsIDEwKTtcbiBpZiAocHJpbnRDaGFyQnVmZmVyc1syXS5sZW5ndGgpIHByaW50Q2hhcigyLCAxMCk7XG59XG5cbmZ1bmN0aW9uIF9mZF93cml0ZShmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiB2YXIgbnVtID0gMDtcbiBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gIHZhciBwdHIgPSBIRUFQVTMyW2lvdiA+Pj4gMl07XG4gIHZhciBsZW4gPSBIRUFQVTMyW2lvdiArIDQgPj4+IDJdO1xuICBpb3YgKz0gODtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgcHJpbnRDaGFyKGZkLCBIRUFQVThbcHRyICsgaiA+Pj4gMF0pO1xuICB9XG4gIG51bSArPSBsZW47XG4gfVxuIEhFQVBVMzJbcG51bSA+Pj4gMl0gPSBudW07XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9nZXRhZGRyaW5mbyhub2RlLCBzZXJ2aWNlLCBoaW50LCBvdXQpIHtcbiB2YXIgYWRkcnMgPSBbXTtcbiB2YXIgY2Fub24gPSBudWxsO1xuIHZhciBhZGRyID0gMDtcbiB2YXIgcG9ydCA9IDA7XG4gdmFyIGZsYWdzID0gMDtcbiB2YXIgZmFtaWx5ID0gMDtcbiB2YXIgdHlwZSA9IDA7XG4gdmFyIHByb3RvID0gMDtcbiB2YXIgYWksIGxhc3Q7XG4gZnVuY3Rpb24gYWxsb2NhZGRyaW5mbyhmYW1pbHksIHR5cGUsIHByb3RvLCBjYW5vbiwgYWRkciwgcG9ydCkge1xuICB2YXIgc2EsIHNhbGVuLCBhaTtcbiAgdmFyIGVycm5vO1xuICBzYWxlbiA9IGZhbWlseSA9PT0gMTAgPyAyOCA6IDE2O1xuICBhZGRyID0gZmFtaWx5ID09PSAxMCA/IGluZXROdG9wNihhZGRyKSA6IGluZXROdG9wNChhZGRyKTtcbiAgc2EgPSBfbWFsbG9jKHNhbGVuKTtcbiAgZXJybm8gPSB3cml0ZVNvY2thZGRyKHNhLCBmYW1pbHksIGFkZHIsIHBvcnQpO1xuICBhc3NlcnQoIWVycm5vKTtcbiAgYWkgPSBfbWFsbG9jKDMyKTtcbiAgSEVBUDMyW2FpICsgNCA+Pj4gMl0gPSBmYW1pbHk7XG4gIEhFQVAzMlthaSArIDggPj4+IDJdID0gdHlwZTtcbiAgSEVBUDMyW2FpICsgMTIgPj4+IDJdID0gcHJvdG87XG4gIEhFQVBVMzJbYWkgKyAyNCA+Pj4gMl0gPSBjYW5vbjtcbiAgSEVBUFUzMlthaSArIDIwID4+PiAyXSA9IHNhO1xuICBpZiAoZmFtaWx5ID09PSAxMCkge1xuICAgSEVBUDMyW2FpICsgMTYgPj4+IDJdID0gMjg7XG4gIH0gZWxzZSB7XG4gICBIRUFQMzJbYWkgKyAxNiA+Pj4gMl0gPSAxNjtcbiAgfVxuICBIRUFQMzJbYWkgKyAyOCA+Pj4gMl0gPSAwO1xuICByZXR1cm4gYWk7XG4gfVxuIGlmIChoaW50KSB7XG4gIGZsYWdzID0gSEVBUDMyW2hpbnQgPj4+IDJdO1xuICBmYW1pbHkgPSBIRUFQMzJbaGludCArIDQgPj4+IDJdO1xuICB0eXBlID0gSEVBUDMyW2hpbnQgKyA4ID4+PiAyXTtcbiAgcHJvdG8gPSBIRUFQMzJbaGludCArIDEyID4+PiAyXTtcbiB9XG4gaWYgKHR5cGUgJiYgIXByb3RvKSB7XG4gIHByb3RvID0gdHlwZSA9PT0gMiA/IDE3IDogNjtcbiB9XG4gaWYgKCF0eXBlICYmIHByb3RvKSB7XG4gIHR5cGUgPSBwcm90byA9PT0gMTcgPyAyIDogMTtcbiB9XG4gaWYgKHByb3RvID09PSAwKSB7XG4gIHByb3RvID0gNjtcbiB9XG4gaWYgKHR5cGUgPT09IDApIHtcbiAgdHlwZSA9IDE7XG4gfVxuIGlmICghbm9kZSAmJiAhc2VydmljZSkge1xuICByZXR1cm4gLTI7XG4gfVxuIGlmIChmbGFncyAmIH4oMSB8IDIgfCA0IHwgMTAyNCB8IDggfCAxNiB8IDMyKSkge1xuICByZXR1cm4gLTE7XG4gfVxuIGlmIChoaW50ICE9PSAwICYmIEhFQVAzMltoaW50ID4+PiAyXSAmIDIgJiYgIW5vZGUpIHtcbiAgcmV0dXJuIC0xO1xuIH1cbiBpZiAoZmxhZ3MgJiAzMikge1xuICByZXR1cm4gLTI7XG4gfVxuIGlmICh0eXBlICE9PSAwICYmIHR5cGUgIT09IDEgJiYgdHlwZSAhPT0gMikge1xuICByZXR1cm4gLTc7XG4gfVxuIGlmIChmYW1pbHkgIT09IDAgJiYgZmFtaWx5ICE9PSAyICYmIGZhbWlseSAhPT0gMTApIHtcbiAgcmV0dXJuIC02O1xuIH1cbiBpZiAoc2VydmljZSkge1xuICBzZXJ2aWNlID0gVVRGOFRvU3RyaW5nKHNlcnZpY2UpO1xuICBwb3J0ID0gcGFyc2VJbnQoc2VydmljZSwgMTApO1xuICBpZiAoaXNOYU4ocG9ydCkpIHtcbiAgIGlmIChmbGFncyAmIDEwMjQpIHtcbiAgICByZXR1cm4gLTI7XG4gICB9XG4gICByZXR1cm4gLTg7XG4gIH1cbiB9XG4gaWYgKCFub2RlKSB7XG4gIGlmIChmYW1pbHkgPT09IDApIHtcbiAgIGZhbWlseSA9IDI7XG4gIH1cbiAgaWYgKChmbGFncyAmIDEpID09PSAwKSB7XG4gICBpZiAoZmFtaWx5ID09PSAyKSB7XG4gICAgYWRkciA9IF9odG9ubCgyMTMwNzA2NDMzKTtcbiAgIH0gZWxzZSB7XG4gICAgYWRkciA9IFsgMCwgMCwgMCwgMSBdO1xuICAgfVxuICB9XG4gIGFpID0gYWxsb2NhZGRyaW5mbyhmYW1pbHksIHR5cGUsIHByb3RvLCBudWxsLCBhZGRyLCBwb3J0KTtcbiAgSEVBUFUzMltvdXQgPj4+IDJdID0gYWk7XG4gIHJldHVybiAwO1xuIH1cbiBub2RlID0gVVRGOFRvU3RyaW5nKG5vZGUpO1xuIGFkZHIgPSBpbmV0UHRvbjQobm9kZSk7XG4gaWYgKGFkZHIgIT09IG51bGwpIHtcbiAgaWYgKGZhbWlseSA9PT0gMCB8fCBmYW1pbHkgPT09IDIpIHtcbiAgIGZhbWlseSA9IDI7XG4gIH0gZWxzZSBpZiAoZmFtaWx5ID09PSAxMCAmJiBmbGFncyAmIDgpIHtcbiAgIGFkZHIgPSBbIDAsIDAsIF9odG9ubCg2NTUzNSksIGFkZHIgXTtcbiAgIGZhbWlseSA9IDEwO1xuICB9IGVsc2Uge1xuICAgcmV0dXJuIC0yO1xuICB9XG4gfSBlbHNlIHtcbiAgYWRkciA9IGluZXRQdG9uNihub2RlKTtcbiAgaWYgKGFkZHIgIT09IG51bGwpIHtcbiAgIGlmIChmYW1pbHkgPT09IDAgfHwgZmFtaWx5ID09PSAxMCkge1xuICAgIGZhbWlseSA9IDEwO1xuICAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTI7XG4gICB9XG4gIH1cbiB9XG4gaWYgKGFkZHIgIT0gbnVsbCkge1xuICBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbm9kZSwgYWRkciwgcG9ydCk7XG4gIEhFQVBVMzJbb3V0ID4+PiAyXSA9IGFpO1xuICByZXR1cm4gMDtcbiB9XG4gaWYgKGZsYWdzICYgNCkge1xuICByZXR1cm4gLTI7XG4gfVxuIG5vZGUgPSBETlMubG9va3VwX25hbWUobm9kZSk7XG4gYWRkciA9IGluZXRQdG9uNChub2RlKTtcbiBpZiAoZmFtaWx5ID09PSAwKSB7XG4gIGZhbWlseSA9IDI7XG4gfSBlbHNlIGlmIChmYW1pbHkgPT09IDEwKSB7XG4gIGFkZHIgPSBbIDAsIDAsIF9odG9ubCg2NTUzNSksIGFkZHIgXTtcbiB9XG4gYWkgPSBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIG51bGwsIGFkZHIsIHBvcnQpO1xuIEhFQVBVMzJbb3V0ID4+PiAyXSA9IGFpO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbml0UmFuZG9tRmlsbCgpIHtcbiBpZiAodHlwZW9mIGNyeXB0byA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjcnlwdG9bXCJnZXRSYW5kb21WYWx1ZXNcIl0gPT0gXCJmdW5jdGlvblwiKSB7XG4gIHJldHVybiB2aWV3ID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXModmlldyk7XG4gfSBlbHNlIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gIHRyeSB7XG4gICB2YXIgY3J5cHRvX21vZHVsZSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gICB2YXIgcmFuZG9tRmlsbFN5bmMgPSBjcnlwdG9fbW9kdWxlW1wicmFuZG9tRmlsbFN5bmNcIl07XG4gICBpZiAocmFuZG9tRmlsbFN5bmMpIHtcbiAgICByZXR1cm4gdmlldyA9PiBjcnlwdG9fbW9kdWxlW1wicmFuZG9tRmlsbFN5bmNcIl0odmlldyk7XG4gICB9XG4gICB2YXIgcmFuZG9tQnl0ZXMgPSBjcnlwdG9fbW9kdWxlW1wicmFuZG9tQnl0ZXNcIl07XG4gICByZXR1cm4gdmlldyA9PiAodmlldy5zZXQocmFuZG9tQnl0ZXModmlldy5ieXRlTGVuZ3RoKSksIHZpZXcpO1xuICB9IGNhdGNoIChlKSB7fVxuIH1cbiBhYm9ydChcIm5vIGNyeXB0b2dyYXBoaWMgc3VwcG9ydCBmb3VuZCBmb3IgcmFuZG9tRGV2aWNlLiBjb25zaWRlciBwb2x5ZmlsbGluZyBpdCBpZiB5b3Ugd2FudCB0byB1c2Ugc29tZXRoaW5nIGluc2VjdXJlIGxpa2UgTWF0aC5yYW5kb20oKSwgZS5nLiBwdXQgdGhpcyBpbiBhIC0tcHJlLWpzOiB2YXIgY3J5cHRvID0geyBnZXRSYW5kb21WYWx1ZXM6IGZ1bmN0aW9uKGFycmF5KSB7IGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIGFycmF5W2ldID0gKE1hdGgucmFuZG9tKCkqMjU2KXwwIH0gfTtcIik7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbUZpbGwodmlldykge1xuIHJldHVybiAocmFuZG9tRmlsbCA9IGluaXRSYW5kb21GaWxsKCkpKHZpZXcpO1xufVxuXG5mdW5jdGlvbiBfZ2V0ZW50cm9weShidWZmZXIsIHNpemUpIHtcbiByYW5kb21GaWxsKEhFQVBVOC5zdWJhcnJheShidWZmZXIgPj4+IDAsIGJ1ZmZlciArIHNpemUgPj4+IDApKTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2dldG5hbWVpbmZvKHNhLCBzYWxlbiwgbm9kZSwgbm9kZWxlbiwgc2Vydiwgc2VydmxlbiwgZmxhZ3MpIHtcbiB2YXIgaW5mbyA9IHJlYWRTb2NrYWRkcihzYSwgc2FsZW4pO1xuIGlmIChpbmZvLmVycm5vKSB7XG4gIHJldHVybiAtNjtcbiB9XG4gdmFyIHBvcnQgPSBpbmZvLnBvcnQ7XG4gdmFyIGFkZHIgPSBpbmZvLmFkZHI7XG4gdmFyIG92ZXJmbG93ZWQgPSBmYWxzZTtcbiBpZiAobm9kZSAmJiBub2RlbGVuKSB7XG4gIHZhciBsb29rdXA7XG4gIGlmIChmbGFncyAmIDEgfHwgIShsb29rdXAgPSBETlMubG9va3VwX2FkZHIoYWRkcikpKSB7XG4gICBpZiAoZmxhZ3MgJiA4KSB7XG4gICAgcmV0dXJuIC0yO1xuICAgfVxuICB9IGVsc2Uge1xuICAgYWRkciA9IGxvb2t1cDtcbiAgfVxuICB2YXIgbnVtQnl0ZXNXcml0dGVuRXhjbE51bGwgPSBzdHJpbmdUb1VURjgoYWRkciwgbm9kZSwgbm9kZWxlbik7XG4gIGlmIChudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCArIDEgPj0gbm9kZWxlbikge1xuICAgb3ZlcmZsb3dlZCA9IHRydWU7XG4gIH1cbiB9XG4gaWYgKHNlcnYgJiYgc2Vydmxlbikge1xuICBwb3J0ID0gXCJcIiArIHBvcnQ7XG4gIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IHN0cmluZ1RvVVRGOChwb3J0LCBzZXJ2LCBzZXJ2bGVuKTtcbiAgaWYgKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsICsgMSA+PSBzZXJ2bGVuKSB7XG4gICBvdmVyZmxvd2VkID0gdHJ1ZTtcbiAgfVxuIH1cbiBpZiAob3ZlcmZsb3dlZCkge1xuICByZXR1cm4gLTEyO1xuIH1cbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYXJyYXlTdW0oYXJyYXksIGluZGV4KSB7XG4gdmFyIHN1bSA9IDA7XG4gZm9yICh2YXIgaSA9IDA7IGkgPD0gaW5kZXg7IHN1bSArPSBhcnJheVtpKytdKSB7fVxuIHJldHVybiBzdW07XG59XG5cbnZhciBNT05USF9EQVlTX0xFQVAgPSBbIDMxLCAyOSwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzEgXTtcblxudmFyIE1PTlRIX0RBWVNfUkVHVUxBUiA9IFsgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMSBdO1xuXG5mdW5jdGlvbiBhZGREYXlzKGRhdGUsIGRheXMpIHtcbiB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiB3aGlsZSAoZGF5cyA+IDApIHtcbiAgdmFyIGxlYXAgPSBpc0xlYXBZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSk7XG4gIHZhciBjdXJyZW50TW9udGggPSBuZXdEYXRlLmdldE1vbnRoKCk7XG4gIHZhciBkYXlzSW5DdXJyZW50TW9udGggPSAobGVhcCA/IE1PTlRIX0RBWVNfTEVBUCA6IE1PTlRIX0RBWVNfUkVHVUxBUilbY3VycmVudE1vbnRoXTtcbiAgaWYgKGRheXMgPiBkYXlzSW5DdXJyZW50TW9udGggLSBuZXdEYXRlLmdldERhdGUoKSkge1xuICAgZGF5cyAtPSBkYXlzSW5DdXJyZW50TW9udGggLSBuZXdEYXRlLmdldERhdGUoKSArIDE7XG4gICBuZXdEYXRlLnNldERhdGUoMSk7XG4gICBpZiAoY3VycmVudE1vbnRoIDwgMTEpIHtcbiAgICBuZXdEYXRlLnNldE1vbnRoKGN1cnJlbnRNb250aCArIDEpO1xuICAgfSBlbHNlIHtcbiAgICBuZXdEYXRlLnNldE1vbnRoKDApO1xuICAgIG5ld0RhdGUuc2V0RnVsbFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpICsgMSk7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkgKyBkYXlzKTtcbiAgIHJldHVybiBuZXdEYXRlO1xuICB9XG4gfVxuIHJldHVybiBuZXdEYXRlO1xufVxuXG5mdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkge1xuIHZhciBsZW4gPSBsZW5ndGggPiAwID8gbGVuZ3RoIDogbGVuZ3RoQnl0ZXNVVEY4KHN0cmluZ3kpICsgMTtcbiB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xuIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7XG4gaWYgKGRvbnRBZGROdWxsKSB1OGFycmF5Lmxlbmd0aCA9IG51bUJ5dGVzV3JpdHRlbjtcbiByZXR1cm4gdThhcnJheTtcbn1cblxuZnVuY3Rpb24gd3JpdGVBcnJheVRvTWVtb3J5KGFycmF5LCBidWZmZXIpIHtcbiBhc3NlcnQoYXJyYXkubGVuZ3RoID49IDAsIFwid3JpdGVBcnJheVRvTWVtb3J5IGFycmF5IG11c3QgaGF2ZSBhIGxlbmd0aCAoc2hvdWxkIGJlIGFuIGFycmF5IG9yIHR5cGVkIGFycmF5KVwiKTtcbiBIRUFQOC5zZXQoYXJyYXksIGJ1ZmZlciA+Pj4gMCk7XG59XG5cbmZ1bmN0aW9uIF9zdHJmdGltZShzLCBtYXhzaXplLCBmb3JtYXQsIHRtKSB7XG4gdmFyIHRtX3pvbmUgPSBIRUFQMzJbdG0gKyA0MCA+Pj4gMl07XG4gdmFyIGRhdGUgPSB7XG4gIHRtX3NlYzogSEVBUDMyW3RtID4+PiAyXSxcbiAgdG1fbWluOiBIRUFQMzJbdG0gKyA0ID4+PiAyXSxcbiAgdG1faG91cjogSEVBUDMyW3RtICsgOCA+Pj4gMl0sXG4gIHRtX21kYXk6IEhFQVAzMlt0bSArIDEyID4+PiAyXSxcbiAgdG1fbW9uOiBIRUFQMzJbdG0gKyAxNiA+Pj4gMl0sXG4gIHRtX3llYXI6IEhFQVAzMlt0bSArIDIwID4+PiAyXSxcbiAgdG1fd2RheTogSEVBUDMyW3RtICsgMjQgPj4+IDJdLFxuICB0bV95ZGF5OiBIRUFQMzJbdG0gKyAyOCA+Pj4gMl0sXG4gIHRtX2lzZHN0OiBIRUFQMzJbdG0gKyAzMiA+Pj4gMl0sXG4gIHRtX2dtdG9mZjogSEVBUDMyW3RtICsgMzYgPj4+IDJdLFxuICB0bV96b25lOiB0bV96b25lID8gVVRGOFRvU3RyaW5nKHRtX3pvbmUpIDogXCJcIlxuIH07XG4gdmFyIHBhdHRlcm4gPSBVVEY4VG9TdHJpbmcoZm9ybWF0KTtcbiB2YXIgRVhQQU5TSU9OX1JVTEVTXzEgPSB7XG4gIFwiJWNcIjogXCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFxuICBcIiVEXCI6IFwiJW0vJWQvJXlcIixcbiAgXCIlRlwiOiBcIiVZLSVtLSVkXCIsXG4gIFwiJWhcIjogXCIlYlwiLFxuICBcIiVyXCI6IFwiJUk6JU06JVMgJXBcIixcbiAgXCIlUlwiOiBcIiVIOiVNXCIsXG4gIFwiJVRcIjogXCIlSDolTTolU1wiLFxuICBcIiV4XCI6IFwiJW0vJWQvJXlcIixcbiAgXCIlWFwiOiBcIiVIOiVNOiVTXCIsXG4gIFwiJUVjXCI6IFwiJWNcIixcbiAgXCIlRUNcIjogXCIlQ1wiLFxuICBcIiVFeFwiOiBcIiVtLyVkLyV5XCIsXG4gIFwiJUVYXCI6IFwiJUg6JU06JVNcIixcbiAgXCIlRXlcIjogXCIleVwiLFxuICBcIiVFWVwiOiBcIiVZXCIsXG4gIFwiJU9kXCI6IFwiJWRcIixcbiAgXCIlT2VcIjogXCIlZVwiLFxuICBcIiVPSFwiOiBcIiVIXCIsXG4gIFwiJU9JXCI6IFwiJUlcIixcbiAgXCIlT21cIjogXCIlbVwiLFxuICBcIiVPTVwiOiBcIiVNXCIsXG4gIFwiJU9TXCI6IFwiJVNcIixcbiAgXCIlT3VcIjogXCIldVwiLFxuICBcIiVPVVwiOiBcIiVVXCIsXG4gIFwiJU9WXCI6IFwiJVZcIixcbiAgXCIlT3dcIjogXCIld1wiLFxuICBcIiVPV1wiOiBcIiVXXCIsXG4gIFwiJU95XCI6IFwiJXlcIlxuIH07XG4gZm9yICh2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMSkge1xuICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSwgXCJnXCIpLCBFWFBBTlNJT05fUlVMRVNfMVtydWxlXSk7XG4gfVxuIHZhciBXRUVLREFZUyA9IFsgXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiIF07XG4gdmFyIE1PTlRIUyA9IFsgXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiIF07XG4gZnVuY3Rpb24gbGVhZGluZ1NvbWV0aGluZyh2YWx1ZSwgZGlnaXRzLCBjaGFyYWN0ZXIpIHtcbiAgdmFyIHN0ciA9IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlIHx8IFwiXCI7XG4gIHdoaWxlIChzdHIubGVuZ3RoIDwgZGlnaXRzKSB7XG4gICBzdHIgPSBjaGFyYWN0ZXJbMF0gKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbiB9XG4gZnVuY3Rpb24gbGVhZGluZ051bGxzKHZhbHVlLCBkaWdpdHMpIHtcbiAgcmV0dXJuIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsIGRpZ2l0cywgXCIwXCIpO1xuIH1cbiBmdW5jdGlvbiBjb21wYXJlQnlEYXkoZGF0ZTEsIGRhdGUyKSB7XG4gIGZ1bmN0aW9uIHNnbih2YWx1ZSkge1xuICAgcmV0dXJuIHZhbHVlIDwgMCA/IC0xIDogdmFsdWUgPiAwID8gMSA6IDA7XG4gIH1cbiAgdmFyIGNvbXBhcmU7XG4gIGlmICgoY29tcGFyZSA9IHNnbihkYXRlMS5nZXRGdWxsWWVhcigpIC0gZGF0ZTIuZ2V0RnVsbFllYXIoKSkpID09PSAwKSB7XG4gICBpZiAoKGNvbXBhcmUgPSBzZ24oZGF0ZTEuZ2V0TW9udGgoKSAtIGRhdGUyLmdldE1vbnRoKCkpKSA9PT0gMCkge1xuICAgIGNvbXBhcmUgPSBzZ24oZGF0ZTEuZ2V0RGF0ZSgpIC0gZGF0ZTIuZ2V0RGF0ZSgpKTtcbiAgIH1cbiAgfVxuICByZXR1cm4gY29tcGFyZTtcbiB9XG4gZnVuY3Rpb24gZ2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aCkge1xuICBzd2l0Y2ggKGphbkZvdXJ0aC5nZXREYXkoKSkge1xuICBjYXNlIDA6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCkgLSAxLCAxMSwgMjkpO1xuXG4gIGNhc2UgMTpcbiAgIHJldHVybiBqYW5Gb3VydGg7XG5cbiAgY2FzZSAyOlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLCAwLCAzKTtcblxuICBjYXNlIDM6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksIDAsIDIpO1xuXG4gIGNhc2UgNDpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG5cbiAgY2FzZSA1OlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpIC0gMSwgMTEsIDMxKTtcblxuICBjYXNlIDY6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCkgLSAxLCAxMSwgMzApO1xuICB9XG4gfVxuIGZ1bmN0aW9uIGdldFdlZWtCYXNlZFllYXIoZGF0ZSkge1xuICB2YXIgdGhpc0RhdGUgPSBhZGREYXlzKG5ldyBEYXRlKGRhdGUudG1feWVhciArIDE5MDAsIDAsIDEpLCBkYXRlLnRtX3lkYXkpO1xuICB2YXIgamFuRm91cnRoVGhpc1llYXIgPSBuZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcbiAgdmFyIGphbkZvdXJ0aE5leHRZZWFyID0gbmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSArIDEsIDAsIDQpO1xuICB2YXIgZmlyc3RXZWVrU3RhcnRUaGlzWWVhciA9IGdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhUaGlzWWVhcik7XG4gIHZhciBmaXJzdFdlZWtTdGFydE5leHRZZWFyID0gZ2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aE5leHRZZWFyKTtcbiAgaWYgKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydFRoaXNZZWFyLCB0aGlzRGF0ZSkgPD0gMCkge1xuICAgaWYgKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydE5leHRZZWFyLCB0aGlzRGF0ZSkgPD0gMCkge1xuICAgIHJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpICsgMTtcbiAgIH1cbiAgIHJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9XG4gIHJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpIC0gMTtcbiB9XG4gdmFyIEVYUEFOU0lPTl9SVUxFU18yID0ge1xuICBcIiVhXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldLnN1YnN0cmluZygwLCAzKTtcbiAgfSxcbiAgXCIlQVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gV0VFS0RBWVNbZGF0ZS50bV93ZGF5XTtcbiAgfSxcbiAgXCIlYlwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXS5zdWJzdHJpbmcoMCwgMyk7XG4gIH0sXG4gIFwiJUJcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIE1PTlRIU1tkYXRlLnRtX21vbl07XG4gIH0sXG4gIFwiJUNcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIHllYXIgPSBkYXRlLnRtX3llYXIgKyAxOTAwO1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyh5ZWFyIC8gMTAwIHwgMCwgMik7XG4gIH0sXG4gIFwiJWRcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXksIDIpO1xuICB9LFxuICBcIiVlXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nU29tZXRoaW5nKGRhdGUudG1fbWRheSwgMiwgXCIgXCIpO1xuICB9LFxuICBcIiVnXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpO1xuICB9LFxuICBcIiVHXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpO1xuICB9LFxuICBcIiVIXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9ob3VyLCAyKTtcbiAgfSxcbiAgXCIlSVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgdHdlbHZlSG91ciA9IGRhdGUudG1faG91cjtcbiAgIGlmICh0d2VsdmVIb3VyID09IDApIHR3ZWx2ZUhvdXIgPSAxMjsgZWxzZSBpZiAodHdlbHZlSG91ciA+IDEyKSB0d2VsdmVIb3VyIC09IDEyO1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyh0d2VsdmVIb3VyLCAyKTtcbiAgfSxcbiAgXCIlalwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheSArIGFycmF5U3VtKGlzTGVhcFllYXIoZGF0ZS50bV95ZWFyICsgMTkwMCkgPyBNT05USF9EQVlTX0xFQVAgOiBNT05USF9EQVlTX1JFR1VMQVIsIGRhdGUudG1fbW9uIC0gMSksIDMpO1xuICB9LFxuICBcIiVtXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tb24gKyAxLCAyKTtcbiAgfSxcbiAgXCIlTVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWluLCAyKTtcbiAgfSxcbiAgXCIlblwiOiBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBcIlxcblwiO1xuICB9LFxuICBcIiVwXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIGlmIChkYXRlLnRtX2hvdXIgPj0gMCAmJiBkYXRlLnRtX2hvdXIgPCAxMikge1xuICAgIHJldHVybiBcIkFNXCI7XG4gICB9XG4gICByZXR1cm4gXCJQTVwiO1xuICB9LFxuICBcIiVTXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9zZWMsIDIpO1xuICB9LFxuICBcIiV0XCI6IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIFwiXFx0XCI7XG4gIH0sXG4gIFwiJXVcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGRhdGUudG1fd2RheSB8fCA3O1xuICB9LFxuICBcIiVVXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciBkYXlzID0gZGF0ZS50bV95ZGF5ICsgNyAtIGRhdGUudG1fd2RheTtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoTWF0aC5mbG9vcihkYXlzIC8gNyksIDIpO1xuICB9LFxuICBcIiVWXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciB2YWwgPSBNYXRoLmZsb29yKChkYXRlLnRtX3lkYXkgKyA3IC0gKGRhdGUudG1fd2RheSArIDYpICUgNykgLyA3KTtcbiAgIGlmICgoZGF0ZS50bV93ZGF5ICsgMzcxIC0gZGF0ZS50bV95ZGF5IC0gMikgJSA3IDw9IDIpIHtcbiAgICB2YWwrKztcbiAgIH1cbiAgIGlmICghdmFsKSB7XG4gICAgdmFsID0gNTI7XG4gICAgdmFyIGRlYzMxID0gKGRhdGUudG1fd2RheSArIDcgLSBkYXRlLnRtX3lkYXkgLSAxKSAlIDc7XG4gICAgaWYgKGRlYzMxID09IDQgfHwgZGVjMzEgPT0gNSAmJiBpc0xlYXBZZWFyKGRhdGUudG1feWVhciAlIDQwMCAtIDEpKSB7XG4gICAgIHZhbCsrO1xuICAgIH1cbiAgIH0gZWxzZSBpZiAodmFsID09IDUzKSB7XG4gICAgdmFyIGphbjEgPSAoZGF0ZS50bV93ZGF5ICsgMzcxIC0gZGF0ZS50bV95ZGF5KSAlIDc7XG4gICAgaWYgKGphbjEgIT0gNCAmJiAoamFuMSAhPSAzIHx8ICFpc0xlYXBZZWFyKGRhdGUudG1feWVhcikpKSB2YWwgPSAxO1xuICAgfVxuICAgcmV0dXJuIGxlYWRpbmdOdWxscyh2YWwsIDIpO1xuICB9LFxuICBcIiV3XCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBkYXRlLnRtX3dkYXk7XG4gIH0sXG4gIFwiJVdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIGRheXMgPSBkYXRlLnRtX3lkYXkgKyA3IC0gKGRhdGUudG1fd2RheSArIDYpICUgNztcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoTWF0aC5mbG9vcihkYXlzIC8gNyksIDIpO1xuICB9LFxuICBcIiV5XCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiAoZGF0ZS50bV95ZWFyICsgMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMik7XG4gIH0sXG4gIFwiJVlcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGRhdGUudG1feWVhciArIDE5MDA7XG4gIH0sXG4gIFwiJXpcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIG9mZiA9IGRhdGUudG1fZ210b2ZmO1xuICAgdmFyIGFoZWFkID0gb2ZmID49IDA7XG4gICBvZmYgPSBNYXRoLmFicyhvZmYpIC8gNjA7XG4gICBvZmYgPSBvZmYgLyA2MCAqIDEwMCArIG9mZiAlIDYwO1xuICAgcmV0dXJuIChhaGVhZCA/IFwiK1wiIDogXCItXCIpICsgU3RyaW5nKFwiMDAwMFwiICsgb2ZmKS5zbGljZSgtNCk7XG4gIH0sXG4gIFwiJVpcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGRhdGUudG1fem9uZTtcbiAgfSxcbiAgXCIlJVwiOiBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBcIiVcIjtcbiAgfVxuIH07XG4gcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvJSUvZywgXCJcXDBcXDBcIik7XG4gZm9yICh2YXIgcnVsZSBpbiBFWFBBTlNJT05fUlVMRVNfMikge1xuICBpZiAocGF0dGVybi5pbmNsdWRlcyhydWxlKSkge1xuICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShuZXcgUmVnRXhwKHJ1bGUsIFwiZ1wiKSwgRVhQQU5TSU9OX1JVTEVTXzJbcnVsZV0oZGF0ZSkpO1xuICB9XG4gfVxuIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcMFxcMC9nLCBcIiVcIik7XG4gdmFyIGJ5dGVzID0gaW50QXJyYXlGcm9tU3RyaW5nKHBhdHRlcm4sIGZhbHNlKTtcbiBpZiAoYnl0ZXMubGVuZ3RoID4gbWF4c2l6ZSkge1xuICByZXR1cm4gMDtcbiB9XG4gd3JpdGVBcnJheVRvTWVtb3J5KGJ5dGVzLCBzKTtcbiByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gMTtcbn1cblxuZnVuY3Rpb24gX3N0cmZ0aW1lX2wocywgbWF4c2l6ZSwgZm9ybWF0LCB0bSwgbG9jKSB7XG4gcmV0dXJuIF9zdHJmdGltZShzLCBtYXhzaXplLCBmb3JtYXQsIHRtKTtcbn1cblxuZnVuY3Rpb24gX3VjbnZfY2xvc2VfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNudl9jbG9zZV82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y252X2NvbnZlcnRFeF82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X2NvbnZlcnRFeF82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y252X29wZW5fNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNudl9vcGVuXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VjbnZfdG9BbGdvcml0aG1pY182NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X3RvQWxnb3JpdGhtaWNfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNzZGV0X2Nsb3NlXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9jbG9zZV82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfZGV0ZWN0XzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9kZXRlY3RfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNzZGV0X2dldENvbmZpZGVuY2VfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2dldENvbmZpZGVuY2VfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNzZGV0X2dldE5hbWVfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2dldE5hbWVfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNzZGV0X29wZW5fNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X29wZW5fNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNzZGV0X3NldFRleHRfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X3NldFRleHRfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56Q2xvc2UoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56Q2xvc2VcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56Q2xvc2VDdXJyZW50RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpDbG9zZUN1cnJlbnRGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekdldEN1cnJlbnRGaWxlSW5mbygpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHZXRDdXJyZW50RmlsZUluZm9cIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R2V0Q3VycmVudEZpbGVJbmZvNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R2V0Q3VycmVudEZpbGVJbmZvNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R2V0R2xvYmFsSW5mbygpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHZXRHbG9iYWxJbmZvXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekdvVG9GaXJzdEZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R29Ub0ZpcnN0RmlsZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHb1RvTmV4dEZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R29Ub05leHRGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekxvY2F0ZUZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56TG9jYXRlRmlsZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpPcGVuKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuek9wZW5cIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56T3BlbjIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlbjJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56T3BlbkN1cnJlbnRGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuek9wZW5DdXJyZW50RmlsZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpSZWFkQ3VycmVudEZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56UmVhZEN1cnJlbnRGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKSB7XG4gRVhJVFNUQVRVUyA9IGNvZGU7XG4gaWYgKCFrZWVwUnVudGltZUFsaXZlKCkpIHtcbiAgaWYgKE1vZHVsZVtcIm9uRXhpdFwiXSkgTW9kdWxlW1wib25FeGl0XCJdKGNvZGUpO1xuICBBQk9SVCA9IHRydWU7XG4gfVxuIHF1aXRfKGNvZGUsIG5ldyBFeGl0U3RhdHVzKGNvZGUpKTtcbn1cblxuZnVuY3Rpb24gZXhpdEpTKHN0YXR1cywgaW1wbGljaXQpIHtcbiBFWElUU1RBVFVTID0gc3RhdHVzO1xuIGNoZWNrVW5mbHVzaGVkQ29udGVudCgpO1xuIGlmIChrZWVwUnVudGltZUFsaXZlKCkgJiYgIWltcGxpY2l0KSB7XG4gIHZhciBtc2cgPSBgcHJvZ3JhbSBleGl0ZWQgKHdpdGggc3RhdHVzOiAke3N0YXR1c30pLCBidXQga2VlcFJ1bnRpbWVBbGl2ZSgpIGlzIHNldCAoY291bnRlcj0ke3J1bnRpbWVLZWVwYWxpdmVDb3VudGVyfSkgZHVlIHRvIGFuIGFzeW5jIG9wZXJhdGlvbiwgc28gaGFsdGluZyBleGVjdXRpb24gYnV0IG5vdCBleGl0aW5nIHRoZSBydW50aW1lIG9yIHByZXZlbnRpbmcgZnVydGhlciBhc3luYyBleGVjdXRpb24gKHlvdSBjYW4gdXNlIGVtc2NyaXB0ZW5fZm9yY2VfZXhpdCwgaWYgeW91IHdhbnQgdG8gZm9yY2UgYSB0cnVlIHNodXRkb3duKWA7XG4gIHJlYWR5UHJvbWlzZVJlamVjdChtc2cpO1xuICBlcnIobXNnKTtcbiB9XG4gX3Byb2NfZXhpdChzdGF0dXMpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFeGNlcHRpb24oZSkge1xuIGlmIChlIGluc3RhbmNlb2YgRXhpdFN0YXR1cyB8fCBlID09IFwidW53aW5kXCIpIHtcbiAgcmV0dXJuIEVYSVRTVEFUVVM7XG4gfVxuIGNoZWNrU3RhY2tDb29raWUoKTtcbiBpZiAoZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcikge1xuICBpZiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQoKSA8PSAwKSB7XG4gICBlcnIoXCJTdGFjayBvdmVyZmxvdyBkZXRlY3RlZC4gIFlvdSBjYW4gdHJ5IGluY3JlYXNpbmcgLXNTVEFDS19TSVpFIChjdXJyZW50bHkgc2V0IHRvIDY1NTM2KVwiKTtcbiAgfVxuIH1cbiBxdWl0XygxLCBlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q0Z1bmMoaWRlbnQpIHtcbiB2YXIgZnVuYyA9IE1vZHVsZVtcIl9cIiArIGlkZW50XTtcbiBhc3NlcnQoZnVuYywgXCJDYW5ub3QgY2FsbCB1bmtub3duIGZ1bmN0aW9uIFwiICsgaWRlbnQgKyBcIiwgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkXCIpO1xuIHJldHVybiBmdW5jO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjhPblN0YWNrKHN0cikge1xuIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuIHZhciByZXQgPSBzdGFja0FsbG9jKHNpemUpO1xuIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgc2l6ZSk7XG4gcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY2NhbGwoaWRlbnQsIHJldHVyblR5cGUsIGFyZ1R5cGVzLCBhcmdzLCBvcHRzKSB7XG4gdmFyIHRvQyA9IHtcbiAgXCJzdHJpbmdcIjogc3RyID0+IHtcbiAgIHZhciByZXQgPSAwO1xuICAgaWYgKHN0ciAhPT0gbnVsbCAmJiBzdHIgIT09IHVuZGVmaW5lZCAmJiBzdHIgIT09IDApIHtcbiAgICByZXQgPSBzdHJpbmdUb1VURjhPblN0YWNrKHN0cik7XG4gICB9XG4gICByZXR1cm4gcmV0O1xuICB9LFxuICBcImFycmF5XCI6IGFyciA9PiB7XG4gICB2YXIgcmV0ID0gc3RhY2tBbGxvYyhhcnIubGVuZ3RoKTtcbiAgIHdyaXRlQXJyYXlUb01lbW9yeShhcnIsIHJldCk7XG4gICByZXR1cm4gcmV0O1xuICB9XG4gfTtcbiBmdW5jdGlvbiBjb252ZXJ0UmV0dXJuVmFsdWUocmV0KSB7XG4gIGlmIChyZXR1cm5UeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICByZXR1cm4gVVRGOFRvU3RyaW5nKHJldCk7XG4gIH1cbiAgaWYgKHJldHVyblR5cGUgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gQm9vbGVhbihyZXQpO1xuICByZXR1cm4gcmV0O1xuIH1cbiB2YXIgZnVuYyA9IGdldENGdW5jKGlkZW50KTtcbiB2YXIgY0FyZ3MgPSBbXTtcbiB2YXIgc3RhY2sgPSAwO1xuIGFzc2VydChyZXR1cm5UeXBlICE9PSBcImFycmF5XCIsICdSZXR1cm4gdHlwZSBzaG91bGQgbm90IGJlIFwiYXJyYXlcIi4nKTtcbiBpZiAoYXJncykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgIHZhciBjb252ZXJ0ZXIgPSB0b0NbYXJnVHlwZXNbaV1dO1xuICAgaWYgKGNvbnZlcnRlcikge1xuICAgIGlmIChzdGFjayA9PT0gMCkgc3RhY2sgPSBzdGFja1NhdmUoKTtcbiAgICBjQXJnc1tpXSA9IGNvbnZlcnRlcihhcmdzW2ldKTtcbiAgIH0gZWxzZSB7XG4gICAgY0FyZ3NbaV0gPSBhcmdzW2ldO1xuICAgfVxuICB9XG4gfVxuIHZhciByZXQgPSBmdW5jLmFwcGx5KG51bGwsIGNBcmdzKTtcbiBmdW5jdGlvbiBvbkRvbmUocmV0KSB7XG4gIGlmIChzdGFjayAhPT0gMCkgc3RhY2tSZXN0b3JlKHN0YWNrKTtcbiAgcmV0dXJuIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpO1xuIH1cbiByZXQgPSBvbkRvbmUocmV0KTtcbiByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjaGVja0luY29taW5nTW9kdWxlQVBJKCkge1xuIGlnbm9yZWRNb2R1bGVQcm9wKFwiZmV0Y2hTZXR0aW5nc1wiKTtcbn1cblxudmFyIHdhc21JbXBvcnRzID0ge1xuIFwiWE1MX0dldEJ1ZmZlclwiOiBfWE1MX0dldEJ1ZmZlcixcbiBcIlhNTF9HZXRFcnJvckNvZGVcIjogX1hNTF9HZXRFcnJvckNvZGUsXG4gXCJYTUxfUGFyc2VcIjogX1hNTF9QYXJzZSxcbiBcIlhNTF9QYXJzZUJ1ZmZlclwiOiBfWE1MX1BhcnNlQnVmZmVyLFxuIFwiWE1MX1BhcnNlckNyZWF0ZVwiOiBfWE1MX1BhcnNlckNyZWF0ZSxcbiBcIlhNTF9QYXJzZXJGcmVlXCI6IF9YTUxfUGFyc2VyRnJlZSxcbiBcIlhNTF9SZXN1bWVQYXJzZXJcIjogX1hNTF9SZXN1bWVQYXJzZXIsXG4gXCJYTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXJcIjogX1hNTF9TZXRDaGFyYWN0ZXJEYXRhSGFuZGxlcixcbiBcIlhNTF9TZXRFbGVtZW50SGFuZGxlclwiOiBfWE1MX1NldEVsZW1lbnRIYW5kbGVyLFxuIFwiWE1MX1NldFVzZXJEYXRhXCI6IF9YTUxfU2V0VXNlckRhdGEsXG4gXCJYTUxfU3RvcFBhcnNlclwiOiBfWE1MX1N0b3BQYXJzZXIsXG4gXCJfX2Fzc2VydF9mYWlsXCI6IF9fX2Fzc2VydF9mYWlsLFxuIFwiX19kbHN5bVwiOiBfX19kbHN5bSxcbiBcIl9fc3lzY2FsbF9fbmV3c2VsZWN0XCI6IF9fX3N5c2NhbGxfX25ld3NlbGVjdCxcbiBcIl9fc3lzY2FsbF9iaW5kXCI6IF9fX3N5c2NhbGxfYmluZCxcbiBcIl9fc3lzY2FsbF9jb25uZWN0XCI6IF9fX3N5c2NhbGxfY29ubmVjdCxcbiBcIl9fc3lzY2FsbF9mYWNjZXNzYXRcIjogX19fc3lzY2FsbF9mYWNjZXNzYXQsXG4gXCJfX3N5c2NhbGxfZmNudGw2NFwiOiBfX19zeXNjYWxsX2ZjbnRsNjQsXG4gXCJfX3N5c2NhbGxfZnN0YXQ2NFwiOiBfX19zeXNjYWxsX2ZzdGF0NjQsXG4gXCJfX3N5c2NhbGxfZnRydW5jYXRlNjRcIjogX19fc3lzY2FsbF9mdHJ1bmNhdGU2NCxcbiBcIl9fc3lzY2FsbF9nZXRkZW50czY0XCI6IF9fX3N5c2NhbGxfZ2V0ZGVudHM2NCxcbiBcIl9fc3lzY2FsbF9nZXRwZWVybmFtZVwiOiBfX19zeXNjYWxsX2dldHBlZXJuYW1lLFxuIFwiX19zeXNjYWxsX2dldHNvY2tvcHRcIjogX19fc3lzY2FsbF9nZXRzb2Nrb3B0LFxuIFwiX19zeXNjYWxsX2lvY3RsXCI6IF9fX3N5c2NhbGxfaW9jdGwsXG4gXCJfX3N5c2NhbGxfbHN0YXQ2NFwiOiBfX19zeXNjYWxsX2xzdGF0NjQsXG4gXCJfX3N5c2NhbGxfbWtkaXJhdFwiOiBfX19zeXNjYWxsX21rZGlyYXQsXG4gXCJfX3N5c2NhbGxfbmV3ZnN0YXRhdFwiOiBfX19zeXNjYWxsX25ld2ZzdGF0YXQsXG4gXCJfX3N5c2NhbGxfb3BlbmF0XCI6IF9fX3N5c2NhbGxfb3BlbmF0LFxuIFwiX19zeXNjYWxsX3JlY3Zmcm9tXCI6IF9fX3N5c2NhbGxfcmVjdmZyb20sXG4gXCJfX3N5c2NhbGxfcmVuYW1lYXRcIjogX19fc3lzY2FsbF9yZW5hbWVhdCxcbiBcIl9fc3lzY2FsbF9ybWRpclwiOiBfX19zeXNjYWxsX3JtZGlyLFxuIFwiX19zeXNjYWxsX3NlbmR0b1wiOiBfX19zeXNjYWxsX3NlbmR0byxcbiBcIl9fc3lzY2FsbF9zb2NrZXRcIjogX19fc3lzY2FsbF9zb2NrZXQsXG4gXCJfX3N5c2NhbGxfc3RhdDY0XCI6IF9fX3N5c2NhbGxfc3RhdDY0LFxuIFwiX19zeXNjYWxsX3VubGlua2F0XCI6IF9fX3N5c2NhbGxfdW5saW5rYXQsXG4gXCJfX3Rocm93X2V4Y2VwdGlvbl93aXRoX3N0YWNrX3RyYWNlXCI6IF9fX3Rocm93X2V4Y2VwdGlvbl93aXRoX3N0YWNrX3RyYWNlLFxuIFwiX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWNcIjogX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFxuIFwiX2xvY2FsdGltZV9qc1wiOiBfX2xvY2FsdGltZV9qcyxcbiBcIl90enNldF9qc1wiOiBfX3R6c2V0X2pzLFxuIFwiYWJvcnRcIjogX2Fib3J0LFxuIFwiZGxvcGVuXCI6IF9kbG9wZW4sXG4gXCJkdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGVcIjogX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2NyZWF0ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0c1wiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfZXhpc3RzLFxuIFwiZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlc1wiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlcyxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X3JlbW92ZVwiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfcmVtb3ZlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2Nsb3NlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfY2xvc2UsXG4gXCJkdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2dldF9sYXN0X21vZGlmaWVkX3RpbWVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9nZXRfbGFzdF9tb2RpZmllZF90aW1lLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX21vdmVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX29wZW5cIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9vcGVuLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3JlYWRcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfdHJ1bmNhdGUsXG4gXCJkdWNrZGJfd2ViX2ZzX2ZpbGVfd3JpdGVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZ2V0X2RlZmF1bHRfZGF0YV9wcm90b2NvbFwiOiBfZHVja2RiX3dlYl9mc19nZXRfZGVmYXVsdF9kYXRhX3Byb3RvY29sLFxuIFwiZHVja2RiX3dlYl9mc19nbG9iXCI6IF9kdWNrZGJfd2ViX2ZzX2dsb2IsXG4gXCJkdWNrZGJfd2ViX3Rlc3RfcGxhdGZvcm1fZmVhdHVyZVwiOiBfZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmUsXG4gXCJkdWNrZGJfd2ViX3VkZl9zY2FsYXJfY2FsbFwiOiBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGwsXG4gXCJlbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3JcIjogX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcixcbiBcImVtc2NyaXB0ZW5fZGF0ZV9ub3dcIjogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gXCJlbXNjcmlwdGVuX2dldF9oZWFwX21heFwiOiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gXCJlbXNjcmlwdGVuX2dldF9ub3dcIjogX2Vtc2NyaXB0ZW5fZ2V0X25vdyxcbiBcImVtc2NyaXB0ZW5fbWVtY3B5X2JpZ1wiOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFxuIFwiZW1zY3JpcHRlbl9yZXNpemVfaGVhcFwiOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiBcImVudmlyb25fZ2V0XCI6IF9lbnZpcm9uX2dldCxcbiBcImVudmlyb25fc2l6ZXNfZ2V0XCI6IF9lbnZpcm9uX3NpemVzX2dldCxcbiBcImZkX2Nsb3NlXCI6IF9mZF9jbG9zZSxcbiBcImZkX2Zkc3RhdF9nZXRcIjogX2ZkX2Zkc3RhdF9nZXQsXG4gXCJmZF9wcmVhZFwiOiBfZmRfcHJlYWQsXG4gXCJmZF9wd3JpdGVcIjogX2ZkX3B3cml0ZSxcbiBcImZkX3JlYWRcIjogX2ZkX3JlYWQsXG4gXCJmZF9zZWVrXCI6IF9mZF9zZWVrLFxuIFwiZmRfc3luY1wiOiBfZmRfc3luYyxcbiBcImZkX3dyaXRlXCI6IF9mZF93cml0ZSxcbiBcImdldGFkZHJpbmZvXCI6IF9nZXRhZGRyaW5mbyxcbiBcImdldGVudHJvcHlcIjogX2dldGVudHJvcHksXG4gXCJnZXRuYW1laW5mb1wiOiBfZ2V0bmFtZWluZm8sXG4gXCJzdHJmdGltZV9sXCI6IF9zdHJmdGltZV9sLFxuIFwidWNudl9jbG9zZV82NFwiOiBfdWNudl9jbG9zZV82NCxcbiBcInVjbnZfY29udmVydEV4XzY0XCI6IF91Y252X2NvbnZlcnRFeF82NCxcbiBcInVjbnZfb3Blbl82NFwiOiBfdWNudl9vcGVuXzY0LFxuIFwidWNudl90b0FsZ29yaXRobWljXzY0XCI6IF91Y252X3RvQWxnb3JpdGhtaWNfNjQsXG4gXCJ1Y3NkZXRfY2xvc2VfNjRcIjogX3Vjc2RldF9jbG9zZV82NCxcbiBcInVjc2RldF9kZXRlY3RfNjRcIjogX3Vjc2RldF9kZXRlY3RfNjQsXG4gXCJ1Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NFwiOiBfdWNzZGV0X2dldENvbmZpZGVuY2VfNjQsXG4gXCJ1Y3NkZXRfZ2V0TmFtZV82NFwiOiBfdWNzZGV0X2dldE5hbWVfNjQsXG4gXCJ1Y3NkZXRfb3Blbl82NFwiOiBfdWNzZGV0X29wZW5fNjQsXG4gXCJ1Y3NkZXRfc2V0VGV4dF82NFwiOiBfdWNzZGV0X3NldFRleHRfNjQsXG4gXCJ1bnpDbG9zZVwiOiBfdW56Q2xvc2UsXG4gXCJ1bnpDbG9zZUN1cnJlbnRGaWxlXCI6IF91bnpDbG9zZUN1cnJlbnRGaWxlLFxuIFwidW56R2V0Q3VycmVudEZpbGVJbmZvXCI6IF91bnpHZXRDdXJyZW50RmlsZUluZm8sXG4gXCJ1bnpHZXRDdXJyZW50RmlsZUluZm82NFwiOiBfdW56R2V0Q3VycmVudEZpbGVJbmZvNjQsXG4gXCJ1bnpHZXRHbG9iYWxJbmZvXCI6IF91bnpHZXRHbG9iYWxJbmZvLFxuIFwidW56R29Ub0ZpcnN0RmlsZVwiOiBfdW56R29Ub0ZpcnN0RmlsZSxcbiBcInVuekdvVG9OZXh0RmlsZVwiOiBfdW56R29Ub05leHRGaWxlLFxuIFwidW56TG9jYXRlRmlsZVwiOiBfdW56TG9jYXRlRmlsZSxcbiBcInVuek9wZW5cIjogX3Vuek9wZW4sXG4gXCJ1bnpPcGVuMlwiOiBfdW56T3BlbjIsXG4gXCJ1bnpPcGVuQ3VycmVudEZpbGVcIjogX3Vuek9wZW5DdXJyZW50RmlsZSxcbiBcInVuelJlYWRDdXJyZW50RmlsZVwiOiBfdW56UmVhZEN1cnJlbnRGaWxlXG59O1xuXG52YXIgYXNtID0gY3JlYXRlV2FzbSgpO1xuXG52YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fd2FzbV9jYWxsX2N0b3JzXCIpO1xuXG52YXIgX21haW4gPSBNb2R1bGVbXCJfbWFpblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtYWluXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2UgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NsZWFyX3Jlc3BvbnNlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmFpbF93aXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmFpbF93aXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZmFpbF93aXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcmVzZXQgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3Jlc2V0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29ubmVjdCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2Nvbm5lY3RcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb25uZWN0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZGlzY29ubmVjdCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3RcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9kaXNjb25uZWN0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mbHVzaF9maWxlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfb3BlbiA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX29wZW5cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9vcGVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X2dsb2JhbF9maWxlX2luZm8gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mb1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9leHBvcnRfZmlsZV9zdGF0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlcyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV91cmwgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXIgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX2J1ZmZlclwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlciA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X3ZlcnNpb24gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF92ZXJzaW9uXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3MgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfZmVhdHVyZV9mbGFnc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF9mZWF0dXJlX2ZsYWdzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfdG9rZW5pemUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl90b2tlbml6ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3Rva2VuaXplXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3VkZl9zY2FsYXJfY3JlYXRlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2UgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3ByZXBhcmVkX2Nsb3NlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcXVlcnlfcnVuID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfcnVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcXVlcnlfcnVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWwgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X2NhbmNlbFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0cyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X3RhYmxlbmFtZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdGFibGVuYW1lc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW1cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2Nzdl9mcm9tX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2luc2VydF9jc3ZfZnJvbV9wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCIpO1xuXG52YXIgX19fZXJybm9fbG9jYXRpb24gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19lcnJub19sb2NhdGlvblwiKTtcblxudmFyIF9mZmx1c2ggPSBNb2R1bGVbXCJfZmZsdXNoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZmbHVzaFwiKTtcblxudmFyIF9odG9ubCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJodG9ubFwiKTtcblxudmFyIF9odG9ucyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJodG9uc1wiKTtcblxudmFyIF9udG9ocyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJudG9oc1wiKTtcblxudmFyIF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1hbGxvY1wiKTtcblxudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZnJlZVwiKTtcblxudmFyIF9fX3RyYXAgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9fX3RyYXAgPSBNb2R1bGVbXCJhc21cIl1bXCJfX3RyYXBcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfaW5pdCA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfaW5pdCA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfaW5pdFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIChfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2VcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZFwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBzdGFja1NhdmUgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic3RhY2tTYXZlXCIpO1xuXG52YXIgc3RhY2tSZXN0b3JlID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrUmVzdG9yZVwiKTtcblxudmFyIHN0YWNrQWxsb2MgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwic3RhY2tBbGxvY1wiKTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50ID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIChfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCA9IE1vZHVsZVtcImFzbVwiXVtcImVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX19fY3hhX2RlY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQgPSBNb2R1bGVbXCJfX19jeGFfZGVjcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX2N4YV9kZWNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50XCIpO1xuXG52YXIgX19fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQgPSBNb2R1bGVbXCJfX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50XCIpO1xuXG52YXIgX19fdGhyb3duX29iamVjdF9mcm9tX3Vud2luZF9leGNlcHRpb24gPSBNb2R1bGVbXCJfX190aHJvd25fb2JqZWN0X2Zyb21fdW53aW5kX2V4Y2VwdGlvblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX3Rocm93bl9vYmplY3RfZnJvbV91bndpbmRfZXhjZXB0aW9uXCIpO1xuXG52YXIgX19fZ2V0X2V4Y2VwdGlvbl9tZXNzYWdlID0gTW9kdWxlW1wiX19fZ2V0X2V4Y2VwdGlvbl9tZXNzYWdlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fZ2V0X2V4Y2VwdGlvbl9tZXNzYWdlXCIpO1xuXG52YXIgZHluQ2FsbF9qaWppID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamppXCIpO1xuXG52YXIgZHluQ2FsbF9paWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqaVwiKTtcblxudmFyIGR5bkNhbGxfamkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpalwiKTtcblxudmFyIGR5bkNhbGxfdmpqaWppaiA9IE1vZHVsZVtcImR5bkNhbGxfdmpqaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZqamlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpampqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqamppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqamppXCIpO1xuXG52YXIgZHluQ2FsbF92amppaSA9IE1vZHVsZVtcImR5bkNhbGxfdmpqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92amppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpalwiKTtcblxudmFyIGR5bkNhbGxfamlqamlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqaWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWpqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpqalwiKTtcblxudmFyIGR5bkNhbGxfdmlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpampcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlqaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWppaVwiKTtcblxudmFyIGR5bkNhbGxfamlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlpaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlpalwiKTtcblxudmFyIGR5bkNhbGxfdmlqaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpamlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWppaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWpqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlpXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWppID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9paWppaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlcIik7XG5cbnZhciBkeW5DYWxsX2lpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpampcIik7XG5cbnZhciBkeW5DYWxsX2ppamogPSBNb2R1bGVbXCJkeW5DYWxsX2ppampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlcIik7XG5cbnZhciBkeW5DYWxsX2ppaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2ogPSBNb2R1bGVbXCJkeW5DYWxsX2pcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfamlpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2pqID0gTW9kdWxlW1wiZHluQ2FsbF9qalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2pqXCIpO1xuXG52YXIgZHluQ2FsbF9paiA9IE1vZHVsZVtcImR5bkNhbGxfaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9palwiKTtcblxudmFyIGR5bkNhbGxfaWpqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWpqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lqampcIik7XG5cbnZhciBkeW5DYWxsX2pqamQgPSBNb2R1bGVbXCJkeW5DYWxsX2pqamRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qampkXCIpO1xuXG52YXIgZHluQ2FsbF9qampqampkID0gTW9kdWxlW1wiZHluQ2FsbF9qampqampkXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfampqampqZFwiKTtcblxudmFyIGR5bkNhbGxfamlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqaWlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpamlpaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWlpamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWppaWlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlqaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpXCIpO1xuXG5Nb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gc3RhY2tBbGxvYztcblxuTW9kdWxlW1wic3RhY2tTYXZlXCJdID0gc3RhY2tTYXZlO1xuXG5Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl0gPSBzdGFja1Jlc3RvcmU7XG5cbk1vZHVsZVtcImNjYWxsXCJdID0gY2NhbGw7XG5cbnZhciBtaXNzaW5nTGlicmFyeVN5bWJvbHMgPSBbIFwiZ2V0SG9zdEJ5TmFtZVwiLCBcInRyYXZlcnNlU3RhY2tcIiwgXCJnZXRDYWxsc3RhY2tcIiwgXCJlbXNjcmlwdGVuTG9nXCIsIFwiY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvblwiLCBcInJlYWRFbUFzbUFyZ3NcIiwgXCJqc3RvaV9zXCIsIFwibGlzdGVuT25jZVwiLCBcImF1dG9SZXN1bWVBdWRpb0NvbnRleHRcIiwgXCJkeW5DYWxsTGVnYWN5XCIsIFwiZ2V0RHluQ2FsbGVyXCIsIFwiZHluQ2FsbFwiLCBcInJ1bnRpbWVLZWVwYWxpdmVQdXNoXCIsIFwicnVudGltZUtlZXBhbGl2ZVBvcFwiLCBcImNhbGxVc2VyQ2FsbGJhY2tcIiwgXCJtYXliZUV4aXRcIiwgXCJzYWZlU2V0VGltZW91dFwiLCBcImFzbWpzTWFuZ2xlXCIsIFwiYXN5bmNMb2FkXCIsIFwiYWxpZ25NZW1vcnlcIiwgXCJtbWFwQWxsb2NcIiwgXCJIYW5kbGVBbGxvY2F0b3JcIiwgXCJnZXROYXRpdmVUeXBlU2l6ZVwiLCBcIlNUQUNLX1NJWkVcIiwgXCJTVEFDS19BTElHTlwiLCBcIlBPSU5URVJfU0laRVwiLCBcIkFTU0VSVElPTlNcIiwgXCJ3cml0ZUk1M1RvSTY0XCIsIFwid3JpdGVJNTNUb0k2NENsYW1wZWRcIiwgXCJ3cml0ZUk1M1RvSTY0U2lnbmFsaW5nXCIsIFwid3JpdGVJNTNUb1U2NENsYW1wZWRcIiwgXCJ3cml0ZUk1M1RvVTY0U2lnbmFsaW5nXCIsIFwicmVhZEk1M0Zyb21VNjRcIiwgXCJjb252ZXJ0STMyUGFpclRvSTUzXCIsIFwiY29udmVydFUzMlBhaXJUb0k1M1wiLCBcImN3cmFwXCIsIFwidWxlYjEyOEVuY29kZVwiLCBcInNpZ1RvV2FzbVR5cGVzXCIsIFwiZ2VuZXJhdGVGdW5jVHlwZVwiLCBcImNvbnZlcnRKc0Z1bmN0aW9uVG9XYXNtXCIsIFwiZ2V0RW1wdHlUYWJsZVNsb3RcIiwgXCJ1cGRhdGVUYWJsZU1hcFwiLCBcImdldEZ1bmN0aW9uQWRkcmVzc1wiLCBcImFkZEZ1bmN0aW9uXCIsIFwicmVtb3ZlRnVuY3Rpb25cIiwgXCJyZWFsbHlOZWdhdGl2ZVwiLCBcInVuU2lnblwiLCBcInN0ckxlblwiLCBcInJlU2lnblwiLCBcImZvcm1hdFN0cmluZ1wiLCBcImludEFycmF5VG9TdHJpbmdcIiwgXCJBc2NpaVRvU3RyaW5nXCIsIFwiVVRGMTZUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGMTZcIiwgXCJsZW5ndGhCeXRlc1VURjE2XCIsIFwiVVRGMzJUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGMzJcIiwgXCJsZW5ndGhCeXRlc1VURjMyXCIsIFwicmVnaXN0ZXJLZXlFdmVudENhbGxiYWNrXCIsIFwibWF5YmVDU3RyaW5nVG9Kc1N0cmluZ1wiLCBcImZpbmRFdmVudFRhcmdldFwiLCBcImZpbmRDYW52YXNFdmVudFRhcmdldFwiLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiLCBcImZpbGxNb3VzZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJXaGVlbEV2ZW50Q2FsbGJhY2tcIiwgXCJyZWdpc3RlclVpRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyRm9jdXNFdmVudENhbGxiYWNrXCIsIFwiZmlsbERldmljZU9yaWVudGF0aW9uRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJEZXZpY2VPcmllbnRhdGlvbkV2ZW50Q2FsbGJhY2tcIiwgXCJmaWxsRGV2aWNlTW90aW9uRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJEZXZpY2VNb3Rpb25FdmVudENhbGxiYWNrXCIsIFwic2NyZWVuT3JpZW50YXRpb25cIiwgXCJmaWxsT3JpZW50YXRpb25DaGFuZ2VFdmVudERhdGFcIiwgXCJyZWdpc3Rlck9yaWVudGF0aW9uQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcImZpbGxGdWxsc2NyZWVuQ2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcIkpTRXZlbnRzX3JlcXVlc3RGdWxsc2NyZWVuXCIsIFwiSlNFdmVudHNfcmVzaXplQ2FudmFzRm9yRnVsbHNjcmVlblwiLCBcInJlZ2lzdGVyUmVzdG9yZU9sZFN0eWxlXCIsIFwiaGlkZUV2ZXJ5dGhpbmdFeGNlcHRHaXZlbkVsZW1lbnRcIiwgXCJyZXN0b3JlSGlkZGVuRWxlbWVudHNcIiwgXCJzZXRMZXR0ZXJib3hcIiwgXCJzb2Z0RnVsbHNjcmVlblJlc2l6ZVdlYkdMUmVuZGVyVGFyZ2V0XCIsIFwiZG9SZXF1ZXN0RnVsbHNjcmVlblwiLCBcImZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyUG9pbnRlcmxvY2tDaGFuZ2VFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJQb2ludGVybG9ja0Vycm9yRXZlbnRDYWxsYmFja1wiLCBcInJlcXVlc3RQb2ludGVyTG9ja1wiLCBcImZpbGxWaXNpYmlsaXR5Q2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyVG91Y2hFdmVudENhbGxiYWNrXCIsIFwiZmlsbEdhbWVwYWRFdmVudERhdGFcIiwgXCJyZWdpc3RlckdhbWVwYWRFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJCZWZvcmVVbmxvYWRFdmVudENhbGxiYWNrXCIsIFwiZmlsbEJhdHRlcnlFdmVudERhdGFcIiwgXCJiYXR0ZXJ5XCIsIFwicmVnaXN0ZXJCYXR0ZXJ5RXZlbnRDYWxsYmFja1wiLCBcInNldENhbnZhc0VsZW1lbnRTaXplXCIsIFwiZ2V0Q2FudmFzRWxlbWVudFNpemVcIiwgXCJkZW1hbmdsZVwiLCBcImRlbWFuZ2xlQWxsXCIsIFwianNTdGFja1RyYWNlXCIsIFwic3RhY2tUcmFjZVwiLCBcImNoZWNrV2FzaUNsb2NrXCIsIFwid2FzaVJpZ2h0c1RvTXVzbE9GbGFnc1wiLCBcIndhc2lPRmxhZ3NUb011c2xPRmxhZ3NcIiwgXCJjcmVhdGVEeW5jYWxsV3JhcHBlclwiLCBcInNldEltbWVkaWF0ZVdyYXBwZWRcIiwgXCJjbGVhckltbWVkaWF0ZVdyYXBwZWRcIiwgXCJwb2x5ZmlsbFNldEltbWVkaWF0ZVwiLCBcImdldFByb21pc2VcIiwgXCJtYWtlUHJvbWlzZVwiLCBcImlkc1RvUHJvbWlzZXNcIiwgXCJtYWtlUHJvbWlzZUNhbGxiYWNrXCIsIFwic2V0TWFpbkxvb3BcIiwgXCJoZWFwT2JqZWN0Rm9yV2ViR0xUeXBlXCIsIFwiaGVhcEFjY2Vzc1NoaWZ0Rm9yV2ViR0xIZWFwXCIsIFwid2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXNcIiwgXCJ3ZWJnbF9lbmFibGVfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiwgXCJ3ZWJnbF9lbmFibGVfV0VCR0xfZHJhd19idWZmZXJzXCIsIFwid2ViZ2xfZW5hYmxlX1dFQkdMX211bHRpX2RyYXdcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRcIiwgXCJjb21wdXRlVW5wYWNrQWxpZ25lZEltYWdlU2l6ZVwiLCBcImNvbG9yQ2hhbm5lbHNJbkdsVGV4dHVyZUZvcm1hdFwiLCBcImVtc2NyaXB0ZW5XZWJHTEdldFRleFBpeGVsRGF0YVwiLCBcIl9fZ2xHZW5PYmplY3RcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRVbmlmb3JtXCIsIFwid2ViZ2xHZXRVbmlmb3JtTG9jYXRpb25cIiwgXCJ3ZWJnbFByZXBhcmVVbmlmb3JtTG9jYXRpb25zQmVmb3JlRmlyc3RVc2VcIiwgXCJ3ZWJnbEdldExlZnRCcmFjZVBvc1wiLCBcImVtc2NyaXB0ZW5XZWJHTEdldFZlcnRleEF0dHJpYlwiLCBcIl9fZ2xHZXRBY3RpdmVBdHRyaWJPclVuaWZvcm1cIiwgXCJ3cml0ZUdMQXJyYXlcIiwgXCJyZWdpc3RlcldlYkdsRXZlbnRDYWxsYmFja1wiLCBcInJ1bkFuZEFib3J0SWZFcnJvclwiLCBcIlNETF91bmljb2RlXCIsIFwiU0RMX3R0ZkNvbnRleHRcIiwgXCJTRExfYXVkaW9cIiwgXCJHTEZXX1dpbmRvd1wiLCBcIkFMTE9DX05PUk1BTFwiLCBcIkFMTE9DX1NUQUNLXCIsIFwiYWxsb2NhdGVcIiwgXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XCIsIFwid3JpdGVBc2NpaVRvTWVtb3J5XCIgXTtcblxubWlzc2luZ0xpYnJhcnlTeW1ib2xzLmZvckVhY2gobWlzc2luZ0xpYnJhcnlTeW1ib2wpO1xuXG52YXIgdW5leHBvcnRlZFN5bWJvbHMgPSBbIFwicnVuXCIsIFwiYWRkT25QcmVSdW5cIiwgXCJhZGRPbkluaXRcIiwgXCJhZGRPblByZU1haW5cIiwgXCJhZGRPbkV4aXRcIiwgXCJhZGRPblBvc3RSdW5cIiwgXCJhZGRSdW5EZXBlbmRlbmN5XCIsIFwicmVtb3ZlUnVuRGVwZW5kZW5jeVwiLCBcIkZTX2NyZWF0ZUZvbGRlclwiLCBcIkZTX2NyZWF0ZVBhdGhcIiwgXCJGU19jcmVhdGVEYXRhRmlsZVwiLCBcIkZTX2NyZWF0ZUxhenlGaWxlXCIsIFwiRlNfY3JlYXRlTGlua1wiLCBcIkZTX2NyZWF0ZURldmljZVwiLCBcIkZTX3VubGlua1wiLCBcIm91dFwiLCBcImVyclwiLCBcImNhbGxNYWluXCIsIFwiYWJvcnRcIiwgXCJrZWVwUnVudGltZUFsaXZlXCIsIFwid2FzbU1lbW9yeVwiLCBcImdldFRlbXBSZXQwXCIsIFwic2V0VGVtcFJldDBcIiwgXCJ3cml0ZVN0YWNrQ29va2llXCIsIFwiY2hlY2tTdGFja0Nvb2tpZVwiLCBcInB0clRvU3RyaW5nXCIsIFwiemVyb01lbW9yeVwiLCBcImV4aXRKU1wiLCBcImdldEhlYXBNYXhcIiwgXCJlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyXCIsIFwiRU5WXCIsIFwiTU9OVEhfREFZU19SRUdVTEFSXCIsIFwiTU9OVEhfREFZU19MRUFQXCIsIFwiTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkVcIiwgXCJNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVwiLCBcImlzTGVhcFllYXJcIiwgXCJ5ZGF5RnJvbURhdGVcIiwgXCJhcnJheVN1bVwiLCBcImFkZERheXNcIiwgXCJFUlJOT19DT0RFU1wiLCBcIkVSUk5PX01FU1NBR0VTXCIsIFwic2V0RXJyTm9cIiwgXCJpbmV0UHRvbjRcIiwgXCJpbmV0TnRvcDRcIiwgXCJpbmV0UHRvbjZcIiwgXCJpbmV0TnRvcDZcIiwgXCJyZWFkU29ja2FkZHJcIiwgXCJ3cml0ZVNvY2thZGRyXCIsIFwiRE5TXCIsIFwiUHJvdG9jb2xzXCIsIFwiU29ja2V0c1wiLCBcImluaXRSYW5kb21GaWxsXCIsIFwicmFuZG9tRmlsbFwiLCBcInRpbWVyc1wiLCBcIndhcm5PbmNlXCIsIFwiVU5XSU5EX0NBQ0hFXCIsIFwicmVhZEVtQXNtQXJnc0FycmF5XCIsIFwianN0b2lfcVwiLCBcImdldEV4ZWN1dGFibGVOYW1lXCIsIFwiaGFuZGxlRXhjZXB0aW9uXCIsIFwicmVhZEk1M0Zyb21JNjRcIiwgXCJjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZFwiLCBcImdldENGdW5jXCIsIFwiZnJlZVRhYmxlSW5kZXhlc1wiLCBcImZ1bmN0aW9uc0luVGFibGVNYXBcIiwgXCJzZXRWYWx1ZVwiLCBcImdldFZhbHVlXCIsIFwiUEFUSFwiLCBcIlBBVEhfRlNcIiwgXCJVVEY4RGVjb2RlclwiLCBcIlVURjhBcnJheVRvU3RyaW5nXCIsIFwiVVRGOFRvU3RyaW5nXCIsIFwic3RyaW5nVG9VVEY4QXJyYXlcIiwgXCJzdHJpbmdUb1VURjhcIiwgXCJsZW5ndGhCeXRlc1VURjhcIiwgXCJpbnRBcnJheUZyb21TdHJpbmdcIiwgXCJzdHJpbmdUb0FzY2lpXCIsIFwiVVRGMTZEZWNvZGVyXCIsIFwic3RyaW5nVG9OZXdVVEY4XCIsIFwic3RyaW5nVG9VVEY4T25TdGFja1wiLCBcIndyaXRlQXJyYXlUb01lbW9yeVwiLCBcIkpTRXZlbnRzXCIsIFwic3BlY2lhbEhUTUxUYXJnZXRzXCIsIFwiY3VycmVudEZ1bGxzY3JlZW5TdHJhdGVneVwiLCBcInJlc3RvcmVPbGRXaW5kb3dlZFN0eWxlXCIsIFwiRXhpdFN0YXR1c1wiLCBcImdldEVudlN0cmluZ3NcIiwgXCJmbHVzaF9OT19GSUxFU1lTVEVNXCIsIFwiZGxvcGVuTWlzc2luZ0Vycm9yXCIsIFwicHJvbWlzZU1hcFwiLCBcImdldEV4Y2VwdGlvbk1lc3NhZ2VDb21tb25cIiwgXCJnZXRDcHBFeGNlcHRpb25UYWdcIiwgXCJnZXRDcHBFeGNlcHRpb25UaHJvd25PYmplY3RGcm9tV2ViQXNzZW1ibHlFeGNlcHRpb25cIiwgXCJpbmNyZW1lbnRFeGNlcHRpb25SZWZjb3VudFwiLCBcImRlY3JlbWVudEV4Y2VwdGlvblJlZmNvdW50XCIsIFwiZ2V0RXhjZXB0aW9uTWVzc2FnZVwiLCBcIkJyb3dzZXJcIiwgXCJ3Z2V0XCIsIFwiU1lTQ0FMTFNcIiwgXCJnZXRTb2NrZXRGcm9tRkRcIiwgXCJnZXRTb2NrZXRBZGRyZXNzXCIsIFwidGVtcEZpeGVkTGVuZ3RoQXJyYXlcIiwgXCJtaW5pVGVtcFdlYkdMRmxvYXRCdWZmZXJzXCIsIFwibWluaVRlbXBXZWJHTEludEJ1ZmZlcnNcIiwgXCJHTFwiLCBcImVtc2NyaXB0ZW5fd2ViZ2xfcG93ZXJfcHJlZmVyZW5jZXNcIiwgXCJBTFwiLCBcIkdMVVRcIiwgXCJFR0xcIiwgXCJHTEVXXCIsIFwiSURCU3RvcmVcIiwgXCJTRExcIiwgXCJTRExfZ2Z4XCIsIFwiR0xGV1wiLCBcImFsbG9jYXRlVVRGOFwiLCBcImFsbG9jYXRlVVRGOE9uU3RhY2tcIiwgXCJTT0NLRlNcIiwgXCJGU1wiIF07XG5cbnVuZXhwb3J0ZWRTeW1ib2xzLmZvckVhY2godW5leHBvcnRlZFJ1bnRpbWVTeW1ib2wpO1xuXG52YXIgY2FsbGVkUnVuO1xuXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7XG59O1xuXG5mdW5jdGlvbiBjYWxsTWFpbigpIHtcbiBhc3NlcnQocnVuRGVwZW5kZW5jaWVzID09IDAsICdjYW5ub3QgY2FsbCBtYWluIHdoZW4gYXN5bmMgZGVwZW5kZW5jaWVzIHJlbWFpbiEgKGxpc3RlbiBvbiBNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSknKTtcbiBhc3NlcnQoX19BVFBSRVJVTl9fLmxlbmd0aCA9PSAwLCBcImNhbm5vdCBjYWxsIG1haW4gd2hlbiBwcmVSdW4gZnVuY3Rpb25zIHJlbWFpbiB0byBiZSBjYWxsZWRcIik7XG4gdmFyIGVudHJ5RnVuY3Rpb24gPSBfbWFpbjtcbiB2YXIgYXJnYyA9IDA7XG4gdmFyIGFyZ3YgPSAwO1xuIHRyeSB7XG4gIHZhciByZXQgPSBlbnRyeUZ1bmN0aW9uKGFyZ2MsIGFyZ3YpO1xuICBleGl0SlMocmV0LCB0cnVlKTtcbiAgcmV0dXJuIHJldDtcbiB9IGNhdGNoIChlKSB7XG4gIHJldHVybiBoYW5kbGVFeGNlcHRpb24oZSk7XG4gfVxufVxuXG5mdW5jdGlvbiBzdGFja0NoZWNrSW5pdCgpIHtcbiBfZW1zY3JpcHRlbl9zdGFja19pbml0KCk7XG4gd3JpdGVTdGFja0Nvb2tpZSgpO1xufVxuXG5mdW5jdGlvbiBydW4oKSB7XG4gaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgcmV0dXJuO1xuIH1cbiBzdGFja0NoZWNrSW5pdCgpO1xuIHByZVJ1bigpO1xuIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gIHJldHVybjtcbiB9XG4gZnVuY3Rpb24gZG9SdW4oKSB7XG4gIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgTW9kdWxlW1wiY2FsbGVkUnVuXCJdID0gdHJ1ZTtcbiAgaWYgKEFCT1JUKSByZXR1cm47XG4gIGluaXRSdW50aW1lKCk7XG4gIHByZU1haW4oKTtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xuICBpZiAoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7XG4gIGlmIChzaG91bGRSdW5Ob3cpIGNhbGxNYWluKCk7XG4gIHBvc3RSdW4oKTtcbiB9XG4gaWYgKE1vZHVsZVtcInNldFN0YXR1c1wiXSkge1xuICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJcIik7XG4gICB9LCAxKTtcbiAgIGRvUnVuKCk7XG4gIH0sIDEpO1xuIH0gZWxzZSB7XG4gIGRvUnVuKCk7XG4gfVxuIGNoZWNrU3RhY2tDb29raWUoKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tVbmZsdXNoZWRDb250ZW50KCkge1xuIHZhciBvbGRPdXQgPSBvdXQ7XG4gdmFyIG9sZEVyciA9IGVycjtcbiB2YXIgaGFzID0gZmFsc2U7XG4gb3V0ID0gZXJyID0geCA9PiB7XG4gIGhhcyA9IHRydWU7XG4gfTtcbiB0cnkge1xuICBmbHVzaF9OT19GSUxFU1lTVEVNKCk7XG4gfSBjYXRjaCAoZSkge31cbiBvdXQgPSBvbGRPdXQ7XG4gZXJyID0gb2xkRXJyO1xuIGlmIChoYXMpIHtcbiAgd2Fybk9uY2UoXCJzdGRpbyBzdHJlYW1zIGhhZCBjb250ZW50IGluIHRoZW0gdGhhdCB3YXMgbm90IGZsdXNoZWQuIHlvdSBzaG91bGQgc2V0IEVYSVRfUlVOVElNRSB0byAxIChzZWUgdGhlIEZBUSksIG9yIG1ha2Ugc3VyZSB0byBlbWl0IGEgbmV3bGluZSB3aGVuIHlvdSBwcmludGYgZXRjLlwiKTtcbiAgd2Fybk9uY2UoXCIodGhpcyBtYXkgYWxzbyBiZSBkdWUgdG8gbm90IGluY2x1ZGluZyBmdWxsIGZpbGVzeXN0ZW0gc3VwcG9ydCAtIHRyeSBidWlsZGluZyB3aXRoIC1zRk9SQ0VfRklMRVNZU1RFTSlcIik7XG4gfVxufVxuXG5pZiAoTW9kdWxlW1wicHJlSW5pdFwiXSkge1xuIGlmICh0eXBlb2YgTW9kdWxlW1wicHJlSW5pdFwiXSA9PSBcImZ1bmN0aW9uXCIpIE1vZHVsZVtcInByZUluaXRcIl0gPSBbIE1vZHVsZVtcInByZUluaXRcIl0gXTtcbiB3aGlsZSAoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGggPiAwKSB7XG4gIE1vZHVsZVtcInByZUluaXRcIl0ucG9wKCkoKTtcbiB9XG59XG5cbnZhciBzaG91bGRSdW5Ob3cgPSB0cnVlO1xuXG5pZiAoTW9kdWxlW1wibm9Jbml0aWFsUnVuXCJdKSBzaG91bGRSdW5Ob3cgPSBmYWxzZTtcblxucnVuKCk7XG5cblxuICByZXR1cm4gRHVja0RCLnJlYWR5XG59XG5cbik7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgRHVja0RCOyIsICJpbXBvcnQgRHVja0RCV2FzbSBmcm9tICcuL2R1Y2tkYi1laC5qcyc7XG5pbXBvcnQgeyBEdWNrREJCcm93c2VyQmluZGluZ3MgfSBmcm9tICcuL2JpbmRpbmdzX2Jyb3dzZXJfYmFzZSc7XG5pbXBvcnQgeyBEdWNrREJNb2R1bGUgfSBmcm9tICcuL2R1Y2tkYl9tb2R1bGUnO1xuaW1wb3J0IHsgRHVja0RCUnVudGltZSB9IGZyb20gJy4vcnVudGltZSc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2cnO1xuXG4vKiogRHVja0RCIGJpbmRpbmdzIGZvciB0aGUgYnJvd3NlciAqL1xuZXhwb3J0IGNsYXNzIER1Y2tEQiBleHRlbmRzIER1Y2tEQkJyb3dzZXJCaW5kaW5ncyB7XG4gICAgLyoqIENvbnN0cnVjdG9yICovXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcbiAgICAgICAgcnVudGltZTogRHVja0RCUnVudGltZSxcbiAgICAgICAgbWFpbk1vZHVsZVVSTDogc3RyaW5nLFxuICAgICAgICBwdGhyZWFkV29ya2VyVVJMOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICApIHtcbiAgICAgICAgc3VwZXIobG9nZ2VyLCBydW50aW1lLCBtYWluTW9kdWxlVVJMLCBwdGhyZWFkV29ya2VyVVJMKTtcbiAgICB9XG5cbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIGJpbmRpbmdzICovXG4gICAgcHJvdGVjdGVkIGluc3RhbnRpYXRlSW1wbChtb2R1bGVPdmVycmlkZXM6IFBhcnRpYWw8RHVja0RCTW9kdWxlPik6IFByb21pc2U8RHVja0RCTW9kdWxlPiB7XG4gICAgICAgIHJldHVybiBEdWNrREJXYXNtKHtcbiAgICAgICAgICAgIC4uLm1vZHVsZU92ZXJyaWRlcyxcbiAgICAgICAgICAgIGluc3RhbnRpYXRlV2FzbTogdGhpcy5pbnN0YW50aWF0ZVdhc20uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxvY2F0ZUZpbGU6IHRoaXMubG9jYXRlRmlsZS5iaW5kKHRoaXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IER1Y2tEQjtcbiIsICJleHBvcnQgKiBmcm9tICcuLi9iaW5kaW5ncyc7XG5leHBvcnQgKiBmcm9tICcuLi9sb2cnO1xuZXhwb3J0ICogZnJvbSAnLi4vcGxhdGZvcm0nO1xuZXhwb3J0ICogZnJvbSAnLi4vc3RhdHVzJztcbmV4cG9ydCAqIGZyb20gJy4uL3ZlcnNpb24nO1xuZXhwb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vYmluZGluZ3MvcnVudGltZSc7XG5leHBvcnQgeyBERUZBVUxUX1JVTlRJTUUgfSBmcm9tICcuLi9iaW5kaW5ncy9ydW50aW1lJztcbmV4cG9ydCB7IEJST1dTRVJfUlVOVElNRSB9IGZyb20gJy4uL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlcic7XG5cbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XG5pbXBvcnQgeyBEdWNrREJSdW50aW1lLCBEdWNrREJCaW5kaW5ncyB9IGZyb20gJy4uL2JpbmRpbmdzJztcbmltcG9ydCB7IER1Y2tEQkJ1bmRsZXMsIGdldFBsYXRmb3JtRmVhdHVyZXMgfSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBEdWNrREIgYXMgRHVja0RCTVZQIH0gZnJvbSAnLi4vYmluZGluZ3MvYmluZGluZ3NfYnJvd3Nlcl9tdnAnO1xuaW1wb3J0IHsgRHVja0RCIGFzIER1Y2tEQk5leHQgfSBmcm9tICcuLi9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX2VoJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUR1Y2tEQihcbiAgICBidW5kbGVzOiBEdWNrREJCdW5kbGVzLFxuICAgIGxvZ2dlcjogTG9nZ2VyLFxuICAgIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsXG4pOiBQcm9taXNlPER1Y2tEQkJpbmRpbmdzPiB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBnZXRQbGF0Zm9ybUZlYXR1cmVzKCk7XG4gICAgaWYgKHBsYXRmb3JtLndhc21FeGNlcHRpb25zKSB7XG4gICAgICAgIGlmIChidW5kbGVzLmVoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1Y2tEQk5leHQobG9nZ2VyLCBydW50aW1lLCBidW5kbGVzLmVoIS5tYWluTW9kdWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IER1Y2tEQk1WUChsb2dnZXIsIHJ1bnRpbWUsIGJ1bmRsZXMubXZwLm1haW5Nb2R1bGUpO1xufVxuIiwgImltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5pbXBvcnQgeyBBc3luY0R1Y2tEQiB9IGZyb20gJy4vYXN5bmNfYmluZGluZ3MnO1xuaW1wb3J0IHsgTG9nTGV2ZWwsIExvZ1RvcGljLCBMb2dPcmlnaW4sIExvZ0V2ZW50IH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IEFycm93SW5zZXJ0T3B0aW9ucywgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMgfSBmcm9tICcuLi9iaW5kaW5ncy9pbnNlcnRfb3B0aW9ucyc7XG5cbi8qKiBBIHRoaW4gaGVscGVyIHRvIG1lbW9pemUgdGhlIGNvbm5lY3Rpb24gaWQgKi9cbmV4cG9ydCBjbGFzcyBBc3luY0R1Y2tEQkNvbm5lY3Rpb24ge1xuICAgIC8qKiBUaGUgYXN5bmMgZHVja2RiICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9iaW5kaW5nczogQXN5bmNEdWNrREI7XG4gICAgLyoqIFRoZSBjb25uIGhhbmRsZSAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfY29ubjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IoYmluZGluZ3M6IEFzeW5jRHVja0RCLCBjb25uOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5fY29ubiA9IGNvbm47XG4gICAgfVxuXG4gICAgLyoqIEFjY2VzcyB0aGUgZGF0YWJhc2UgYmluZGluZ3MgKi9cbiAgICBwdWJsaWMgZ2V0IGJpbmRpbmdzKCk6IEFzeW5jRHVja0RCIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzO1xuICAgIH1cblxuICAgIC8qKiBEaXNjb25uZWN0IGZyb20gdGhlIGRhdGFiYXNlICovXG4gICAgcHVibGljIGFzeW5jIGNsb3NlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MuZGlzY29ubmVjdCh0aGlzLl9jb25uKTtcbiAgICB9XG5cbiAgICAvKiogQnJhdmUgc291bHMgbWF5IHVzZSB0aGlzIGZ1bmN0aW9uIHRvIGNvbnN1bWUgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvbiBpZCAqL1xuICAgIHB1YmxpYyB1c2VVbnNhZmU8Uj4oY2FsbGJhY2s6IChiaW5kaW5nczogQXN5bmNEdWNrREIsIGNvbm46IG51bWJlcikgPT4gUikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4pO1xuICAgIH1cblxuICAgIC8qKiBSdW4gYSBxdWVyeSAqL1xuICAgIHB1YmxpYyBhc3luYyBxdWVyeTxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55Pih0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPGFycm93LlRhYmxlPFQ+PiB7XG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmxvZ2dlci5sb2coe1xuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgbGV2ZWw6IExvZ0xldmVsLklORk8sXG4gICAgICAgICAgICBvcmlnaW46IExvZ09yaWdpbi5BU1lOQ19EVUNLREIsXG4gICAgICAgICAgICB0b3BpYzogTG9nVG9waWMuUVVFUlksXG4gICAgICAgICAgICBldmVudDogTG9nRXZlbnQuUlVOLFxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB0aGlzLl9iaW5kaW5ncy5ydW5RdWVyeSh0aGlzLl9jb25uLCB0ZXh0KTtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihidWZmZXIpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTeW5jKCksIFwiUmVhZGVyIGlzIG5vdCBzeW5jXCIpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNGaWxlKCksIFwiUmVhZGVyIGlzIG5vdCBmaWxlXCIpO1xuICAgICAgICByZXR1cm4gbmV3IGFycm93LlRhYmxlKHJlYWRlciBhcyBhcnJvdy5SZWNvcmRCYXRjaEZpbGVSZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKiBTZW5kIGEgcXVlcnkgKi9cbiAgICBwdWJsaWMgYXN5bmMgc2VuZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PihcbiAgICAgICAgdGV4dDogc3RyaW5nLFxuICAgICk6IFByb21pc2U8YXJyb3cuQXN5bmNSZWNvcmRCYXRjaFN0cmVhbVJlYWRlcjxUPj4ge1xuICAgICAgICB0aGlzLl9iaW5kaW5ncy5sb2dnZXIubG9nKHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxuICAgICAgICAgICAgb3JpZ2luOiBMb2dPcmlnaW4uQVNZTkNfRFVDS0RCLFxuICAgICAgICAgICAgdG9waWM6IExvZ1RvcGljLlFVRVJZLFxuICAgICAgICAgICAgZXZlbnQ6IExvZ0V2ZW50LlJVTixcbiAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGhlYWRlciA9IGF3YWl0IHRoaXMuX2JpbmRpbmdzLnN0YXJ0UGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4sIHRleHQpO1xuICAgICAgICB3aGlsZSAoaGVhZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlciA9IGF3YWl0IHRoaXMuX2JpbmRpbmdzLnBvbGxQZW5kaW5nUXVlcnkodGhpcy5fY29ubik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBBc3luY1Jlc3VsdFN0cmVhbUl0ZXJhdG9yKHRoaXMuX2JpbmRpbmdzLCB0aGlzLl9jb25uLCBoZWFkZXIpO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGl0ZXIpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNBc3luYygpKTtcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3RyZWFtKCkpO1xuICAgICAgICByZXR1cm4gcmVhZGVyIGFzIHVua25vd24gYXMgYXJyb3cuQXN5bmNSZWNvcmRCYXRjaFN0cmVhbVJlYWRlcjxUPjsgLy8gWFhYXG4gICAgfVxuXG4gICAgLyoqIENhbmNlbCBhIHF1ZXJ5IHRoYXQgd2FzIHNlbnQgZWFybGllciAqL1xuICAgIHB1YmxpYyBhc3luYyBjYW5jZWxTZW50KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYmluZGluZ3MuY2FuY2VsUGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4pO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGFibGUgbmFtZXMgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VGFibGVOYW1lcyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYmluZGluZ3MuZ2V0VGFibGVOYW1lcyh0aGlzLl9jb25uLCBxdWVyeSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHByZXBhcmVkIHN0YXRlbWVudCAqL1xuICAgIHB1YmxpYyBhc3luYyBwcmVwYXJlPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFycm93LkRhdGFUeXBlIH0gPSBhbnk+KFxuICAgICAgICB0ZXh0OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxBc3luY1ByZXBhcmVkU3RhdGVtZW50PiB7XG4gICAgICAgIGNvbnN0IHN0bXQgPSBhd2FpdCB0aGlzLl9iaW5kaW5ncy5jcmVhdGVQcmVwYXJlZCh0aGlzLl9jb25uLCB0ZXh0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luY1ByZXBhcmVkU3RhdGVtZW50PFQ+KHRoaXMuX2JpbmRpbmdzLCB0aGlzLl9jb25uLCBzdG10KTtcbiAgICB9XG5cbiAgICAvKiogSW5zZXJ0IGFuIGFycm93IHRhYmxlICovXG4gICAgcHVibGljIGFzeW5jIGluc2VydEFycm93VGFibGUodGFibGU6IGFycm93LlRhYmxlLCBvcHRpb25zOiBBcnJvd0luc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXJyb3cudGFibGVUb0lQQyh0YWJsZSwgJ3N0cmVhbScpO1xuICAgICAgICBhd2FpdCB0aGlzLmluc2VydEFycm93RnJvbUlQQ1N0cmVhbShidWZmZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKiogSW5zZXJ0IGFuIGFycm93IHRhYmxlIGZyb20gYW4gaXBjIHN0cmVhbSAqL1xuICAgIHB1YmxpYyBhc3luYyBpbnNlcnRBcnJvd0Zyb21JUENTdHJlYW0oYnVmZmVyOiBVaW50OEFycmF5LCBvcHRpb25zOiBBcnJvd0luc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5fYmluZGluZ3MuaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKHRoaXMuX2Nvbm4sIGJ1ZmZlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnQgY3N2IGZpbGUgZnJvbSBwYXRoICovXG4gICAgcHVibGljIGFzeW5jIGluc2VydENTVkZyb21QYXRoKHRleHQ6IHN0cmluZywgb3B0aW9uczogQ1NWSW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCB0aGlzLl9iaW5kaW5ncy5pbnNlcnRDU1ZGcm9tUGF0aCh0aGlzLl9jb25uLCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIEluc2VydCBqc29uIGZpbGUgZnJvbSBwYXRoICovXG4gICAgcHVibGljIGFzeW5jIGluc2VydEpTT05Gcm9tUGF0aCh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM6IEpTT05JbnNlcnRPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2JpbmRpbmdzLmluc2VydEpTT05Gcm9tUGF0aCh0aGlzLl9jb25uLCB0ZXh0LCBvcHRpb25zKTtcbiAgICB9XG59XG5cbi8qKiBBbiBhc3luYyByZXN1bHQgc3RyZWFtIGl0ZXJhdG9yICovXG5leHBvcnQgY2xhc3MgQXN5bmNSZXN1bHRTdHJlYW1JdGVyYXRvciBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8VWludDhBcnJheT4ge1xuICAgIC8qKiBGaXJzdCBjaHVuaz8gKi9cbiAgICBwcm90ZWN0ZWQgX2ZpcnN0OiBib29sZWFuO1xuICAgIC8qKiBSZWFjaGVkIGVuZCBvZiBzdHJlYW0/ICovXG4gICAgcHJvdGVjdGVkIF9kZXBsZXRlZDogYm9vbGVhbjtcbiAgICAvKiogSW4tZmxpZ2h0ICovXG4gICAgcHJvdGVjdGVkIF9pbkZsaWdodDogUHJvbWlzZTxVaW50OEFycmF5PiB8IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGRiOiBBc3luY0R1Y2tEQixcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbm46IG51bWJlcixcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGhlYWRlcjogVWludDhBcnJheSxcbiAgICApIHtcbiAgICAgICAgdGhpcy5fZmlyc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbkZsaWdodCA9IG51bGw7XG4gICAgfVxuXG4gICAgYXN5bmMgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFVpbnQ4QXJyYXk+PiB7XG4gICAgICAgIGlmICh0aGlzLl9maXJzdCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdGhpcy5oZWFkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVwbGV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZmZlcjogVWludDhBcnJheTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IGF3YWl0IHRoaXMuX2luRmxpZ2h0O1xuICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyID0gYXdhaXQgdGhpcy5kYi5mZXRjaFF1ZXJ5UmVzdWx0cyh0aGlzLmNvbm4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlcGxldGVkID0gYnVmZmVyLmxlbmd0aCA9PSAwO1xuICAgICAgICBpZiAoIXRoaXMuX2RlcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pbkZsaWdodCA9IHRoaXMuZGIuZmV0Y2hRdWVyeVJlc3VsdHModGhpcy5jb25uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdGhpcy5fZGVwbGV0ZWQsXG4gICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuLyoqIEEgdGhpbiBoZWxwZXIgdG8gYmluZCB0aGUgcHJlcGFyZWQgc3RhdGVtZW50IGlkICovXG5leHBvcnQgY2xhc3MgQXN5bmNQcmVwYXJlZFN0YXRlbWVudDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PiB7XG4gICAgLyoqIFRoZSBiaW5kaW5ncyAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBiaW5kaW5nczogQXN5bmNEdWNrREI7XG4gICAgLyoqIFRoZSBjb25uZWN0aW9uIGlkICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbm5lY3Rpb25JZDogbnVtYmVyO1xuICAgIC8qKiBUaGUgc3RhdGVtZW50IGlkICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0YXRlbWVudElkOiBudW1iZXI7XG5cbiAgICAvKiogQ29uc3RydWN0b3IgKi9cbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nczogQXN5bmNEdWNrREIsIGNvbm5lY3Rpb25JZDogbnVtYmVyLCBzdGF0ZW1lbnRJZDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XG4gICAgICAgIHRoaXMuc3RhdGVtZW50SWQgPSBzdGF0ZW1lbnRJZDtcbiAgICB9XG5cbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cbiAgICBwdWJsaWMgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuYmluZGluZ3MuY2xvc2VQcmVwYXJlZCh0aGlzLmNvbm5lY3Rpb25JZCwgdGhpcy5zdGF0ZW1lbnRJZCk7XG4gICAgfVxuXG4gICAgLyoqIFJ1biBhIHByZXBhcmVkIHN0YXRlbWVudCAqL1xuICAgIHB1YmxpYyBhc3luYyBxdWVyeSguLi5wYXJhbXM6IGFueVtdKTogUHJvbWlzZTxhcnJvdy5UYWJsZTxUPj4ge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB0aGlzLmJpbmRpbmdzLnJ1blByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGJ1ZmZlcik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0ZpbGUoKSk7XG4gICAgICAgIHJldHVybiBuZXcgYXJyb3cuVGFibGUocmVhZGVyIGFzIGFycm93LlJlY29yZEJhdGNoRmlsZVJlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqIFNlbmQgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cbiAgICBwdWJsaWMgYXN5bmMgc2VuZCguLi5wYXJhbXM6IGFueVtdKTogUHJvbWlzZTxhcnJvdy5Bc3luY1JlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMuYmluZGluZ3Muc2VuZFByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IEFzeW5jUmVzdWx0U3RyZWFtSXRlcmF0b3IodGhpcy5iaW5kaW5ncywgdGhpcy5jb25uZWN0aW9uSWQsIGhlYWRlcik7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGF3YWl0IGFycm93LlJlY29yZEJhdGNoUmVhZGVyLmZyb208VD4oaXRlcik7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0FzeW5jKCkpO1xuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTdHJlYW0oKSk7XG4gICAgICAgIHJldHVybiByZWFkZXIgYXMgdW5rbm93biBhcyBhcnJvdy5Bc3luY1JlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+OyAvLyBYWFhcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMsIEFycm93SW5zZXJ0T3B0aW9ucyB9IGZyb20gJy4uL2JpbmRpbmdzL2luc2VydF9vcHRpb25zJztcbmltcG9ydCB7IExvZ0VudHJ5VmFyaWFudCB9IGZyb20gJy4uL2xvZyc7XG5pbXBvcnQgeyBTY3JpcHRUb2tlbnMgfSBmcm9tICcuLi9iaW5kaW5ncy90b2tlbnMnO1xuaW1wb3J0IHsgRmlsZVN0YXRpc3RpY3MgfSBmcm9tICcuLi9iaW5kaW5ncy9maWxlX3N0YXRzJztcbmltcG9ydCB7IER1Y2tEQkNvbmZpZyB9IGZyb20gJy4uL2JpbmRpbmdzL2NvbmZpZyc7XG5pbXBvcnQgeyBXZWJGaWxlIH0gZnJvbSAnLi4vYmluZGluZ3Mvd2ViX2ZpbGUnO1xuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLi4vYmluZGluZ3MvcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vYmluZGluZ3MnO1xuXG5leHBvcnQgdHlwZSBDb25uZWN0aW9uSUQgPSBudW1iZXI7XG5leHBvcnQgdHlwZSBTdGF0ZW1lbnRJRCA9IG51bWJlcjtcblxuZXhwb3J0IGVudW0gV29ya2VyUmVxdWVzdFR5cGUge1xuICAgIENBTkNFTF9QRU5ESU5HX1FVRVJZID0gJ0NBTkNFTF9QRU5ESU5HX1FVRVJZJyxcbiAgICBDTE9TRV9QUkVQQVJFRCA9ICdDTE9TRV9QUkVQQVJFRCcsXG4gICAgQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1MgPSAnQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1MnLFxuICAgIENPTk5FQ1QgPSAnQ09OTkVDVCcsXG4gICAgQ09QWV9GSUxFX1RPX0JVRkZFUiA9ICdDT1BZX0ZJTEVfVE9fQlVGRkVSJyxcbiAgICBDT1BZX0ZJTEVfVE9fUEFUSCA9ICdDT1BZX0ZJTEVfVE9fUEFUSCcsXG4gICAgQ1JFQVRFX1BSRVBBUkVEID0gJ0NSRUFURV9QUkVQQVJFRCcsXG4gICAgRElTQ09OTkVDVCA9ICdESVNDT05ORUNUJyxcbiAgICBEUk9QX0ZJTEUgPSAnRFJPUF9GSUxFJyxcbiAgICBEUk9QX0ZJTEVTID0gJ0RST1BfRklMRVMnLFxuICAgIEVYUE9SVF9GSUxFX1NUQVRJU1RJQ1MgPSAnRVhQT1JUX0ZJTEVfU1RBVElTVElDUycsXG4gICAgRkVUQ0hfUVVFUllfUkVTVUxUUyA9ICdGRVRDSF9RVUVSWV9SRVNVTFRTJyxcbiAgICBGTFVTSF9GSUxFUyA9ICdGTFVTSF9GSUxFUycsXG4gICAgR0VUX0ZFQVRVUkVfRkxBR1MgPSAnR0VUX0ZFQVRVUkVfRkxBR1MnLFxuICAgIEdFVF9UQUJMRV9OQU1FUyA9ICdHRVRfVEFCTEVfTkFNRVMnLFxuICAgIEdFVF9WRVJTSU9OID0gJ0dFVF9WRVJTSU9OJyxcbiAgICBHTE9CX0ZJTEVfSU5GT1MgPSAnR0xPQl9GSUxFX0lORk9TJyxcbiAgICBJTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNID0gJ0lOU0VSVF9BUlJPV19GUk9NX0lQQ19TVFJFQU0nLFxuICAgIElOU0VSVF9DU1ZfRlJPTV9QQVRIID0gJ0lNUE9SVF9DU1ZfRlJPTV9QQVRIJyxcbiAgICBJTlNFUlRfSlNPTl9GUk9NX1BBVEggPSAnSU1QT1JUX0pTT05fRlJPTV9QQVRIJyxcbiAgICBJTlNUQU5USUFURSA9ICdJTlNUQU5USUFURScsXG4gICAgT1BFTiA9ICdPUEVOJyxcbiAgICBQSU5HID0gJ1BJTkcnLFxuICAgIFBPTExfUEVORElOR19RVUVSWSA9ICdQT0xMX1BFTkRJTkdfUVVFUlknLFxuICAgIFJFR0lTVEVSX0ZJTEVfQlVGRkVSID0gJ1JFR0lTVEVSX0ZJTEVfQlVGRkVSJyxcbiAgICBSRUdJU1RFUl9GSUxFX0hBTkRMRSA9ICdSRUdJU1RFUl9GSUxFX0hBTkRMRScsXG4gICAgUkVHSVNURVJfRklMRV9VUkwgPSAnUkVHSVNURVJfRklMRV9VUkwnLFxuICAgIFJFU0VUID0gJ1JFU0VUJyxcbiAgICBSVU5fUFJFUEFSRUQgPSAnUlVOX1BSRVBBUkVEJyxcbiAgICBSVU5fUVVFUlkgPSAnUlVOX1FVRVJZJyxcbiAgICBTRU5EX1BSRVBBUkVEID0gJ1NFTkRfUFJFUEFSRUQnLFxuICAgIFNUQVJUX1BFTkRJTkdfUVVFUlkgPSAnU1RBUlRfUEVORElOR19RVUVSWScsXG4gICAgVE9LRU5JWkUgPSAnVE9LRU5JWkUnLFxufVxuXG5leHBvcnQgZW51bSBXb3JrZXJSZXNwb25zZVR5cGUge1xuICAgIENPTk5FQ1RJT05fSU5GTyA9ICdDT05ORUNUSU9OX0lORk8nLFxuICAgIEVSUk9SID0gJ0VSUk9SJyxcbiAgICBGRUFUVVJFX0ZMQUdTID0gJ0ZFQVRVUkVfRkxBR1MnLFxuICAgIEZJTEVfQlVGRkVSID0gJ0ZJTEVfQlVGRkVSJyxcbiAgICBGSUxFX0lORk9TID0gJ0ZJTEVfSU5GT1MnLFxuICAgIEZJTEVfU0laRSA9ICdGSUxFX1NJWkUnLFxuICAgIEZJTEVfU1RBVElTVElDUyA9ICdGSUxFX1NUQVRJU1RJQ1MnLFxuICAgIElOU1RBTlRJQVRFX1BST0dSRVNTID0gJ0lOU1RBTlRJQVRFX1BST0dSRVNTJyxcbiAgICBMT0cgPSAnTE9HJyxcbiAgICBPSyA9ICdPSycsXG4gICAgUFJFUEFSRURfU1RBVEVNRU5UX0lEID0gJ1BSRVBBUkVEX1NUQVRFTUVOVF9JRCcsXG4gICAgUVVFUllfUExBTiA9ICdRVUVSWV9QTEFOJyxcbiAgICBRVUVSWV9SRVNVTFQgPSAnUVVFUllfUkVTVUxUJyxcbiAgICBRVUVSWV9SRVNVTFRfQ0hVTksgPSAnUVVFUllfUkVTVUxUX0NIVU5LJyxcbiAgICBRVUVSWV9SRVNVTFRfSEVBREVSID0gJ1FVRVJZX1JFU1VMVF9IRUFERVInLFxuICAgIFFVRVJZX1JFU1VMVF9IRUFERVJfT1JfTlVMTCA9ICdRVUVSWV9SRVNVTFRfSEVBREVSX09SX05VTEwnLFxuICAgIFJFR0lTVEVSRURfRklMRSA9ICdSRUdJU1RFUkVEX0ZJTEUnLFxuICAgIFNDUklQVF9UT0tFTlMgPSAnU0NSSVBUX1RPS0VOUycsXG4gICAgU1VDQ0VTUyA9ICdTVUNDRVNTJyxcbiAgICBUQUJMRV9OQU1FUyA9ICdUQUJMRV9OQU1FUycsXG4gICAgVkVSU0lPTl9TVFJJTkcgPSAnVkVSU0lPTl9TVFJJTkcnLFxufVxuXG5leHBvcnQgdHlwZSBXb3JrZXJSZXF1ZXN0PFQsIFA+ID0ge1xuICAgIHJlYWRvbmx5IG1lc3NhZ2VJZDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHR5cGU6IFQ7XG4gICAgcmVhZG9ubHkgZGF0YTogUDtcbn07XG5cbmV4cG9ydCB0eXBlIFdvcmtlclJlc3BvbnNlPFQsIFA+ID0ge1xuICAgIHJlYWRvbmx5IG1lc3NhZ2VJZDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHJlcXVlc3RJZDogbnVtYmVyO1xuICAgIHJlYWRvbmx5IHR5cGU6IFQ7XG4gICAgcmVhZG9ubHkgZGF0YTogUDtcbn07XG5cbmV4cG9ydCB0eXBlIFdvcmtlclRhc2tSZXR1cm5UeXBlPFQgZXh0ZW5kcyBXb3JrZXJUYXNrVmFyaWFudD4gPSBUIGV4dGVuZHMgV29ya2VyVGFzazxhbnksIGFueSwgaW5mZXIgUD4gPyBQIDogbmV2ZXI7XG5cbmV4cG9ydCBjbGFzcyBXb3JrZXJUYXNrPFQsIEQsIFA+IHtcbiAgICByZWFkb25seSB0eXBlOiBUO1xuICAgIHJlYWRvbmx5IGRhdGE6IEQ7XG4gICAgcHJvbWlzZTogUHJvbWlzZTxQPjtcbiAgICBwcm9taXNlUmVzb2x2ZXI6ICh2YWx1ZTogUCB8IFByb21pc2VMaWtlPFA+KSA9PiB2b2lkID0gKCkgPT4ge307XG4gICAgcHJvbWlzZVJlamVjdGVyOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHt9O1xuXG4gICAgY29uc3RydWN0b3IodHlwZTogVCwgZGF0YTogRCkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZTxQPihcbiAgICAgICAgICAgIChyZXNvbHZlOiAodmFsdWU6IFAgfCBQcm9taXNlTGlrZTxQPikgPT4gdm9pZCwgcmVqZWN0OiAocmVhc29uPzogdm9pZCkgPT4gdm9pZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbWlzZVJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VSZWplY3RlciA9IHJlamVjdDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBXb3JrZXJSZXF1ZXN0VmFyaWFudCA9XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNMT1NFX1BSRVBBUkVELCBbQ29ubmVjdGlvbklELCBTdGF0ZW1lbnRJRF0+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNBTkNFTF9QRU5ESU5HX1FVRVJZLCBudW1iZXI+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLCBbc3RyaW5nLCBib29sZWFuXT5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuQ09OTkVDVCwgbnVsbD5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUiwgc3RyaW5nPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fUEFUSCwgW3N0cmluZywgc3RyaW5nXT5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuQ1JFQVRFX1BSRVBBUkVELCBbQ29ubmVjdGlvbklELCBzdHJpbmddPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5ESVNDT05ORUNULCBudW1iZXI+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRSwgc3RyaW5nPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEVTLCBudWxsPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTLCBzdHJpbmc+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkZFVENIX1FVRVJZX1JFU1VMVFMsIG51bWJlcj5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuRkxVU0hfRklMRVMsIG51bGw+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkdFVF9GRUFUVVJFX0ZMQUdTLCBudWxsPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVEFCTEVfTkFNRVMsIFtudW1iZXIsIHN0cmluZ10+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OLCBudWxsPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1MsIHN0cmluZz5cbiAgICB8IFdvcmtlclJlcXVlc3Q8XG4gICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0FSUk9XX0ZST01fSVBDX1NUUkVBTSxcbiAgICAgICAgICBbbnVtYmVyLCBVaW50OEFycmF5LCBBcnJvd0luc2VydE9wdGlvbnMgfCB1bmRlZmluZWRdXG4gICAgICA+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIENTVkluc2VydE9wdGlvbnNdPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfSlNPTl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgSlNPTkluc2VydE9wdGlvbnNdPlxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNUQU5USUFURSwgW3N0cmluZywgc3RyaW5nIHwgbnVsbF0+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLk9QRU4sIER1Y2tEQkNvbmZpZz5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUElORywgbnVsbD5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLCBudW1iZXI+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSLCBbc3RyaW5nLCBVaW50OEFycmF5XT5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsIFtzdHJpbmcsIGFueSwgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXT5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9VUkwsIFtzdHJpbmcsIHN0cmluZywgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXT5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUkVTRVQsIG51bGw+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyLCBhbnlbXV0+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJVTl9RVUVSWSwgW251bWJlciwgc3RyaW5nXT5cbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyLCBhbnlbXV0+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlNUQVJUX1BFTkRJTkdfUVVFUlksIFtudW1iZXIsIHN0cmluZ10+XG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFLCBzdHJpbmc+O1xuXG5leHBvcnQgdHlwZSBXb3JrZXJSZXNwb25zZVZhcmlhbnQgPVxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkNPTk5FQ1RJT05fSU5GTywgbnVtYmVyPlxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkVSUk9SLCBhbnk+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuRkVBVFVSRV9GTEFHUywgbnVtYmVyPlxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfQlVGRkVSLCBVaW50OEFycmF5PlxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfSU5GT1MsIFdlYkZpbGVbXT5cbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NJWkUsIG51bWJlcj5cbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NUQVRJU1RJQ1MsIEZpbGVTdGF0aXN0aWNzPlxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLklOU1RBTlRJQVRFX1BST0dSRVNTLCBJbnN0YW50aWF0aW9uUHJvZ3Jlc3M+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuTE9HLCBMb2dFbnRyeVZhcmlhbnQ+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuT0ssIG51bGw+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuUFJFUEFSRURfU1RBVEVNRU5UX0lELCBudW1iZXI+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUExBTiwgVWludDhBcnJheT5cbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFQsIFVpbnQ4QXJyYXk+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0NIVU5LLCBVaW50OEFycmF5PlxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVF9IRUFERVIsIFVpbnQ4QXJyYXk+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0hFQURFUl9PUl9OVUxMLCBVaW50OEFycmF5IHwgbnVsbD5cbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5TQ1JJUFRfVE9LRU5TLCBTY3JpcHRUb2tlbnM+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuU1VDQ0VTUywgYm9vbGVhbj5cbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5UQUJMRV9OQU1FUywgc3RyaW5nW10+XG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuVkVSU0lPTl9TVFJJTkcsIHN0cmluZz47XG5cbmV4cG9ydCB0eXBlIFdvcmtlclRhc2tWYXJpYW50ID1cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1MsIFtzdHJpbmcsIGJvb2xlYW5dLCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyXSwgbnVsbD5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09OTkVDVCwgbnVsbCwgQ29ubmVjdGlvbklEPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fQlVGRkVSLCBzdHJpbmcsIFVpbnQ4QXJyYXk+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19QQVRILCBbc3RyaW5nLCBzdHJpbmddLCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsIFtudW1iZXIsIHN0cmluZ10sIG51bWJlcj5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCwgQ29ubmVjdGlvbklELCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEUsIHN0cmluZywgbnVsbD5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbCwgbnVsbD5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRVhQT1JUX0ZJTEVfU1RBVElTVElDUywgc3RyaW5nLCBGaWxlU3RhdGlzdGljcz5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUywgQ29ubmVjdGlvbklELCBVaW50OEFycmF5PlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5GTFVTSF9GSUxFUywgbnVsbCwgbnVsbD5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuR0VUX0ZFQVRVUkVfRkxBR1MsIG51bGwsIG51bWJlcj5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuR0VUX1RBQkxFX05BTUVTLCBbbnVtYmVyLCBzdHJpbmddLCBzdHJpbmdbXT5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuR0VUX1ZFUlNJT04sIG51bGwsIHN0cmluZz5cbiAgICB8IFdvcmtlclRhc2s8XG4gICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0FSUk9XX0ZST01fSVBDX1NUUkVBTSxcbiAgICAgICAgICBbbnVtYmVyLCBVaW50OEFycmF5LCBBcnJvd0luc2VydE9wdGlvbnMgfCB1bmRlZmluZWRdLFxuICAgICAgICAgIG51bGxcbiAgICAgID5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0NTVl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgQ1NWSW5zZXJ0T3B0aW9uc10sIG51bGw+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9KU09OX0ZST01fUEFUSCwgW251bWJlciwgc3RyaW5nLCBKU09OSW5zZXJ0T3B0aW9uc10sIG51bGw+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLklOU1RBTlRJQVRFLCBbc3RyaW5nLCBzdHJpbmcgfCBudWxsXSwgbnVsbD5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuT1BFTiwgRHVja0RCQ29uZmlnLCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsLCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUiwgW3N0cmluZywgVWludDhBcnJheV0sIG51bGw+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfSEFORExFLCBbc3RyaW5nLCBhbnksIER1Y2tEQkRhdGFQcm90b2NvbCwgYm9vbGVhbl0sIG51bGw+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfVVJMLCBbc3RyaW5nLCBzdHJpbmcsIER1Y2tEQkRhdGFQcm90b2NvbCwgYm9vbGVhbl0sIG51bGw+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdMT0JfRklMRV9JTkZPUywgc3RyaW5nLCBXZWJGaWxlW10+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFU0VULCBudWxsLCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUVVFUlksIFtDb25uZWN0aW9uSUQsIHN0cmluZ10sIFVpbnQ4QXJyYXk+XG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5TVEFSVF9QRU5ESU5HX1FVRVJZLCBbQ29ubmVjdGlvbklELCBzdHJpbmddLCBVaW50OEFycmF5IHwgbnVsbD5cbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLCBDb25uZWN0aW9uSUQsIFVpbnQ4QXJyYXkgfCBudWxsPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DQU5DRUxfUEVORElOR19RVUVSWSwgQ29ubmVjdGlvbklELCBib29sZWFuPlxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5UT0tFTklaRSwgc3RyaW5nLCBTY3JpcHRUb2tlbnM+O1xuIiwgImltcG9ydCB7XG4gICAgV29ya2VyUmVxdWVzdFR5cGUsXG4gICAgV29ya2VyUmVzcG9uc2VUeXBlLFxuICAgIFdvcmtlclJlc3BvbnNlVmFyaWFudCxcbiAgICBXb3JrZXJUYXNrVmFyaWFudCxcbiAgICBXb3JrZXJUYXNrLFxuICAgIENvbm5lY3Rpb25JRCxcbiAgICBXb3JrZXJUYXNrUmV0dXJuVHlwZSxcbn0gZnJvbSAnLi93b3JrZXJfcmVxdWVzdCc7XG5pbXBvcnQgeyBBc3luY0R1Y2tEQkJpbmRpbmdzIH0gZnJvbSAnLi9hc3luY19iaW5kaW5nc19pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcbmltcG9ydCB7IEFzeW5jRHVja0RCQ29ubmVjdGlvbiB9IGZyb20gJy4vYXN5bmNfY29ubmVjdGlvbic7XG5pbXBvcnQgeyBDU1ZJbnNlcnRPcHRpb25zLCBKU09OSW5zZXJ0T3B0aW9ucywgQXJyb3dJbnNlcnRPcHRpb25zIH0gZnJvbSAnLi4vYmluZGluZ3MvaW5zZXJ0X29wdGlvbnMnO1xuaW1wb3J0IHsgU2NyaXB0VG9rZW5zIH0gZnJvbSAnLi4vYmluZGluZ3MvdG9rZW5zJztcbmltcG9ydCB7IEZpbGVTdGF0aXN0aWNzIH0gZnJvbSAnLi4vYmluZGluZ3MvZmlsZV9zdGF0cyc7XG5pbXBvcnQgeyBEdWNrREJDb25maWcgfSBmcm9tICcuLi9iaW5kaW5ncy9jb25maWcnO1xuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLi4vYmluZGluZ3MvcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgYXJyb3dUb1NRTEZpZWxkIH0gZnJvbSAnLi4vanNvbl90eXBlZGVmJztcbmltcG9ydCB7IFdlYkZpbGUgfSBmcm9tICcuLi9iaW5kaW5ncy93ZWJfZmlsZSc7XG5pbXBvcnQgeyBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuLi9iaW5kaW5ncyc7XG5cbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG5leHBvcnQgY2xhc3MgQXN5bmNEdWNrREIgaW1wbGVtZW50cyBBc3luY0R1Y2tEQkJpbmRpbmdzIHtcbiAgICAvKiogVGhlIG1lc3NhZ2UgaGFuZGxlciAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfb25NZXNzYWdlSGFuZGxlcjogKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHZvaWQ7XG4gICAgLyoqIFRoZSBlcnJvciBoYW5kbGVyICovXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9vbkVycm9ySGFuZGxlcjogKGV2ZW50OiBFcnJvckV2ZW50KSA9PiB2b2lkO1xuICAgIC8qKiBUaGUgY2xvc2UgaGFuZGxlciAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfb25DbG9zZUhhbmRsZXI6ICgpID0+IHZvaWQ7XG5cbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIG1vZHVsZSAqL1xuICAgIHByb3RlY3RlZCBfb25JbnN0YW50aWF0aW9uUHJvZ3Jlc3M6ICgocDogSW5zdGFudGlhdGlvblByb2dyZXNzKSA9PiB2b2lkKVtdID0gW107XG5cbiAgICAvKiogVGhlIGxvZ2dlciAqL1xuICAgIHByb3RlY3RlZCByZWFkb25seSBfbG9nZ2VyOiBMb2dnZXI7XG4gICAgLyoqIFRoZSB3b3JrZXIgKi9cbiAgICBwcm90ZWN0ZWQgX3dvcmtlcjogV29ya2VyIHwgbnVsbCA9IG51bGw7XG4gICAgLyoqIFRoZSBwcm9taXNlIGZvciB0aGUgd29ya2VyIHNodXRkb3duICovXG4gICAgcHJvdGVjdGVkIF93b3JrZXJTaHV0ZG93blByb21pc2U6IFByb21pc2U8bnVsbD4gfCBudWxsID0gbnVsbDtcbiAgICAvKiogTWFrZSB0aGUgd29ya2VyIGFzIHRlcm1pbmF0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX3dvcmtlclNodXRkb3duUmVzb2x2ZXI6ICh2YWx1ZTogUHJvbWlzZUxpa2U8bnVsbD4gfCBudWxsKSA9PiB2b2lkID0gKCkgPT4ge307XG5cbiAgICAvKiogVGhlIG5leHQgbWVzc2FnZSBpZCAqL1xuICAgIHByb3RlY3RlZCBfbmV4dE1lc3NhZ2VJZCA9IDA7XG4gICAgLyoqIFRoZSBwZW5kaW5nIHJlcXVlc3RzICovXG4gICAgcHJvdGVjdGVkIF9wZW5kaW5nUmVxdWVzdHM6IE1hcDxudW1iZXIsIFdvcmtlclRhc2tWYXJpYW50PiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcjogTG9nZ2VyLCB3b3JrZXI6IFdvcmtlciB8IG51bGwgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5fb25NZXNzYWdlSGFuZGxlciA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uRXJyb3JIYW5kbGVyID0gdGhpcy5vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX29uQ2xvc2VIYW5kbGVyID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgICAgIGlmICh3b3JrZXIgIT0gbnVsbCkgdGhpcy5hdHRhY2god29ya2VyKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBsb2dnZXIgKi9cbiAgICBwdWJsaWMgZ2V0IGxvZ2dlcigpOiBMb2dnZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyO1xuICAgIH1cblxuICAgIC8qKiBBdHRhY2ggdG8gd29ya2VyICovXG4gICAgcHJvdGVjdGVkIGF0dGFjaCh3b3JrZXI6IFdvcmtlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3JIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25DbG9zZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2UgPSBuZXcgUHJvbWlzZTxudWxsPihcbiAgICAgICAgICAgIChyZXNvbHZlOiAodmFsdWU6IFByb21pc2VMaWtlPG51bGw+IHwgbnVsbCkgPT4gdm9pZCwgX3JlamVjdDogKHJlYXNvbj86IHZvaWQpID0+IHZvaWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blJlc29sdmVyID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqIERldGFjaCBmcm9tIHdvcmtlciAqL1xuICAgIHB1YmxpYyBkZXRhY2goKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3dvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlSGFuZGxlcik7XG4gICAgICAgIHRoaXMuX3dvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3JIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25DbG9zZUhhbmRsZXIpO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blJlc29sdmVyKG51bGwpO1xuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blJlc29sdmVyID0gKCkgPT4ge307XG4gICAgfVxuXG4gICAgLyoqIEtpbGwgdGhlIHdvcmtlciAqL1xuICAgIHB1YmxpYyBhc3luYyB0ZXJtaW5hdGUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgLy9hd2FpdCB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2U7IFRPRE8gZGVhZGxvY2tpbmcgaW4ga2FybWE/XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUmVzb2x2ZXIgPSAoKSA9PiB7fTtcbiAgICB9XG5cbiAgICAvKiogUG9zdCBhIHRhc2sgKi9cbiAgICBwcm90ZWN0ZWQgYXN5bmMgcG9zdFRhc2s8VyBleHRlbmRzIFdvcmtlclRhc2tWYXJpYW50PihcbiAgICAgICAgdGFzazogVyxcbiAgICAgICAgdHJhbnNmZXI6IEFycmF5QnVmZmVyW10gPSBbXSxcbiAgICApOiBQcm9taXNlPFdvcmtlclRhc2tSZXR1cm5UeXBlPFc+PiB7XG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjYW5ub3Qgc2VuZCBhIG1lc3NhZ2Ugc2luY2UgdGhlIHdvcmtlciBpcyBub3Qgc2V0IScpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlkID0gdGhpcy5fbmV4dE1lc3NhZ2VJZCsrO1xuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuc2V0KG1pZCwgdGFzayk7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wb3N0TWVzc2FnZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1pZCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0YXNrLnR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogdGFzay5kYXRhLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zZmVyLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRhc2sucHJvbWlzZSkgYXMgV29ya2VyVGFza1JldHVyblR5cGU8Vz47XG4gICAgfVxuXG4gICAgLyoqIFJlY2VpdmVkIGEgbWVzc2FnZSAqL1xuICAgIHByb3RlY3RlZCBvbk1lc3NhZ2UoZXZlbnQ6IE1lc3NhZ2VFdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBVbmFzc29jaWF0ZWQgcmVzcG9uc2VzP1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGV2ZW50LmRhdGEgYXMgV29ya2VyUmVzcG9uc2VWYXJpYW50O1xuICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnR5cGUpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgZmFpbGVkP1xuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXNwb25zZVR5cGUuTE9HOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmxvZyhyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIHByb2dyZXNzIGNhbGxiYWNrXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlc3BvbnNlVHlwZS5JTlNUQU5USUFURV9QUk9HUkVTUzoge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLl9vbkluc3RhbnRpYXRpb25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBwKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYXNzb2NpYXRlZCB0YXNrXG4gICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZ2V0KHJlc3BvbnNlLnJlcXVlc3RJZCk7XG4gICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB1bmFzc29jaWF0ZWQgcmVzcG9uc2U6IFske3Jlc3BvbnNlLnJlcXVlc3RJZH0sICR7cmVzcG9uc2UudHlwZS50b1N0cmluZygpfV1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKHJlc3BvbnNlLnJlcXVlc3RJZCk7XG5cbiAgICAgICAgLy8gUmVxdWVzdCBmYWlsZWQ/XG4gICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5FUlJPUikge1xuICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgRmlyZWZveCBub3QgYmVpbmcgYWJsZSB0byBwZXJmb3JtIHN0cnVjdHVyZWQtY2xvbmUgb24gTmF0aXZlIEVycm9yc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU1NjYwNFxuICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihyZXNwb25zZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgZS5uYW1lID0gcmVzcG9uc2UuZGF0YS5uYW1lO1xuICAgICAgICAgICAgZS5zdGFjayA9IHJlc3BvbnNlLmRhdGEuc3RhY2s7XG4gICAgICAgICAgICB0YXNrLnByb21pc2VSZWplY3RlcihlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlIHRhc2tzIGZpcnN0XG4gICAgICAgIHN3aXRjaCAodGFzay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkNMT1NFX1BSRVBBUkVEOlxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5DT0xMRUNUX0ZJTEVfU1RBVElTVElDUzpcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEg6XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRTpcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUzpcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRkxVU0hfRklMRVM6XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9BUlJPV19GUk9NX0lQQ19TVFJFQU06XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRIOlxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfSlNPTl9GUk9NX1BBVEg6XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLk9QRU46XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlBJTkc6XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSOlxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0hBTkRMRTpcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9VUkw6XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlJFU0VUOlxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5PSykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuSU5TVEFOVElBVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkdMT0JfRklMRV9JTkZPUzpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRklMRV9JTkZPUykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuR0VUX1ZFUlNJT046XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlZFUlNJT05fU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfRkVBVFVSRV9GTEFHUzpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRkVBVFVSRV9GTEFHUykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuR0VUX1RBQkxFX05BTUVTOlxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5UQUJMRV9OQU1FUykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuVE9LRU5JWkU6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlNDUklQVF9UT0tFTlMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19CVUZGRVI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfQlVGRkVSKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTOlxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NUQVRJU1RJQ1MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkNPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkNPTk5FQ1RJT05fSU5GTykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUlVOX1BSRVBBUkVEOlxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUVVFUlk6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRDpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0hFQURFUikge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWTpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0hFQURFUl9PUl9OVUxMKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5QT0xMX1BFTkRJTkdfUVVFUlk6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVF9IRUFERVJfT1JfTlVMTCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ0FOQ0VMX1BFTkRJTkdfUVVFUlk6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuU1VDQ0VTUykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUzpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0NIVU5LKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQ6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlBSRVBBUkVEX1NUQVRFTUVOVF9JRCkge1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0YXNrLnByb21pc2VSZWplY3RlcihuZXcgRXJyb3IoYHVuZXhwZWN0ZWQgcmVzcG9uc2UgdHlwZTogJHtyZXNwb25zZS50eXBlLnRvU3RyaW5nKCl9YCkpO1xuICAgIH1cblxuICAgIC8qKiBSZWNlaXZlZCBhbiBlcnJvciAqL1xuICAgIHByb3RlY3RlZCBvbkVycm9yKGV2ZW50OiBFcnJvckV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXZlbnQpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBlcnJvciBpbiBkdWNrZGIgd29ya2VyOiAke2V2ZW50Lm1lc3NhZ2V9YCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKiBUaGUgd29ya2VyIHdhcyBjbG9zZWQgKi9cbiAgICBwcm90ZWN0ZWQgb25DbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fd29ya2VyU2h1dGRvd25SZXNvbHZlcihudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaXplICE9IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihgd29ya2VyIHRlcm1pbmF0ZWQgd2l0aCAke3RoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaXplfSBwZW5kaW5nIHJlcXVlc3RzYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLyoqIFJlc2V0IHRoZSBkdWNrZGIgKi9cbiAgICBwdWJsaWMgYXN5bmMgcmVzZXQoKTogUHJvbWlzZTxudWxsPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRVNFVCwgbnVsbCwgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuUkVTRVQsIG51bGwpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICAvKiogUGluZyB0aGUgd29ya2VyIHRocmVhZCAqL1xuICAgIHB1YmxpYyBhc3luYyBwaW5nKCk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsLCBudWxsPihXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG4gICAgLyoqIFRyeSB0byBkcm9wIGEgZmlsZSAqL1xuICAgIHB1YmxpYyBhc3luYyBkcm9wRmlsZShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPG51bGw+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRSwgc3RyaW5nLCBudWxsPihXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEUsIG5hbWUpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG4gICAgLyoqIFRyeSB0byBkcm9wIGZpbGVzICovXG4gICAgcHVibGljIGFzeW5jIGRyb3BGaWxlcygpOiBQcm9taXNlPG51bGw+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRVMsIG51bGwsIG51bGw+KFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRVMsIG51bGwpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG4gICAgLyoqIEZsdXNoIGFsbCBmaWxlcyAqL1xuICAgIHB1YmxpYyBhc3luYyBmbHVzaEZpbGVzKCk6IFByb21pc2U8bnVsbD4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkxVU0hfRklMRVMsIG51bGwsIG51bGw+KFdvcmtlclJlcXVlc3RUeXBlLkZMVVNIX0ZJTEVTLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuXG4gICAgLyoqIE9wZW4gdGhlIGRhdGFiYXNlICovXG4gICAgcHVibGljIGFzeW5jIGluc3RhbnRpYXRlKFxuICAgICAgICBtYWluTW9kdWxlVVJMOiBzdHJpbmcsXG4gICAgICAgIHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICAgICAgICBwcm9ncmVzczogKHByb2dyZXNzOiBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MpID0+IHZvaWQgPSBfcCA9PiB7fSxcbiAgICApOiBQcm9taXNlPG51bGw+IHtcbiAgICAgICAgdGhpcy5fb25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MucHVzaChwcm9ncmVzcyk7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNUQU5USUFURSwgW3N0cmluZywgc3RyaW5nIHwgbnVsbF0sIG51bGw+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TVEFOVElBVEUsXG4gICAgICAgICAgICBbbWFpbk1vZHVsZVVSTCwgcHRocmVhZFdvcmtlclVSTF0sXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIHZlcnNpb24gKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0VmVyc2lvbigpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuR0VUX1ZFUlNJT04sIG51bGwsIHN0cmluZz4oV29ya2VyUmVxdWVzdFR5cGUuR0VUX1ZFUlNJT04sIG51bGwpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICAgICAgcmV0dXJuIHZlcnNpb247XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgZmVhdHVyZSBmbGFncyAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRGZWF0dXJlRmxhZ3MoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9GRUFUVVJFX0ZMQUdTLCBudWxsLCBudW1iZXI+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuR0VUX0ZFQVRVUkVfRkxBR1MsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBmZWF0dXJlID0gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxuXG4gICAgLyoqIE9wZW4gYSBuZXcgZGF0YWJhc2UgKi9cbiAgICBwdWJsaWMgYXN5bmMgb3Blbihjb25maWc6IER1Y2tEQkNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuT1BFTiwgRHVja0RCQ29uZmlnLCBudWxsPihXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOLCBjb25maWcpO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cblxuICAgIC8qKiBUb2tlbml6ZSBhIHNjcmlwdCB0ZXh0ICovXG4gICAgcHVibGljIGFzeW5jIHRva2VuaXplKHRleHQ6IHN0cmluZyk6IFByb21pc2U8U2NyaXB0VG9rZW5zPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5UT0tFTklaRSwgc3RyaW5nLCBTY3JpcHRUb2tlbnM+KFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFLCB0ZXh0KTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG5cbiAgICAvKiogQ29ubmVjdCB0byB0aGUgZGF0YWJhc2UgKi9cbiAgICBwdWJsaWMgYXN5bmMgY29ubmVjdEludGVybmFsKCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNULCBudWxsLCBDb25uZWN0aW9uSUQ+KFdvcmtlclJlcXVlc3RUeXBlLkNPTk5FQ1QsIG51bGwpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICAvKiogQ29ubmVjdCB0byB0aGUgZGF0YWJhc2UgKi9cbiAgICBwdWJsaWMgYXN5bmMgY29ubmVjdCgpOiBQcm9taXNlPEFzeW5jRHVja0RCQ29ubmVjdGlvbj4ge1xuICAgICAgICBjb25zdCBjaWQgPSBhd2FpdCB0aGlzLmNvbm5lY3RJbnRlcm5hbCgpO1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jRHVja0RCQ29ubmVjdGlvbih0aGlzLCBjaWQpO1xuICAgIH1cblxuICAgIC8qKiBEaXNjb25uZWN0IGZyb20gdGhlIGRhdGFiYXNlICovXG4gICAgcHVibGljIGFzeW5jIGRpc2Nvbm5lY3QoY29ubjogQ29ubmVjdGlvbklEKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5ESVNDT05ORUNULCBDb25uZWN0aW9uSUQsIG51bGw+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCxcbiAgICAgICAgICAgIGNvbm4sXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuXG4gICAgLyoqIFJ1biBhIHF1ZXJ5ICovXG4gICAgcHVibGljIGFzeW5jIHJ1blF1ZXJ5KGNvbm46IENvbm5lY3Rpb25JRCwgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUVVFUlksIFtDb25uZWN0aW9uSUQsIHN0cmluZ10sIFVpbnQ4QXJyYXk+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLFxuICAgICAgICAgICAgW2Nvbm4sIHRleHRdLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICAvKiogU3RhcnQgYSBwZW5kaW5nIHF1ZXJ5ICovXG4gICAgcHVibGljIGFzeW5jIHN0YXJ0UGVuZGluZ1F1ZXJ5KGNvbm46IENvbm5lY3Rpb25JRCwgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxVaW50OEFycmF5IHwgbnVsbD4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWSwgW0Nvbm5lY3Rpb25JRCwgc3RyaW5nXSwgVWludDhBcnJheSB8IG51bGw+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWSxcbiAgICAgICAgICAgIFtjb25uLCB0ZXh0XSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuICAgIC8qKiBQb2xsIGEgcGVuZGluZyBxdWVyeSAqL1xuICAgIHB1YmxpYyBhc3luYyBwb2xsUGVuZGluZ1F1ZXJ5KGNvbm46IENvbm5lY3Rpb25JRCk6IFByb21pc2U8VWludDhBcnJheSB8IG51bGw+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlBPTExfUEVORElOR19RVUVSWSwgQ29ubmVjdGlvbklELCBVaW50OEFycmF5IHwgbnVsbD4oXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5QT0xMX1BFTkRJTkdfUVVFUlksXG4gICAgICAgICAgICBjb25uLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG4gICAgLyoqIENhbmNlbCBhIHBlbmRpbmcgcXVlcnkgKi9cbiAgICBwdWJsaWMgYXN5bmMgY2FuY2VsUGVuZGluZ1F1ZXJ5KGNvbm46IENvbm5lY3Rpb25JRCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ0FOQ0VMX1BFTkRJTkdfUVVFUlksIENvbm5lY3Rpb25JRCwgYm9vbGVhbj4oXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DQU5DRUxfUEVORElOR19RVUVSWSxcbiAgICAgICAgICAgIGNvbm4sXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cblxuICAgIC8qKiBGZXRjaCBxdWVyeSByZXN1bHRzICovXG4gICAgcHVibGljIGFzeW5jIGZldGNoUXVlcnlSZXN1bHRzKGNvbm46IENvbm5lY3Rpb25JRCk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUywgQ29ubmVjdGlvbklELCBVaW50OEFycmF5PihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkZFVENIX1FVRVJZX1JFU1VMVFMsXG4gICAgICAgICAgICBjb25uLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRhYmxlIG5hbWVzICovXG4gICAgcHVibGljIGFzeW5jIGdldFRhYmxlTmFtZXMoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVEFCTEVfTkFNRVMsIFtudW1iZXIsIHN0cmluZ10sIHN0cmluZ1tdPihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkdFVF9UQUJMRV9OQU1FUyxcbiAgICAgICAgICAgIFtjb25uLCB0ZXh0XSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuXG4gICAgLyoqIFByZXBhcmUgYSBzdGF0ZW1lbnQgYW5kIHJldHVybiBpdHMgaWRlbnRpZmllciAqL1xuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVQcmVwYXJlZChjb25uOiBudW1iZXIsIHRleHQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsIFtudW1iZXIsIHN0cmluZ10sIG51bWJlcj4oXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsXG4gICAgICAgICAgICBbY29ubiwgdGV4dF0sXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cbiAgICBwdWJsaWMgYXN5bmMgY2xvc2VQcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyXSwgbnVsbD4oXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCxcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnRdLFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cbiAgICAvKiogRXhlY3V0ZSBhIHByZXBhcmVkIHN0YXRlbWVudCBhbmQgcmV0dXJuIHRoZSBmdWxsIHJlc3VsdCAqL1xuICAgIHB1YmxpYyBhc3luYyBydW5QcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUFJFUEFSRUQsIFtDb25uZWN0aW9uSUQsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRCxcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnQsIHBhcmFtc10sXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cbiAgICAvKiogRXhlY3V0ZSBhIHByZXBhcmVkIHN0YXRlbWVudCBhbmQgc3RyZWFtIHRoZSByZXN1bHQgKi9cbiAgICBwdWJsaWMgYXN5bmMgc2VuZFByZXBhcmVkKGNvbm46IG51bWJlciwgc3RhdGVtZW50OiBudW1iZXIsIHBhcmFtczogYW55W10pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsIFtDb25uZWN0aW9uSUQsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsXG4gICAgICAgICAgICBbY29ubiwgc3RhdGVtZW50LCBwYXJhbXNdLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG4gICAgLyoqIEdsb2IgZmlsZSBpbmZvcyAqL1xuICAgIHB1YmxpYyBhc3luYyBnbG9iRmlsZXMocGF0aDogc3RyaW5nKTogUHJvbWlzZTxXZWJGaWxlW10+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdMT0JfRklMRV9JTkZPUywgc3RyaW5nLCBXZWJGaWxlW10+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuR0xPQl9GSUxFX0lORk9TLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBmaWxlIHRleHQgKi9cbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJGaWxlVGV4dChuYW1lOiBzdHJpbmcsIHRleHQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBURVhUX0VOQ09ERVIuZW5jb2RlKHRleHQpO1xuICAgICAgICBhd2FpdCB0aGlzLnJlZ2lzdGVyRmlsZUJ1ZmZlcihuYW1lLCBidWZmZXIpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBmaWxlIHBhdGguICovXG4gICAgcHVibGljIGFzeW5jIHJlZ2lzdGVyRmlsZVVSTChcbiAgICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgICB1cmw6IHN0cmluZyxcbiAgICAgICAgcHJvdG86IER1Y2tEQkRhdGFQcm90b2NvbCxcbiAgICAgICAgZGlyZWN0SU86IGJvb2xlYW4sXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXJsID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8XG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCxcbiAgICAgICAgICAgIFtzdHJpbmcsIHN0cmluZywgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgPihXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCwgW25hbWUsIHVybCwgcHJvdG8sIGRpcmVjdElPXSk7XG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuXG4gICAgLyoqIFJlZ2lzdGVyIGFuIGVtcHR5IGZpbGUgYnVmZmVyLiAqL1xuICAgIHB1YmxpYyBhc3luYyByZWdpc3RlckVtcHR5RmlsZUJ1ZmZlcihuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSLCBbc3RyaW5nLCBVaW50OEFycmF5XSwgbnVsbD4oXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUixcbiAgICAgICAgICAgIFtuYW1lLCBuZXcgVWludDhBcnJheSgpXSxcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICAvKiogUmVnaXN0ZXIgYSBmaWxlIGJ1ZmZlci4gKi9cbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJGaWxlQnVmZmVyKG5hbWU6IHN0cmluZywgYnVmZmVyOiBVaW50OEFycmF5KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUiwgW3N0cmluZywgVWludDhBcnJheV0sIG51bGw+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9CVUZGRVIsXG4gICAgICAgICAgICBbbmFtZSwgYnVmZmVyXSxcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrLCBbYnVmZmVyLmJ1ZmZlcl0pO1xuICAgIH1cblxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgaGFuZGxlLiAqL1xuICAgIHB1YmxpYyBhc3luYyByZWdpc3RlckZpbGVIYW5kbGU8SGFuZGxlVHlwZT4oXG4gICAgICAgIG5hbWU6IHN0cmluZyxcbiAgICAgICAgaGFuZGxlOiBIYW5kbGVUeXBlLFxuICAgICAgICBwcm90b2NvbDogRHVja0RCRGF0YVByb3RvY29sLFxuICAgICAgICBkaXJlY3RJTzogYm9vbGVhbixcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsXG4gICAgICAgICAgICBbc3RyaW5nLCBhbnksIER1Y2tEQkRhdGFQcm90b2NvbCwgYm9vbGVhbl0sXG4gICAgICAgICAgICBudWxsXG4gICAgICAgID4oV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsIFtuYW1lLCBoYW5kbGUsIHByb3RvY29sLCBkaXJlY3RJT10pO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtdKTtcbiAgICB9XG5cbiAgICAvKiogRW5hYmxlIGZpbGUgc3RhdGlzdGljcyAqL1xuICAgIHB1YmxpYyBhc3luYyBjb2xsZWN0RmlsZVN0YXRpc3RpY3MobmFtZTogc3RyaW5nLCBlbmFibGU6IGJvb2xlYW4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLCBbc3RyaW5nLCBib29sZWFuXSwgbnVsbD4oXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DT0xMRUNUX0ZJTEVfU1RBVElTVElDUyxcbiAgICAgICAgICAgIFtuYW1lLCBlbmFibGVdLFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtdKTtcbiAgICB9XG5cbiAgICAvKiogRXhwb3J0IGZpbGUgc3RhdGlzdGljcyAqL1xuICAgIHB1YmxpYyBhc3luYyBleHBvcnRGaWxlU3RhdGlzdGljcyhuYW1lOiBzdHJpbmcpOiBQcm9taXNlPEZpbGVTdGF0aXN0aWNzPiB7XG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTLCBzdHJpbmcsIEZpbGVTdGF0aXN0aWNzPihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkVYUE9SVF9GSUxFX1NUQVRJU1RJQ1MsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrLCBbXSk7XG4gICAgfVxuXG4gICAgLyoqIENvcHkgYSBmaWxlIHRvIGEgYnVmZmVyLiAqL1xuICAgIHB1YmxpYyBhc3luYyBjb3B5RmlsZVRvQnVmZmVyKG5hbWU6IHN0cmluZyk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUiwgc3RyaW5nLCBVaW50OEFycmF5PihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19CVUZGRVIsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG5cbiAgICAvKiogQ29weSBhIGZpbGUgdG8gYSBwYXRoLiAqL1xuICAgIHB1YmxpYyBhc3luYyBjb3B5RmlsZVRvUGF0aChuYW1lOiBzdHJpbmcsIHBhdGg6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEgsIFtzdHJpbmcsIHN0cmluZ10sIG51bGw+KFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEgsXG4gICAgICAgICAgICBbbmFtZSwgcGF0aF0sXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XG4gICAgfVxuXG4gICAgLyoqIEluc2VydCBhcnJvdyBmcm9tIGFuIGlwYyBzdHJlYW0gKi9cbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKFxuICAgICAgICBjb25uOiBDb25uZWN0aW9uSUQsXG4gICAgICAgIGJ1ZmZlcjogVWludDhBcnJheSxcbiAgICAgICAgb3B0aW9ucz86IEFycm93SW5zZXJ0T3B0aW9ucyxcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT0gMCkgcmV0dXJuO1xuICAgICAgICAvLyBQYXNzIHRvIHRoZSB3b3JrZXJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0FSUk9XX0ZST01fSVBDX1NUUkVBTSxcbiAgICAgICAgICAgIFtudW1iZXIsIFVpbnQ4QXJyYXksIEFycm93SW5zZXJ0T3B0aW9ucyB8IHVuZGVmaW5lZF0sXG4gICAgICAgICAgICBudWxsXG4gICAgICAgID4oV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0FSUk9XX0ZST01fSVBDX1NUUkVBTSwgW2Nvbm4sIGJ1ZmZlciwgb3B0aW9uc10pO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtidWZmZXIuYnVmZmVyXSk7XG4gICAgfVxuICAgIC8qKiBJbnNlcnQgYSBjc3YgZmlsZSAqL1xuICAgIHB1YmxpYyBhc3luYyBpbnNlcnRDU1ZGcm9tUGF0aChjb25uOiBDb25uZWN0aW9uSUQsIHBhdGg6IHN0cmluZywgb3B0aW9uczogQ1NWSW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBGbGF0dGVuIHRoZSB0YWJsZSBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zLmNvbHVtbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMuY29sdW1uc1trXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChhcnJvd1RvU1FMRmllbGQoaywgdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdCA9IG91dDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNvbHVtbnM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXNzIHRvIHRoZSB3b3JrZXJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIENTVkluc2VydE9wdGlvbnNdLCBudWxsPihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRILFxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdGlvbnNdLFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xuICAgIH1cbiAgICAvKiogSW5zZXJ0IGEganNvbiBmaWxlICovXG4gICAgcHVibGljIGFzeW5jIGluc2VydEpTT05Gcm9tUGF0aChjb25uOiBDb25uZWN0aW9uSUQsIHBhdGg6IHN0cmluZywgb3B0aW9uczogSlNPTkluc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgdGFibGUgb3B0aW9uc1xuICAgICAgICBpZiAob3B0aW9ucy5jb2x1bW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLmNvbHVtbnNba107XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goYXJyb3dUb1NRTEZpZWxkKGssIHR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY29sdW1uc0ZsYXQgPSBvdXQ7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jb2x1bW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFzcyB0byB0aGUgd29ya2VyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfSlNPTl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgSlNPTkluc2VydE9wdGlvbnNdLCBudWxsPihcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9KU09OX0ZST01fUEFUSCxcbiAgICAgICAgICAgIFtjb25uLCBwYXRoLCBvcHRpb25zXSxcbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IFdvcmtlciBmcm9tICd3ZWItd29ya2VyJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcih1cmw6IHN0cmluZykge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwpO1xuICAgIGNvbnN0IHdvcmtlclNjcmlwdCA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xuICAgIGNvbnN0IHdvcmtlclVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYXdhaXQgd29ya2VyU2NyaXB0LmJsb2IoKSk7XG4gICAgcmV0dXJuIG5ldyBXb3JrZXIod29ya2VyVVJMKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XG5pbXBvcnQgeyBWZWN0b3IgfSBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0IHsgRHVja0RCUXVlcnlDb25maWcgfSBmcm9tICcuLi9zcmMvJztcblxuLy8gVGhlIG1heCBpbnRlcnZhbCBpbiBtaWNyb3NlYyBmcm9tIER1Y2tEQiBpcyA4MyB5ZWFycyAzIG1vbnRocyA5OTkgZGF5cyAwMDoxNjozOS45OTk5OTksIHdpdGggbW9udGhzIGFzIDMwIGRheXMuXG4vLyBOb3RlIHRoYXQgZHVlIHRvIEFycm93IEpTIG5vdCBzdXBwb3J0aW5nIHRoZSBkdXJhdGlvbiB0eXBlLCB0aGUgY2FzdER1cmF0aW9uVG9JbnRlcnZhbCBvcHRpb24gaXMgdXNlZCBmb3IgaW50ZXJ2YWxzLlxuLy8gVGhpcyBoYXMgYSBzaWRlLWVmZmVjdCB0aGF0IHdoaWxlIHRoZSB2YWx1ZSBpcyBpbiBtaWNyb3NlY29uZHMsIGl0IG9ubHkgaGFzIG1pbGxpc2Vjb25kIGFjY3VyYWN5LiBUaGlzIGlzXG4vLyBiZWNhdXNlIER1Y2tEQiBlbWl0cyBpbnRlcnZhbHMgaW4gbWlsbGlzZWNvbmRzIGFuZCB0aGUgQXJyb3cgVGltZTY0IHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBtaWxsaXNlY29uZHMgYXMgdW5pdC5cbi8vY29uc3QgTUFYX0lOVEVSVkFMX1VTID0gKCgoODMgKiAoMTIgKiAzMCkgKyAzICogMzAgKyA5OTkpICogMjQgKiA2MCArIDE2KSAqIDYwICsgMzkpICogMTAwMDAwMCArIDk5OTAwMDtcblxuLy8gSlMgRGF0ZSBhdCArLy04NjQwMDAwMDAwMDAwMDAwbXNcbmNvbnN0IE1JTklNVU1fREFURV9TVFIgPSAnLTI3MTgyMS0wNC0yMCc7XG5jb25zdCBNSU5JTVVNX0RBVEUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMjcxODIxLCAzLCAyMCkpO1xuY29uc3QgTUFYSU1VTV9EQVRFX1NUUiA9ICcyNzU3NjAtMDktMTMnO1xuY29uc3QgTUFYSU1VTV9EQVRFID0gbmV3IERhdGUoRGF0ZS5VVEMoMjc1NzYwLCA4LCAxMykpO1xuXG4vLyBBbGwgY29sdW1ucyBjb250YWluIDMgdmFsdWVzOiBbbWluX3ZhbHVlLCBtYXhfdmFsdWUsIG51bGxdXG50eXBlIEFuc3dlck9iamVjdFR5cGUgPSB7XG4gICAgW2tleTogc3RyaW5nXTogYW55W107XG59O1xuXG5pbnRlcmZhY2UgQWxsVHlwZXNUZXN0IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcXVlcnk6IHN0cmluZztcbiAgICBza2lwOiBzdHJpbmdbXTtcbiAgICBhbnN3ZXJNYXA6IEFuc3dlck9iamVjdFR5cGU7XG4gICAgYW5zd2VyQ291bnQ6IG51bWJlcjtcbiAgICBxdWVyeUNvbmZpZzogRHVja0RCUXVlcnlDb25maWcgfCBudWxsO1xufVxuXG4vLyBUaGVzZSB0eXBlcyBjdXJyZW50bHkgZG8gbm90IHdvcmsgaW4gRHVja0RCLVdBU01cbi8vIHRpbWVzdGFtcF94eCBhbmQgZGF0ZV90eiB0eXBlcyB3aWxsIHNvb24gYmUgZnVsbHkgc3VwcG9ydGVkIGJ5IGR1Y2tkYiBhbmQgc2hvdWxkIGJlIGFkZGVkIHRoZW4uXG4vLyBodWdlaW50LCBkZWNfMThfMywgZGVjMzhfMTAgYW5kIHV1aWQgcmVxdWlyZSBKUyBCaWdJbnRzIGZvciBmdWxsIHN1cHBvcnQsIHdoaWNoIGlzIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIGJ5IEFycm93SlNcbmNvbnN0IE5PVF9JTVBMRU1FTlRFRF9UWVBFUyA9IFtcbiAgICAndGltZXN0YW1wX3MnLFxuICAgICd0aW1lc3RhbXBfbXMnLFxuICAgICd0aW1lc3RhbXBfbnMnLFxuICAgICd0aW1lc3RhbXBfdHonLFxuICAgICdodWdlaW50JyxcbiAgICAnZGVjXzE4XzYnLFxuICAgICdkZWMzOF8xMCcsXG4gICAgJ3V1aWQnLFxuICAgICdtYXAnLFxuICAgICdqc29uJyxcbiAgICAnZGF0ZV9hcnJheScsXG4gICAgJ3RpbWVzdGFtcF9hcnJheScsXG4gICAgJ3RpbWVzdGFtcHR6X2FycmF5Jyxcbl07XG5cbi8vIFRoZXNlIHR5cGVzIGFyZSBzdXBwb3J0ZWQsIGJ1dCBub3QgdGhlIGZ1bGwgcmFuZ2UgcmV0dXJuZWQgZnJvbSB0aGUgdGVzdF9hbGxfdHlwZXMoKSB0YWJsZSBmdW5jdGlvbiwgaGVyZSB3ZSBkZWZpbmVcbi8vIHRoZSBsaW1pdHMgd2UgZG8gZXhwZWN0IHRvIGJlIHN1cHBvcnRlZC5cbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFUyA9IFsnZGF0ZScsICd0aW1lc3RhbXAnXTtcbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQOiBBbnN3ZXJPYmplY3RUeXBlID0ge1xuICAgIGRhdGU6IFtNSU5JTVVNX0RBVEUudmFsdWVPZigpLCBNQVhJTVVNX0RBVEUudmFsdWVPZigpLCBudWxsXSxcbiAgICB0aW1lc3RhbXA6IFtNSU5JTVVNX0RBVEUudmFsdWVPZigpLCBNQVhJTVVNX0RBVEUudmFsdWVPZigpLCBudWxsXSxcbn07XG5cbi8vIFN1YnF1ZXJpZXMgdGhhdCByZXR1cm4gdGhlIGxpbWl0cyBvZiB0aGUgc3Vic2V0IG9mIHRoZSBmdWxsIHJhbmdlIHRoYXQgaXMgaW1wbGVtZW50ZWRcbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFU19TVUJTVElUVVRJT05TID0gW1xuICAgIGAoU0VMRUNUIGFycmF5X2V4dHJhY3QoWycke01JTklNVU1fREFURV9TVFJ9Jzo6RGF0ZSwnJHtNQVhJTVVNX0RBVEVfU1RSfSc6OkRhdGUsbnVsbF0saSArIDEpKSBhcyBkYXRlYCxcbiAgICBgKFNFTEVDVCBhcnJheV9leHRyYWN0KFsnJHtNSU5JTVVNX0RBVEVfU1RSfSc6OlRpbWVzdGFtcCwnJHtNQVhJTVVNX0RBVEVfU1RSfSc6OlRpbWVzdGFtcCxudWxsXSxpICsgMSkpIGFzIHRpbWVzdGFtcGAsXG5dO1xuXG4vLyBUaGVzZSB0eXBlcyBkbyBub3Qgd29yayB3aXRoIGRlZmF1bHQgY29uZmlndXJhdGlvbiwgYnV0IGhhdmVcbmNvbnN0IFRZUEVTX1JFUVVJUklOR19DVVNUT01fQ09ORklHID0gWydkZWNfNF8xJywgJ2RlY185XzQnXTtcblxuLy8gVHlwZXMgdGhhdCBhcmUgZnVsbHkgc3VwcG9ydGVkLlxuY29uc3QgRlVMTFlfSU1QTEVNRU5URURfQU5TV0VSX01BUDogQW5zd2VyT2JqZWN0VHlwZSA9IHtcbiAgICBib29sOiBbZmFsc2UsIHRydWUsIG51bGxdLFxuICAgIHRpbnlpbnQ6IFstMTI4LCAxMjcsIG51bGxdLFxuICAgIHNtYWxsaW50OiBbLTMyNzY4LCAzMjc2NywgbnVsbF0sXG4gICAgaW50OiBbLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcsIG51bGxdLFxuICAgIHV0aW55aW50OiBbMCwgMjU1LCBudWxsXSxcbiAgICB1c21hbGxpbnQ6IFswLCA2NTUzNSwgbnVsbF0sXG4gICAgdWludDogWzAsIDQyOTQ5NjcyOTUsIG51bGxdLFxuICAgIHViaWdpbnQ6IFtCaWdJbnQoMCksIEJpZ0ludCgnMTg0NDY3NDQwNzM3MDk1NTE2MTUnKSwgbnVsbF0sXG4gICAgYmlnaW50OiBbQmlnSW50KCctOTIyMzM3MjAzNjg1NDc3NTgwOCcpLCBCaWdJbnQoJzkyMjMzNzIwMzY4NTQ3NzU4MDcnKSwgbnVsbF0sXG5cbiAgICAvLyBOb3RlIHRoYXQgd2UgbXVsdGlwbHkgYnkgdGhvdXNhbmQgKGFuZCBhZGQgOTk5IGZvciB0aGUgbWF4KSBiZWNhdXNlIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBEdWNrREIgaXMgaW4gbWljcm9zZWNvbmRzLFxuICAgIC8vIHdoZXJlYXMgdGhlIERhdGUgb2JqZWN0IGlzIGluIG1pbGxpc2Vjb25kcy5cbiAgICB0aW1lOiBbQmlnSW50KDApLCBCaWdJbnQobmV3IERhdGUoJzE5NzAtMDEtMDFUMjM6NTk6NTkuOTk5KzAwOjAwJykudmFsdWVPZigpKSAqIEJpZ0ludCgxMDAwKSArIEJpZ0ludCg5OTkpLCBudWxsXSxcbiAgICB0aW1lX3R6OiBbXG4gICAgICAgIEJpZ0ludCgwKSxcbiAgICAgICAgQmlnSW50KG5ldyBEYXRlKCcxOTcwLTAxLTAxVDIzOjU5OjU5Ljk5OSswMDowMCcpLnZhbHVlT2YoKSkgKiBCaWdJbnQoMTAwMCkgKyBCaWdJbnQoOTk5KSxcbiAgICAgICAgbnVsbCxcbiAgICBdLFxuICAgIGludGVydmFsOiBbbmV3IEludDMyQXJyYXkoWzAsMF0pLCAgbmV3IEludDMyQXJyYXkoWzAsMF0pLCBudWxsXSxcblxuICAgIGZsb2F0OiBbLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgMy40MDI4MjM0NjYzODUyODg2ZTM4LCBudWxsXSxcbiAgICBkb3VibGU6IFstMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCwgMS43OTc2OTMxMzQ4NjIzMTU3ZTMwOCwgbnVsbF0sXG4gICAgdmFyY2hhcjogWydcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODYnLCAnZ29vXFx4MDBzZScsIG51bGxdLFxuICAgIHNtYWxsX2VudW06IFsnRFVDS19EVUNLX0VOVU0nLCAnR09PU0UnLCBudWxsXSxcbiAgICBtZWRpdW1fZW51bTogWydlbnVtXzAnLCAnZW51bV8yOTknLCBudWxsXSxcbiAgICBsYXJnZV9lbnVtOiBbJ2VudW1fMCcsICdlbnVtXzY5OTk5JywgbnVsbF0sXG5cbiAgICBpbnRfYXJyYXk6IFtbXSwgWzQyLCA5OTksIG51bGwsIG51bGwsIC00Ml0sIG51bGxdLFxuICAgIGRvdWJsZV9hcnJheTogW1tdLCBbNDIuMCwgTmFOLCBJbmZpbml0eSwgLUluZmluaXR5LCBudWxsLCAtNDIuMF0sIG51bGxdLFxuICAgIHZhcmNoYXJfYXJyYXk6IFtbXSwgWydcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODYnLCAnZ29vc2UnLCBudWxsLCAnJ10sIG51bGxdLFxuICAgIG5lc3RlZF9pbnRfYXJyYXk6IFtbXSwgW1tdLCBbNDIsIDk5OSwgbnVsbCwgbnVsbCwgLTQyXSwgbnVsbCwgW10sIFs0MiwgOTk5LCBudWxsLCBudWxsLCAtNDJdXSwgbnVsbF0sXG5cbiAgICBzdHJ1Y3Q6IFsne1wiYVwiOm51bGwsXCJiXCI6bnVsbH0nLCAne1wiYVwiOjQyLFwiYlwiOlwiXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XCJ9JywgbnVsbF0sXG4gICAgc3RydWN0X29mX2FycmF5czogW1xuICAgICAgICAne1wiYVwiOm51bGwsXCJiXCI6bnVsbH0nLFxuICAgICAgICAne1wiYVwiOls0Miw5OTksbnVsbCxudWxsLC00Ml0sXCJiXCI6W1wiXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XCIsXCJnb29zZVwiLG51bGwsXCJcIl19JyxcbiAgICAgICAgbnVsbCxcbiAgICBdLFxuICAgIGFycmF5X29mX3N0cnVjdHM6IFtbXSwgWyd7XCJhXCI6bnVsbCxcImJcIjpudWxsfScsICd7XCJhXCI6NDIsXCJiXCI6XCJcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcIn0nLCBudWxsXSwgbnVsbF0sXG5cbiAgICAvLyBYWFggc29tZXRpbWVzIHRocm93c1xuICAgIC8vIG1hcDogWyd7fScsICd7XCJrZXkxXCI6XCJcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcIixcImtleTJcIjpcImdvb3NlXCJ9JywgbnVsbF0sXG4gICAgYmxvYjogW1xuICAgICAgICBVaW50OEFycmF5LmZyb20oW1xuICAgICAgICAgICAgMTE2LCAxMDQsIDEwNSwgMTE1LCAxMDUsIDExNSwgOTcsIDEwOCwgMTExLCAxMTAsIDEwMywgOTgsIDEwOCwgMTExLCA5OCwgMCwgMTE5LCAxMDUsIDExNiwgMTA0LCAxMTAsIDExNyxcbiAgICAgICAgICAgIDEwOCwgMTA4LCA5OCwgMTIxLCAxMTYsIDEwMSwgMTE1LFxuICAgICAgICBdKSxcbiAgICAgICAgVWludDhBcnJheS5mcm9tKFswLCAwLCAwLCA5N10pLFxuICAgICAgICBudWxsLFxuICAgIF0sXG59O1xuXG4vLyBSZXBsYWNlbWVudHMgZm9yIHRoZSB2YWx1ZXMgd2Uga25vd2luZ2x5IGRvbid0IHN1cHBvcnQgZnJvbSB0aGUgdGVzdF9hbGxfdHlwZXMgcXVlcnlcbmNvbnN0IFJFUExBQ0VfQ09MVU1OUyA9IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFUy5jb25jYXQoTk9UX0lNUExFTUVOVEVEX1RZUEVTKS5jb25jYXQoVFlQRVNfUkVRVUlSSU5HX0NVU1RPTV9DT05GSUcpO1xuXG5mdW5jdGlvbiB1bnBhY2sodjogYW55KTogYW55IHtcbiAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodiBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICBjb25zdCByZXQgPSBBcnJheS5mcm9tKHYudG9BcnJheSgpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdi5pc1ZhbGlkKGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0W2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5wYWNrKHJldCk7XG4gICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgcmV0OiBhbnkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXRbaV0gPSB1bnBhY2sodltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAodi50b0pTT04gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodi50b0pTT04oKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHg6IGFueSk6IGFueSB7XG4gICAgaWYgKHR5cGVvZiB4Py52YWx1ZU9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB4LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG59XG5cbmNvbnN0IEFMTF9UWVBFU19URVNUOiBBbGxUeXBlc1Rlc3RbXSA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmdWxseSBzdXBwb3J0ZWQgdHlwZXMnLFxuICAgICAgICBxdWVyeTogYFNFTEVDVCAqIFJFUExBQ0UoJ25vdF9pbXBsZW1lbnRlZCcgYXMgbWFwKSBGUk9NIHRlc3RfYWxsX3R5cGVzKClgLFxuICAgICAgICBza2lwOiBSRVBMQUNFX0NPTFVNTlMsXG4gICAgICAgIGFuc3dlck1hcDogRlVMTFlfSU1QTEVNRU5URURfQU5TV0VSX01BUCxcbiAgICAgICAgYW5zd2VyQ291bnQ6IFJFUExBQ0VfQ09MVU1OUy5sZW5ndGggKyBPYmplY3Qua2V5cyhGVUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQKS5sZW5ndGgsXG4gICAgICAgIHF1ZXJ5Q29uZmlnOiBudWxsLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAncGFydGlhbGx5IHN1cHBvcnRlZCB0eXBlcycsXG4gICAgICAgIHF1ZXJ5OiBgU0VMRUNUICR7UEFSVElBTExZX0lNUExFTUVOVEVEX1RZUEVTX1NVQlNUSVRVVElPTlMuam9pbignLCAnKX1cbiAgICAgICAgICAgICAgICBGUk9NIHJhbmdlKDAsIDMpIHRibChpKWAsXG4gICAgICAgIHNraXA6IFtdLFxuICAgICAgICBhbnN3ZXJNYXA6IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQLFxuICAgICAgICBhbnN3ZXJDb3VudDogUEFSVElBTExZX0lNUExFTUVOVEVEX1RZUEVTLmxlbmd0aCxcbiAgICAgICAgcXVlcnlDb25maWc6IG51bGwsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd0eXBlcyB3aXRoIGN1c3RvbSBjb25maWcnLFxuICAgICAgICBxdWVyeTogYFNFTEVDVCAke1RZUEVTX1JFUVVJUklOR19DVVNUT01fQ09ORklHLmpvaW4oJywnKX0gRlJPTSB0ZXN0X2FsbF90eXBlcygpYCxcbiAgICAgICAgc2tpcDogW10sXG4gICAgICAgIGFuc3dlck1hcDoge1xuICAgICAgICAgICAgZGVjXzRfMTogWy05OTkuOTAwMDAwMDAwMDAwMSwgOTk5LjkwMDAwMDAwMDAwMDEsIG51bGxdLFxuICAgICAgICAgICAgZGVjXzlfNDogWy05OTk5OS45OTk5MDAwMDAwMSwgOTk5OTkuOTk5OTAwMDAwMDEsIG51bGxdLFxuICAgICAgICB9LFxuICAgICAgICBhbnN3ZXJDb3VudDogVFlQRVNfUkVRVUlSSU5HX0NVU1RPTV9DT05GSUcubGVuZ3RoLFxuICAgICAgICBxdWVyeUNvbmZpZzoge1xuICAgICAgICAgICAgY2FzdERlY2ltYWxUb0RvdWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBbGxUeXBlcyhkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uIHwgbnVsbDtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGlmIChjb25uKSB7XG4gICAgICAgICAgICBjb25uLmNsb3NlKCk7XG4gICAgICAgICAgICBjb25uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICAgICAgZGIoKS5kcm9wRmlsZXMoKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnVGVzdCBBbGwgVHlwZXMnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBBTExfVFlQRVNfVEVTVCkge1xuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3QucXVlcnlDb25maWcpIGRiKCkub3Blbih7IHF1ZXJ5OiB0ZXN0LnF1ZXJ5Q29uZmlnIH0pO1xuXG4gICAgICAgICAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMubnVtQ29scykudG9FcXVhbCh0ZXN0LmFuc3dlckNvdW50KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzIG9mIHRlc3Quc2tpcCkge1xuICAgICAgICAgICAgICAgICAgICBza2lwLnNldChzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLm51bUNvbHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcmVzdWx0cy5zY2hlbWEuZmllbGRzW2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiYml0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gcmVzdWx0cy5nZXRDaGlsZEF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcC5nZXQobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoY29sKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbD8ubGVuZ3RoKS5ub3QudG9FcXVhbCgwKTtcblxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodW5wYWNrKGdldFZhbHVlKGNvbCEuZ2V0KDApKSkpXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbCh0ZXN0LmFuc3dlck1hcFtuYW1lXVswXSk7IC8vIE1pblxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodW5wYWNrKGdldFZhbHVlKGNvbCEuZ2V0KDEpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbCh0ZXN0LmFuc3dlck1hcFtuYW1lXVsxXSk7IC8vIE1heFxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoY29sIS5nZXQoMikpXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbCh0ZXN0LmFuc3dlck1hcFtuYW1lXVsyXSk7IC8vIE51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdEFsbFR5cGVzQXN5bmMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGNvbm4pIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgIGNvbm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1Rlc3QgQWxsIFR5cGVzIEFzeW5jJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgQUxMX1RZUEVTX1RFU1QpIHtcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0LnF1ZXJ5Q29uZmlnKSBkYigpLm9wZW4oeyBxdWVyeTogdGVzdC5xdWVyeUNvbmZpZyB9KTtcblxuICAgICAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0cy5udW1Db2xzKS50b0VxdWFsKHRlc3QuYW5zd2VyQ291bnQpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGVzdC5za2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNraXAuc2V0KHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubnVtQ29sczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSByZXN1bHRzLnNjaGVtYS5maWVsZHNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJiaXRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSByZXN1bHRzLmdldENoaWxkQXQoaSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwLmdldChuYW1lKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChjb2wpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoY29sPy5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xuXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChPYmplY3Qua2V5cyh0ZXN0LmFuc3dlck1hcCkpLnRvQ29udGFpbihuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHVucGFjayhnZXRWYWx1ZShjb2whLmdldCgwKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhDb250ZXh0KG5hbWUgKyAnfCcgKyBjb2w/LnRvU3RyaW5nKCkgKyAnfFswXScpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbCh0ZXN0LmFuc3dlck1hcFtuYW1lXVswXSk7IC8vIE1pblxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodW5wYWNrKGdldFZhbHVlKGNvbCEuZ2V0KDEpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aENvbnRleHQobmFtZSArICd8JyArIGNvbD8udG9TdHJpbmcoKSArICd8WzFdJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzFdKTsgLy8gTWF4XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChjb2whLmdldCgyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lICsgJ3wnICsgY29sPy50b1N0cmluZygpICsgJ3xbMl0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwodGVzdC5hbnN3ZXJNYXBbbmFtZV1bMl0pOyAvLyBOdWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XG5pbXBvcnQgeyBnZXRTM1BhcmFtcywgUzNQYXJhbXMsIFMzUGF5bG9hZFBhcmFtcywgY3JlYXRlUzNIZWFkZXJzLCB1cmlFbmNvZGUsIGdldEhUVFBVcmwgfSBmcm9tICcuLi9zcmMvdXRpbHMnO1xuaW1wb3J0IHsgQXN5bmNEdWNrREJDb25uZWN0aW9uLCBEdWNrREJCaW5kaW5ncywgRHVja0RCQmluZGluZ3NCYXNlLCBEdWNrREJNb2R1bGUgfSBmcm9tICcuLi9zcmMvJztcbmltcG9ydCBCUk9XU0VSX1JVTlRJTUUgZnJvbSAnLi4vc3JjL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlcic7XG5cbi8vIFMzIGNvbmZpZyBmb3IgdGVzdHNcbmNvbnN0IEJVQ0tFVF9OQU1FID0gJ3Rlc3QtYnVja2V0JztcbmNvbnN0IEFDQ0VTU19LRVlfSUQgPSAnUzNSVkVSJztcbmNvbnN0IEFDQ0VTU19LRVlfU0VDUkVUID0gJ1MzUlZFUic7XG5jb25zdCBTM19FTkRQT0lOVCA9ICdodHRwOi8vbG9jYWxob3N0OjQ5MjMnO1xuY29uc3QgUzNfUkVHSU9OID0gJ2V1LXdlc3QtMSc7XG5cbmVudW0gQVdTQ29uZmlnVHlwZSB7XG4gICAgRU1QVFksXG4gICAgVkFMSUQsXG4gICAgSU5WQUxJRCxcbn1cbmNvbnN0IHNldEF3c0NvbmZpZyA9IGFzeW5jIGZ1bmN0aW9uIChjb25uOiBBc3luY0R1Y2tEQkNvbm5lY3Rpb24sIHR5cGU6IEFXU0NvbmZpZ1R5cGUgPSBBV1NDb25maWdUeXBlLlZBTElEKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgQVdTQ29uZmlnVHlwZS5FTVBUWTpcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfcmVnaW9uPScnO1wiKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfYWNjZXNzX2tleV9pZD0nJztcIik7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PScnO1wiKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfc2Vzc2lvbl90b2tlbj0nJztcIik7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfZW5kcG9pbnQ9JyR7UzNfRU5EUE9JTlR9JztgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFXU0NvbmZpZ1R5cGUuVkFMSUQ6XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfcmVnaW9uPScke1MzX1JFR0lPTn0nO2ApO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgU0VUIHMzX2FjY2Vzc19rZXlfaWQ9JyR7QUNDRVNTX0tFWV9JRH0nO2ApO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PScke0FDQ0VTU19LRVlfU0VDUkVUfSc7YCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49Jyc7XCIpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgU0VUIHMzX2VuZHBvaW50PScke1MzX0VORFBPSU5UfSc7YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLklOVkFMSUQ6XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3JlZ2lvbj0nYS12ZXJ5LXJlbW90ZS1hbmQtbm9uLWV4aXN0ZW50LXMzLXJlZ2lvbic7XCIpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShcIlNFVCBzM19hY2Nlc3Nfa2V5X2lkPSdUSElTQUNDRVNTS0VZSURJU05PVFZBTElEJztcIik7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PSdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCc7XCIpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShcIlNFVCBzM19zZXNzaW9uX3Rva2VuPSdJTlZBTElEU0VTU0lPTlRPS0VOJztcIik7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfZW5kcG9pbnQ9JyR7UzNfRU5EUE9JTlR9JztgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0SFRUUEZTKHNkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uIHwgbnVsbDtcblxuICAgIGNvbnN0IGdldE1vZHVsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IG1vZHVsZTogRHVja0RCTW9kdWxlIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNvbm4hLnVzZVVuc2FmZSgoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25fbnVtYmVyOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIG1vZHVsZSA9IChiaW5kaW5ncyBhcyBEdWNrREJCaW5kaW5nc0Jhc2UpLm1vZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4cGVjdChtb2R1bGUpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfTtcbiAgICBjb25zdCByZXNldCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgc2RiKCkucmVzZXQoKTtcbiAgICAgICAgY29ubiA9IHNkYigpLmNvbm5lY3QoKTtcbiAgICB9O1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4gYXdhaXQgcmVzZXQoKSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IGF3YWl0IHJlc2V0KCkpO1xuXG4gICAgZGVzY3JpYmUoJ0hUVFBGUycsICgpID0+IHtcbiAgICAgICAgaXQoJ3MzIGNvbmZpZyBpcyBzZXQgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gZ2V0TW9kdWxlKCk7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWVzIGFyZSBlbXB0eVxuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm8gPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUVwb2NoID0gZ2xvYmFsRmlsZUluZm8hLmNhY2hlRXBvY2g7XG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZz8ucmVnaW9uKS50b0VxdWFsKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mbz8uczNDb25maWc/LmFjY2Vzc0tleUlkKS50b0VxdWFsKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mbz8uczNDb25maWc/LnNlY3JldEFjY2Vzc0tleSkudG9FcXVhbCgnJyk7XG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJycpO1xuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZz8uZW5kcG9pbnQpLnRvRXF1YWwoJycpO1xuXG4gICAgICAgICAgICAvLyBDb25maXJtIHNldHRpbmdzIGFyZSBjb3JyZWN0bHkgc2V0XG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19yZWdpb249J2EtdmVyeS1yZW1vdGUtYW5kLW5vbi1leGlzdGVudC1zMy1yZWdpb24nO1wiKTtcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2FjY2Vzc19rZXlfaWQ9J1RISVNBQ0NFU1NLRVlJRElTTk9UVkFMSUQnO1wiKTtcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PSdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCc7XCIpO1xuICAgICAgICAgICAgY29ubiEucXVlcnkoXCJTRVQgczNfc2Vzc2lvbl90b2tlbj0nQU5JQ0VTRVNTSU9OVE9LRU4nO1wiKTtcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdzMy5zb21lLnNvcnQub2YuY2xvdWQnO1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvVXBkYXRlZCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mb1VwZGF0ZWQ/LnMzQ29uZmlnKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvVXBkYXRlZD8uY2FjaGVFcG9jaCkudG9FcXVhbChjYWNoZUVwb2NoICsgNSk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBnZXRTM1BhcmFtcyhnbG9iYWxGaWxlSW5mb1VwZGF0ZWQ/LnMzQ29uZmlnLCAnczM6Ly90ZXN0LWJ1Y2tldC90ZXN0ZmlsZS50eHQnLCAnR0VUJyk7XG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnVybCkudG9FcXVhbCgnL3Rlc3RmaWxlLnR4dCcpO1xuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5xdWVyeSkudG9FcXVhbCgnJyk7XG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLmhvc3QpLnRvRXF1YWwoJ3Rlc3QtYnVja2V0LnMzLnNvbWUuc29ydC5vZi5jbG91ZCcpO1xuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5yZWdpb24pLnRvRXF1YWwoJ2EtdmVyeS1yZW1vdGUtYW5kLW5vbi1leGlzdGVudC1zMy1yZWdpb24nKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMuc2VydmljZSkudG9FcXVhbCgnczMnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMubWV0aG9kKS50b0VxdWFsKCdHRVQnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMuYWNjZXNzS2V5SWQpLnRvRXF1YWwoJ1RISVNBQ0NFU1NLRVlJRElTTk9UVkFMSUQnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMuc2VjcmV0QWNjZXNzS2V5KS50b0VxdWFsKCdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCcpO1xuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJ0FOSUNFU0VTU0lPTlRPS0VOJyk7XG5cbiAgICAgICAgICAgIC8vIENvdmVyIGZ1bGwgaHR0cCBlbmRwb2ludCBjb25maWdcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdodHRwOi8vbG9jYWxob3N0OjEzMzcnO1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvRnVsbEh0dHBFbmRwb2ludCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0Z1bGxIdHRwRW5kcG9pbnQgPSBnZXRTM1BhcmFtcyhcbiAgICAgICAgICAgICAgICBnbG9iYWxGaWxlSW5mb0Z1bGxIdHRwRW5kcG9pbnQ/LnMzQ29uZmlnLFxuICAgICAgICAgICAgICAgICdzMzovL3Rlc3QtYnVja2V0L3Rlc3RmaWxlLnR4dCcsXG4gICAgICAgICAgICAgICAgJ0dFVCcsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0Z1bGxIdHRwRW5kcG9pbnQuaG9zdCkudG9FcXVhbCgnbG9jYWxob3N0OjEzMzcnKTtcblxuICAgICAgICAgICAgLy8gUmVzZXQgc2hvdWxkIGNsZWFyIGNvbmZpZ1xuICAgICAgICAgICAgYXdhaXQgcmVzZXQoKTtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvQ2xlYXJlZCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0NsZWFyZWQgPSBnZXRTM1BhcmFtcyhnbG9iYWxGaWxlSW5mb0NsZWFyZWQ/LnMzQ29uZmlnLCAnczM6Ly90ZXN0LWJ1Y2tldC90ZXN0ZmlsZS50eHQnLCAnR0VUJyk7XG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC51cmwpLnRvRXF1YWwoJy90ZXN0ZmlsZS50eHQnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLnF1ZXJ5KS50b0VxdWFsKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLmhvc3QpLnRvRXF1YWwoJ3Rlc3QtYnVja2V0LnMzLmFtYXpvbmF3cy5jb20nKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLnJlZ2lvbikudG9FcXVhbCgnJyk7XG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5zZXJ2aWNlKS50b0VxdWFsKCdzMycpO1xuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQubWV0aG9kKS50b0VxdWFsKCdHRVQnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLmFjY2Vzc0tleUlkKS50b0VxdWFsKCcnKTtcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLnNlY3JldEFjY2Vzc0tleSkudG9FcXVhbCgnJyk7XG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgndXJsIHBhcnNpbmcgaXMgY29ycmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGdldE1vZHVsZSgpO1xuXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0nJztcIik7XG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0RlZmF1bHQgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm9EZWZhdWx0Py5zM0NvbmZpZykudG9CZURlZmluZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRVcmwgPSBnZXRIVFRQVXJsKGdsb2JhbEZpbGVJbmZvRGVmYXVsdD8uczNDb25maWcsIGBzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3QtZmlsZS5jc3ZgKTtcbiAgICAgICAgICAgIGV4cGVjdChkZWZhdWx0VXJsKS50b0VxdWFsKGBodHRwczovLyR7QlVDS0VUX05BTUV9LnMzLmFtYXpvbmF3cy5jb20vdGVzdC1maWxlLmNzdmApO1xuXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0naHR0cHM6Ly9kdWNrZGJsYWJzLmNvbSc7XCIpO1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm9GdWxsVXJsID0gQlJPV1NFUl9SVU5USU1FLmdldEdsb2JhbEZpbGVJbmZvKG1vZHVsZSEpO1xuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvRnVsbFVybD8uczNDb25maWcpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gZ2V0SFRUUFVybChnbG9iYWxGaWxlSW5mb0Z1bGxVcmw/LnMzQ29uZmlnLCBgczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XG4gICAgICAgICAgICBleHBlY3QoZnVsbFVybCkudG9FcXVhbChgaHR0cHM6Ly9kdWNrZGJsYWJzLmNvbS8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XG5cbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdkdWNrZGJsYWJzLmNvbSc7XCIpO1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm9Eb21haW4gPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm9Eb21haW4/LnMzQ29uZmlnKS50b0JlRGVmaW5lZCgpO1xuICAgICAgICAgICAgY29uc3QgZG9tYWluT25seVVybCA9IGdldEhUVFBVcmwoZ2xvYmFsRmlsZUluZm9Eb21haW4/LnMzQ29uZmlnLCBgczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XG4gICAgICAgICAgICBleHBlY3QoZG9tYWluT25seVVybCkudG9FcXVhbChgaHR0cHM6Ly8ke0JVQ0tFVF9OQU1FfS5kdWNrZGJsYWJzLmNvbS90ZXN0LWZpbGUuY3N2YCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHZhbGlkYXRlIGF1dGhvcml6YXRpb24gaGVhZGVycyBmb3Iga25vd24gcmVxdWVzdHMsIGJhc2VkIG9uOiBodHRwczovL2N6YWsucGwvMjAxNS8wOS8xNS9zMy1yZXN0LWFwaS13aXRoLWN1cmwuaHRtbFxuICAgICAgICBpdCgnczMgaGVscGVyIHBhc3NlcyB2YWxpZGF0aW9uJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGVzdFBhcmFtczE6IFMzUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVybDogJy8nLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgICAgICAgICAgICBob3N0OiAnbXktcHJlY2lvdXMtYnVja2V0LnMzLmFtYXpvbmF3cy5jb20nLFxuICAgICAgICAgICAgICAgIHJlZ2lvbjogJ3VzLWVhc3QtMScsXG4gICAgICAgICAgICAgICAgc2VydmljZTogJ3MzJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiAnQUtJQUlPU0ZPRE5ON0VYQU1QTEUnLFxuICAgICAgICAgICAgICAgIHNlY3JldEFjY2Vzc0tleTogJ3dKYWxyWFV0bkZFTUkvSzdNREVORy9iUHhSZmlDWUVYQU1QTEVLRVknLFxuICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogJycsXG4gICAgICAgICAgICAgICAgZGF0ZU5vdzogJzIwMTUwOTE1JyxcbiAgICAgICAgICAgICAgICBkYXRldGltZU5vdzogJzIwMTUwOTE1VDEyNDUwMFonLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVMzSGVhZGVycyh0ZXN0UGFyYW1zMSkuZ2V0KCdBdXRob3JpemF0aW9uJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFxuICAgICAgICAgICAgICAgICdBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9QUtJQUlPU0ZPRE5ON0VYQU1QTEUvMjAxNTA5MTUvdXMtZWFzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1ob3N0O3gtYW16LWNvbnRlbnQtc2hhMjU2O3gtYW16LWRhdGUsIFNpZ25hdHVyZT0xODIwNzJlYjUzZDg1YzM2YjJkNzkxYTFmYTQ2YTEyZDIzNDU0ZWMxZTkyMWIwMjA3NWMyM2FlZTQwMTY2ZDVhJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbF9xdWVyeV9zdHJpbmcgPSAnZGVsaW1pdGVyPSUyRiZlbmNvZGluZy10eXBlPXVybCZsaXN0LXR5cGU9MiZwcmVmaXg9JzsgLy8gYXdzIHMzIGxzIDxidWNrZXQ+XG4gICAgICAgICAgICBjb25zdCB0ZXN0UGFyYW1zMjogUzNQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiAnLycsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGNhbm9uaWNhbF9xdWVyeV9zdHJpbmcsXG4gICAgICAgICAgICAgICAgaG9zdDogJ215LXByZWNpb3VzLWJ1Y2tldC5zMy5ldS13ZXN0LTEuYW1hem9uYXdzLmNvbScsXG4gICAgICAgICAgICAgICAgcmVnaW9uOiAnZXUtd2VzdC0xJyxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiAnczMnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6ICdBU0lBWVNQSU9ZRFRIVEJJSVRWQycsXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAndnMxQlpQeFNMMnFWQVJCU2c1dkNNS0pzYXZDb0VQbG8vSFNIUmFWZScsXG4gICAgICAgICAgICAgICAgc2Vzc2lvblRva2VuOlxuICAgICAgICAgICAgICAgICAgICAnSVFvSmIzSnBaMmx1WDJWakVOWC8vLy8vLy8vLy93RWFDV1YxTFhkbGMzUXRNU0pITUVVQ0lRRGZqenM5QllIckVYRE1VL05SK1BIVjF1U1RyN0NTVlNRZGpLU2ZpUFJMZGdJZ0NDenRGMFZNYmk5K3VISEFmQlZLaFY0dDlNbFVyUWczVkFPSXNMeHJXeW9xbEFJSUhSQUFHZ3cxT0RrME16UTRPVFkyTVRRaURPR2wyRHNZeEVOY0tDYmgraXJ4QVJlOTFmYUkraHdVaFQ2MHNNR1JGZzBHV2VmS25QY2xINHVSRnpjenJET2NKbEFBYVFSSjdLT3NUOEJySmxyWTFqU2dqa083UGtWalBwOTJ2aTZsSlg3N2JnOTlNa1VUSkFjdGlPS21kODRYdkFFNWJGYy9qRmJxZWNodEJqWHpvcEFQa0tzR3VhcUFoQ2VuWG5GdDZjd3ErTFppa3YvTkpHVnc3VFJwaExWK0FxOVBTTDlYd2R6SWdzVzJxWHdlMWMzcnhETmo1M3lTdFJaSFZnZ2R4SjBPZ0h4NXYwNDBjOThnRnBoelNVTEh5ZzBPWTZ3bUNNVFljc3dwYjRrTzJJSWk2QWlEOWNZMjVUbHdQS1JLUGk1Q2RCc1RQbnlUZVc2MnU3UHZ3SzBmVFN5NFp1SlV1R0tRbkgyY0ttQ1hxdUV3b09IRWlRWTZuUUg5ZnpZL0VER0hNUnhXV2h4dTBIaXFJZnN1RnFDN0dTMHAwVG9LUUUrcHpOc3ZWd01qWmMrS0lMSUREUXBkQ1dSSXd1NTNJNVBaeTJDdmsrM3k0WEx2ZFpLUUNzQUtxZU9jNGM5NFVBUzRObVVUN21DRE91UlYwY0xCVk04RjBKWUJHclV4eUkrWW9JdkhoUVdtblJMdUtnVGI1UGtGN1pXclhCSEZXRzUvdFpET3ZCYmJhQ1dUbFJDTDliMFZwZzUrQk0vODF4ZDhqQ2hQNHc4MycsXG4gICAgICAgICAgICAgICAgZGF0ZU5vdzogJzIwMjEwOTA0JyxcbiAgICAgICAgICAgICAgICBkYXRldGltZU5vdzogJzIwMjEwOTA0VDEyMTc0NlonLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBjcmVhdGVTM0hlYWRlcnModGVzdFBhcmFtczIpLmdldCgnQXV0aG9yaXphdGlvbicpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdDIpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgJ0FXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD1BU0lBWVNQSU9ZRFRIVEJJSVRWQy8yMDIxMDkwNC9ldS13ZXN0LTEvczMvYXdzNF9yZXF1ZXN0LCBTaWduZWRIZWFkZXJzPWhvc3Q7eC1hbXotY29udGVudC1zaGEyNTY7eC1hbXotZGF0ZTt4LWFtei1zZWN1cml0eS10b2tlbiwgU2lnbmF0dXJlPTRkOWQ2YjU5ZDc4MzZiNjQ4NWY2YWQ4MjJkZTk3YmU0MDI4N2RhMzAzNDdkODMwNDJlYTdmYmVkNTMwZGM0YzAnLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgdGVzdFBhcmFtczM6IFMzUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVybDogJy9jb3JyZWN0X2F1dGhfdGVzdC5jc3YnLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiAnJyxcbiAgICAgICAgICAgICAgICBob3N0OiAndGVzdC1idWNrZXQtY2VpdmVyYW4uczMuYW1hem9uYXdzLmNvbScsXG4gICAgICAgICAgICAgICAgcmVnaW9uOiAnZXUtd2VzdC0xJyxcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiAnczMnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6ICdTM1JWRVInLFxuICAgICAgICAgICAgICAgIHNlY3JldEFjY2Vzc0tleTogJ1MzUlZFUicsXG4gICAgICAgICAgICAgICAgc2Vzc2lvblRva2VuOiAnJyxcbiAgICAgICAgICAgICAgICBkYXRlTm93OiAnMjAyMjAxMjEnLFxuICAgICAgICAgICAgICAgIGRhdGV0aW1lTm93OiAnMjAyMjAxMjFUMTQxNDUyWicsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdGVzdDNQYXlsb2FkUGFyYW1zOiBTM1BheWxvYWRQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudEhhc2g6ICcyOGEwY2Y2YWM1YzRjYjczNzkzMDkxZmU2ZWNjNmE2OGJmOTA4NTVhYzkxODYxNTg3NDgxNThmNTAyNDFiYjBjJyxcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ3RleHQvZGF0YTtjaGFyc2V0PXV0Zi04JyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQzID0gY3JlYXRlUzNIZWFkZXJzKHRlc3RQYXJhbXMzLCB0ZXN0M1BheWxvYWRQYXJhbXMpLmdldCgnQXV0aG9yaXphdGlvbicpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdDMpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgJ0FXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD1TM1JWRVIvMjAyMjAxMjEvZXUtd2VzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1jb250ZW50LXR5cGU7aG9zdDt4LWFtei1jb250ZW50LXNoYTI1Njt4LWFtei1kYXRlLCBTaWduYXR1cmU9NWQ5YTZjYmZhYTc4YTZkMGYyYWI3ZGYwNDQ1ZTJmMWNjOWM4MGNkMzY1NWFjN2RlOWU3MjE5YzAzNmYyM2YwMicsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvY2F0ZWdvcnk9Qm9va3MvJykpLnRvRXF1YWwoJy9jYXRlZ29yeSUzREJvb2tzLycpO1xuICAgICAgICAgICAgZXhwZWN0KHVyaUVuY29kZSgnLz9jYXRlZ29yeT1Cb29rcyZ0aXRsZT1EdWNrcyBSZXRyZWF0LycpKS50b0VxdWFsKFxuICAgICAgICAgICAgICAgICcvJTNGY2F0ZWdvcnklM0RCb29rcyUyNnRpdGxlJTNERHVja3MlMjBSZXRyZWF0LycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KHVyaUVuY29kZSgnLz9jYXRlZ29yeT1Cb29rcyZ0aXRsZT1EdWNrcyBSZXRyZWF0LycsIHRydWUpKS50b0VxdWFsKFxuICAgICAgICAgICAgICAgICclMkYlM0ZjYXRlZ29yeSUzREJvb2tzJTI2dGl0bGUlM0REdWNrcyUyMFJldHJlYXQlMkYnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0SFRUUEZTQXN5bmMoXG4gICAgYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXG4gICAgcmVzb2x2ZURhdGE6ICh1cmw6IHN0cmluZykgPT4gUHJvbWlzZTxVaW50OEFycmF5IHwgbnVsbD4sXG4gICAgYmFzZURpcjogc3RyaW5nLFxuKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb24gfCBudWxsO1xuXG4gICAgLy8gUFVUcyBhbiBTMyBmaWxlIHRvIHRoZSBTMyB0ZXN0IHNlcnZlclxuICAgIGNvbnN0IHB1dFRlc3RGaWxlVG9TMyA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlTmFtZTogc3RyaW5nLCBmb3JtYXQ6IHN0cmluZywgdGVzdF9kYXRhOiBVaW50OEFycmF5IHwgbnVsbCkge1xuICAgICAgICBhd2FpdCBhZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3Rlc3RfZmlsZS5wYXJxdWV0JywgdGVzdF9kYXRhISk7XG4gICAgICAgIGlmICghY29ubikge1xuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiwgQVdTQ29uZmlnVHlwZS5WQUxJRCk7XG4gICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYENSRUFURSBUQUJMRSB0ZXN0X3RhYmxlIEFTIChTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2NhbigndGVzdF9maWxlLnBhcnF1ZXQnKSk7YCk7XG4gICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYENPUFkgdGVzdF90YWJsZSBUTyAnczM6Ly8ke0JVQ0tFVF9OQU1FfS8ke2ZpbGVOYW1lfS4ke2Zvcm1hdH0nIChGT1JNQVQgJyR7Zm9ybWF0fScpO2ApO1xuICAgICAgICBhd2FpdCBhZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGFkYigpLmRyb3BGaWxlcygpO1xuICAgIH07XG5cbiAgICAvLyBSZXF1aXJlcyBhbiBvcGVuIGNvbm5cbiAgICBjb25zdCBhc3NlcnRUZXN0RmlsZVJlc3VsdENvcnJlY3QgPSBhc3luYyBmdW5jdGlvbiAocmVzdWx0OiBhbnksIHRlc3RfZGF0YTogVWludDhBcnJheSB8IG51bGwpIHtcbiAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCd0ZXN0X2ZpbGVfYmFzZWxpbmUucGFycXVldCcsIHRlc3RfZGF0YSEpO1xuICAgICAgICBhd2FpdCBjb25uIS5xdWVyeShgU0VMRUNUICogRlJPTSBwYXJxdWV0X3NjYW4oJ3Rlc3RfZmlsZV9iYXNlbGluZS5wYXJxdWV0Jyk7YCk7XG4gICAgICAgIC8vIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKS50b0FycmF5KCkpLnRvRXF1YWwocmVzdWx0X2Jhc2VsaW5lLmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSk7XG4gICAgfTtcblxuICAgIC8vIFJlc2V0IGRhdGFiYXNlcyBiZXR3ZWVuIHRlc3RzXG4gICAgY29uc3QgcmVzZXQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGFkYigpLnJlc2V0KCk7XG4gICAgICAgIGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XG4gICAgfTtcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IGF3YWl0IHJlc2V0KCkpO1xuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiBhd2FpdCByZXNldCgpKTtcblxuICAgIGRlc2NyaWJlKCdIVFRQRlMgQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdjYW4gZmV0Y2ggaHR0cHMgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uIS5xdWVyeShcbiAgICAgICAgICAgICAgICBgc2VsZWN0ICogZnJvbSBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9kdWNrZGIvZHVja2RiLXdhc20vbWFzdGVyL2RhdGEvdGVzdC5jc3ZcIjtgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChCaWdJbnQocmVzdWx0cy5nZXRDaGlsZEF0KDIpPy5nZXQoMikpKS50b0VxdWFsKEJpZ0ludCg5bikpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnY2FuIHJlYWQgYW5kIHdyaXRlIGNzdiBmaWxlIGZyb20gUzMgd2l0aCBjb3JyZWN0IGF1dGggY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEpO1xuICAgICAgICAgICAgYXdhaXQgcHV0VGVzdEZpbGVUb1MzKCdjb3JyZWN0X2F1dGhfdGVzdCcsICdjc3YnLCBkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNfd2l0aF9hdXRoID0gYXdhaXQgY29ubiEucXVlcnkoYHNlbGVjdCAqIGZyb20gXCJzMzovLyR7QlVDS0VUX05BTUV9L2NvcnJlY3RfYXV0aF90ZXN0LmNzdlwiO2ApO1xuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBhc3NlcnRUZXN0RmlsZVJlc3VsdENvcnJlY3QocmVzdWx0c193aXRoX2F1dGgsIGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnY2FuIHJlYWQgYW5kIHdyaXRlIHBhcnF1ZXQgZmlsZSBmcm9tIFMzIHdpdGggY29ycmVjdCBhdXRoIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xuICAgICAgICAgICAgYXdhaXQgcHV0VGVzdEZpbGVUb1MzKCdjb3JyZWN0X2F1dGhfdGVzdCcsICdwYXJxdWV0JywgZGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0c193aXRoX2F1dGggPSBhd2FpdCBjb25uIS5xdWVyeShcbiAgICAgICAgICAgICAgICBgc2VsZWN0ICogZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vY29ycmVjdF9hdXRoX3Rlc3QucGFycXVldFwiO2AsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBhc3NlcnRUZXN0RmlsZVJlc3VsdENvcnJlY3QocmVzdWx0c193aXRoX2F1dGgsIGRhdGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnY2FuIG5vdCByZWFkIGEgZmlsZSB3aXRoIGluY29ycmVjdCBjcmVkZW50aWFscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xuICAgICAgICAgICAgYXdhaXQgcHV0VGVzdEZpbGVUb1MzKCdpbmNvcnJlY3RfYXV0aF90ZXN0JywgJ3BhcnF1ZXQnLCBkYXRhKTtcbiAgICAgICAgICAgIGF3YWl0IHNldEF3c0NvbmZpZyhjb25uISwgQVdTQ29uZmlnVHlwZS5JTlZBTElEKTtcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKFxuICAgICAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KGBzZWxlY3QgKiBmcm9tIFwiczM6Ly8ke0JVQ0tFVF9OQU1FfS9pbmNvcnJlY3RfYXV0aF90ZXN0LmNzdlwiO2ApLFxuICAgICAgICAgICAgKS50b0JlUmVqZWN0ZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Byb3Blcmx5IGludmFsaWRhdGVzIGZpbGUgY2FjaGVzIG9uIHNldHRpbmdzIHVwZGF0ZS4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBhd2FpdCBwdXRUZXN0RmlsZVRvUzMoJ2ZpbGVfY2FjaGVfaW52YWxpZGF0aW9uX3Rlc3QnLCAncGFycXVldCcsIGRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNfY29ycmVjdCA9IGF3YWl0IGNvbm4hLnF1ZXJ5KFxuICAgICAgICAgICAgICAgIGBzZWxlY3QgbF9wYXJ0a2V5IGZyb20gXCJzMzovLyR7QlVDS0VUX05BTUV9L2ZpbGVfY2FjaGVfaW52YWxpZGF0aW9uX3Rlc3QucGFycXVldFwiIGxpbWl0IDE7YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0c19jb3JyZWN0LmdldENoaWxkQXQoMCk/LmdldCgwKSkudG9FcXVhbCgxNTUyKTtcbiAgICAgICAgICAgIGF3YWl0IHNldEF3c0NvbmZpZyhjb25uISwgQVdTQ29uZmlnVHlwZS5JTlZBTElEKTtcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKFxuICAgICAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KGBzZWxlY3QgYXZnKGxfcGFydGtleSkgZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vbGluZWl0ZW0ucGFycXVldFwiO2ApLFxuICAgICAgICAgICAgKS50b0JlUmVqZWN0ZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3dyaXRlIGFmdGVyIHJlYWQgdGhyb3dzIGluY29ycmVjdCBmbGFnIGVycm9yIHdpdGhvdXQgZHJvcHBpbmcgZmlsZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEpO1xuICAgICAgICAgICAgYXdhaXQgY29ubiEucXVlcnkoXG4gICAgICAgICAgICAgICAgYENPUFkgKFNFTEVDVCAqIEZST00gcmFuZ2UoMTAwMCwxMDEwKSB0YmwoaSkpIFRPICdzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3Rfd3JpdHRlbi5jc3YnIChGT1JNQVQgJ2NzdicpO2AsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubiEucXVlcnkoYFNFTEVDVCAqIEZST00gXCJzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3Rfd3JpdHRlbi5jc3ZcIjtgKTtcbiAgICAgICAgICAgIGV4cGVjdChOdW1iZXIoKHJlc3VsdC5nZXRDaGlsZEF0KDApPy5nZXQoNikpKSkudG9FcXVhbChOdW1iZXIoMTAwNikpO1xuICAgICAgICAgICAgYXdhaXQgZXhwZWN0QXN5bmMoXG4gICAgICAgICAgICAgICAgY29ubiEucXVlcnkoXG4gICAgICAgICAgICAgICAgICAgIGBDT1BZIChTRUxFQ1QgKiBGUk9NIHJhbmdlKDIwMDAsMjAxMCkgdGJsKGkpKSBUTyAnczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0X3dyaXR0ZW4uY3N2JyAoRk9STUFUICdjc3YnKTtgLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApLnRvQmVSZWplY3RlZFdpdGhFcnJvcignSW52YWxpZCBFcnJvcjogRmlsZSBpcyBub3Qgb3BlbmVkIGluIHdyaXRlIG1vZGUnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcbmltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcbmltcG9ydCB7IER1Y2tEQkFjY2Vzc01vZGUsIER1Y2tEQkRhdGFQcm90b2NvbCB9IGZyb20gJy4uL3NyYy8nO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVzdEJpbmRpbmdzKGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MsIGJhc2VVUkw6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICBjb25uLmNsb3NlKCk7XG4gICAgICAgIGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0R1Y2tEQkJpbmRpbmdzJywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgnZXJyb3IgaGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnSU5WQUxJRCBTUUwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uc2VuZCgnSU5WQUxJRCcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChlcnJvcikubm90LnRvQmUobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ0NoZWNrIHZlcnNpb24nLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnVmVyc2lvbiBjaGVjaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBjb25uLnF1ZXJ5PHsgbmFtZTogYXJyb3cuVXRmOCB9PihcbiAgICAgICAgICAgICAgICAgICAgXCJzZWxlY3QgKiBmcm9tIChzZWxlY3QgdmVyc2lvbigpKSB3aGVyZSB2ZXJzaW9uKCkgIT0gJ3YwLjAuMS1kZXYwJztcIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSB2ZXJzaW9uLnRvQXJyYXkoKTtcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZXNldCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vZGVzY3JpYmUoJ09wZW4nLCAoKSA9PiB7XG4gICAgICAgIC8vIFhYWCBhcHBhcmVudGx5IHN5bmNocm9ub3VzIFhIUiBvbiB0aGUgbWFpbiB0aHJlYWQgZG9lcyBub3QgYWxsb3cgZm9yIGFycmF5YnVmZmVyIHJlc3BvbnNlIHR5cGU/XG4gICAgICAgIC8vIGl0KCdSZW1vdGUgVFBDSCAwXzAxJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVVUkwoJ3RwY2hfMF8wMS5kYicsIGAke2Jhc2VVUkx9L3RwY2gvMF8wMS9kdWNrZGIvZGJgKTtcbiAgICAgICAgLy8gICAgIGRiKCkub3BlbigndHBjaF8wXzAxLmRiJyk7XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvL30pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdSZXNldCcsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCd0YWJsZSBtdXN0IGRpc2FwcGVhcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbm4ucXVlcnkoJ0NSRUFURSBUQUJMRSBmb28gKGEgaW50KScpO1xuICAgICAgICAgICAgICAgIGxldCB0YWJsZSA9IGNvbm4ucXVlcnk8eyBuYW1lOiBhcnJvdy5VdGY4IH0+KCdQUkFHTUEgc2hvd190YWJsZXM7Jyk7XG4gICAgICAgICAgICAgICAgbGV0IHJvd3MgPSB0YWJsZS50b0FycmF5KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJvd3MubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzWzBdPy5uYW1lKS50b0VxdWFsKCdmb28nKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRhYmxlID0gY29ubi5xdWVyeTx7IG5hbWU6IGFycm93LlV0ZjggfT4oJ1BSQUdNQSBzaG93X3RhYmxlczsnKTtcbiAgICAgICAgICAgICAgICByb3dzID0gdGFibGUudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzLmxlbmd0aCkudG9FcXVhbCgwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnUHJlcGFyZWQgU3RhdGVtZW50JywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ01hdGVyaWFsaXplZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gY29ubi5wcmVwYXJlKCdTRUxFQ1Qgdjo6SU5URUdFUiArID8gQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTsnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdG10LnF1ZXJ5KDIzNCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0JlKDEwMDAxKTtcbiAgICAgICAgICAgICAgICBzdG10LmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ1N0cmVhbWluZycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gY29ubi5wcmVwYXJlKCdTRUxFQ1Qgdjo6SU5URUdFUiArID8gQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTsnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBzdG10LnNlbmQoMjM0KTtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBiYXRjaC5udW1Sb3dzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3Qoc2l6ZSkudG9CZSgxMDAwMSk7XG4gICAgICAgICAgICAgICAgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnVHlwZWNoZWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm4ucXVlcnkoYENSRUFURSBUQUJMRSB0eXBlY2hlY2sgKFxuICAgICAgICAgICAgICAgICAgICBhIEJPT0xFQU4gREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBiIFRJTllJTlQgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBjIFNNQUxMSU5UIERFRkFVTFQgTlVMTCxcbiAgICAgICAgICAgICAgICAgICAgZCBJTlRFR0VSIERFRkFVTFQgTlVMTCxcbiAgICAgICAgICAgICAgICAgICAgZSBCSUdJTlQgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBmIEZMT0FUIERFRkFVTFQgTlVMTCxcbiAgICAgICAgICAgICAgICAgICAgZyBET1VCTEUgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBoIENIQVIoMTEpIERFRkFVTFQgTlVMTCxcbiAgICAgICAgICAgICAgICAgICAgaSBWQVJDSEFSKDExKSBERUZBVUxUIE5VTExcbiAgICAgICAgICAgICAgICApYCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gY29ubi5wcmVwYXJlKCdJTlNFUlQgSU5UTyB0eXBlY2hlY2sgVkFMVUVTKD8sPyw/LD8sPyw/LD8sPyw/KScpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KHRydWUsIDEwMCwgMTBfMDAwLCAxXzAwMF8wMDAsIDVfMDAwXzAwMF8wMDAsIDAuNSwgTWF0aC5QSSwgJ2hlbGxvIHdvcmxkJywgJ2hpJyksXG4gICAgICAgICAgICAgICAgKS5ub3QudG9UaHJvdygpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rlc3QnLCAvLyB2YXJjaGFyIGZvciBib29sXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICkudG9UaHJvdygpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCwgLy8gc21hbGxpbnQgZm9yIHRpbnlpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlbGxvIHdvcmxkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaScsXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKS50b1Rocm93KCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KCgpID0+XG4gICAgICAgICAgICAgICAgICAgIHN0bXQucXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMV8wMDBfMDAwLCAvLyBpbnQgZm9yIHNtYWxsaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICkudG9UaHJvdygpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCgoKSA9PlxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsIC8vIGJpZ2ludCBmb3IgaW50XG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICkudG9UaHJvdygpO1xuICAgICAgICAgICAgICAgIGNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBc3luY0JpbmRpbmdzKFxuICAgIGFkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCLFxuICAgIGJhc2VVUkw6IHN0cmluZyxcbiAgICBiYXNlRGlyUHJvdG86IER1Y2tEQkRhdGFQcm90b2NvbCxcbik6IHZvaWQge1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge30pO1xuXG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgYWRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBhd2FpdCBhZGIoKS5kcm9wRmlsZXMoKTtcbiAgICAgICAgYXdhaXQgYWRiKCkub3Blbih7XG4gICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdCaW5kaW5ncycsICgpID0+IHtcbiAgICAgICAgZGVzY3JpYmUoJ09wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnUmVtb3RlIFRQQ0ggMF8wMScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5yZWdpc3RlckZpbGVVUkwoJ3RwY2hfMF8wMS5kYicsIGAke2Jhc2VVUkx9L3RwY2gvMF8wMS9kdWNrZGIvZGJgLCBiYXNlRGlyUHJvdG8sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJ3RwY2hfMF8wMS5kYicsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnk8e1xuICAgICAgICAgICAgICAgICAgICBhOiBhcnJvdy5JbnQ7XG4gICAgICAgICAgICAgICAgfT4oJ3NlbGVjdCBjb3VudCgqKTo6SU5URUdFUiBhcyBhIGZyb20gbGluZWl0ZW0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gdGFibGUudG9BcnJheSgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93c1swXT8uYSkudG9FcXVhbCg2MDE3NSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ1BhdGNoaW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ0NvdW50KCopIERlZmF1bHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkub3Blbih7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXN0QmlnSW50VG9Eb3VibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KCdzZWxlY3QgMTo6QklHSU5UJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHMubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzWzBdLnR5cGVJZCkudG9FcXVhbChhcnJvdy5UeXBlLkludCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0NvdW50KCopIE5vIEJpZ0ludCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RCaWdJbnRUb0RvdWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0IDE6OkJJR0lOVCcpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzLmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgICAgICBleHBlY3QodGFibGUuc2NoZW1hLmZpZWxkc1swXS50eXBlSWQpLnRvRXF1YWwoYXJyb3cuVHlwZS5GbG9hdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ1ByZXBhcmVkIFN0YXRlbWVudCcsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdNYXRlcmlhbGl6ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgY29ubi5wcmVwYXJlKCdTRUxFQ1QgdiArID8gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RtdC5xdWVyeSgyMzQpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9CZSgxMDAwMSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdTdHJlYW1pbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgY29ubi5wcmVwYXJlKCdTRUxFQ1Qgdjo6SU5URUdFUiArID8gQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTsnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzdG10LnNlbmQoMjM0KTtcbiAgICAgICAgICAgICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBiYXRjaC5udW1Sb3dzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3Qoc2l6ZSkudG9CZSgxMDAwMSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnVHlwZWNoZWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHR5cGVjaGVjayAoXG4gICAgICAgICAgICAgICAgICAgIGEgQk9PTEVBTiBERUZBVUxUIE5VTEwsXG4gICAgICAgICAgICAgICAgICAgIGIgVElOWUlOVCBERUZBVUxUIE5VTEwsXG4gICAgICAgICAgICAgICAgICAgIGMgU01BTExJTlQgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBkIElOVEVHRVIgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBlIEJJR0lOVCBERUZBVUxUIE5VTEwsXG4gICAgICAgICAgICAgICAgICAgIGYgRkxPQVQgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBnIERPVUJMRSBERUZBVUxUIE5VTEwsXG4gICAgICAgICAgICAgICAgICAgIGggQ0hBUigxMSkgREVGQVVMVCBOVUxMLFxuICAgICAgICAgICAgICAgICAgICBpIFZBUkNIQVIoMTEpIERFRkFVTFQgTlVMTFxuICAgICAgICAgICAgICAgIClgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBhd2FpdCBjb25uLnByZXBhcmUoJ0lOU0VSVCBJTlRPIHR5cGVjaGVjayBWQUxVRVMoPyw/LD8sPyw/LD8sPyw/LD8pJyk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RUb1Rocm93ID0gYXN5bmMgKGZuOiAoKSA9PiBQcm9taXNlPHZvaWQ+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0aHJvd2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodGhyb3dlZCkudG9CZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdG10LnF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3Rlc3QnLCAvLyB2YXJjaGFyIGZvciBib29sXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdG10LnF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCwgLy8gc21hbGxpbnQgZm9yIHRpbnlpbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlbGxvIHdvcmxkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaScsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0VG9UaHJvdyhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMV8wMDBfMDAwLCAvLyBpbnQgZm9yIHNtYWxsaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdG10LnF1ZXJ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsIC8vIGJpZ2ludCBmb3IgaW50XG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZXNjcmliZSgnQWNjZXNzTW9kZScsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdSRUFEX09OTFknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZXhwZWN0QXN5bmMoXG4gICAgICAgICAgICAgICAgICAgIGFkYigpLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzTW9kZTogRHVja0RCQWNjZXNzTW9kZS5SRUFEX09OTFksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICkudG9CZVJlamVjdGVkV2l0aEVycm9yKC9DYW5ub3QgbGF1bmNoIGluLW1lbW9yeSBkYXRhYmFzZSBpbiByZWFkLW9ubHkgbW9kZS8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnUkVBRF9XUklURScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBleHBlY3RBc3luYyhcbiAgICAgICAgICAgICAgICAgICAgYWRiKCkub3Blbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NNb2RlOiBEdWNrREJBY2Nlc3NNb2RlLlJFQURfV1JJVEUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICkudG9CZVJlc29sdmVkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVzY3JpYmUoJ0NhbmNlbGxhdGlvbicsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdoZWxsbyBjYW5jZWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHF1ZXJ5IHBvbGxpbmcgaW50ZXJ2YWwgdG8gMCB0byBwb2xsIDEgdGFzayBhdCBhIHRpbWVcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UG9sbGluZ0ludGVydmFsOiAwLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT5cbiAgICAgICAgICAgICAgICAgICAgZGIuc3RhcnRQZW5kaW5nUXVlcnkoaWQsICdTRUxFQ1QgU1VNKGkpIEZST00gcmFuZ2UoMTAwMDAwMCkgdGJsKGkpOycpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxPSyA9IGF3YWl0IGNvbm4udXNlVW5zYWZlKChkYiwgaWQpID0+IGRiLmNhbmNlbFBlbmRpbmdRdWVyeShpZCkpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChjYW5jZWxPSykudG9CZVRydWUoKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9sbGVkSGVhZGVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgcG9sbGVkRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbGxlZEhlYWRlciA9IGF3YWl0IGNvbm4udXNlVW5zYWZlKChkYiwgaWQpID0+IGRiLnBvbGxQZW5kaW5nUXVlcnkoaWQpKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9sbGVkRXJyb3IgPSBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QocG9sbGVkSGVhZGVyKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgICAgIGV4cGVjdChwb2xsZWRFcnJvcikubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEVycm9yLnRvU3RyaW5nKCkpLnRvRXF1YWwoJ0Vycm9yOiBxdWVyeSB3YXMgY2FuY2VsZWQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxlZEFnYWluID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGNhbmNlbGVkQWdhaW4pLnRvQmVGYWxzZSgpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBjb25uZWN0aW9uIGlzIGRlc3Ryb3llZCBvciBub3Qgd2hlbiB3ZSBjYW5jZWwgcXVlcnlcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoJ3NlbGVjdCA0Mjo6aW50ZWdlcjsnKTtcbiAgICAgICAgICAgICAgICBleHBlY3QodGFibGUuc2NoZW1hLmZpZWxkcy5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ25vb3AgY2FuY2VsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLm9wZW4oe1xuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQb2xsaW5nSW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PlxuICAgICAgICAgICAgICAgICAgICBkYi5zdGFydFBlbmRpbmdRdWVyeShpZCwgJ1NFTEVDVCBTVU0oaSkgRlJPTSByYW5nZSgxMDAwMDAwKSB0YmwoaSk7JyksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgICAgIGxldCBwb2xsZWRIZWFkZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBwb2xsZWRFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZXhlY3V0ZSAxIHRhc2sgYXQgYSB0aW1lLCBzbyB0aGlzIG1heSB0YWtlIG11bHRpcGxlIHBvbGxzXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwb2xsZWRIZWFkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbGVkSGVhZGVyID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIucG9sbFBlbmRpbmdRdWVyeShpZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvbGxlZEVycm9yID0gZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEhlYWRlcikubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbE9LID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGNhbmNlbE9LKS50b0JlRmFsc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbm90aGVyT25lID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KGFub3RoZXJPbmUpLnRvQmVGYWxzZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcblxuY29uc3QgdGVzdFJvd3MgPSAxMDAwMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RCYXRjaFN0cmVhbShkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGNvbm4uY2xvc2UoKTtcbiAgICAgICAgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQXJyb3cgUmVjb3JkLUJhdGNoZXMgUm93LU1ham9yJywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDEyNyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMzI3NjcpOjpTTUFMTElOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3chLnYpLnRvQmUoaSsrICYgMzI3NjcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKEJpZ0ludChpKyspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OlZBUkNIQVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKFN0cmluZyhpKyspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Fycm93IFJlY29yZC1CYXRjaGVzIENvbHVtbi1NYWpvcicsICgpID0+IHtcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDEyNyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMzI3NjcpOjpTTUFMTElOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAzMjc2Nyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnSU5URUdFUicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKyspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKEJpZ0ludChpKyspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OlZBUkNIQVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoU3RyaW5nKGkrKykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQXJyb3cgVGFibGUgUm93LU1ham9yJywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKysgJiAxMjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdTTUFMTElOVCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrICYgMzI3NjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShCaWdJbnQoaSsrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ1NUUklORycsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93Py52LnZhbHVlT2YoKSkudG9CZShTdHJpbmcoaSsrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQXJyb3cgVGFibGUgQ29sdW1uLU1ham9yJywgKCkgPT4ge1xuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDEyNyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDMyNzY3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnSU5URUdFUicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKEJpZ0ludChpKyspKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShTdHJpbmcoaSsrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xuXG5jb25zdCB0ZXN0Um93cyA9IDEwMDAwO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVzdEFzeW5jQmF0Y2hTdHJlYW0oZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQXN5bmNEdWNrREInLCAoKSA9PiB7XG4gICAgICAgIGl0KCdwaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgZGIoKS5waW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Fycm93IFJlY29yZC1CYXRjaGVzIFJvdy1NYWpvcicsICgpID0+IHtcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdyEudikudG9CZShpKysgJiAxMjcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdCSUdJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlc2NyaWJlKCdzY3JpcHRzJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ3Rlc3QxJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHgsIChzaW4odikgKiAxMDAgKyAxMDApOjpJTlRFR0VSIEFTIHkgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodilcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS54KS50b0JlKGkrKyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdBcnJvdyBSZWNvcmQtQmF0Y2hlcyBDb2x1bW4tTWFqb3InLCAoKSA9PiB7XG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAxMjcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdCSUdJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Fycm93IFRhYmxlIFJvdy1NYWpvcicsICgpID0+IHtcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrICYgMTI3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMzI3NjcpOjpTTUFMTElOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93Py52KS50b0JlKGkrKyAmIDMyNzY3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpdCgnSU5URUdFUicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93Py52KS50b0JlKGkrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoQmlnSW50KGkrKykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OlZBUkNIQVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udi52YWx1ZU9mKCkpLnRvQmUoU3RyaW5nKGkrKykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ0Fycm93IFRhYmxlIENvbHVtbi1NYWpvcicsICgpID0+IHtcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAxMjcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGl0KCdTTUFMTElOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAzMjc2Nyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XG4gICAgICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaXQoJ1NUUklORycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xuICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoU3RyaW5nKGkrKykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5cbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RGaWxlc3lzdGVtKFxuICAgIGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXG4gICAgcmVzb2x2ZURhdGE6ICh1cmw6IHN0cmluZykgPT4gUHJvbWlzZTxVaW50OEFycmF5IHwgbnVsbD4sXG4gICAgYmFzZURpcjogc3RyaW5nLFxuICAgIGJhc2VEaXJQcm90bzogZHVja2RiLkR1Y2tEQkRhdGFQcm90b2NvbCxcbik6IHZvaWQge1xuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRmlsZSBidWZmZXIgcmVnaXN0cmF0aW9uJywgKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludCB9PihiYXRjaGVzKTtcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoWzI0MDAyLCAyNTQwMywgMjYxMjAsIDI2ODMwLCAyNzU1MCwgMjgxMDYsIDI5MTIwLCAyOTU1NV0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgICAgaXQoJ0ZpbGUgYnVmZmVyIHVzZWQgb25jZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50cyEpO1xuICAgICAgICAgICAgYXdhaXQgdGVzdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ0ZpbGUgYnVmZmVyIHJlZ2lzdGVyZWQgdHdpY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHVkZW50czAgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xuICAgICAgICAgICAgY29uc3Qgc3R1ZGVudHMxID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50czApLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzMSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50czAhKTtcbiAgICAgICAgICAgIGF3YWl0IHRlc3QoKTtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzMSEpO1xuICAgICAgICAgICAgYXdhaXQgdGVzdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXQoJ0ZpbGUgYnVmZmVyIHVzZWQgdHdpY2UnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcbiAgICAgICAgICAgIGF3YWl0IHRlc3QoKTtcbiAgICAgICAgICAgIGF3YWl0IHRlc3QoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnUGFycXVldCBTY2FucycsICgpID0+IHtcbiAgICAgICAgaXQoJ3NpbmdsZSB0YWJsZSBmcm9tIGJ1ZmZlcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50cyEpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludCB9PihiYXRjaGVzKTtcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoWzI0MDAyLCAyNTQwMywgMjYxMjAsIDI2ODMwLCAyNzU1MCwgMjgxMDYsIDI5MTIwLCAyOTU1NV0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3NpbXBsZSBqb2luJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3R1ZGVudHMgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xuICAgICAgICAgICAgY29uc3QgaG9lcmVuID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvaG9lcmVuLnBhcnF1ZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IHZvcmxlc3VuZ2VuID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvdm9ybGVzdW5nZW4ucGFycXVldCcpO1xuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGV4cGVjdChob2VyZW4pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgZXhwZWN0KHZvcmxlc3VuZ2VuKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzISk7XG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignaG9lcmVuLnBhcnF1ZXQnLCBob2VyZW4hKTtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCd2b3JsZXN1bmdlbi5wYXJxdWV0Jywgdm9ybGVzdW5nZW4hKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHN0dWRlbnRzLm1hdHJuciwgdm9ybGVzdW5nZW4udGl0ZWxcbiAgICAgICAgICAgICAgICAgICAgRlJPTSBwYXJxdWV0X3NjYW4oJ3N0dWRlbnRlbi5wYXJxdWV0Jykgc3R1ZGVudHNcbiAgICAgICAgICAgICAgICAgICAgSU5ORVIgSk9JTiBwYXJxdWV0X3NjYW4oJ2hvZXJlbi5wYXJxdWV0JykgaG9lcmVuIE9OIChzdHVkZW50cy5tYXRybnIgPSBob2VyZW4ubWF0cm5yKVxuICAgICAgICAgICAgICAgICAgICBJTk5FUiBKT0lOIHBhcnF1ZXRfc2Nhbigndm9ybGVzdW5nZW4ucGFycXVldCcpIHZvcmxlc3VuZ2VuIE9OICh2b3JsZXN1bmdlbi52b3JsbnIgPSBob2VyZW4udm9ybG5yKTtcbiAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlcy5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgbmV3IGFycm93LlRhYmxlPHsgbWF0cm5yOiBhcnJvdy5JbnQ7IHRpdGVsOiBhcnJvdy5VdGY4IH0+KGJhdGNoZXMpO1xuICAgICAgICAgICAgZXhwZWN0KHRhYmxlLm51bUNvbHMpLnRvQmUoMik7XG4gICAgICAgICAgICBjb25zdCBmbGF0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xuICAgICAgICAgICAgICAgIGZsYXQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1hdHJucjogcm93Py5tYXRybnIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGVsOiByb3c/LnRpdGVsPy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwZWN0KGZsYXQpLnRvRXF1YWwoW1xuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyNjEyMCwgdGl0ZWw6ICdHcnVuZHpcdTAwRkNnZScgfSxcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjc1NTAsIHRpdGVsOiAnR3J1bmR6XHUwMEZDZ2UnIH0sXG4gICAgICAgICAgICAgICAgeyBtYXRybnI6IDI3NTUwLCB0aXRlbDogJ0xvZ2lrJyB9LFxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyODEwNiwgdGl0ZWw6ICdFdGhpaycgfSxcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnV2lzc2Vuc2NoYWZ0c3RoZW9yaWUnIH0sXG4gICAgICAgICAgICAgICAgeyBtYXRybnI6IDI4MTA2LCB0aXRlbDogJ0Jpb2V0aGlrJyB9LFxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyODEwNiwgdGl0ZWw6ICdEZXIgV2llbmVyIEtyZWlzJyB9LFxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdHcnVuZHpcdTAwRkNnZScgfSxcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjkxMjAsIHRpdGVsOiAnRXRoaWsnIH0sXG4gICAgICAgICAgICAgICAgeyBtYXRybnI6IDI5MTIwLCB0aXRlbDogJ01cdTAwRTRldXRpaycgfSxcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjk1NTUsIHRpdGVsOiAnR2xhdWJlIHVuZCBXaXNzZW4nIH0sXG4gICAgICAgICAgICAgICAgeyBtYXRybnI6IDI1NDAzLCB0aXRlbDogJ0dsYXViZSB1bmQgV2lzc2VuJyB9LFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1dyaXRpbmcnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdDb3B5IFRvIENTViBCdWZmZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIoJ3N0dWRlbnRzLmNzdicpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzIEFTIFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ09QWSBzdHVkZW50cyBUTyAnc3R1ZGVudHMuY3N2JyBXSVRIIChIRUFERVIgMSwgREVMSU1JVEVSICc7JywgRk9STUFUIENTVik7YCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyBzdHVkZW50c2ApO1xuICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50cy5jc3YnKTtcbiAgICAgICAgICAgIGV4cGVjdChvdXRCdWZmZXIpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKG91dEJ1ZmZlciEpO1xuICAgICAgICAgICAgZXhwZWN0KHRleHQpLnRvQmUoYG1hdHJucjtuYW1lO3NlbWVzdGVyXG4yNDAwMjtYZW5va3JhdGVzOzE4XG4yNTQwMztKb25hczsxMlxuMjYxMjA7RmljaHRlOzEwXG4yNjgzMDtBcmlzdG94ZW5vczs4XG4yNzU1MDtTY2hvcGVuaGF1ZXI7NlxuMjgxMDY7Q2FybmFwOzNcbjI5MTIwO1RoZW9waHJhc3RvczsyXG4yOTU1NTtGZXVlcmJhY2g7MlxuYCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdDb3B5IFRvIFBhcnF1ZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIoJ3N0dWRlbnRzMi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDUkVBVEUgVEFCTEUgc3R1ZGVudHMyIEFTIFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ09QWSBzdHVkZW50czIgVE8gJ3N0dWRlbnRzMi5wYXJxdWV0JyAoRk9STUFUIFBBUlFVRVQpO2ApO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50czIucGFycXVldCcpO1xuICAgICAgICAgICAgZXhwZWN0KHVybCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdDb3B5IFRvIFBhcnF1ZXQgQW5kIExvYWQgQWdhaW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIoJ3N0dWRlbnRzMy5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDUkVBVEUgVEFCTEUgc3R1ZGVudHMzIEFTIFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ09QWSBzdHVkZW50czMgVE8gJ3N0dWRlbnRzMy5wYXJxdWV0JyAoRk9STUFUIFBBUlFVRVQpO2ApO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50czMucGFycXVldCcpO1xuICAgICAgICAgICAgZXhwZWN0KHVybCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDUkVBVEUgVEFCTEUgc3R1ZGVudHM0IEFTIFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50czMucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gc3R1ZGVudHM0O2ApO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludCB9PihiYXRjaGVzKTtcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoWzI0MDAyLCAyNTQwMywgMjYxMjAsIDI2ODMwLCAyNzU1MCwgMjgxMDYsIDI5MTIwLCAyOTU1NV0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRmlsZSBhY2Nlc3MnLCAoKSA9PiB7XG4gICAgICAgIGl0KCdTbWFsbCBQYXJxdWV0IGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZVVSTCgnc3R1ZGVudGVuLnBhcnF1ZXQnLCBgJHtiYXNlRGlyfS91bmkvc3R1ZGVudGVuLnBhcnF1ZXRgLCBiYXNlRGlyUHJvdG8sIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludCB9PihiYXRjaGVzKTtcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoWzI0MDAyLCAyNTQwMywgMjYxMjAsIDI2ODMwLCAyNzU1MCwgMjgxMDYsIDI5MTIwLCAyOTU1NV0pLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ0xhcmdlIFBhcnF1ZXQgZmlsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlVVJMKFxuICAgICAgICAgICAgICAgICdsaW5laXRlbS5wYXJxdWV0JyxcbiAgICAgICAgICAgICAgICBgJHtiYXNlRGlyfS90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0YCxcbiAgICAgICAgICAgICAgICBiYXNlRGlyUHJvdG8sXG4gICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFNFTEVDVCBjb3VudCgqKTo6SU5URUdFUiBhcyBjbnQgRlJPTSBwYXJxdWV0X3NjYW4oJ2xpbmVpdGVtLnBhcnF1ZXQnKTtgKTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlcy5wdXNoKGJhdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgbmV3IGFycm93LlRhYmxlPHsgY250OiBhcnJvdy5JbnQgfT4oYmF0Y2hlcyk7XG4gICAgICAgICAgICBleHBlY3QodGFibGUuZ2V0Q2hpbGRBdCgwKT8uZ2V0KDApKS50b0JlR3JlYXRlclRoYW4oNjBfMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnRXhwb3J0JywgKCkgPT4ge1xuICAgICAgICBpdCgnR2VuZXJhdGUgU2VyaWVzIGFzIENTVicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0NSRUFURSBUQUJMRSBmb28gQVMgU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KScpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRVhQT1JUIERBVEFCQVNFICcvdG1wL2R1Y2tkYmV4cG9ydGNzdidgKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRiKCkuZ2xvYkZpbGVzKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi8qJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cykubm90LnRvRXF1YWwoW10pO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0VxdWFsKDMpO1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVzID0gcmVzdWx0cy5tYXAoZmlsZSA9PiBmaWxlLmZpbGVOYW1lKS5zb3J0KCk7XG4gICAgICAgICAgICBleHBlY3QoZmlsZW5hbWVzKS50b0VxdWFsKFtcbiAgICAgICAgICAgICAgICAnL3RtcC9kdWNrZGJleHBvcnRjc3YvZm9vLmNzdicsXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0Y3N2L2xvYWQuc3FsJyxcbiAgICAgICAgICAgICAgICAnL3RtcC9kdWNrZGJleHBvcnRjc3Yvc2NoZW1hLnNxbCcsXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgY29uc3QgY3N2X2J1ZmZlcl91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9mb28uY3N2Jyk7XG4gICAgICAgICAgICBjb25zdCBsb2FkX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9sb2FkLnNxbCcpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9zY2hlbWEuc3FsJyk7XG4gICAgICAgICAgICBleHBlY3QobG9hZF9zY3JpcHRfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xuICAgICAgICAgICAgZXhwZWN0KHNjaGVtYV9zY3JpcHRfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xuICAgICAgICAgICAgZXhwZWN0KGNzdl9idWZmZXJfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xuXG4gICAgICAgICAgICBjb25zdCBsb2FkX3NjcmlwdCA9IGRlY29kZXIuZGVjb2RlKGxvYWRfc2NyaXB0X3V0ZjgpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdCA9IGRlY29kZXIuZGVjb2RlKHNjaGVtYV9zY3JpcHRfdXRmOCk7XG4gICAgICAgICAgICBjb25zdCBjc3ZfYnVmZmVyID0gZGVjb2Rlci5kZWNvZGUoY3N2X2J1ZmZlcl91dGY4KTtcbiAgICAgICAgICAgIGV4cGVjdChsb2FkX3NjcmlwdC50cmltKCkpLnRvRXF1YWwoXG4gICAgICAgICAgICAgICAgYENPUFkgZm9vIEZST00gJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnIChGT1JNQVQgJ2NzdicsIHF1b3RlICdcIicsIGRlbGltaXRlciAnLCcsIGhlYWRlciAwKTtgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChzY2hlbWFfc2NyaXB0LnRyaW0oKSkudG9FcXVhbChgQ1JFQVRFIFRBQkxFIGZvbyh2IEJJR0lOVCk7YCk7XG4gICAgICAgICAgICBleHBlY3QoY3N2X2J1ZmZlci50cmltKCkpLnRvRXF1YWwoYDFcXG4yXFxuM1xcbjRcXG41YCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdHZW5lcmF0ZSBTZXJpZXMgYXMgUGFycXVldCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0NSRUFURSBUQUJMRSBmb28gQVMgU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KScpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRVhQT1JUIERBVEFCQVNFICcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQnIChGT1JNQVQgUEFSUVVFVClgKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRiKCkuZ2xvYkZpbGVzKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvKicpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMpLm5vdC50b0VxdWFsKFtdKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9FcXVhbCgzKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lcyA9IHJlc3VsdHMubWFwKGZpbGUgPT4gZmlsZS5maWxlTmFtZSkuc29ydCgpO1xuICAgICAgICAgICAgZXhwZWN0KGZpbGVuYW1lcykudG9FcXVhbChbXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcsXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9sb2FkLnNxbCcsXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9zY2hlbWEuc3FsJyxcbiAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJxdWV0X2J1ZmZlciA9IGF3YWl0IGRiKCkuY29weUZpbGVUb0J1ZmZlcignL3RtcC9kdWNrZGJleHBvcnRwYXJxdWV0L2Zvby5wYXJxdWV0Jyk7XG4gICAgICAgICAgICBjb25zdCBsb2FkX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvbG9hZC5zcWwnKTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYV9zY3JpcHRfdXRmOCA9IGF3YWl0IGRiKCkuY29weUZpbGVUb0J1ZmZlcignL3RtcC9kdWNrZGJleHBvcnRwYXJxdWV0L3NjaGVtYS5zcWwnKTtcbiAgICAgICAgICAgIGV4cGVjdChsb2FkX3NjcmlwdF91dGY4Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XG4gICAgICAgICAgICBleHBlY3Qoc2NoZW1hX3NjcmlwdF91dGY4Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XG4gICAgICAgICAgICBleHBlY3QocGFycXVldF9idWZmZXIubGVuZ3RoKS5ub3QudG9FcXVhbCgwKTtcblxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCB2OjppbnRlZ2VyIEZST00gcGFycXVldF9zY2FuKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvZm9vLnBhcnF1ZXQnKWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQubnVsbENvdW50KS50b0VxdWFsKDApO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQubnVtUm93cykudG9FcXVhbCg1KTtcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbMSwgMiwgMywgNCwgNV0pKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnQ29weScsICgpID0+IHtcbiAgICAgICAgaXQoJ0dlbmVyYXRlIFNlcmllcyBhcyBQYXJxdWV0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShcbiAgICAgICAgICAgICAgICBgQ09QWSAoU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KSkgVE8gJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcgKEZPUk1BVCAncGFycXVldCcpYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZGIoKS5nbG9iRmlsZXMoJy90bXAvZHVja2RiY29weXRlc3QqJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cykubm90LnRvRXF1YWwoW10pO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdHMubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVzID0gcmVzdWx0cy5tYXAoZmlsZSA9PiBmaWxlLmZpbGVOYW1lKS5zb3J0KCk7XG4gICAgICAgICAgICBleHBlY3QoZmlsZW5hbWVzKS50b0VxdWFsKFsnL3RtcC9kdWNrZGJjb3B5dGVzdC5wYXJxdWV0J10pO1xuICAgICAgICAgICAgY29uc3QgcGFycXVldF9idWZmZXIgPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcpO1xuICAgICAgICAgICAgZXhwZWN0KHBhcnF1ZXRfYnVmZmVyLmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgY29ubi5xdWVyeShgU0VMRUNUIHY6OmludGVnZXIgRlJPTSBwYXJxdWV0X3NjYW4oJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcpYCk7XG4gICAgICAgICAgICBleHBlY3QoY29udGVudC5udW1Sb3dzKS50b0VxdWFsKDUpO1xuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxLCAyLCAzLCA0LCA1XSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENvbHVtbiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIHZhbHVlczogYW55W107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlVGFibGUodGFibGU6IGFycm93LlRhYmxlLCBleHBlY3RlZDogQ29sdW1uW10pOiB2b2lkIHtcbiAgICAvLyBDaGVjayBjb2x1bW4gY291bnRcbiAgICBjb25zdCBjb2xDb3VudCA9IGV4cGVjdGVkLmxlbmd0aDtcbiAgICBleHBlY3QodGFibGUubnVtQ29scykudG9FcXVhbChjb2xDb3VudCk7XG4gICAgaWYgKGNvbENvdW50ID09IDApIHJldHVybjtcblxuICAgIC8vIENoZWNrIGNvbHVtbnNcbiAgICBjb25zdCByb3dDb3VudCA9IGV4cGVjdGVkWzBdLnZhbHVlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgKytpKSB7XG4gICAgICAgIGV4cGVjdChleHBlY3RlZFtpXS52YWx1ZXMubGVuZ3RoKS50b0VxdWFsKHJvd0NvdW50KTtcbiAgICAgICAgZXhwZWN0KHRhYmxlLmdldENoaWxkQXQoaSk/Lmxlbmd0aCkudG9FcXVhbChyb3dDb3VudCk7XG4gICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzW2ldPy5uYW1lKS50b0VxdWFsKGV4cGVjdGVkW2ldLm5hbWUpO1xuICAgIH1cblxuICAgIC8vIENvbXBhcmUgdGhlIGFjdHVhbCB2YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENvdW50OyArK2kpIHtcbiAgICAgICAgY29uc3QgY29sID0gdGFibGUuZ2V0Q2hpbGRBdChpKSE7XG4gICAgICAgIGNvbnN0IGhhdmUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dDb3VudDsgKytqKSB7XG4gICAgICAgICAgICBoYXZlLnB1c2goY29sLmdldChqKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwZWN0KE51bWJlcihoYXZlKSkudG9FcXVhbChOdW1iZXIoZXhwZWN0ZWRbaV0udmFsdWVzKSk7XG4gICAgfVxufVxuIiwgImltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5pbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XG5pbXBvcnQgeyBDb2x1bW4sIGNvbXBhcmVUYWJsZSB9IGZyb20gJy4vdGFibGVfdGVzdCc7XG5cbi8vLyBVbmZvcnR1bmF0ZWx5LCBhcnJvdy5UYWJsZS5mcm9tIGRvZXMgbm90IGJ1aWxkIGEgcHJvcGVyIFNjaGVtYS5cbi8vLyBXaGVuIGl0IGRvZXMsIHdlIG1pZ2h0IHdhbnQgdG8gc3dpdGNoIGJhY2sgdG8gYXJyb3cuVGFibGUgaGVyZSBpbnN0ZWFkXG4vLy8gb2YgYXJyb3cgU2NoZW1hICsgQXJyb3dCYXRjaC5cbmludGVyZmFjZSBBcnJvd0luc2VydFRlc3Qge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzY2hlbWE6IGFycm93LlNjaGVtYTtcbiAgICBiYXRjaGVzOiBBcnJvd0JhdGNoW107XG4gICAgb3B0aW9uczogZHVja2RiLkFycm93SW5zZXJ0T3B0aW9ucztcbiAgICBxdWVyeTogc3RyaW5nO1xuICAgIGV4cGVjdGVkQ29sdW1uczogQ29sdW1uW107XG59XG5cbmludGVyZmFjZSBBcnJvd0JhdGNoIHtcbiAgICBudW1Sb3dzOiBudW1iZXI7XG4gICAgY29sdW1uczogYXJyb3cuRGF0YVtdO1xufVxuXG5jb25zdCBidWlsZFV0ZjhBcnJheSA9ICh2YWx1ZXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBhcnJvdy5VdGY4QnVpbGRlcih7XG4gICAgICAgIHR5cGU6IG5ldyBhcnJvdy5VdGY4KCksXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcykge1xuICAgICAgICBidWlsZGVyLmFwcGVuZCh2KTtcbiAgICB9XG4gICAgYnVpbGRlci5maW5pc2goKTtcbiAgICByZXR1cm4gYnVpbGRlci5mbHVzaCgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWEludDMyKG46IG51bWJlciwgY29sczogbnVtYmVyKTogbnVtYmVyW11bXSB7XG4gICAgY29uc3QgY29sdW1ucyA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgKytqKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgICAgY29sdW1uLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1ucy5wdXNoKGNvbHVtbik7XG4gICAgfVxuICAgIHJldHVybiBjb2x1bW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVBcnJvd1hJbnQzMihuOiBudW1iZXIsIGNvbHM6IG51bWJlcik6IFthcnJvdy5TY2hlbWEsIGFycm93LlJlY29yZEJhdGNoW11dIHtcbiAgICBjb25zdCBjb2x1bW5zID0gZ2VuZXJhdGVYSW50MzIobiwgY29scyk7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcbiAgICAgICAgZmllbGRzLnB1c2gobmV3IGFycm93LkZpZWxkKGB2JHtqfWAsIG5ldyBhcnJvdy5JbnQzMigpKSk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBhcnJvdy5TY2hlbWEoZmllbGRzKTtcbiAgICBjb25zdCBiYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyApIHtcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWluKDEwMDAsIG4gLSBpKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFycm93Lm1ha2VEYXRhKHtcbiAgICAgICAgICAgIHR5cGU6IG5ldyBhcnJvdy5TdHJ1Y3QoZmllbGRzKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjb2x1bW5zLm1hcChjID0+XG4gICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmV3IEludDMyQXJyYXkoYy5zbGljZShpLCBpICsgcm93cykpLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJhdGNoZXMucHVzaChuZXcgYXJyb3cuUmVjb3JkQmF0Y2goc2NoZW1hLCBkYXRhKSk7XG4gICAgICAgIGkgKz0gcm93cztcbiAgICB9XG4gICAgcmV0dXJuIFtzY2hlbWEsIGJhdGNoZXNdO1xufVxuXG5jb25zdCBBUlJPV19JTlNFUlRfVEVTVFM6IEFycm93SW5zZXJ0VGVzdFtdID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTogJ2ludGVnZXJzXzEnLFxuICAgICAgICBzY2hlbWE6IG5ldyBhcnJvdy5TY2hlbWEoW1xuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdhJywgbmV3IGFycm93LkludDMyKCkpLFxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdiJywgbmV3IGFycm93LkludDMyKCkpLFxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdjJywgbmV3IGFycm93LkludDMyKCkpLFxuICAgICAgICBdKSxcbiAgICAgICAgYmF0Y2hlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG51bVJvd3M6IDMsXG4gICAgICAgICAgICAgICAgY29sdW1uczogW1xuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMSwgNCwgN10pIH0pLFxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMiwgNSwgOF0pIH0pLFxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMywgNiwgOV0pIH0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICB9LFxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2NvbWJpbmVkXzEnLFxuICAgICAgICBzY2hlbWE6IG5ldyBhcnJvdy5TY2hlbWEoW1xuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdhJywgbmV3IGFycm93LkludDMyKCkpLFxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdiJywgbmV3IGFycm93LkludDE2KCkpLFxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdjJywgbmV3IGFycm93LlV0ZjgoKSksXG4gICAgICAgIF0pLFxuICAgICAgICBiYXRjaGVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbnVtUm93czogMyxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDMyKCksIGRhdGE6IG5ldyBJbnQzMkFycmF5KFsxLCA0LCA3XSkgfSksXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDE2KCksIGRhdGE6IG5ldyBJbnQxNkFycmF5KFsyLCA1LCA4XSkgfSksXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkVXRmOEFycmF5KFsnMycsICc2JywgJzknXSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFsnMycsICc2JywgJzknXSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnY29tYmluZWRfMicsXG4gICAgICAgIHNjaGVtYTogbmV3IGFycm93LlNjaGVtYShbXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2EnLCBuZXcgYXJyb3cuSW50MzIoKSksXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2InLCBuZXcgYXJyb3cuSW50MTYoKSksXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2MnLCBuZXcgYXJyb3cuVXRmOCgpKSxcbiAgICAgICAgXSksXG4gICAgICAgIGJhdGNoZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1Sb3dzOiAzLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSwgZGF0YTogbmV3IEludDMyQXJyYXkoWzEsIDQsIDddKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MTYoKSwgZGF0YTogbmV3IEludDE2QXJyYXkoWzIsIDUsIDhdKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVdGY4QXJyYXkoWyczJywgJzYnLCAnOSddKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBudW1Sb3dzOiAyLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSwgZGF0YTogbmV3IEludDMyQXJyYXkoWzEwLCAxM10pIH0pLFxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQxNigpLCBkYXRhOiBuZXcgSW50MTZBcnJheShbMTEsIDE0XSkgfSksXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkVXRmOEFycmF5KFsnMTInLCAnMTUnXSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDcsIDEwLCAxM10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4LCAxMSwgMTRdIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbJzMnLCAnNicsICc5JywgJzEyJywgJzE1J10gfSxcbiAgICAgICAgXSxcbiAgICB9LFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBcnJvd0luc2VydChkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29ubi5jbG9zZSgpO1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnQXJyb3cgaW5zZXJ0IGZyb20gaXRlcmFibGUnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBBUlJPV19JTlNFUlRfVEVTVFMpIHtcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbm4ucXVlcnkoYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGVzdC5vcHRpb25zLnNjaGVtYSB8fCAnbWFpbid9LiR7dGVzdC5vcHRpb25zLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IHRlc3QuYmF0Y2hlcy5tYXAoYiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhcnJvdy5tYWtlRGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXcgYXJyb3cuU3RydWN0KHRlc3Quc2NoZW1hLmZpZWxkcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogYi5jb2x1bW5zLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhcnJvdy5SZWNvcmRCYXRjaCh0ZXN0LnNjaGVtYSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgYXJyb3cuVGFibGUodGVzdC5zY2hlbWEsIGJhdGNoZXMpO1xuICAgICAgICAgICAgICAgIGNvbm4uaW5zZXJ0QXJyb3dUYWJsZSh0YWJsZSwgdGVzdC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBcnJvd0luc2VydEFzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xuICAgIH0pO1xuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0Fycm93IGFzeW5jIGluc2VydCBmcm9tIGl0ZXJhYmxlJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgQVJST1dfSU5TRVJUX1RFU1RTKSB7XG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0ZXN0LmJhdGNoZXMubWFwKGIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXJyb3cubWFrZURhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbmV3IGFycm93LlN0cnVjdCh0ZXN0LnNjaGVtYS5maWVsZHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGIuY29sdW1ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXJyb3cuUmVjb3JkQmF0Y2godGVzdC5zY2hlbWEsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IGFycm93LlRhYmxlKHRlc3Quc2NoZW1hLCBiYXRjaGVzKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydEFycm93VGFibGUodGFibGUsIHRlc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0Fycm93IGFzeW5jIGluc2VydCBmcm9tIHRhYmxlJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2ltcGxlIGludGVnZXJzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgaW5zZXJ0X2Zyb21fdGFibGVgKTtcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IGFycm93LlRhYmxlKHtcbiAgICAgICAgICAgICAgICBhOiBhcnJvdy5tYWtlVmVjdG9yKG5ldyBJbnQzMkFycmF5KFsxLCA0LCA3XSkpLFxuICAgICAgICAgICAgICAgIGI6IGFycm93Lm1ha2VWZWN0b3IobmV3IEludDMyQXJyYXkoWzIsIDUsIDhdKSksXG4gICAgICAgICAgICAgICAgYzogYXJyb3cudmVjdG9yRnJvbUFycmF5PGFycm93LlV0Zjg+KFsnMycsICc2JywgJzknXSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0QXJyb3dUYWJsZSh0YWJsZSwge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdpbnNlcnRfZnJvbV92ZWN0b3JzJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkoJ3NlbGVjdCAqIGZyb20gaW5zZXJ0X2Zyb21fdmVjdG9ycycpO1xuICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIFtcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbJzMnLCAnNicsICc5J10gfSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xuaW1wb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vc3JjLyc7XG5pbXBvcnQgeyBDb2x1bW4sIGNvbXBhcmVUYWJsZSB9IGZyb20gJy4vdGFibGVfdGVzdCc7XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQnJvd3NlcihkZXNjcmlwdGlvbjogc3RyaW5nLCBzcGVjRGVmaW5pdGlvbnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgfVxufVxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbmludGVyZmFjZSBKU09OSW5zZXJ0VGVzdCB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGlucHV0OiBzdHJpbmc7XG4gICAgb3B0aW9uczogZHVja2RiLkpTT05JbnNlcnRPcHRpb25zO1xuICAgIHF1ZXJ5OiBzdHJpbmc7XG4gICAgZXhwZWN0ZWRDb2x1bW5zOiBDb2x1bW5bXTtcbn1cblxuY29uc3QgSlNPTl9JTlNFUlRfVEVTVFM6IEpTT05JbnNlcnRUZXN0W10gPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAncm93c19pbnRlZ2VycycsXG4gICAgICAgIGlucHV0OiBgW1xuICAgICAgICAgICAge1wiYVwiOjEsIFwiYlwiOjIsIFwiY1wiOjN9LFxuICAgICAgICAgICAge1wiYVwiOjQsIFwiYlwiOjUsIFwiY1wiOjZ9LFxuICAgICAgICAgICAge1wiYVwiOjcsIFwiYlwiOjgsIFwiY1wiOjl9LFxuICAgICAgICBdYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcbiAgICAgICAgfSxcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYycsIHZhbHVlczogWzMsIDYsIDldIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdjb2xzX2ludGVnZXJzJyxcbiAgICAgICAgaW5wdXQ6IGB7XG4gICAgICAgICAgICBcImFcIjogWzEsIDQsIDddLFxuICAgICAgICAgICAgXCJiXCI6IFsyLCA1LCA4XSxcbiAgICAgICAgICAgIFwiY1wiOiBbMywgNiwgOV1cbiAgICAgICAgfWAsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFszLCA2LCA5XSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnb3B0aW9uc18xJyxcbiAgICAgICAgaW5wdXQ6IGBbXG4gICAgICAgICAgICB7XCJhXCI6MSwgXCJiXCI6MiwgXCJjXCI6M30sXG4gICAgICAgICAgICB7XCJhXCI6NCwgXCJiXCI6NSwgXCJjXCI6Nn0sXG4gICAgICAgICAgICB7XCJhXCI6NywgXCJiXCI6OCwgXCJjXCI6OX0sXG4gICAgICAgIF1gLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICAgICAgc2hhcGU6IGR1Y2tkYi5KU09OVGFibGVTaGFwZS5ST1dfQVJSQVksXG4gICAgICAgICAgICBjb2x1bW5zOiB7XG4gICAgICAgICAgICAgICAgYTogbmV3IGFycm93LkludDE2KCksXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXG4gICAgICAgICAgICAgICAgYzogbmV3IGFycm93LlV0ZjgoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFsnMycsICc2JywgJzknXSB9LFxuICAgICAgICBdLFxuICAgIH0sXG5dO1xuXG5jb25zdCBURVNUX0ZJTEUgPSAnVEVTVCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0SlNPTkluc2VydChkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uO1xuXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29ubi5jbG9zZSgpO1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnSlNPTiBJbnNlcnQgU3luYycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEpTT05fSU5TRVJUX1RFU1RTKSB7XG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKFRFU1RfRklMRSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBjb25uLmluc2VydEpTT05Gcm9tUGF0aChURVNUX0ZJTEUsIHRlc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0SlNPTkluc2VydEFzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcblxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xuICAgIH0pO1xuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0pTT04gSW5zZXJ0IEJ1ZmZlciBBc3luYycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEpTT05fSU5TRVJUX1RFU1RTKSB7XG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKFRFU1RfRklMRSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydEpTT05Gcm9tUGF0aChURVNUX0ZJTEUsIHRlc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZUJyb3dzZXIoJ0pTT04gSW5zZXJ0IEJsb2IgQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBKU09OX0lOU0VSVF9URVNUUykge1xuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBlbmNvZGVyLmVuY29kZSh0ZXN0LmlucHV0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlSGFuZGxlKFRFU1RfRklMRSwgYmxvYiwgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0SlNPTkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xuaW1wb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vc3JjLyc7XG5pbXBvcnQgeyBDb2x1bW4sIGNvbXBhcmVUYWJsZSB9IGZyb20gJy4vdGFibGVfdGVzdCc7XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQnJvd3NlcihkZXNjcmlwdGlvbjogc3RyaW5nLCBzcGVjRGVmaW5pdGlvbnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XG4gICAgfVxufVxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5cbmludGVyZmFjZSBDU1ZJbnNlcnRUZXN0IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgaW5wdXQ6IHN0cmluZztcbiAgICBvcHRpb25zOiBkdWNrZGIuQ1NWSW5zZXJ0T3B0aW9ucztcbiAgICBxdWVyeTogc3RyaW5nO1xuICAgIGV4cGVjdGVkQ29sdW1uczogQ29sdW1uW107XG59XG5cbmNvbnN0IENTVl9JTlNFUlRfVEVTVFM6IENTVkluc2VydFRlc3RbXSA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6ICdpbnRlZ2Vyc19hdXRvXzEnLFxuICAgICAgICBpbnB1dDogYFwiYVwiLFwiYlwiLFwiY1wiXG4xLDIsM1xuNCw1LDZcbjcsOCw5XG5gLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICB9LFxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2ludGVnZXJzX2F1dG9fMicsXG4gICAgICAgIGlucHV0OiBgYSxiLGNcbjEsMiwzXG40LDUsNlxuNyw4LDlcbmAsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFszLCA2LCA5XSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaW50ZWdlcnNfYXV0b18zJyxcbiAgICAgICAgaW5wdXQ6IGBhLGIsY2AsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMCcsIHZhbHVlczogWydhJ10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogJ2NvbHVtbjEnLCB2YWx1ZXM6IFsnYiddIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjb2x1bW4yJywgdmFsdWVzOiBbJ2MnXSB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnaW50ZWdlcnNfYXV0b18yJyxcbiAgICAgICAgaW5wdXQ6IGBhXG4xXG40XG43XG5gLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICB9LFxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFt7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfV0sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdvcHRpb25zXzEnLFxuICAgICAgICBpbnB1dDogYDEsMiwzXG40LDUsNlxuNyw4LDlcbmAsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxuICAgICAgICAgICAgbmFtZTogJ2ZvbzInLFxuICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRldGVjdDogZmFsc2UsXG4gICAgICAgICAgICBjb2x1bW5zOiB7XG4gICAgICAgICAgICAgICAgYTogbmV3IGFycm93LkludDE2KCksXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXG4gICAgICAgICAgICAgICAgYzogbmV3IGFycm93LlV0ZjgoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbzInLFxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbJzMnLCAnNicsICc5J10gfSxcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ29wdGlvbnNfMicsXG4gICAgICAgIGlucHV0OiBgMXwyfDAxLzAyLzIwMjBcbjR8NXwwMS8wMy8yMDIwXG43fDh8MDEvMDQvMjAyMFxuYCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcbiAgICAgICAgICAgIGRldGVjdDogZmFsc2UsXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICAgICAgZGVsaW1pdGVyOiAnfCcsXG4gICAgICAgICAgICBkYXRlRm9ybWF0OiAnJW0vJWQvJVknLFxuICAgICAgICAgICAgY29sdW1uczoge1xuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxuICAgICAgICAgICAgICAgIGI6IG5ldyBhcnJvdy5JbnQzMigpLFxuICAgICAgICAgICAgICAgIGM6IG5ldyBhcnJvdy5EYXRlRGF5KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2MnLFxuICAgICAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygyMDIwLCAwLCAyKSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKERhdGUuVVRDKDIwMjAsIDAsIDMpKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoRGF0ZS5VVEMoMjAyMCwgMCwgNCkpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnb3B0aW9uc18zJyxcbiAgICAgICAgaW5wdXQ6IGAxfDJ8MjA6MzI6NDUgMTk5Mi0wMy0wMlxuNHw1fDIwOjMyOjUwIDE5OTItMDMtMDJcbjd8OHwyMDozMjo1NSAxOTkyLTAzLTAyXG5gLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxuICAgICAgICAgICAgZGV0ZWN0OiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICBkZWxpbWl0ZXI6ICd8JyxcbiAgICAgICAgICAgIHF1b3RlOiBcIidcIixcbiAgICAgICAgICAgIHRpbWVzdGFtcEZvcm1hdDogJyVIOiVNOiVTICVZLSVtLSVkJyxcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcbiAgICAgICAgICAgICAgICBhOiBuZXcgYXJyb3cuSW50MTYoKSxcbiAgICAgICAgICAgICAgICBiOiBuZXcgYXJyb3cuSW50MzIoKSxcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuVGltZXN0YW1wU2Vjb25kKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ2MnLFxuICAgICAgICAgICAgICAgIHZhbHVlczogW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyLCAyMCwgMzIsIDQ1KSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyLCAyMCwgMzIsIDUwKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyLCAyMCwgMzIsIDU1KSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0sXG5dO1xuXG5jb25zdCBURVNUX0ZJTEUgPSAnVEVTVCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0Q1NWSW5zZXJ0KGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25uLmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdDU1YgSW5zZXJ0IFN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBDU1ZfSU5TRVJUX1RFU1RTKSB7XG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKFRFU1RfRklMRSwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RDU1ZJbnNlcnRBc3luYyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb247XG5cbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdDU1YgSW5zZXJ0IEJ1ZmZlciBBc3luYycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGVzdC5vcHRpb25zLnNjaGVtYSB8fCAnbWFpbid9LiR7dGVzdC5vcHRpb25zLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoVEVTVF9GSUxFLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0Q1NWRnJvbVBhdGgoVEVTVF9GSUxFLCB0ZXN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xuICAgICAgICAgICAgICAgIGNvbXBhcmVUYWJsZShyZXN1bHRzLCB0ZXN0LmV4cGVjdGVkQ29sdW1ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVzY3JpYmVCcm93c2VyKCdDU1YgSW5zZXJ0IEJsb2IgQXN5bmMnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgdGVzdCBvZiBDU1ZfSU5TRVJUX1RFU1RTKSB7XG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVIYW5kbGUoVEVTVF9GSUxFLCBibG9iLCBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRDU1ZGcm9tUGF0aChURVNUX0ZJTEUsIHRlc3Qub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRva2VuaXphdGlvbihkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgZGVzY3JpYmUoJ1Rva2VuaXplcicsICgpID0+IHtcbiAgICAgICAgaXQoJ1NFTEVDVCAxJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KGRiKCkudG9rZW5pemUoJ1NFTEVDVCAxJykpLnRvRXF1YWwoe1xuICAgICAgICAgICAgICAgIG9mZnNldHM6IFswLCA3XSxcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpdCgnU0VMRUNUICogRlJPTSByZWdpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoZGIoKS50b2tlbml6ZSgnU0VMRUNUICogRlJPTSByZWdpb24nKSkudG9FcXVhbCh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0czogWzAsIDcsIDksIDE0XSxcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDMsIDQsIDBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRva2VuaXphdGlvbkFzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBkZXNjcmliZSgnVG9rZW5pemVyJywgKCkgPT4ge1xuICAgICAgICBpdCgnU0VMRUNUIDEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBleHBlY3QoYXdhaXQgZGIoKS50b2tlbml6ZSgnU0VMRUNUIDEnKSkudG9FcXVhbCh7XG4gICAgICAgICAgICAgICAgb2Zmc2V0czogWzAsIDddLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbNCwgMV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCdTRUxFQ1QgKiBGUk9NIHJlZ2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBkYigpLnRva2VuaXplKCdTRUxFQ1QgKiBGUk9NIHJlZ2lvbicpKS50b0VxdWFsKHtcbiAgICAgICAgICAgICAgICBvZmZzZXRzOiBbMCwgNywgOSwgMTRdLFxuICAgICAgICAgICAgICAgIHR5cGVzOiBbNCwgMywgNCwgMF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xuXG5pbnRlcmZhY2UgVGFibGVOYW1lVGVzdCB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGlucHV0OiBzdHJpbmc7XG4gICAgdGFibGVzOiBzdHJpbmdbXTtcbn1cblxuY29uc3QgVEFCTEVOQU1FX1RFU1RTOiBUYWJsZU5hbWVUZXN0W10gPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAnc3RhbmRhcmQnLFxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUnLFxuICAgICAgICB0YWJsZXM6IFsnbXlfdGFibGUnXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2ZldGNoX3NwZWNpZmljJyxcbiAgICAgICAgaW5wdXQ6ICdTRUxFQ1QgY29sX2EgRlJPTSBteV90YWJsZScsXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnbXVsdGlwbGVfdGFibGVzJyxcbiAgICAgICAgaW5wdXQ6ICdTRUxFQ1QgKiBGUk9NIG15X3RhYmxlMSwgbXlfdGFibGUyLCBteV90YWJsZTMnLFxuICAgICAgICB0YWJsZXM6IFsnbXlfdGFibGUxJywgJ215X3RhYmxlMicsICdteV90YWJsZTMnXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3NhbWVfdGFibGVfbXVsdGlwbGVfdGltZXMnLFxuICAgICAgICBpbnB1dDogJ1NFTEVDVCBjb2xfYSBGUk9NIG15X3RhYmxlLCBteV90YWJsZSBtMiwgbXlfdGFibGUgbTMnLFxuICAgICAgICB0YWJsZXM6IFsnbXlfdGFibGUnXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3N1YnF1ZXJpZXMnLFxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gKFNFTEVDVCAqIEZST00gKFNFTEVDVCAqIEZST00gbXlfdGFibGUpIGJsYSkgYmxhMycsXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiAnam9pbicsXG4gICAgICAgIGlucHV0OiAnU0VMRUNUIGNvbF9hIEZST00gbXlfdGFibGUgSk9JTiBteV90YWJsZTIgT04gKG15X3RhYmxlLmNvbF9iPW15X3RhYmxlMi5jb2xfZCknLFxuICAgICAgICB0YWJsZXM6IFsnbXlfdGFibGUnLCAnbXlfdGFibGUyJ10sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdzY2FsYXJfc3VicXVlcnknLFxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAoU0VMRUNUIENPVU5UKCopIEZST00gbXlfdGFibGUpJyxcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJ10sXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdzZXRfb3BlcmF0aW9ucycsXG4gICAgICAgIGlucHV0OiAnU0VMRUNUICogRlJPTSBteV90YWJsZSBVTklPTiBBTEwgU0VMRUNUICogRlJPTSBteV90YWJsZTIgSU5URVJTRUNUIFNFTEVDVCAqIEZST00gbXlfdGFibGUzJyxcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJywgJ215X3RhYmxlMicsICdteV90YWJsZTMnXSxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3dpbmRvd19mdW5jdGlvbnMnLFxuICAgICAgICBpbnB1dDogJ1NFTEVDVCByb3dfbnVtYmVyKCkgT1ZFUiAoT1JERVIgQlkgKFNFTEVDVCBpK2ogRlJPTSBteV90YWJsZTIpKSBGUk9NIG15X3RhYmxlJyxcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJywgJ215X3RhYmxlMiddLFxuICAgIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRhYmxlTmFtZXMoZGI6ICgpID0+IGR1Y2tkYi5EdWNrREJCaW5kaW5ncyk6IHZvaWQge1xuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xuICAgIH0pO1xuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGNvbm4uY2xvc2UoKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnVGFibGVOYW1lcycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIFRBQkxFTkFNRV9URVNUUykge1xuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVzID0gY29ubi5nZXRUYWJsZU5hbWVzKHRlc3QuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZXMpLnRvRXF1YWwodGVzdC50YWJsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RUYWJsZU5hbWVzQXN5bmMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uO1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgIH0pO1xuICAgIGRlc2NyaWJlKCdUYWJsZU5hbWVzIEFzeW5jJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgVEFCTEVOQU1FX1RFU1RTKSB7XG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZXMgPSBhd2FpdCBjb25uLmdldFRhYmxlTmFtZXModGVzdC5pbnB1dCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlcykudG9FcXVhbCh0ZXN0LnRhYmxlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi8uLi9zcmMnO1xuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2R1Y2tkYi9kdWNrZGItd2FzbS9pc3N1ZXMvMzMyXG5leHBvcnQgZnVuY3Rpb24gdGVzdDMzMihkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb247XG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcbiAgICB9KTtcbiAgICBkZXNjcmliZSgnR2l0SHViIGlzc3VlcycsICgpID0+IHtcbiAgICAgICAgaXQoJzMzMicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlVGV4dChcbiAgICAgICAgICAgICAgICAnUHJvZHVjdHMuY3N2JyxcbiAgICAgICAgICAgICAgICBgUHJvZHVjdEdyb3VwLFByb2R1Y3QsWWVhcixRdWFydGVyLFJldmVudWUsVW5pdHMsQ291bnQsUHJvZHVjdCBLZXksUmVzZWxsZXIsUHJvZHVjdCBJbmZvLFF1YXJ0ZXJBc051bWJlclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOCxRMSwxMDMsNywxLDIwMTgtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOCxRMSwxMDIsNCwxLDIwMTgtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOSxRMSw5OCwxMiwxLDIwMTktUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAxOCxRMSwxMDQsMywxLDIwMTgtUTEsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAxOSxRMSw4Myw3LDEsMjAxOS1RMSxHb29nbGUsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbk1lZGlhLFRoZWF0ZXIsMjAxOCxRMSwxNyw0LDEsMjAxOC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXG5NZWRpYSxUaGVhdGVyLDIwMTksUTEsMjAsNywxLDIwMTktUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuTWVkaWEsTW92aWVzLDIwMTgsUTEsMjUsMTIsMSwyMDE4LVExLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuTWVkaWEsTW92aWVzLDIwMTksUTEsMjYsMTMsMSwyMDE5LVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbkVsZWN0cm9uaWNzLFBob25lLDIwMTgsUTIsMTA1LDUsMSwyMDE4LVEyLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTksUTIsODIsMTUsMSwyMDE5LVEyLExHLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDE4LFEyLDk5LDQsMSwyMDE4LVEyLExHLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDE5LFEyLDg0LDIwLDEsMjAxOS1RMixTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5NZWRpYSxUaGVhdGVyLDIwMTgsUTIsMTcsNCwxLDIwMTgtUTIsTWljcm9zb2Z0LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5NZWRpYSxUaGVhdGVyLDIwMTksUTIsMjIsNSwxLDIwMTktUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxuTWVkaWEsTW92aWVzLDIwMTgsUTIsMjUsMTIsMSwyMDE4LVEyLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbk1lZGlhLE1vdmllcywyMDE5LFEyLDI2LDE0LDEsMjAxOS1RMixHb29nbGUsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbkVsZWN0cm9uaWNzLFBob25lLDIwMDAsUTEsMTAzLDcsMSwyMDAwLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbkVsZWN0cm9uaWNzLFBob25lLDIwMDEsUTEsMTAyLDQsMSwyMDAxLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbkVsZWN0cm9uaWNzLFBob25lLDIwMDIsUTEsOTgsMTIsMSwyMDAyLVExLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAwMyxRMSwxMDQsMywxLDIwMDMtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAwNCxRMSw4Myw3LDEsMjAwNC1RMSxTYW1zdW5nLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXG5NZWRpYSxUaGVhdGVyLDIwMDUsUTEsMTcsNCwxLDIwMDUtUTEsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXG5NZWRpYSxUaGVhdGVyLDIwMDYsUTEsMjAsNywxLDIwMDYtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuTWVkaWEsTW92aWVzLDIwMDcsUTEsMjUsMTIsMSwyMDA3LVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbk1lZGlhLE1vdmllcywyMDA4LFExLDI2LDEzLDEsMjAwOC1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbkVsZWN0cm9uaWNzLFBob25lLDIwMDksUTIsMTA1LDUsMSwyMDA5LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTAsUTIsODIsMTUsMSwyMDEwLVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMTEsUTIsOTksNCwxLDIwMTEtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAxMixRMiw4NCwyMCwxLDIwMTItUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxuTWVkaWEsVGhlYXRlciwyMDEzLFEyLDE3LDQsMSwyMDEzLVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbk1lZGlhLFRoZWF0ZXIsMjAxNCxRMiwyMiw1LDEsMjAxNC1RMixTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5NZWRpYSxNb3ZpZXMsMjAxNSxRMiwyNSwxMiwxLDIwMTUtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxuTWVkaWEsTW92aWVzLDIwMTYsUTIsMjYsMTQsMSwyMDE2LVEyLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbk1lZGlhLE1vdmllcywyMDE3LFExLDI2LDEzLDEsMjAxNy1RMSxHb29nbGUsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbkVsZWN0cm9uaWNzLFBob25lLDIwMTgsUTIsMTA1LDUsMSwyMDE4LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTksUTIsODIsMTUsMSwyMDE5LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMjAsUTIsOTksNCwxLDIwMjAtUTIsTWljcm9zb2Z0LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDIwLFExLDEwMyw3LDEsMjAyMC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXG5FbGVjdHJvbmljcyxQaG9uZSwyMDIwLFEyLDEwMiw0LDEsMjAyMC1RMixTYW1zdW5nLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDIwLFEzLDk4LDEyLDEsMjAyMC1RMyxMRyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsM1xuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAyMCxRNCwxMDQsMywxLDIwMjAtUTQsTEcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDRcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMjAsUTEsODMsNywxLDIwMjAtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuTWVkaWEsVGhlYXRlciwyMDIwLFExLDE3LDQsMSwyMDIwLVExLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxuTWVkaWEsVGhlYXRlciwyMDIwLFExLDIwLDcsMSwyMDIwLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShcIkNSRUFURSBUQUJMRSBwcm9kdWN0cyBBUyBTRUxFQ1QgKiBGUk9NICdQcm9kdWN0cy5jc3YnXCIpO1xuICAgICAgICAgICAgY29uc3QgYWxsID0gYXdhaXQgY29ubi5xdWVyeSgnU0VMRUNUICogRlJPTSBwcm9kdWN0cycpO1xuICAgICAgICAgICAgZXhwZWN0KGFsbC5zY2hlbWEuZmllbGRzLmxlbmd0aCkudG9CZSgxMSk7XG4gICAgICAgICAgICBleHBlY3QoYWxsLnNjaGVtYS5maWVsZHNbMF0ubmFtZSkudG9CZSgnUHJvZHVjdEdyb3VwJyk7XG4gICAgICAgICAgICBjb25zdCBpbnNlbnNpdGl2ZSA9IGF3YWl0IGNvbm4ucXVlcnk8e1xuICAgICAgICAgICAgICAgIFByb2R1Y3RHcm91cDogYXJyb3cuVXRmODtcbiAgICAgICAgICAgIH0+KCdTRUxFQ1QgcHJvZHVjdGdyb3VwIEZST00gcHJvZHVjdHMgR1JPVVAgQlkgcHJvZHVjdGdyb3VwJyk7XG4gICAgICAgICAgICBleHBlY3QoaW5zZW5zaXRpdmUuc2NoZW1hLmZpZWxkcy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QoaW5zZW5zaXRpdmUuc2NoZW1hLmZpZWxkc1swXS5uYW1lKS50b0JlKCdQcm9kdWN0R3JvdXAnKTtcbiAgICAgICAgICAgIGV4cGVjdChpbnNlbnNpdGl2ZS50b0FycmF5KCkubGVuZ3RoKS50b0VxdWFsKDIpO1xuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeSgnRFJPUCBUQUJMRSBwcm9kdWN0cycpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vLi4vc3JjJztcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kdWNrZGIvZHVja2RiLXdhc20vaXNzdWVzLzMzNFxuZXhwb3J0IGZ1bmN0aW9uIHRlc3QzMzQoYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBkZXNjcmliZSgnR2l0SHViIGlzc3VlcycsICgpID0+IHtcbiAgICAgICAgZGVzY3JpYmUoJzMzNCcsICgpID0+IHtcbiAgICAgICAgICAgIGl0KCdDU1YgaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLnJlZ2lzdGVyRmlsZVRleHQoYGRhdGEuY3N2YCwgJzF8Zm9vXFxuMnxiYXJcXG4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0Q1NWRnJvbVBhdGgoJ2RhdGEuY3N2Jywge1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZvbycsXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlcjogJ3wnLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wxOiBuZXcgYXJyb3cuSW50MzIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDI6IG5ldyBhcnJvdy5VdGY4KCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeSgnRFJPUCBUQUJMRSBJRiBFWElTVFMgZm9vJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLmRyb3BGaWxlKCdkYXRhLmNzdicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnSlNPTiByb3cgaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLnJlZ2lzdGVyRmlsZVRleHQoXG4gICAgICAgICAgICAgICAgICAgICdyb3dzLmpzb24nLFxuICAgICAgICAgICAgICAgICAgICBgW1xuICAgICAgICAgICAgICAgICAgICB7IFwiY29sMVwiOiAxLCBcImNvbDJcIjogXCJmb29cIiB9LFxuICAgICAgICAgICAgICAgICAgICB7IFwiY29sMVwiOiAyLCBcImNvbDJcIjogXCJiYXJcIiB9LFxuICAgICAgICAgICAgICAgIF1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydEpTT05Gcm9tUGF0aCgncm93cy5qc29uJywgeyBuYW1lOiAncm93cycgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeSgnRFJPUCBUQUJMRSBJRiBFWElTVFMgcm93cycpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5kcm9wRmlsZSgncm93cy5qc29uJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGl0KCdKU09OIGNvbHVtbiBpbnNlcnQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChcbiAgICAgICAgICAgICAgICAgICAgJ2NvbHVtbnMuanNvbicsXG4gICAgICAgICAgICAgICAgICAgIGB7XG4gICAgICAgICAgICAgICAgICAgIFwiY29sMVwiOiBbMSwgMl0sXG4gICAgICAgICAgICAgICAgICAgIFwiY29sMlwiOiBbXCJmb29cIiwgXCJiYXJcIl1cbiAgICAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRKU09ORnJvbVBhdGgoJ2NvbHVtbnMuanNvbicsIHsgbmFtZTogJ2NvbHVtbnMnIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0RST1AgVEFCTEUgSUYgRVhJU1RTIGNvbHVtbnMnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkuZHJvcEZpbGUoJ2NvbHVtbnMuanNvbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnUXVlcnkgcmVzdWx0IG1hdGVyaWFsaXplZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnk8eyB2OiBhcnJvdy5JbnQgfT4oYFxuICAgICAgICAgICAgICAgIFNFTEVDVCAqIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMCkgdCh2KVxuICAgICAgICAgICAgYCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnUXVlcnkgcmVzdWx0IHN0cmVhbWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiBhd2FpdCBjb25uLnNlbmQ8eyB2OiBhcnJvdy5JbnQgfT4oYFxuICAgICAgICAgICAgICAgIFNFTEVDVCAqIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMCkgdCh2KVxuICAgICAgICAgICAgYCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bVJvd3MpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpdCgnUHJlcGFyZWQgc3RhdGVtZW50IG1hdGVyaWFsaXplZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBhd2FpdCBjb25uLnByZXBhcmUoYFNFTEVDVCB2ICsgPyBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTtgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzdG10LnF1ZXJ5KDIzNCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaXQoJ1ByZXBhcmVkIHN0YXRlbWVudCBzdHJlYW1lZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBhd2FpdCBjb25uLnByZXBhcmUoYFNFTEVDVCB2ICsgPyBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTtgKTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIGF3YWl0IHN0bXQuc2VuZCgyMzQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Sb3dzKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy8zOTNcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0MzkzKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoY29ubikge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgY29ubiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCczOTMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xuICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgY2FzdFRpbWVzdGFtcFRvRGF0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aG91dENhc3QgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcbiAgICAgICAgICAgICAgICB0czogYXJyb3cuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9PihgU0VMRUNUIFRJTUVTVEFNUCAnMTk5Mi0wMy0yMiAwMTowMjowMycgYXMgdHNgKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRXaXRob3V0Q2FzdC50b0FycmF5KClbMF0/LnRzKS50b0VxdWFsKG5ldyBEYXRlKERhdGUuVVRDKDE5OTIsIDIsIDIyLCAxLCAyLCAzKSkuZ2V0VGltZSgpKTtcblxuICAgICAgICAgICAgYXdhaXQgZGIoKS5vcGVuKHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNhc3RUaW1lc3RhbXBUb0RhdGU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aENhc3QgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcbiAgICAgICAgICAgICAgICB0czogYXJyb3cuRGF0ZU1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfT4oYFNFTEVDVCBUSU1FU1RBTVAgJzE5OTItMDMtMjIgMDE6MDI6MDMnIGFzIHRzYCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0V2l0aENhc3QudG9BcnJheSgpWzBdPy50cykudG9FcXVhbChuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyMiwgMSwgMiwgMykpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy80NDhcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0NDQ4KGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoY29ubikge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgY29ubiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCc0NDgnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBjcmVhdGUgdGVtcCB0YWJsZSB0ZXN0NDQ4KGkgaW50ZWdlcilgKTtcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYGluc2VydCBpbnRvIHRlc3Q0NDggdmFsdWVzICgxKSwoMiksKDEpYCk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY29ubi5xdWVyeShgc2VsZWN0ICogZnJvbSB0ZXN0NDQ4YCk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbMSwgMiwgMV0pKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGNvbm4ucXVlcnk8eyBpOiBhcnJvdy5NYXBfPGFycm93LkludDMyLCBhcnJvdy5VaW50NjQ+IH0+KGBzZWxlY3QgaGlzdG9ncmFtKGkpIGZyb20gdGVzdDQ0OGApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0JlKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0JlKDEpO1xuICAgICAgICAgICAgY29uc3QgYXJyYXkgPSByZXN1bHQuZ2V0Q2hpbGRBdCgwKSEudG9BcnJheSgpO1xuICAgICAgICAgICAgZXhwZWN0KGFycmF5Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChhcnJheVswXS50b1N0cmluZygpKS50b0VxdWFsKCd7MTogMiwgMjogMX0nKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy80NzBcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0NDcwKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoY29ubikge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgY29ubiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCc0NzAnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCYXNlbGluZSB3aXRob3V0IGNhc3Q6IHdlIGV4cGVjdCBhbiBlcnJvciB0byBiZSB0aHJvd24gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gdHlwZSB0aGF0IGlzIGVtaXR0ZWRcbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RHVyYXRpb25Ub1RpbWU2NDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0MSA9IGF3YWl0IGNvbm4ucXVlcnk8e1xuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XG4gICAgICAgICAgICB9PihgU0VMRUNUIElOVEVSVkFMICczJyBNT05USCBBUyBpbnRlcnZhbGApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdDEudG9BcnJheSgpWzBdPy5pbnRlcnZhbD8udG9TdHJpbmcoKSkudG9FcXVhbCgnMCwzJyk7XG5cbiAgICAgICAgICAgIC8vIENhc3QgZXhwbGljaXRseSBlbmFibGVkOiBUaW1lNjQgdmFsdWUgaXMgcmV0dXJuZWRcbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RHVyYXRpb25Ub1RpbWU2NDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRXaXRoQ2FzdCA9IGF3YWl0IGNvbm4ucXVlcnk8e1xuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XG4gICAgICAgICAgICB9PihgU0VMRUNUIElOVEVSVkFMICczJyBNT05USCBBUyBpbnRlcnZhbGApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhDYXN0LnRvQXJyYXkoKVswXT8uaW50ZXJ2YWw/LnRvU3RyaW5nKCkpLnRvRXF1YWwoJzAsMycpO1xuXG4gICAgICAgICAgICAvLyBDYXN0IHNob3VsZCBiZSBvbiBieSBkZWZhdWx0XG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xuICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRXaXRoRGVmYXVsdCA9IGF3YWl0IGNvbm4ucXVlcnk8e1xuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XG4gICAgICAgICAgICB9PihgU0VMRUNUIElOVEVSVkFMICczJyBNT05USCBBUyBpbnRlcnZhbGApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhEZWZhdWx0LnRvQXJyYXkoKVswXT8uaW50ZXJ2YWw/LnRvU3RyaW5nKCkpLnRvRXF1YWwoJzAsMycpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vLi4vc3JjJztcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kdWNrZGIvZHVja2RiLXdhc20vaXNzdWVzLzQ3N1xuLy8gTm90ZSB0aGF0IHdoZW4gQXJyb3dKUyBzdXBwb3J0cyBuZWdhdGl2ZSBkZWNpbWFscywgY2FzdERlY2ltYWxUb0RvdWJsZSBzaG91bGQgcHJvYmFibHkgYmUgZGVwcmVjYXRlZC5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0NDc3KGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoY29ubikge1xuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgY29ubiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XG4gICAgICAgIGl0KCc0NzcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBCYXNlbGluZSB3aXRob3V0IGNhc3Q6IHdlIGV4cGVjdCB0aGUgbmVnYXRpdmUgZGVjaW1hbCB2YWx1ZXMgdG8gbm90IHdvcmsgYWNjdXJhdGVseVxuICAgICAgICAgICAgYXdhaXQgZGIoKS5vcGVuKHtcbiAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aG91dENhc3QgPSBhd2FpdCBjb25uLnF1ZXJ5KGBTRUxFQ1QgKC0xLjkpOjpERUNJTUFMKDIsMSkgYXMgZGVjaW1hbGApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnNjaGVtYS5maWVsZHNbMF0udHlwZS5zY2FsZSkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRXaXRob3V0Q2FzdC5zY2hlbWEuZmllbGRzWzBdLnR5cGUucHJlY2lzaW9uKS50b0VxdWFsKDIpO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBhc3NlcnRpb24gYnJlYWtzLCBhcnJvdyBKUyB3YXMgbGlrZWx5IHVwZGF0ZWQgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnRvQXJyYXkoKVswXT8uZGVjaW1hbCA9PSAtMTkpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBVc2luZyBjYXN0RGVjaW1hbFRvRG91YmxlIHdlIGZvcmNlIGRlY2ltYWxzIHRvIGJlIGNhc3QgdG8gZG91Ymxlcywgbm90ZSB0aGUgaW5ldml0YWJsZSBpbXByZWNpc2lvbi5cbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBjYXN0RGVjaW1hbFRvRG91YmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhDYXN0ID0gYXdhaXQgY29ubi5xdWVyeTx7XG4gICAgICAgICAgICAgICAgZGVjaW1hbDogYXJyb3cuRmxvYXQ2NDtcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgKC0xLjkpOjpERUNJTUFMKDIsMSkgYXMgZGVjaW1hbGApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhDYXN0LnRvQXJyYXkoKVswXT8uZGVjaW1hbCkudG9FcXVhbCgtMS45MDAwMDAwMDAwMDAwMDAxKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYy8nO1xuaW1wb3J0IHsgdGVzdDMzMiB9IGZyb20gJy4vZ2l0aHViXzMzMi50ZXN0JztcbmltcG9ydCB7IHRlc3QzMzQgfSBmcm9tICcuL2dpdGh1Yl8zMzQudGVzdCc7XG5pbXBvcnQgeyB0ZXN0MzkzIH0gZnJvbSAnLi9naXRodWJfMzkzLnRlc3QnO1xuaW1wb3J0IHsgdGVzdDQ0OCB9IGZyb20gJy4vZ2l0aHViXzQ0OC50ZXN0JztcbmltcG9ydCB7IHRlc3Q0NzAgfSBmcm9tICcuL2dpdGh1Yl80NzAudGVzdCc7XG5pbXBvcnQgeyB0ZXN0NDc3IH0gZnJvbSBcIi4vZ2l0aHViXzQ3Ny50ZXN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0UmVncmVzc2lvbkFzeW5jKGFkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XG4gICAgdGVzdDMzMihhZGIpO1xuICAgIHRlc3QzMzQoYWRiKTtcbiAgICB0ZXN0MzkzKGFkYik7XG4gICAgdGVzdDQ0OChhZGIpO1xuICAgIHRlc3Q0NzAoYWRiKTtcbiAgICB0ZXN0NDc3KGFkYik7XG59XG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xuaW1wb3J0IHsgRmxvYXQ2NCwgSW50MzIsIFV0ZjggfSBmcm9tICdhcGFjaGUtYXJyb3cnO1xuXG5leHBvcnQgZnVuY3Rpb24gdGVzdFVERihkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uO1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICBjb25uLmNsb3NlKCk7XG4gICAgICAgIGRiKCkuZmx1c2hGaWxlcygpO1xuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ1VERicsICgpID0+IHtcbiAgICAgICAgaXQoJ3NpbXBsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmJywgbmV3IEludDMyKCksIGEgPT4gYSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGYodjo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxMDAwMF0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2RvdWJsZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMicsIG5ldyBGbG9hdDY0KCksIGEgPT4gYSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGYyKHY6OkRPVUJMRSkpOjpET1VCTEUgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEZsb2F0NjRBcnJheShbMTAwMDBdKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCcyIGFyZ3MnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjMnLCBuZXcgSW50MzIoKSwgKGEsIGIpID0+IGEgKyBiKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcbiAgICAgICAgICAgICAgICAnU0VMRUNUIG1heChqc3VkZjModjo6SU5URUdFUiwgdjo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsyMDAwMF0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJzMgYXJncycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmM2FyZ3MnLCBuZXcgSW50MzIoKSwgKGEsIGIsIGMpID0+IGEgKyBiICsgYyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGYzYXJncyh2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzMwMDAwXSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnNCBhcmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY0YXJncycsIG5ldyBJbnQzMigpLCAoYSwgYiwgYywgZCkgPT4gYSArIGIgKyBjICsgZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGY0YXJncyh2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQwMDAwXSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnbm9hcmdzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY0JywgbmV3IEludDMyKCksICgpID0+IDQyKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoJ1NFTEVDVCBtYXgoanN1ZGY0KCkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScpO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFs0Ml0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0KCd3aXRobnVsbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjUnLCBuZXcgSW50MzIoKSwgYSA9PiAoYSA9PSBudWxsID8gLTEwMCA6IGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtaW4oanN1ZGY1KChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFstMTAwXSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc3RyaW5ncGFyYW0nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBqc3VkZjYoczogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY2JywgbmV3IEludDMyKCksIGpzdWRmNik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxuICAgICAgICAgICAgICAgIFwiU0VMRUNUIG1heChqc3VkZjYoJ3N0cl8nIHx8IHYpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodilcIixcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzldKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzdHJpbmdwYXJhbW51bGxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZnVuY3Rpb24ganN1ZGY3KHM6IHN0cmluZykge1xuICAgICAgICAgICAgICAgIGlmIChzID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY3JywgbmV3IEludDMyKCksIGpzdWRmNyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxuICAgICAgICAgICAgICAgIFwiU0VMRUNUIG1heChqc3VkZjcoKGNhc2Ugd2hlbiB2ICUgMiA9IDAgdGhlbiAnc3RyXycgfHwgdiBlbHNlIG51bGwgZW5kKTo6VkFSQ0hBUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KVwiLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbOV0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ251bGxpbnRyZXR1cm4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjgnLCBuZXcgSW50MzIoKSwgYSA9PiB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KENPQUxFU0NFKGpzdWRmOCh2OjpJTlRFR0VSKSwgNDIpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodiknLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbNDJdKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzdHJpbmdyZXR1cm4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjknLCBuZXcgVXRmOCgpLCBhID0+ICdIZWxsbyAnICsgYSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoTEVOR1RIKGpzdWRmOSh2OjpJTlRFR0VSKSkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxMV0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ251bGxzdHJpbmdyZXR1cm4nLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjEwJywgbmV3IFV0ZjgoKSwgYSA9PiAoYSAlIDIgPT0gMCA/ICdIZWxsbycgOiB1bmRlZmluZWQpKTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcbiAgICAgICAgICAgICAgICAnU0VMRUNUIENPVU5UKGpzdWRmMTAodjo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFs1MDAwXSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc3RydWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGYxMScsIG5ldyBJbnQzMigpLCBhID0+IChhLnggPT0gbnVsbCA/IC0xMDAgOiBhLngpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCBtaW4oanN1ZGYxMSh7J3gnOiAoY2FzZSB3aGVuIHYgJSAyID0gMCB0aGVuIHYgZWxzZSBudWxsIGVuZCk6OklOVEVHRVIsICd5JzogNDJ9KSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpYCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWy0xMDBdKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzdHJ1Y3RuZXN0ZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjEyJywgbmV3IEludDMyKCksIGEgPT4gKGEueC55ID09IG51bGwgPyAtMTAwIDogYS54LnkpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXG4gICAgICAgICAgICAgICAgYFNFTEVDVCBtaW4oanN1ZGYxMih7J3gnOiB7J3knOiAoY2FzZSB3aGVuIHYgJSAyID0gMCB0aGVuIHYgZWxzZSBudWxsIGVuZCk6OklOVEVHRVIgfSwgJ3onOiA0Mn0pKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodilgLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbLTEwMF0pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3N0cnVjdG5lc3RlZG51bGwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjEzJywgbmV3IEludDMyKCksIGEgPT4gKGEueD8ueSA9PSBudWxsID8gLTEwMCA6IGEueCEueSkpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcbiAgICAgICAgICAgICAgICBgU0VMRUNUIG1pbihqc3VkZjEzKHsneCc6IChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4geyd5Jzogdjo6SU5URUdFUiB9IGVsc2UgbnVsbCBlbmQpLCAneic6IDQyfSkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KWAsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFstMTAwXSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgKiBhcyBkdWNrZGJfYmxvY2tpbmcgZnJvbSAnLi4vc3JjL3RhcmdldHMvZHVja2RiLWJyb3dzZXItYmxvY2tpbmcnO1xuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy90YXJnZXRzL2R1Y2tkYic7XG5pbXBvcnQgKiBhcyBjaGVjayBmcm9tICd3YXNtLWZlYXR1cmUtZGV0ZWN0JztcblxuLy8gQ29uZmlndXJlIHRoZSB3b3JrZXJcbmNvbnN0IERVQ0tEQl9CVU5ETEVTOiBkdWNrZGIuRHVja0RCQnVuZGxlcyA9IHtcbiAgICBtdnA6IHtcbiAgICAgICAgbWFpbk1vZHVsZTogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItbXZwLndhc20nLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcbiAgICAgICAgbWFpbldvcmtlcjogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItYnJvd3Nlci1tdnAud29ya2VyLmpzJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXG4gICAgfSxcbiAgICBlaDoge1xuICAgICAgICBtYWluTW9kdWxlOiBuZXcgVVJMKCcvc3RhdGljL2R1Y2tkYi1laC53YXNtJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXG4gICAgICAgIG1haW5Xb3JrZXI6IG5ldyBVUkwoJy9zdGF0aWMvZHVja2RiLWJyb3dzZXItZWgud29ya2VyLmpzJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXG4gICAgfSxcbiAgICBjb2k6IHtcbiAgICAgICAgbWFpbk1vZHVsZTogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItY29pLndhc20nLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcbiAgICAgICAgbWFpbldvcmtlcjogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItYnJvd3Nlci1jb2kud29ya2VyLmpzJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXG4gICAgICAgIHB0aHJlYWRXb3JrZXI6IG5ldyBVUkwoJy9zdGF0aWMvZHVja2RiLWJyb3dzZXItY29pLnB0aHJlYWQud29ya2VyLmpzJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXG4gICAgfSxcbn07XG5sZXQgRFVDS0RCX0JVTkRMRTogZHVja2RiLkR1Y2tEQkJ1bmRsZSB8IG51bGwgPSBudWxsO1xuXG5kZXNjcmliZSgnd2FzbSBjaGVjaycsICgpID0+IHtcbiAgICBpdCgnd29ya2VyIGFuZCB3YXNtIHVybHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChhd2FpdCBkdWNrZGIuZ2V0UGxhdGZvcm1GZWF0dXJlcygpKS5jcm9zc09yaWdpbklzb2xhdGVkICYmXG4gICAgICAgICAgICAoYXdhaXQgY2hlY2suZXhjZXB0aW9ucygpKSAmJlxuICAgICAgICAgICAgKGF3YWl0IGNoZWNrLnRocmVhZHMoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBleHBlY3QoRFVDS0RCX0JVTkRMRSEubWFpbk1vZHVsZSkudG9FcXVhbChEVUNLREJfQlVORExFUy5jb2khLm1haW5Nb2R1bGUpO1xuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLm1haW5Xb3JrZXIpLnRvRXF1YWwoRFVDS0RCX0JVTkRMRVMuY29pIS5tYWluV29ya2VyKTtcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEucHRocmVhZFdvcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChhd2FpdCBjaGVjay5leGNlcHRpb25zKCkpICYmICEoYXdhaXQgY2hlY2sudGhyZWFkcygpKSkge1xuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLm1haW5Nb2R1bGUpLnRvRXF1YWwoRFVDS0RCX0JVTkRMRVMuZWghLm1haW5Nb2R1bGUpO1xuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLm1haW5Xb3JrZXIpLnRvRXF1YWwoRFVDS0RCX0JVTkRMRVMuZWghLm1haW5Xb3JrZXIpO1xuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLnB0aHJlYWRXb3JrZXIpLnRvRXF1YWwobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoYXdhaXQgY2hlY2suZXhjZXB0aW9ucygpKSkge1xuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLm1haW5Nb2R1bGUpLnRvRXF1YWwoRFVDS0RCX0JVTkRMRVMubXZwIS5tYWluTW9kdWxlKTtcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLm12cCEubWFpbldvcmtlcik7XG4gICAgICAgICAgICBleHBlY3QoRFVDS0RCX0JVTkRMRSEucHRocmVhZFdvcmtlcikudG9FcXVhbChudWxsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cbi8vIExvYWRpbmcgZGVidWcgc3ltYm9scywgZXNwZWNpYWxseSBmb3IgV0FTTSB0YWtlIGluc2FuZWx5IGxvbmcgc28gd2UganVzdCBkaXNhYmxlIHRoZSB0ZXN0IHRpbWVvdXRcbmphc21pbmUuREVGQVVMVF9USU1FT1VUX0lOVEVSVkFMID0gNjAwMDA7XG5cbi8vIFJlc29sdmUgYSBidWZmZXIgYnkgZmV0Y2hpbmcgZnJvbSBkaXNrXG5jb25zdCByZXNvbHZlQnVmZmVyID0gYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgcmVxID0gYXdhaXQgZmV0Y2goYC9kYXRhJHt1cmx9YCk7XG4gICAgaWYgKCFyZXEub2spIHJldHVybiBudWxsO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhd2FpdCByZXEuYXJyYXlCdWZmZXIoKSk7XG59O1xuXG4vLyBSZXNvbHZlIHRlc3QgZGF0YVxuY29uc3QgcmVzb2x2ZURhdGEgPSBhc3luYyAodXJsOiBzdHJpbmcpID0+IHtcbiAgICBzd2l0Y2ggKHVybCkge1xuICAgICAgICBjYXNlICcvdW5pL2FsbC56aXAnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy91bmkvYWxsLnppcCcpO1xuICAgICAgICBjYXNlICcvdW5pL2Fzc2lzdGVudGVuLnBhcnF1ZXQnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy91bmkvYXNzaXN0ZW50ZW4ucGFycXVldCcpO1xuICAgICAgICBjYXNlICcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0JzpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XG4gICAgICAgIGNhc2UgJy91bmkvaG9lcmVuLnBhcnF1ZXQnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy91bmkvaG9lcmVuLnBhcnF1ZXQnKTtcbiAgICAgICAgY2FzZSAnL3VuaS92b3JsZXN1bmdlbi5wYXJxdWV0JzpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL3Zvcmxlc3VuZ2VuLnBhcnF1ZXQnKTtcbiAgICAgICAgY2FzZSAnL3RwY2gvMF8wMS9wYXJxdWV0L2xpbmVpdGVtLnBhcnF1ZXQnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0Jyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG4vLyBUZXN0IGVudmlyb25tZW50XG5sZXQgZGI6IGR1Y2tkYl9ibG9ja2luZy5EdWNrREJCaW5kaW5ncyB8IG51bGwgPSBudWxsO1xubGV0IGFkYjogZHVja2RiLkFzeW5jRHVja0RCIHwgbnVsbCA9IG51bGw7XG5sZXQgd29ya2VyOiBXb3JrZXIgfCBudWxsID0gbnVsbDtcblxuYmVmb3JlQWxsKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgZHVja2RiX2Jsb2NraW5nLlZvaWRMb2dnZXIoKTtcbiAgICBkYiA9IGF3YWl0IGR1Y2tkYl9ibG9ja2luZy5jcmVhdGVEdWNrREIoRFVDS0RCX0JVTkRMRVMsIGxvZ2dlciwgZHVja2RiX2Jsb2NraW5nLkJST1dTRVJfUlVOVElNRSk7XG4gICAgYXdhaXQgZGIuaW5zdGFudGlhdGUoXyA9PiB7fSk7XG5cbiAgICBEVUNLREJfQlVORExFID0gYXdhaXQgZHVja2RiLnNlbGVjdEJ1bmRsZShEVUNLREJfQlVORExFUyk7XG4gICAgd29ya2VyID0gYXdhaXQgZHVja2RiLmNyZWF0ZVdvcmtlcihEVUNLREJfQlVORExFIS5tYWluV29ya2VyISk7XG4gICAgYWRiID0gbmV3IGR1Y2tkYi5Bc3luY0R1Y2tEQihsb2dnZXIsIHdvcmtlcik7XG4gICAgYXdhaXQgYWRiLmluc3RhbnRpYXRlKERVQ0tEQl9CVU5ETEUhLm1haW5Nb2R1bGUsIERVQ0tEQl9CVU5ETEUhLnB0aHJlYWRXb3JrZXIpO1xufSk7XG5cbmFmdGVyQWxsKGFzeW5jICgpID0+IHtcbiAgICBpZiAod29ya2VyKSB3b3JrZXIudGVybWluYXRlKCk7XG59KTtcblxuaW1wb3J0IHsgdGVzdEFsbFR5cGVzLCB0ZXN0QWxsVHlwZXNBc3luYyB9IGZyb20gJy4vYWxsX3R5cGVzLnRlc3QnO1xuaW1wb3J0IHsgdGVzdEhUVFBGUywgdGVzdEhUVFBGU0FzeW5jIH0gZnJvbSAnLi9odHRwZnNfdGVzdCc7XG5pbXBvcnQgeyB0ZXN0QmluZGluZ3MsIHRlc3RBc3luY0JpbmRpbmdzIH0gZnJvbSAnLi9iaW5kaW5ncy50ZXN0JztcbmltcG9ydCB7IHRlc3RCYXRjaFN0cmVhbSB9IGZyb20gJy4vYmF0Y2hfc3RyZWFtLnRlc3QnO1xuaW1wb3J0IHsgdGVzdEFzeW5jQmF0Y2hTdHJlYW0gfSBmcm9tICcuL2JhdGNoX3N0cmVhbV9hc3luYy50ZXN0JztcbmltcG9ydCB7IHRlc3RGaWxlc3lzdGVtIH0gZnJvbSAnLi9maWxlc3lzdGVtLnRlc3QnO1xuaW1wb3J0IHsgdGVzdEFycm93SW5zZXJ0LCB0ZXN0QXJyb3dJbnNlcnRBc3luYyB9IGZyb20gJy4vaW5zZXJ0X2Fycm93LnRlc3QnO1xuaW1wb3J0IHsgdGVzdEpTT05JbnNlcnQsIHRlc3RKU09OSW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9qc29uLnRlc3QnO1xuaW1wb3J0IHsgdGVzdENTVkluc2VydCwgdGVzdENTVkluc2VydEFzeW5jIH0gZnJvbSAnLi9pbnNlcnRfY3N2LnRlc3QnO1xuaW1wb3J0IHsgdGVzdFRva2VuaXphdGlvbiwgdGVzdFRva2VuaXphdGlvbkFzeW5jIH0gZnJvbSAnLi90b2tlbml6ZXIudGVzdCc7XG5pbXBvcnQgeyB0ZXN0VGFibGVOYW1lcywgdGVzdFRhYmxlTmFtZXNBc3luYyB9IGZyb20gJy4vdGFibGVuYW1lcy50ZXN0JztcbmltcG9ydCB7IHRlc3RSZWdyZXNzaW9uQXN5bmMgfSBmcm9tICcuL3JlZ3Jlc3Npb24nO1xuaW1wb3J0IHsgdGVzdFVERiB9IGZyb20gJy4vdWRmLnRlc3QnO1xuLy9pbXBvcnQgeyB0ZXN0RVhDRUwgfSBmcm9tICcuL2V4Y2VsLnRlc3QnO1xuLy9pbXBvcnQgeyB0ZXN0SlNPTiB9IGZyb20gJy4vanNvbi50ZXN0JztcblxuY29uc3QgYmFzZVVSTCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5jb25zdCBkYXRhVVJMID0gYCR7YmFzZVVSTH0vZGF0YWA7XG5cbnRlc3RIVFRQRlMoKCkgPT4gZGIhKTtcbnRlc3RIVFRQRlNBc3luYygoKSA9PiBhZGIhLCByZXNvbHZlRGF0YSwgZGF0YVVSTCk7XG50ZXN0VURGKCgpID0+IGRiISk7XG50ZXN0VGFibGVOYW1lcygoKSA9PiBkYiEpO1xudGVzdFRhYmxlTmFtZXNBc3luYygoKSA9PiBhZGIhKTtcbnRlc3RSZWdyZXNzaW9uQXN5bmMoKCkgPT4gYWRiISk7XG50ZXN0QWxsVHlwZXMoKCkgPT4gZGIhKTtcbnRlc3RBbGxUeXBlc0FzeW5jKCgpID0+IGFkYiEpO1xudGVzdEJpbmRpbmdzKCgpID0+IGRiISwgZGF0YVVSTCk7XG50ZXN0QXN5bmNCaW5kaW5ncygoKSA9PiBhZGIhLCBkYXRhVVJMLCBkdWNrZGIuRHVja0RCRGF0YVByb3RvY29sLkhUVFApO1xudGVzdEJhdGNoU3RyZWFtKCgpID0+IGRiISk7XG50ZXN0QXN5bmNCYXRjaFN0cmVhbSgoKSA9PiBhZGIhKTtcbnRlc3RGaWxlc3lzdGVtKCgpID0+IGFkYiEsIHJlc29sdmVEYXRhLCBkYXRhVVJMLCBkdWNrZGIuRHVja0RCRGF0YVByb3RvY29sLkhUVFApO1xudGVzdEFycm93SW5zZXJ0KCgpID0+IGRiISk7XG50ZXN0QXJyb3dJbnNlcnRBc3luYygoKSA9PiBhZGIhKTtcbnRlc3RKU09OSW5zZXJ0KCgpID0+IGRiISk7XG50ZXN0SlNPTkluc2VydEFzeW5jKCgpID0+IGFkYiEpO1xudGVzdENTVkluc2VydCgoKSA9PiBkYiEpO1xudGVzdENTVkluc2VydEFzeW5jKCgpID0+IGFkYiEpO1xudGVzdFRva2VuaXphdGlvbigoKSA9PiBkYiEpO1xudGVzdFRva2VuaXphdGlvbkFzeW5jKCgpID0+IGFkYiEpO1xuLy90ZXN0RVhDRUwoKCkgPT4gZGIhKTtcbi8vdGVzdEpTT04oKCkgPT4gZGIhKTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsd0NBQUFBLFVBQUFDLFNBQUE7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SyxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssS0FBSyxJQUNsRixLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUs7QUFFMUIsY0FBSSxNQUFNLFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDOUQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sS0FBTSxNQUN0RCxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxJQUFLLE1BQ3JELFVBQVcsTUFBTSxJQUFLLE1BQVEsVUFBVSxLQUFLLE1BQzdDLFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sS0FBTSxNQUN0RCxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxJQUFLLE1BQ3JELFVBQVcsTUFBTSxJQUFLLE1BQVEsVUFBVSxLQUFLLE1BQzdDLFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sS0FBTSxNQUN0RCxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxJQUFLLE1BQ3JELFVBQVcsTUFBTSxJQUFLLE1BQVEsVUFBVSxLQUFLLE1BQzdDLFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sS0FBTSxNQUN0RCxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxJQUFLLE1BQ3JELFVBQVcsTUFBTSxJQUFLLE1BQVEsVUFBVSxLQUFLLE1BQzdDLFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sS0FBTSxNQUN0RCxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxJQUFLLE1BQ3JELFVBQVcsTUFBTSxJQUFLLE1BQVEsVUFBVSxLQUFLLE1BQzdDLFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxN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SUFBQUEsTUFBQUEsTUFBQSxhQUFBLEtBQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFVBQUEsS0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsVUFBQSxLQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxlQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGNBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsVUFBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxZQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFdBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEscUJBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsbUJBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsU0FBQSxNQUFBO0FBRUEsSUFBQUEsTUFBQUEsTUFBQSxnQkFBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxVQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFdBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsV0FBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxXQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFdBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsWUFBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxZQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFlBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsYUFBQSxPQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxhQUFBLE9BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGFBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsYUFBQSxPQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxxQkFBQSxPQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxxQkFBQSxPQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSwwQkFBQSxPQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSwwQkFBQSxPQUFBO0FB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O0FBQzdCLG1CQUFpQixNQUFNLEVBQUc7QUFDMUIsd0JBQXNCLE1BQU0sR0FBSTsiLAogICJuYW1lcyI6IFsiZXhwb3J0cyIsICJtb2R1bGUiLCAiX19leHRlbmRzIiwgIl9fYXNzaWduIiwgIl9fcmVzdCIsICJfX2RlY29yYXRlIiwgIl9fcGFyYW0iLCAiX19tZXRhZGF0YSIsICJfX2F3YWl0ZXIiLCAiX19nZW5lcmF0b3IiLCAiX19leHBvcnRTdGFyIiwgIl9fdmFsdWVzIiwgIl9fcmVhZCIsICJfX3NwcmVhZCIsICJfX3NwcmVhZEFycmF5cyIsICJfX3NwcmVhZEFycmF5IiwgIl9fYXdhaXQiLCAiX19hc3luY0dlbmVyYXRvciIsICJfX2FzeW5jRGVsZWdhdG9yIiwgIl9fYXN5bmNWYWx1ZXMiLCAiX19tYWtlVGVtcGxhdGVPYmplY3QiLCAiX19pbXBvcnRTdGFyIiwgIl9faW1wb3J0RGVmYXVsdCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEluIiwgIl9fY3JlYXRlQmluZGluZyIsICJyb290IiwgInYiLCAiaXMyMjQiLCAibWV0aG9kIiwgImJsb2NrcyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJ0c2xpYiIsICJpdCIsICJzb3VyY2UiLCAicHVtcCIsICJpdCIsICJldmVudHMiLCAiZXJyIiwgIk1ldGFkYXRhVmVyc2lvbiIsICJVbmlvbk1vZGUiLCAiUHJlY2lzaW9uIiwgIkRhdGVVbml0IiwgIlRpbWVVbml0IiwgIkludGVydmFsVW5pdCIsICJNZXNzYWdlSGVhZGVyIiwgIlR5cGUiLCAiQnVmZmVyVHlwZSIsICJ4IiwgIl9hIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgIl9hIiwgImluc3RhbmNlIiwgImdldEJvb2wiLCAic2V0Qm9vbCIsICJzdW0iLCAiYnl0ZUxlbmd0aCIsICJudWxsQml0bWFwIiwgImxlbmd0aCIsICJnZXRCb29sIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgIl9hIiwgIl9iIiwgIl9kIiwgIl9jIiwgImluc3RhbmNlIiwgImJlZ2luIiwgImVuZCIsICJuZXdEYXRhIiwgIl9hIiwgInNpemUiLCAiX2EiLCAiX2IiLCAiX2MiLCAiX2QiLCAiRW5jb2RpbmciLCAiQnVpbGRlciIsICJNZXRhZGF0YVZlcnNpb24iLCAiRW5kaWFubmVzcyIsICJEaWN0aW9uYXJ5S2luZCIsICJCaW5hcnkiLCAiQm9vbCIsICJEYXRlVW5pdCIsICJEYXRlIiwgIkRhdGVVbml0IiwgIkRlY2ltYWwiLCAiVGltZVVuaXQiLCAiRml4ZWRTaXplQmluYXJ5IiwgIkZpeGVkU2l6ZUxpc3QiLCAiUHJlY2lzaW9uIiwgIlByZWNpc2lvbiIsICJJbnRlcnZhbFVuaXQiLCAiSW50ZXJ2YWxVbml0IiwgIkxpc3QiLCAiTWFwIiwgIk51bGwiLCAiVGltZVVuaXQiLCAiVGltZVVuaXQiLCAiVW5pb25Nb2RlIiwgIlVuaW9uTW9kZSIsICJVdGY4IiwgIlR5cGUiLCAiVHlwZSIsICJNZXRhZGF0YVZlcnNpb24iLCAiU2NoZW1hIiwgIkZpZWxkIiwgIkxvbmciLCAiQnVpbGRlciIsICJCeXRlQnVmZmVyIiwgIlNjaGVtYSIsICJkYiIsICJMb25nIiwgIl9iIiwgIl9jIiwgIkludDY0IiwgIlVpbnQ2NCIsICJzdW0iLCAiRmllbGQiLCAiSW50NjQiLCAiRmllbGQiLCAiRmllbGQiLCAiRmllbGQiLCAiRmllbGQiLCAiRmllbGQiLCAiaW5zdGFuY2UiLCAiaW5zdGFuY2UiLCAiaW5zdGFuY2UiLCAidHlwZSIsICJGaWVsZCIsICJfYSIsICJTY2hlbWEiLCAic2NoZW1hIiwgIkZpZWxkIiwgImJhdGNoZXMiLCAiX2MiLCAiX2IiLCAiaW5zdGFuY2UiLCAiZGF0YSIsICJpbmRpY2VzIiwgIm9sZFRvTmV3IiwgIl9hIiwgIlNjaGVtYSIsICJGaWVsZCIsICJpbnN0YW5jZSIsICJfYiIsICJfYSIsICJCb2R5Q29tcHJlc3Npb25NZXRob2QiLCAiQ29tcHJlc3Npb25UeXBlIiwgIm1ldGhvZCIsICJCdWZmZXIiLCAiUmVjb3JkQmF0Y2giLCAiQnVmZmVyIiwgIlJlY29yZEJhdGNoIiwgIk1lc3NhZ2VIZWFkZXIiLCAiTWV0YWRhdGFWZXJzaW9uIiwgIk1lc3NhZ2VIZWFkZXIiLCAiTG9uZyIsICJOdWxsIiwgIkJpbmFyeSIsICJCb29sIiwgIlV0ZjgiLCAiRGVjaW1hbCIsICJEYXRlIiwgIkxpc3QiLCAiRml4ZWRTaXplQmluYXJ5IiwgIkZpeGVkU2l6ZUxpc3QiLCAiTWFwIiwgImluc3RhbmNlIiwgIlNjaGVtYSIsICJSZWNvcmRCYXRjaCIsICJEaWN0aW9uYXJ5QmF0Y2giLCAiRmllbGQiLCAiRmllbGROb2RlIiwgInN1bSIsICJMb25nIiwgIkJ1aWxkZXIiLCAiQnl0ZUJ1ZmZlciIsICJNZXNzYWdlIiwgIlNjaGVtYSIsICJSZWNvcmRCYXRjaCIsICJEaWN0aW9uYXJ5QmF0Y2giLCAiRmllbGROb2RlIiwgIkZpZWxkIiwgIlR5cGUiLCAiRGVjaW1hbCIsICJEYXRlIiwgIkZpeGVkU2l6ZUJpbmFyeSIsICJGaXhlZFNpemVMaXN0IiwgIk1hcCIsICJpbnN0YW5jZSIsICJCdWZmZXIiLCAiTWVzc2FnZSIsICJfYSIsICJfYiIsICJfYyIsICJzZWxmIiwgIkZpZWxkTm9kZSIsICJNZXNzYWdlIiwgIlJlY29yZEJhdGNoIiwgIkRpY3Rpb25hcnlCYXRjaCIsICJpdCIsICJfYSIsICJyZWFkZXIiLCAidG1wIiwgImRlY29kZXIiLCAiZjY0IiwgImJsb2NrcyIsICJURVhUX0VOQ09ERVIiLCAid29ya2VyIiwgIlRFWFRfRU5DT0RFUiIsICJlIiwgIm1ldGhvZCIsICJ4aHIiLCAicmVzdWx0IiwgIkR1Y2tEQiIsICJyZXF1aXJlIiwgImVyciIsICJhc20iLCAiZ2V0QmluYXJ5IiwgImluc3RhbmNlIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImdldFZhbHVlIiwgImZkIiwgInRtcCIsICJNb2R1bGUiLCAib3V0IiwgImZhbWlseSIsICJ0eXBlIiwgInByb3RvIiwgImNhbm9uIiwgImFkZHIiLCAicG9ydCIsICJhaSIsICJzdW0iLCAiZGF0ZSIsICJyZXQiLCAicmVzcG9uc2UiLCAiRHVja0RCIiwgImltcG9ydF9tZXRhIiwgIkR1Y2tEQiIsICJyZXF1aXJlIiwgImVyciIsICJhc20iLCAiZ2V0QmluYXJ5IiwgImluc3RhbmNlIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImdldFZhbHVlIiwgImZkIiwgInRtcCIsICJNb2R1bGUiLCAib3V0IiwgImZhbWlseSIsICJ0eXBlIiwgInByb3RvIiwgImNhbm9uIiwgImFkZHIiLCAicG9ydCIsICJhaSIsICJzdW0iLCAiZGF0ZSIsICJyZXQiLCAiRHVja0RCIiwgIkR1Y2tEQiIsICJkYiIsICJURVhUX0VOQ09ERVIiLCAid29ya2VyIiwgIl9wIiwgIldvcmtlciIsICJkYiIsICJtb2R1bGUiLCAiYWRiIiwgInJlc29sdmVEYXRhIiwgImRiIiwgImJhc2VVUkwiLCAiYWRiIiwgImRiIiwgInRlc3RSb3dzIiwgImRiIiwgImRlY29kZXIiLCAiZGIiLCAicmVzb2x2ZURhdGEiLCAiU2NoZW1hIiwgIkZpZWxkIiwgImRiIiwgImVuY29kZXIiLCAiZGIiLCAiZGVzY3JpYmVCcm93c2VyIiwgImVuY29kZXIiLCAiVEVTVF9GSUxFIiwgImRiIiwgImRiIiwgImRiIiwgImRiIiwgImFkYiIsICJkYiIsICJkYiIsICJkYiIsICJkYiIsICJhZGIiLCAiZGIiXQp9Cg==
