"use strict";
var duckdb = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "../../node_modules/tslib/tslib.js"(exports2, module2) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __classPrivateFieldIn2;
      var __createBinding2;
      (function(factory) {
        var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports3) {
            factory(createExporter(root2, createExporter(exports3)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root2, createExporter(module2.exports)));
        } else {
          factory(createExporter(root2));
        }
        function createExporter(exports3, previous) {
          if (exports3 !== root2) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports3, "__esModule", { value: true });
            } else {
              exports3.__esModule = true;
            }
          }
          return function(id, v) {
            return exports3[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends2 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest2 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
          return c > 3 && r && Object.defineProperty(target, key, r), r;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding2(o, m, p);
        };
        __createBinding2 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values2 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read2(arguments[i]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray2 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await2 = function(v) {
          return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f, v) {
            if (f(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
            } : f;
          }
        };
        __asyncValues2 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding2(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, state, kind, f) {
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn2 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
      });
    }
  });

  // ../../node_modules/js-sha256/src/sha256.js
  var require_sha256 = __commonJS({
    "../../node_modules/js-sha256/src/sha256.js"(exports, module) {
      (function() {
        "use strict";
        var ERROR = "input is invalid type";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA256_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, is2242) {
          return function(message) {
            return new Sha256(is2242, true).update(message)[outputType]();
          };
        };
        var createMethod = function(is2242) {
          var method2 = createOutputMethod("hex", is2242);
          if (NODE_JS) {
            method2 = nodeWrap(method2, is2242);
          }
          method2.create = function() {
            return new Sha256(is2242);
          };
          method2.update = function(message) {
            return method2.create().update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createOutputMethod(type, is2242);
          }
          return method2;
        };
        var nodeWrap = function(method, is224) {
          var crypto = eval("require('crypto')");
          var Buffer = eval("require('buffer').Buffer");
          var algorithm = is224 ? "sha224" : "sha256";
          var nodeMethod = function(message) {
            if (typeof message === "string") {
              return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
            } else {
              if (message === null || message === void 0) {
                throw new Error(ERROR);
              } else if (message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              }
            }
            if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
              return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
            } else {
              return method(message);
            }
          };
          return nodeMethod;
        };
        var createHmacOutputMethod = function(outputType, is2242) {
          return function(key, message) {
            return new HmacSha256(key, is2242, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(is2242) {
          var method2 = createHmacOutputMethod("hex", is2242);
          method2.create = function(key) {
            return new HmacSha256(key, is2242);
          };
          method2.update = function(key, message) {
            return method2.create(key).update(message);
          };
          for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
            var type = OUTPUT_TYPES[i];
            method2[type] = createHmacOutputMethod(type, is2242);
          }
          return method2;
        };
        function Sha256(is2242, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (is2242) {
            this.h0 = 3238371032;
            this.h1 = 914150663;
            this.h2 = 812702999;
            this.h3 = 4144912697;
            this.h4 = 4290775857;
            this.h5 = 1750603025;
            this.h6 = 1694076839;
            this.h7 = 3204075428;
          } else {
            this.h0 = 1779033703;
            this.h1 = 3144134277;
            this.h2 = 1013904242;
            this.h3 = 2773480762;
            this.h4 = 1359893119;
            this.h5 = 2600822924;
            this.h6 = 528734635;
            this.h7 = 1541459225;
          }
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
          this.first = true;
          this.is224 = is2242;
        }
        Sha256.prototype.update = function(message) {
          if (this.finalized) {
            return;
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
            notString = true;
          }
          var code, index = 0, i, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
            }
            if (notString) {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
            this.lastByteIndex = i;
            this.bytes += i - this.start;
            if (i >= 64) {
              this.block = blocks2[16];
              this.start = i - 64;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha256.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i = this.lastByteIndex;
          blocks2[16] = this.block;
          blocks2[i >> 2] |= EXTRA[i & 3];
          this.block = blocks2[16];
          if (i >= 56) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[15] = this.bytes << 3;
          this.hash();
        };
        Sha256.prototype.hash = function() {
          var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks2 = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
          for (j = 16; j < 64; ++j) {
            t1 = blocks2[j - 15];
            s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
            t1 = blocks2[j - 2];
            s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            blocks2[j] = blocks2[j - 16] + s0 + blocks2[j - 7] + s1 << 0;
          }
          bc = b & c;
          for (j = 0; j < 64; j += 4) {
            if (this.first) {
              if (this.is224) {
                ab = 300032;
                t1 = blocks2[0] - 1413257819;
                h = t1 - 150054599 << 0;
                d = t1 + 24177077 << 0;
              } else {
                ab = 704751109;
                t1 = blocks2[0] - 210244248;
                h = t1 - 1521486534 << 0;
                d = t1 + 143694565 << 0;
              }
              this.first = false;
            } else {
              s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
              s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
              ab = a & b;
              maj = ab ^ a & c ^ bc;
              ch = e & f ^ ~e & g;
              t1 = h + s1 + ch + K[j] + blocks2[j];
              t2 = s0 + maj;
              h = d + t1 << 0;
              d = t1 + t2 << 0;
            }
            s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);
            s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
            da = d & a;
            maj = da ^ d & b ^ ab;
            ch = h & e ^ ~h & f;
            t1 = g + s1 + ch + K[j + 1] + blocks2[j + 1];
            t2 = s0 + maj;
            g = c + t1 << 0;
            c = t1 + t2 << 0;
            s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
            s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);
            cd = c & d;
            maj = cd ^ c & a ^ da;
            ch = g & h ^ ~g & e;
            t1 = f + s1 + ch + K[j + 2] + blocks2[j + 2];
            t2 = s0 + maj;
            f = b + t1 << 0;
            b = t1 + t2 << 0;
            s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);
            s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);
            bc = b & c;
            maj = bc ^ b & d ^ cd;
            ch = f & g ^ ~f & h;
            t1 = e + s1 + ch + K[j + 3] + blocks2[j + 3];
            t2 = s0 + maj;
            e = a + t1 << 0;
            a = t1 + t2 << 0;
          }
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
          this.h4 = this.h4 + e << 0;
          this.h5 = this.h5 + f << 0;
          this.h6 = this.h6 + g << 0;
          this.h7 = this.h7 + h << 0;
        };
        Sha256.prototype.hex = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
          if (!this.is224) {
            hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
          }
          return hex;
        };
        Sha256.prototype.toString = Sha256.prototype.hex;
        Sha256.prototype.digest = function() {
          this.finalize();
          var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
          var arr = [
            h0 >> 24 & 255,
            h0 >> 16 & 255,
            h0 >> 8 & 255,
            h0 & 255,
            h1 >> 24 & 255,
            h1 >> 16 & 255,
            h1 >> 8 & 255,
            h1 & 255,
            h2 >> 24 & 255,
            h2 >> 16 & 255,
            h2 >> 8 & 255,
            h2 & 255,
            h3 >> 24 & 255,
            h3 >> 16 & 255,
            h3 >> 8 & 255,
            h3 & 255,
            h4 >> 24 & 255,
            h4 >> 16 & 255,
            h4 >> 8 & 255,
            h4 & 255,
            h5 >> 24 & 255,
            h5 >> 16 & 255,
            h5 >> 8 & 255,
            h5 & 255,
            h6 >> 24 & 255,
            h6 >> 16 & 255,
            h6 >> 8 & 255,
            h6 & 255
          ];
          if (!this.is224) {
            arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
          }
          return arr;
        };
        Sha256.prototype.array = Sha256.prototype.digest;
        Sha256.prototype.arrayBuffer = function() {
          this.finalize();
          var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0);
          dataView.setUint32(4, this.h1);
          dataView.setUint32(8, this.h2);
          dataView.setUint32(12, this.h3);
          dataView.setUint32(16, this.h4);
          dataView.setUint32(20, this.h5);
          dataView.setUint32(24, this.h6);
          if (!this.is224) {
            dataView.setUint32(28, this.h7);
          }
          return buffer;
        };
        function HmacSha256(key, is2242, sharedMemory) {
          var i, type = typeof key;
          if (type === "string") {
            var bytes = [], length = key.length, index = 0, code;
            for (i = 0; i < length; ++i) {
              code = key.charCodeAt(i);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          } else {
            if (type === "object") {
              if (key === null) {
                throw new Error(ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(ERROR);
                }
              }
            } else {
              throw new Error(ERROR);
            }
          }
          if (key.length > 64) {
            key = new Sha256(is2242, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (i = 0; i < 64; ++i) {
            var b = key[i] || 0;
            oKeyPad[i] = 92 ^ b;
            iKeyPad[i] = 54 ^ b;
          }
          Sha256.call(this, is2242, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha256.prototype = new Sha256();
        HmacSha256.prototype.finalize = function() {
          Sha256.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha256.call(this, this.is224, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha256.prototype.finalize.call(this);
          }
        };
        var exports = createMethod();
        exports.sha256 = exports;
        exports.sha224 = createMethod(true);
        exports.sha256.hmac = createHmacMethod();
        exports.sha224.hmac = createHmacMethod(true);
        if (COMMON_JS) {
          module.exports = exports;
        } else {
          root.sha256 = exports.sha256;
          root.sha224 = exports.sha224;
          if (AMD) {
            define(function() {
              return exports;
            });
          }
        }
      })();
    }
  });

  // ../../node_modules/web-worker/cjs/browser.js
  var require_browser = __commonJS({
    "../../node_modules/web-worker/cjs/browser.js"(exports2, module2) {
      module2.exports = Worker;
    }
  });

  // ../../node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // ../../node_modules/apache-arrow/util/buffer.mjs
  var buffer_exports = {};
  __export(buffer_exports, {
    compareArrayLike: () => compareArrayLike,
    joinUint8Arrays: () => joinUint8Arrays,
    memcpy: () => memcpy,
    rebaseValueOffsets: () => rebaseValueOffsets,
    toArrayBufferView: () => toArrayBufferView,
    toArrayBufferViewAsyncIterator: () => toArrayBufferViewAsyncIterator,
    toArrayBufferViewIterator: () => toArrayBufferViewIterator,
    toBigInt64Array: () => toBigInt64Array,
    toBigUint64Array: () => toBigUint64Array,
    toFloat32Array: () => toFloat32Array,
    toFloat32ArrayAsyncIterator: () => toFloat32ArrayAsyncIterator,
    toFloat32ArrayIterator: () => toFloat32ArrayIterator,
    toFloat64Array: () => toFloat64Array,
    toFloat64ArrayAsyncIterator: () => toFloat64ArrayAsyncIterator,
    toFloat64ArrayIterator: () => toFloat64ArrayIterator,
    toInt16Array: () => toInt16Array,
    toInt16ArrayAsyncIterator: () => toInt16ArrayAsyncIterator,
    toInt16ArrayIterator: () => toInt16ArrayIterator,
    toInt32Array: () => toInt32Array,
    toInt32ArrayAsyncIterator: () => toInt32ArrayAsyncIterator,
    toInt32ArrayIterator: () => toInt32ArrayIterator,
    toInt8Array: () => toInt8Array,
    toInt8ArrayAsyncIterator: () => toInt8ArrayAsyncIterator,
    toInt8ArrayIterator: () => toInt8ArrayIterator,
    toUint16Array: () => toUint16Array,
    toUint16ArrayAsyncIterator: () => toUint16ArrayAsyncIterator,
    toUint16ArrayIterator: () => toUint16ArrayIterator,
    toUint32Array: () => toUint32Array,
    toUint32ArrayAsyncIterator: () => toUint32ArrayAsyncIterator,
    toUint32ArrayIterator: () => toUint32ArrayIterator,
    toUint8Array: () => toUint8Array,
    toUint8ArrayAsyncIterator: () => toUint8ArrayAsyncIterator,
    toUint8ArrayIterator: () => toUint8ArrayIterator,
    toUint8ClampedArray: () => toUint8ClampedArray,
    toUint8ClampedArrayAsyncIterator: () => toUint8ClampedArrayAsyncIterator,
    toUint8ClampedArrayIterator: () => toUint8ClampedArrayIterator
  });

  // ../../node_modules/apache-arrow/util/utf8.mjs
  var decoder = new TextDecoder("utf-8");
  var decodeUtf8 = (buffer) => decoder.decode(buffer);
  var encoder = new TextEncoder();
  var encodeUtf8 = (value) => encoder.encode(value);

  // ../../node_modules/apache-arrow/util/compat.mjs
  var [BigIntCtor, BigIntAvailable] = (() => {
    const BigIntUnavailableError = () => {
      throw new Error("BigInt is not available in this environment");
    };
    function BigIntUnavailable() {
      throw BigIntUnavailableError();
    }
    BigIntUnavailable.asIntN = () => {
      throw BigIntUnavailableError();
    };
    BigIntUnavailable.asUintN = () => {
      throw BigIntUnavailableError();
    };
    return typeof BigInt !== "undefined" ? [BigInt, true] : [BigIntUnavailable, false];
  })();
  var [BigInt64ArrayCtor, BigInt64ArrayAvailable] = (() => {
    const BigInt64ArrayUnavailableError = () => {
      throw new Error("BigInt64Array is not available in this environment");
    };
    class BigInt64ArrayUnavailable {
      static get BYTES_PER_ELEMENT() {
        return 8;
      }
      static of() {
        throw BigInt64ArrayUnavailableError();
      }
      static from() {
        throw BigInt64ArrayUnavailableError();
      }
      constructor() {
        throw BigInt64ArrayUnavailableError();
      }
    }
    return typeof BigInt64Array !== "undefined" ? [BigInt64Array, true] : [BigInt64ArrayUnavailable, false];
  })();
  var [BigUint64ArrayCtor, BigUint64ArrayAvailable] = (() => {
    const BigUint64ArrayUnavailableError = () => {
      throw new Error("BigUint64Array is not available in this environment");
    };
    class BigUint64ArrayUnavailable {
      static get BYTES_PER_ELEMENT() {
        return 8;
      }
      static of() {
        throw BigUint64ArrayUnavailableError();
      }
      static from() {
        throw BigUint64ArrayUnavailableError();
      }
      constructor() {
        throw BigUint64ArrayUnavailableError();
      }
    }
    return typeof BigUint64Array !== "undefined" ? [BigUint64Array, true] : [BigUint64ArrayUnavailable, false];
  })();
  var isNumber = (x) => typeof x === "number";
  var isBoolean = (x) => typeof x === "boolean";
  var isFunction = (x) => typeof x === "function";
  var isObject = (x) => x != null && Object(x) === x;
  var isPromise = (x) => {
    return isObject(x) && isFunction(x.then);
  };
  var isIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.iterator]);
  };
  var isAsyncIterable = (x) => {
    return isObject(x) && isFunction(x[Symbol.asyncIterator]);
  };
  var isArrowJSON = (x) => {
    return isObject(x) && isObject(x["schema"]);
  };
  var isIteratorResult = (x) => {
    return isObject(x) && "done" in x && "value" in x;
  };
  var isFileHandle = (x) => {
    return isObject(x) && isFunction(x["stat"]) && isNumber(x["fd"]);
  };
  var isFetchResponse = (x) => {
    return isObject(x) && isReadableDOMStream(x["body"]);
  };
  var isReadableInterop = (x) => "_getDOMStream" in x && "_getNodeStream" in x;
  var isWritableDOMStream = (x) => {
    return isObject(x) && isFunction(x["abort"]) && isFunction(x["getWriter"]) && !isReadableInterop(x);
  };
  var isReadableDOMStream = (x) => {
    return isObject(x) && isFunction(x["cancel"]) && isFunction(x["getReader"]) && !isReadableInterop(x);
  };
  var isWritableNodeStream = (x) => {
    return isObject(x) && isFunction(x["end"]) && isFunction(x["write"]) && isBoolean(x["writable"]) && !isReadableInterop(x);
  };
  var isReadableNodeStream = (x) => {
    return isObject(x) && isFunction(x["read"]) && isFunction(x["pipe"]) && isBoolean(x["readable"]) && !isReadableInterop(x);
  };
  var isFlatbuffersByteBuffer = (x) => {
    return isObject(x) && isFunction(x["clear"]) && isFunction(x["bytes"]) && isFunction(x["position"]) && isFunction(x["setPosition"]) && isFunction(x["capacity"]) && isFunction(x["getBufferIdentifier"]) && isFunction(x["createLong"]);
  };

  // ../../node_modules/apache-arrow/util/buffer.mjs
  var SharedArrayBuf = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : ArrayBuffer;
  function collapseContiguousByteRanges(chunks) {
    const result = chunks[0] ? [chunks[0]] : [];
    let xOffset, yOffset, xLen, yLen;
    for (let x, y, i = 0, j = 0, n = chunks.length; ++i < n; ) {
      x = result[j];
      y = chunks[i];
      if (!x || !y || x.buffer !== y.buffer || y.byteOffset < x.byteOffset) {
        y && (result[++j] = y);
        continue;
      }
      ({ byteOffset: xOffset, byteLength: xLen } = x);
      ({ byteOffset: yOffset, byteLength: yLen } = y);
      if (xOffset + xLen < yOffset || yOffset + yLen < xOffset) {
        y && (result[++j] = y);
        continue;
      }
      result[j] = new Uint8Array(x.buffer, xOffset, yOffset - xOffset + yLen);
    }
    return result;
  }
  function memcpy(target, source, targetByteOffset = 0, sourceByteLength = source.byteLength) {
    const targetByteLength = target.byteLength;
    const dst = new Uint8Array(target.buffer, target.byteOffset, targetByteLength);
    const src = new Uint8Array(source.buffer, source.byteOffset, Math.min(sourceByteLength, targetByteLength));
    dst.set(src, targetByteOffset);
    return target;
  }
  function joinUint8Arrays(chunks, size) {
    const result = collapseContiguousByteRanges(chunks);
    const byteLength = result.reduce((x, b) => x + b.byteLength, 0);
    let source, sliced, buffer;
    let offset = 0, index = -1;
    const length = Math.min(size || Number.POSITIVE_INFINITY, byteLength);
    for (const n = result.length; ++index < n; ) {
      source = result[index];
      sliced = source.subarray(0, Math.min(source.length, length - offset));
      if (length <= offset + sliced.length) {
        if (sliced.length < source.length) {
          result[index] = source.subarray(sliced.length);
        } else if (sliced.length === source.length) {
          index++;
        }
        buffer ? memcpy(buffer, sliced, offset) : buffer = sliced;
        break;
      }
      memcpy(buffer || (buffer = new Uint8Array(length)), sliced, offset);
      offset += sliced.length;
    }
    return [buffer || new Uint8Array(0), result.slice(index), byteLength - (buffer ? buffer.byteLength : 0)];
  }
  function toArrayBufferView(ArrayBufferViewCtor, input) {
    let value = isIteratorResult(input) ? input.value : input;
    if (value instanceof ArrayBufferViewCtor) {
      if (ArrayBufferViewCtor === Uint8Array) {
        return new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength);
      }
      return value;
    }
    if (!value) {
      return new ArrayBufferViewCtor(0);
    }
    if (typeof value === "string") {
      value = encodeUtf8(value);
    }
    if (value instanceof ArrayBuffer) {
      return new ArrayBufferViewCtor(value);
    }
    if (value instanceof SharedArrayBuf) {
      return new ArrayBufferViewCtor(value);
    }
    if (isFlatbuffersByteBuffer(value)) {
      return toArrayBufferView(ArrayBufferViewCtor, value.bytes());
    }
    return !ArrayBuffer.isView(value) ? ArrayBufferViewCtor.from(value) : value.byteLength <= 0 ? new ArrayBufferViewCtor(0) : new ArrayBufferViewCtor(value.buffer, value.byteOffset, value.byteLength / ArrayBufferViewCtor.BYTES_PER_ELEMENT);
  }
  var toInt8Array = (input) => toArrayBufferView(Int8Array, input);
  var toInt16Array = (input) => toArrayBufferView(Int16Array, input);
  var toInt32Array = (input) => toArrayBufferView(Int32Array, input);
  var toBigInt64Array = (input) => toArrayBufferView(BigInt64ArrayCtor, input);
  var toUint8Array = (input) => toArrayBufferView(Uint8Array, input);
  var toUint16Array = (input) => toArrayBufferView(Uint16Array, input);
  var toUint32Array = (input) => toArrayBufferView(Uint32Array, input);
  var toBigUint64Array = (input) => toArrayBufferView(BigUint64ArrayCtor, input);
  var toFloat32Array = (input) => toArrayBufferView(Float32Array, input);
  var toFloat64Array = (input) => toArrayBufferView(Float64Array, input);
  var toUint8ClampedArray = (input) => toArrayBufferView(Uint8ClampedArray, input);
  var pump = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* toArrayBufferViewIterator(ArrayCtor, source) {
    const wrap = function* (x) {
      yield x;
    };
    const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : !isIterable(source) ? wrap(source) : source;
    yield* pump(function* (it2) {
      let r = null;
      do {
        r = it2.next(yield toArrayBufferView(ArrayCtor, r));
      } while (!r.done);
    }(buffers[Symbol.iterator]()));
    return new ArrayCtor();
  }
  var toInt8ArrayIterator = (input) => toArrayBufferViewIterator(Int8Array, input);
  var toInt16ArrayIterator = (input) => toArrayBufferViewIterator(Int16Array, input);
  var toInt32ArrayIterator = (input) => toArrayBufferViewIterator(Int32Array, input);
  var toUint8ArrayIterator = (input) => toArrayBufferViewIterator(Uint8Array, input);
  var toUint16ArrayIterator = (input) => toArrayBufferViewIterator(Uint16Array, input);
  var toUint32ArrayIterator = (input) => toArrayBufferViewIterator(Uint32Array, input);
  var toFloat32ArrayIterator = (input) => toArrayBufferViewIterator(Float32Array, input);
  var toFloat64ArrayIterator = (input) => toArrayBufferViewIterator(Float64Array, input);
  var toUint8ClampedArrayIterator = (input) => toArrayBufferViewIterator(Uint8ClampedArray, input);
  function toArrayBufferViewAsyncIterator(ArrayCtor, source) {
    return __asyncGenerator(this, arguments, function* toArrayBufferViewAsyncIterator_1() {
      if (isPromise(source)) {
        return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(toArrayBufferViewAsyncIterator(ArrayCtor, yield __await(source))))));
      }
      const wrap = function(x) {
        return __asyncGenerator(this, arguments, function* () {
          yield yield __await(yield __await(x));
        });
      };
      const emit = function(source2) {
        return __asyncGenerator(this, arguments, function* () {
          yield __await(yield* __asyncDelegator(__asyncValues(pump(function* (it2) {
            let r = null;
            do {
              r = it2.next(yield r === null || r === void 0 ? void 0 : r.value);
            } while (!r.done);
          }(source2[Symbol.iterator]())))));
        });
      };
      const buffers = typeof source === "string" ? wrap(source) : ArrayBuffer.isView(source) ? wrap(source) : source instanceof ArrayBuffer ? wrap(source) : source instanceof SharedArrayBuf ? wrap(source) : isIterable(source) ? emit(source) : !isAsyncIterable(source) ? wrap(source) : source;
      yield __await(
        yield* __asyncDelegator(__asyncValues(pump(function(it2) {
          return __asyncGenerator(this, arguments, function* () {
            let r = null;
            do {
              r = yield __await(it2.next(yield yield __await(toArrayBufferView(ArrayCtor, r))));
            } while (!r.done);
          });
        }(buffers[Symbol.asyncIterator]()))))
      );
      return yield __await(new ArrayCtor());
    });
  }
  var toInt8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int8Array, input);
  var toInt16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int16Array, input);
  var toInt32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Int32Array, input);
  var toUint8ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8Array, input);
  var toUint16ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint16Array, input);
  var toUint32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint32Array, input);
  var toFloat32ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float32Array, input);
  var toFloat64ArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Float64Array, input);
  var toUint8ClampedArrayAsyncIterator = (input) => toArrayBufferViewAsyncIterator(Uint8ClampedArray, input);
  function rebaseValueOffsets(offset, length, valueOffsets) {
    if (offset !== 0) {
      valueOffsets = valueOffsets.slice(0, length + 1);
      for (let i = -1; ++i <= length; ) {
        valueOffsets[i] += offset;
      }
    }
    return valueOffsets;
  }
  function compareArrayLike(a, b) {
    let i = 0;
    const n = a.length;
    if (n !== b.length) {
      return false;
    }
    if (n > 0) {
      do {
        if (a[i] !== b[i]) {
          return false;
        }
      } while (++i < n);
    }
    return true;
  }

  // ../../node_modules/apache-arrow/io/adapters.mjs
  var adapters_default = {
    fromIterable(source) {
      return pump2(fromIterable(source));
    },
    fromAsyncIterable(source) {
      return pump2(fromAsyncIterable(source));
    },
    fromDOMStream(source) {
      return pump2(fromDOMStream(source));
    },
    fromNodeStream(stream) {
      return pump2(fromNodeStream(stream));
    },
    toDOMStream(source, options) {
      throw new Error(`"toDOMStream" not available in this environment`);
    },
    toNodeStream(source, options) {
      throw new Error(`"toNodeStream" not available in this environment`);
    }
  };
  var pump2 = (iterator) => {
    iterator.next();
    return iterator;
  };
  function* fromIterable(source) {
    let done, threw = false;
    let buffers = [], buffer;
    let cmd, size, bufferLength = 0;
    function byteRange() {
      if (cmd === "peek") {
        return joinUint8Arrays(buffers, size)[0];
      }
      [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
      return buffer;
    }
    ({ cmd, size } = yield null);
    const it2 = toUint8ArrayIterator(source)[Symbol.iterator]();
    try {
      do {
        ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? it2.next() : it2.next(size - bufferLength));
        if (!done && buffer.byteLength > 0) {
          buffers.push(buffer);
          bufferLength += buffer.byteLength;
        }
        if (done || size <= bufferLength) {
          do {
            ({ cmd, size } = yield byteRange());
          } while (size < bufferLength);
        }
      } while (!done);
    } catch (e) {
      (threw = true) && typeof it2.throw === "function" && it2.throw(e);
    } finally {
      threw === false && typeof it2.return === "function" && it2.return(null);
    }
    return null;
  }
  function fromAsyncIterable(source) {
    return __asyncGenerator(this, arguments, function* fromAsyncIterable_1() {
      let done, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2.next()) : yield __await(it2.next(size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(buffer);
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && typeof it2.throw === "function" && (yield __await(it2.throw(e)));
      } finally {
        threw === false && typeof it2.return === "function" && (yield __await(it2.return(new Uint8Array(0))));
      }
      return yield __await(null);
    });
  }
  function fromDOMStream(source) {
    return __asyncGenerator(this, arguments, function* fromDOMStream_1() {
      let done = false, threw = false;
      let buffers = [], buffer;
      let cmd, size, bufferLength = 0;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      const it2 = new AdaptiveByteReader(source);
      try {
        do {
          ({ done, value: buffer } = Number.isNaN(size - bufferLength) ? yield __await(it2["read"]()) : yield __await(it2["read"](size - bufferLength)));
          if (!done && buffer.byteLength > 0) {
            buffers.push(toUint8Array(buffer));
            bufferLength += buffer.byteLength;
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } catch (e) {
        (threw = true) && (yield __await(it2["cancel"](e)));
      } finally {
        threw === false ? yield __await(it2["cancel"]()) : source["locked"] && it2.releaseLock();
      }
      return yield __await(null);
    });
  }
  var AdaptiveByteReader = class {
    constructor(source) {
      this.source = source;
      this.reader = null;
      this.reader = this.source["getReader"]();
      this.reader["closed"].catch(() => {
      });
    }
    get closed() {
      return this.reader ? this.reader["closed"].catch(() => {
      }) : Promise.resolve();
    }
    releaseLock() {
      if (this.reader) {
        this.reader.releaseLock();
      }
      this.reader = null;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        const { reader, source } = this;
        reader && (yield reader["cancel"](reason).catch(() => {
        }));
        source && (source["locked"] && this.releaseLock());
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        if (size === 0) {
          return { done: this.reader == null, value: new Uint8Array(0) };
        }
        const result = yield this.reader.read();
        !result.done && (result.value = toUint8Array(result));
        return result;
      });
    }
  };
  var onEvent = (stream, event) => {
    const handler = (_) => resolve([event, _]);
    let resolve;
    return [event, handler, new Promise((r) => (resolve = r) && stream["once"](event, handler))];
  };
  function fromNodeStream(stream) {
    return __asyncGenerator(this, arguments, function* fromNodeStream_1() {
      const events = [];
      let event = "error";
      let done = false, err = null;
      let cmd, size, bufferLength = 0;
      let buffers = [], buffer;
      function byteRange() {
        if (cmd === "peek") {
          return joinUint8Arrays(buffers, size)[0];
        }
        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);
        return buffer;
      }
      ({ cmd, size } = yield yield __await(null));
      if (stream["isTTY"]) {
        yield yield __await(new Uint8Array(0));
        return yield __await(null);
      }
      try {
        events[0] = onEvent(stream, "end");
        events[1] = onEvent(stream, "error");
        do {
          events[2] = onEvent(stream, "readable");
          [event, err] = yield __await(Promise.race(events.map((x) => x[2])));
          if (event === "error") {
            break;
          }
          if (!(done = event === "end")) {
            if (!Number.isFinite(size - bufferLength)) {
              buffer = toUint8Array(stream["read"]());
            } else {
              buffer = toUint8Array(stream["read"](size - bufferLength));
              if (buffer.byteLength < size - bufferLength) {
                buffer = toUint8Array(stream["read"]());
              }
            }
            if (buffer.byteLength > 0) {
              buffers.push(buffer);
              bufferLength += buffer.byteLength;
            }
          }
          if (done || size <= bufferLength) {
            do {
              ({ cmd, size } = yield yield __await(byteRange()));
            } while (size < bufferLength);
          }
        } while (!done);
      } finally {
        yield __await(cleanup(events, event === "error" ? err : null));
      }
      return yield __await(null);
      function cleanup(events2, err2) {
        buffer = buffers = null;
        return new Promise((resolve, reject) => {
          for (const [evt, fn] of events2) {
            stream["off"](evt, fn);
          }
          try {
            const destroy = stream["destroy"];
            destroy && destroy.call(stream, err2);
            err2 = void 0;
          } catch (e) {
            err2 = e || err2;
          } finally {
            err2 != null ? reject(err2) : resolve();
          }
        });
      }
    });
  }

  // ../../node_modules/apache-arrow/enum.mjs
  var MetadataVersion;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion || (MetadataVersion = {}));
  var UnionMode;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode || (UnionMode = {}));
  var Precision;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision || (Precision = {}));
  var DateUnit;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit || (DateUnit = {}));
  var TimeUnit;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit || (TimeUnit = {}));
  var IntervalUnit;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit || (IntervalUnit = {}));
  var MessageHeader;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader || (MessageHeader = {}));
  var Type;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["Float"] = 3] = "Float";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct"] = 13] = "Struct";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Dictionary"] = -1] = "Dictionary";
    Type3[Type3["Int8"] = -2] = "Int8";
    Type3[Type3["Int16"] = -3] = "Int16";
    Type3[Type3["Int32"] = -4] = "Int32";
    Type3[Type3["Int64"] = -5] = "Int64";
    Type3[Type3["Uint8"] = -6] = "Uint8";
    Type3[Type3["Uint16"] = -7] = "Uint16";
    Type3[Type3["Uint32"] = -8] = "Uint32";
    Type3[Type3["Uint64"] = -9] = "Uint64";
    Type3[Type3["Float16"] = -10] = "Float16";
    Type3[Type3["Float32"] = -11] = "Float32";
    Type3[Type3["Float64"] = -12] = "Float64";
    Type3[Type3["DateDay"] = -13] = "DateDay";
    Type3[Type3["DateMillisecond"] = -14] = "DateMillisecond";
    Type3[Type3["TimestampSecond"] = -15] = "TimestampSecond";
    Type3[Type3["TimestampMillisecond"] = -16] = "TimestampMillisecond";
    Type3[Type3["TimestampMicrosecond"] = -17] = "TimestampMicrosecond";
    Type3[Type3["TimestampNanosecond"] = -18] = "TimestampNanosecond";
    Type3[Type3["TimeSecond"] = -19] = "TimeSecond";
    Type3[Type3["TimeMillisecond"] = -20] = "TimeMillisecond";
    Type3[Type3["TimeMicrosecond"] = -21] = "TimeMicrosecond";
    Type3[Type3["TimeNanosecond"] = -22] = "TimeNanosecond";
    Type3[Type3["DenseUnion"] = -23] = "DenseUnion";
    Type3[Type3["SparseUnion"] = -24] = "SparseUnion";
    Type3[Type3["IntervalDayTime"] = -25] = "IntervalDayTime";
    Type3[Type3["IntervalYearMonth"] = -26] = "IntervalYearMonth";
  })(Type || (Type = {}));
  var BufferType;
  (function(BufferType2) {
    BufferType2[BufferType2["OFFSET"] = 0] = "OFFSET";
    BufferType2[BufferType2["DATA"] = 1] = "DATA";
    BufferType2[BufferType2["VALIDITY"] = 2] = "VALIDITY";
    BufferType2[BufferType2["TYPE"] = 3] = "TYPE";
  })(BufferType || (BufferType = {}));

  // ../../node_modules/apache-arrow/util/vector.mjs
  var vector_exports = {};
  __export(vector_exports, {
    clampIndex: () => clampIndex,
    clampRange: () => clampRange,
    createElementComparator: () => createElementComparator
  });

  // ../../node_modules/apache-arrow/util/pretty.mjs
  var undf = void 0;
  function valueToString(x) {
    if (x === null) {
      return "null";
    }
    if (x === undf) {
      return "undefined";
    }
    switch (typeof x) {
      case "number":
        return `${x}`;
      case "bigint":
        return `${x}`;
      case "string":
        return `"${x}"`;
    }
    if (typeof x[Symbol.toPrimitive] === "function") {
      return x[Symbol.toPrimitive]("string");
    }
    if (ArrayBuffer.isView(x)) {
      if (x instanceof BigInt64ArrayCtor || x instanceof BigUint64ArrayCtor) {
        return `[${[...x].map((x2) => valueToString(x2))}]`;
      }
      return `[${x}]`;
    }
    return ArrayBuffer.isView(x) ? `[${x}]` : JSON.stringify(x, (_, y) => typeof y === "bigint" ? `${y}` : y);
  }

  // ../../node_modules/apache-arrow/util/bn.mjs
  var bn_exports = {};
  __export(bn_exports, {
    BN: () => BN,
    bignumToBigInt: () => bignumToBigInt,
    bignumToString: () => bignumToString,
    isArrowBigNumSymbol: () => isArrowBigNumSymbol
  });
  var isArrowBigNumSymbol = Symbol.for("isArrowBigNum");
  function BigNum(x, ...xs) {
    if (xs.length === 0) {
      return Object.setPrototypeOf(toArrayBufferView(this["TypedArray"], x), this.constructor.prototype);
    }
    return Object.setPrototypeOf(new this["TypedArray"](x, ...xs), this.constructor.prototype);
  }
  BigNum.prototype[isArrowBigNumSymbol] = true;
  BigNum.prototype.toJSON = function() {
    return `"${bignumToString(this)}"`;
  };
  BigNum.prototype.valueOf = function() {
    return bignumToNumber(this);
  };
  BigNum.prototype.toString = function() {
    return bignumToString(this);
  };
  BigNum.prototype[Symbol.toPrimitive] = function(hint = "default") {
    switch (hint) {
      case "number":
        return bignumToNumber(this);
      case "string":
        return bignumToString(this);
      case "default":
        return bignumToBigInt(this);
    }
    return bignumToString(this);
  };
  function SignedBigNum(...args) {
    return BigNum.apply(this, args);
  }
  function UnsignedBigNum(...args) {
    return BigNum.apply(this, args);
  }
  function DecimalBigNum(...args) {
    return BigNum.apply(this, args);
  }
  Object.setPrototypeOf(SignedBigNum.prototype, Object.create(Int32Array.prototype));
  Object.setPrototypeOf(UnsignedBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.setPrototypeOf(DecimalBigNum.prototype, Object.create(Uint32Array.prototype));
  Object.assign(SignedBigNum.prototype, BigNum.prototype, { "constructor": SignedBigNum, "signed": true, "TypedArray": Int32Array, "BigIntArray": BigInt64ArrayCtor });
  Object.assign(UnsignedBigNum.prototype, BigNum.prototype, { "constructor": UnsignedBigNum, "signed": false, "TypedArray": Uint32Array, "BigIntArray": BigUint64ArrayCtor });
  Object.assign(DecimalBigNum.prototype, BigNum.prototype, { "constructor": DecimalBigNum, "signed": true, "TypedArray": Uint32Array, "BigIntArray": BigUint64ArrayCtor });
  function bignumToNumber(bn) {
    const { buffer, byteOffset, length, "signed": signed } = bn;
    const words = new BigUint64ArrayCtor(buffer, byteOffset, length);
    const negative = signed && words[words.length - 1] & BigInt(1) << BigInt(63);
    let number = negative ? BigInt(1) : BigInt(0);
    let i = BigInt(0);
    if (!negative) {
      for (const word of words) {
        number += word * (BigInt(1) << BigInt(32) * i++);
      }
    } else {
      for (const word of words) {
        number += ~word * (BigInt(1) << BigInt(32) * i++);
      }
      number *= BigInt(-1);
    }
    return number;
  }
  var bignumToString;
  var bignumToBigInt;
  if (!BigIntAvailable) {
    bignumToString = decimalToString;
    bignumToBigInt = bignumToString;
  } else {
    bignumToBigInt = (a) => a.byteLength === 8 ? new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0] : decimalToString(a);
    bignumToString = (a) => a.byteLength === 8 ? `${new a["BigIntArray"](a.buffer, a.byteOffset, 1)[0]}` : decimalToString(a);
  }
  function decimalToString(a) {
    let digits = "";
    const base64 = new Uint32Array(2);
    let base32 = new Uint16Array(a.buffer, a.byteOffset, a.byteLength / 2);
    const checks = new Uint32Array((base32 = new Uint16Array(base32).reverse()).buffer);
    let i = -1;
    const n = base32.length - 1;
    do {
      for (base64[0] = base32[i = 0]; i < n; ) {
        base32[i++] = base64[1] = base64[0] / 10;
        base64[0] = (base64[0] - base64[1] * 10 << 16) + base32[i];
      }
      base32[i] = base64[1] = base64[0] / 10;
      base64[0] = base64[0] - base64[1] * 10;
      digits = `${base64[0]}${digits}`;
    } while (checks[0] || checks[1] || checks[2] || checks[3]);
    return digits !== null && digits !== void 0 ? digits : `0`;
  }
  var BN = class {
    static new(num, isSigned) {
      switch (isSigned) {
        case true:
          return new SignedBigNum(num);
        case false:
          return new UnsignedBigNum(num);
      }
      switch (num.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
        case BigInt64ArrayCtor:
          return new SignedBigNum(num);
      }
      if (num.byteLength === 16) {
        return new DecimalBigNum(num);
      }
      return new UnsignedBigNum(num);
    }
    static signed(num) {
      return new SignedBigNum(num);
    }
    static unsigned(num) {
      return new UnsignedBigNum(num);
    }
    static decimal(num) {
      return new DecimalBigNum(num);
    }
    constructor(num, isSigned) {
      return BN.new(num, isSigned);
    }
  };

  // ../../node_modules/apache-arrow/type.mjs
  var _a;
  var _b;
  var _c;
  var _d;
  var _e;
  var _f;
  var _g;
  var _h;
  var _j;
  var _k;
  var _l;
  var _m;
  var _o;
  var _p;
  var _q;
  var _r;
  var _s;
  var _t;
  var _u;
  var DataType = class {
    static isNull(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Null;
    }
    static isInt(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Int;
    }
    static isFloat(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Float;
    }
    static isBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Binary;
    }
    static isUtf8(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Utf8;
    }
    static isBool(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Bool;
    }
    static isDecimal(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Decimal;
    }
    static isDate(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Date;
    }
    static isTime(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Time;
    }
    static isTimestamp(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Timestamp;
    }
    static isInterval(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Interval;
    }
    static isList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.List;
    }
    static isStruct(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Struct;
    }
    static isUnion(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Union;
    }
    static isFixedSizeBinary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeBinary;
    }
    static isFixedSizeList(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.FixedSizeList;
    }
    static isMap(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Map;
    }
    static isDictionary(x) {
      return (x === null || x === void 0 ? void 0 : x.typeId) === Type.Dictionary;
    }
    static isDenseUnion(x) {
      return DataType.isUnion(x) && x.mode === UnionMode.Dense;
    }
    static isSparseUnion(x) {
      return DataType.isUnion(x) && x.mode === UnionMode.Sparse;
    }
    get typeId() {
      return Type.NONE;
    }
  };
  _a = Symbol.toStringTag;
  DataType[_a] = ((proto) => {
    proto.children = null;
    proto.ArrayType = Array;
    return proto[Symbol.toStringTag] = "DataType";
  })(DataType.prototype);
  var Null = class extends DataType {
    toString() {
      return `Null`;
    }
    get typeId() {
      return Type.Null;
    }
  };
  _b = Symbol.toStringTag;
  Null[_b] = ((proto) => proto[Symbol.toStringTag] = "Null")(Null.prototype);
  var Int_ = class extends DataType {
    constructor(isSigned, bitWidth) {
      super();
      this.isSigned = isSigned;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Int;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 8:
          return this.isSigned ? Int8Array : Uint8Array;
        case 16:
          return this.isSigned ? Int16Array : Uint16Array;
        case 32:
          return this.isSigned ? Int32Array : Uint32Array;
        case 64:
          return this.isSigned ? BigInt64ArrayCtor : BigUint64ArrayCtor;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `${this.isSigned ? `I` : `Ui`}nt${this.bitWidth}`;
    }
  };
  _c = Symbol.toStringTag;
  Int_[_c] = ((proto) => {
    proto.isSigned = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Int";
  })(Int_.prototype);
  var Int8 = class extends Int_ {
    constructor() {
      super(true, 8);
    }
    get ArrayType() {
      return Int8Array;
    }
  };
  var Int16 = class extends Int_ {
    constructor() {
      super(true, 16);
    }
    get ArrayType() {
      return Int16Array;
    }
  };
  var Int32 = class extends Int_ {
    constructor() {
      super(true, 32);
    }
    get ArrayType() {
      return Int32Array;
    }
  };
  var Int64 = class extends Int_ {
    constructor() {
      super(true, 64);
    }
    get ArrayType() {
      return BigInt64ArrayCtor;
    }
  };
  var Uint8 = class extends Int_ {
    constructor() {
      super(false, 8);
    }
    get ArrayType() {
      return Uint8Array;
    }
  };
  var Uint16 = class extends Int_ {
    constructor() {
      super(false, 16);
    }
    get ArrayType() {
      return Uint16Array;
    }
  };
  var Uint32 = class extends Int_ {
    constructor() {
      super(false, 32);
    }
    get ArrayType() {
      return Uint32Array;
    }
  };
  var Uint64 = class extends Int_ {
    constructor() {
      super(false, 64);
    }
    get ArrayType() {
      return BigUint64ArrayCtor;
    }
  };
  Object.defineProperty(Int8.prototype, "ArrayType", { value: Int8Array });
  Object.defineProperty(Int16.prototype, "ArrayType", { value: Int16Array });
  Object.defineProperty(Int32.prototype, "ArrayType", { value: Int32Array });
  Object.defineProperty(Int64.prototype, "ArrayType", { value: BigInt64ArrayCtor });
  Object.defineProperty(Uint8.prototype, "ArrayType", { value: Uint8Array });
  Object.defineProperty(Uint16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Uint32.prototype, "ArrayType", { value: Uint32Array });
  Object.defineProperty(Uint64.prototype, "ArrayType", { value: BigUint64ArrayCtor });
  var Float = class extends DataType {
    constructor(precision) {
      super();
      this.precision = precision;
    }
    get typeId() {
      return Type.Float;
    }
    get ArrayType() {
      switch (this.precision) {
        case Precision.HALF:
          return Uint16Array;
        case Precision.SINGLE:
          return Float32Array;
        case Precision.DOUBLE:
          return Float64Array;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
    toString() {
      return `Float${this.precision << 5 || 16}`;
    }
  };
  _d = Symbol.toStringTag;
  Float[_d] = ((proto) => {
    proto.precision = null;
    return proto[Symbol.toStringTag] = "Float";
  })(Float.prototype);
  var Float16 = class extends Float {
    constructor() {
      super(Precision.HALF);
    }
  };
  var Float32 = class extends Float {
    constructor() {
      super(Precision.SINGLE);
    }
  };
  var Float64 = class extends Float {
    constructor() {
      super(Precision.DOUBLE);
    }
  };
  Object.defineProperty(Float16.prototype, "ArrayType", { value: Uint16Array });
  Object.defineProperty(Float32.prototype, "ArrayType", { value: Float32Array });
  Object.defineProperty(Float64.prototype, "ArrayType", { value: Float64Array });
  var Binary = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Binary;
    }
    toString() {
      return `Binary`;
    }
  };
  _e = Symbol.toStringTag;
  Binary[_e] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Binary";
  })(Binary.prototype);
  var Utf8 = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Utf8;
    }
    toString() {
      return `Utf8`;
    }
  };
  _f = Symbol.toStringTag;
  Utf8[_f] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Utf8";
  })(Utf8.prototype);
  var Bool = class extends DataType {
    constructor() {
      super();
    }
    get typeId() {
      return Type.Bool;
    }
    toString() {
      return `Bool`;
    }
  };
  _g = Symbol.toStringTag;
  Bool[_g] = ((proto) => {
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "Bool";
  })(Bool.prototype);
  var Decimal = class extends DataType {
    constructor(scale, precision, bitWidth = 128) {
      super();
      this.scale = scale;
      this.precision = precision;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Decimal;
    }
    toString() {
      return `Decimal[${this.precision}e${this.scale > 0 ? `+` : ``}${this.scale}]`;
    }
  };
  _h = Symbol.toStringTag;
  Decimal[_h] = ((proto) => {
    proto.scale = null;
    proto.precision = null;
    proto.ArrayType = Uint32Array;
    return proto[Symbol.toStringTag] = "Decimal";
  })(Decimal.prototype);
  var Date_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Date;
    }
    toString() {
      return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;
    }
  };
  _j = Symbol.toStringTag;
  Date_[_j] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Date";
  })(Date_.prototype);
  var DateDay = class extends Date_ {
    constructor() {
      super(DateUnit.DAY);
    }
  };
  var DateMillisecond = class extends Date_ {
    constructor() {
      super(DateUnit.MILLISECOND);
    }
  };
  var Time_ = class extends DataType {
    constructor(unit, bitWidth) {
      super();
      this.unit = unit;
      this.bitWidth = bitWidth;
    }
    get typeId() {
      return Type.Time;
    }
    toString() {
      return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;
    }
    get ArrayType() {
      switch (this.bitWidth) {
        case 32:
          return Int32Array;
        case 64:
          return BigInt64ArrayCtor;
      }
      throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);
    }
  };
  _k = Symbol.toStringTag;
  Time_[_k] = ((proto) => {
    proto.unit = null;
    proto.bitWidth = null;
    return proto[Symbol.toStringTag] = "Time";
  })(Time_.prototype);
  var Timestamp_ = class extends DataType {
    constructor(unit, timezone) {
      super();
      this.unit = unit;
      this.timezone = timezone;
    }
    get typeId() {
      return Type.Timestamp;
    }
    toString() {
      return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ``}>`;
    }
  };
  _l = Symbol.toStringTag;
  Timestamp_[_l] = ((proto) => {
    proto.unit = null;
    proto.timezone = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Timestamp";
  })(Timestamp_.prototype);
  var TimestampSecond = class extends Timestamp_ {
    constructor(timezone) {
      super(TimeUnit.SECOND, timezone);
    }
  };
  var Interval_ = class extends DataType {
    constructor(unit) {
      super();
      this.unit = unit;
    }
    get typeId() {
      return Type.Interval;
    }
    toString() {
      return `Interval<${IntervalUnit[this.unit]}>`;
    }
  };
  _m = Symbol.toStringTag;
  Interval_[_m] = ((proto) => {
    proto.unit = null;
    proto.ArrayType = Int32Array;
    return proto[Symbol.toStringTag] = "Interval";
  })(Interval_.prototype);
  var List = class extends DataType {
    constructor(child) {
      super();
      this.children = [child];
    }
    get typeId() {
      return Type.List;
    }
    toString() {
      return `List<${this.valueType}>`;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
  };
  _o = Symbol.toStringTag;
  List[_o] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "List";
  })(List.prototype);
  var Struct = class extends DataType {
    constructor(children) {
      super();
      this.children = children;
    }
    get typeId() {
      return Type.Struct;
    }
    toString() {
      return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _p = Symbol.toStringTag;
  Struct[_p] = ((proto) => {
    proto.children = null;
    return proto[Symbol.toStringTag] = "Struct";
  })(Struct.prototype);
  var Union_ = class extends DataType {
    constructor(mode, typeIds, children) {
      super();
      this.mode = mode;
      this.children = children;
      this.typeIds = typeIds = Int32Array.from(typeIds);
      this.typeIdToChildIndex = typeIds.reduce((typeIdToChildIndex, typeId, idx) => (typeIdToChildIndex[typeId] = idx) && typeIdToChildIndex || typeIdToChildIndex, /* @__PURE__ */ Object.create(null));
    }
    get typeId() {
      return Type.Union;
    }
    toString() {
      return `${this[Symbol.toStringTag]}<${this.children.map((x) => `${x.type}`).join(` | `)}>`;
    }
  };
  _q = Symbol.toStringTag;
  Union_[_q] = ((proto) => {
    proto.mode = null;
    proto.typeIds = null;
    proto.children = null;
    proto.typeIdToChildIndex = null;
    proto.ArrayType = Int8Array;
    return proto[Symbol.toStringTag] = "Union";
  })(Union_.prototype);
  var FixedSizeBinary = class extends DataType {
    constructor(byteWidth) {
      super();
      this.byteWidth = byteWidth;
    }
    get typeId() {
      return Type.FixedSizeBinary;
    }
    toString() {
      return `FixedSizeBinary[${this.byteWidth}]`;
    }
  };
  _r = Symbol.toStringTag;
  FixedSizeBinary[_r] = ((proto) => {
    proto.byteWidth = null;
    proto.ArrayType = Uint8Array;
    return proto[Symbol.toStringTag] = "FixedSizeBinary";
  })(FixedSizeBinary.prototype);
  var FixedSizeList = class extends DataType {
    constructor(listSize, child) {
      super();
      this.listSize = listSize;
      this.children = [child];
    }
    get typeId() {
      return Type.FixedSizeList;
    }
    get valueType() {
      return this.children[0].type;
    }
    get valueField() {
      return this.children[0];
    }
    get ArrayType() {
      return this.valueType.ArrayType;
    }
    toString() {
      return `FixedSizeList[${this.listSize}]<${this.valueType}>`;
    }
  };
  _s = Symbol.toStringTag;
  FixedSizeList[_s] = ((proto) => {
    proto.children = null;
    proto.listSize = null;
    return proto[Symbol.toStringTag] = "FixedSizeList";
  })(FixedSizeList.prototype);
  var Map_ = class extends DataType {
    constructor(child, keysSorted = false) {
      super();
      this.children = [child];
      this.keysSorted = keysSorted;
    }
    get typeId() {
      return Type.Map;
    }
    get keyType() {
      return this.children[0].type.children[0].type;
    }
    get valueType() {
      return this.children[0].type.children[1].type;
    }
    get childType() {
      return this.children[0].type;
    }
    toString() {
      return `Map<{${this.children[0].type.children.map((f) => `${f.name}:${f.type}`).join(`, `)}}>`;
    }
  };
  _t = Symbol.toStringTag;
  Map_[_t] = ((proto) => {
    proto.children = null;
    proto.keysSorted = null;
    return proto[Symbol.toStringTag] = "Map_";
  })(Map_.prototype);
  var getId = ((atomicDictionaryId) => () => ++atomicDictionaryId)(-1);
  var Dictionary = class extends DataType {
    constructor(dictionary, indices, id, isOrdered) {
      super();
      this.indices = indices;
      this.dictionary = dictionary;
      this.isOrdered = isOrdered || false;
      this.id = id == null ? getId() : typeof id === "number" ? id : id.low;
    }
    get typeId() {
      return Type.Dictionary;
    }
    get children() {
      return this.dictionary.children;
    }
    get valueType() {
      return this.dictionary;
    }
    get ArrayType() {
      return this.dictionary.ArrayType;
    }
    toString() {
      return `Dictionary<${this.indices}, ${this.dictionary}>`;
    }
  };
  _u = Symbol.toStringTag;
  Dictionary[_u] = ((proto) => {
    proto.id = null;
    proto.indices = null;
    proto.isOrdered = null;
    proto.dictionary = null;
    return proto[Symbol.toStringTag] = "Dictionary";
  })(Dictionary.prototype);
  function strideForType(type) {
    const t = type;
    switch (type.typeId) {
      case Type.Decimal:
        return type.bitWidth / 32;
      case Type.Timestamp:
        return 2;
      case Type.Date:
        return 1 + t.unit;
      case Type.Interval:
        return 1 + t.unit;
      case Type.FixedSizeList:
        return t.listSize;
      case Type.FixedSizeBinary:
        return t.byteWidth;
      default:
        return 1;
    }
  }

  // ../../node_modules/apache-arrow/visitor.mjs
  var Visitor = class {
    visitMany(nodes, ...args) {
      return nodes.map((node, i) => this.visit(node, ...args.map((x) => x[i])));
    }
    visit(...args) {
      return this.getVisitFn(args[0], false).apply(this, args);
    }
    getVisitFn(node, throwIfNotFound = true) {
      return getVisitFn(this, node, throwIfNotFound);
    }
    getVisitFnByTypeId(typeId, throwIfNotFound = true) {
      return getVisitFnByTypeId(this, typeId, throwIfNotFound);
    }
    visitNull(_node, ..._args) {
      return null;
    }
    visitBool(_node, ..._args) {
      return null;
    }
    visitInt(_node, ..._args) {
      return null;
    }
    visitFloat(_node, ..._args) {
      return null;
    }
    visitUtf8(_node, ..._args) {
      return null;
    }
    visitBinary(_node, ..._args) {
      return null;
    }
    visitFixedSizeBinary(_node, ..._args) {
      return null;
    }
    visitDate(_node, ..._args) {
      return null;
    }
    visitTimestamp(_node, ..._args) {
      return null;
    }
    visitTime(_node, ..._args) {
      return null;
    }
    visitDecimal(_node, ..._args) {
      return null;
    }
    visitList(_node, ..._args) {
      return null;
    }
    visitStruct(_node, ..._args) {
      return null;
    }
    visitUnion(_node, ..._args) {
      return null;
    }
    visitDictionary(_node, ..._args) {
      return null;
    }
    visitInterval(_node, ..._args) {
      return null;
    }
    visitFixedSizeList(_node, ..._args) {
      return null;
    }
    visitMap(_node, ..._args) {
      return null;
    }
  };
  function getVisitFn(visitor, node, throwIfNotFound = true) {
    if (typeof node === "number") {
      return getVisitFnByTypeId(visitor, node, throwIfNotFound);
    }
    if (typeof node === "string" && node in Type) {
      return getVisitFnByTypeId(visitor, Type[node], throwIfNotFound);
    }
    if (node && node instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node), throwIfNotFound);
    }
    if ((node === null || node === void 0 ? void 0 : node.type) && node.type instanceof DataType) {
      return getVisitFnByTypeId(visitor, inferDType(node.type), throwIfNotFound);
    }
    return getVisitFnByTypeId(visitor, Type.NONE, throwIfNotFound);
  }
  function getVisitFnByTypeId(visitor, dtype, throwIfNotFound = true) {
    let fn = null;
    switch (dtype) {
      case Type.Null:
        fn = visitor.visitNull;
        break;
      case Type.Bool:
        fn = visitor.visitBool;
        break;
      case Type.Int:
        fn = visitor.visitInt;
        break;
      case Type.Int8:
        fn = visitor.visitInt8 || visitor.visitInt;
        break;
      case Type.Int16:
        fn = visitor.visitInt16 || visitor.visitInt;
        break;
      case Type.Int32:
        fn = visitor.visitInt32 || visitor.visitInt;
        break;
      case Type.Int64:
        fn = visitor.visitInt64 || visitor.visitInt;
        break;
      case Type.Uint8:
        fn = visitor.visitUint8 || visitor.visitInt;
        break;
      case Type.Uint16:
        fn = visitor.visitUint16 || visitor.visitInt;
        break;
      case Type.Uint32:
        fn = visitor.visitUint32 || visitor.visitInt;
        break;
      case Type.Uint64:
        fn = visitor.visitUint64 || visitor.visitInt;
        break;
      case Type.Float:
        fn = visitor.visitFloat;
        break;
      case Type.Float16:
        fn = visitor.visitFloat16 || visitor.visitFloat;
        break;
      case Type.Float32:
        fn = visitor.visitFloat32 || visitor.visitFloat;
        break;
      case Type.Float64:
        fn = visitor.visitFloat64 || visitor.visitFloat;
        break;
      case Type.Utf8:
        fn = visitor.visitUtf8;
        break;
      case Type.Binary:
        fn = visitor.visitBinary;
        break;
      case Type.FixedSizeBinary:
        fn = visitor.visitFixedSizeBinary;
        break;
      case Type.Date:
        fn = visitor.visitDate;
        break;
      case Type.DateDay:
        fn = visitor.visitDateDay || visitor.visitDate;
        break;
      case Type.DateMillisecond:
        fn = visitor.visitDateMillisecond || visitor.visitDate;
        break;
      case Type.Timestamp:
        fn = visitor.visitTimestamp;
        break;
      case Type.TimestampSecond:
        fn = visitor.visitTimestampSecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMillisecond:
        fn = visitor.visitTimestampMillisecond || visitor.visitTimestamp;
        break;
      case Type.TimestampMicrosecond:
        fn = visitor.visitTimestampMicrosecond || visitor.visitTimestamp;
        break;
      case Type.TimestampNanosecond:
        fn = visitor.visitTimestampNanosecond || visitor.visitTimestamp;
        break;
      case Type.Time:
        fn = visitor.visitTime;
        break;
      case Type.TimeSecond:
        fn = visitor.visitTimeSecond || visitor.visitTime;
        break;
      case Type.TimeMillisecond:
        fn = visitor.visitTimeMillisecond || visitor.visitTime;
        break;
      case Type.TimeMicrosecond:
        fn = visitor.visitTimeMicrosecond || visitor.visitTime;
        break;
      case Type.TimeNanosecond:
        fn = visitor.visitTimeNanosecond || visitor.visitTime;
        break;
      case Type.Decimal:
        fn = visitor.visitDecimal;
        break;
      case Type.List:
        fn = visitor.visitList;
        break;
      case Type.Struct:
        fn = visitor.visitStruct;
        break;
      case Type.Union:
        fn = visitor.visitUnion;
        break;
      case Type.DenseUnion:
        fn = visitor.visitDenseUnion || visitor.visitUnion;
        break;
      case Type.SparseUnion:
        fn = visitor.visitSparseUnion || visitor.visitUnion;
        break;
      case Type.Dictionary:
        fn = visitor.visitDictionary;
        break;
      case Type.Interval:
        fn = visitor.visitInterval;
        break;
      case Type.IntervalDayTime:
        fn = visitor.visitIntervalDayTime || visitor.visitInterval;
        break;
      case Type.IntervalYearMonth:
        fn = visitor.visitIntervalYearMonth || visitor.visitInterval;
        break;
      case Type.FixedSizeList:
        fn = visitor.visitFixedSizeList;
        break;
      case Type.Map:
        fn = visitor.visitMap;
        break;
    }
    if (typeof fn === "function")
      return fn;
    if (!throwIfNotFound)
      return () => null;
    throw new Error(`Unrecognized type '${Type[dtype]}'`);
  }
  function inferDType(type) {
    switch (type.typeId) {
      case Type.Null:
        return Type.Null;
      case Type.Int: {
        const { bitWidth, isSigned } = type;
        switch (bitWidth) {
          case 8:
            return isSigned ? Type.Int8 : Type.Uint8;
          case 16:
            return isSigned ? Type.Int16 : Type.Uint16;
          case 32:
            return isSigned ? Type.Int32 : Type.Uint32;
          case 64:
            return isSigned ? Type.Int64 : Type.Uint64;
        }
        return Type.Int;
      }
      case Type.Float:
        switch (type.precision) {
          case Precision.HALF:
            return Type.Float16;
          case Precision.SINGLE:
            return Type.Float32;
          case Precision.DOUBLE:
            return Type.Float64;
        }
        return Type.Float;
      case Type.Binary:
        return Type.Binary;
      case Type.Utf8:
        return Type.Utf8;
      case Type.Bool:
        return Type.Bool;
      case Type.Decimal:
        return Type.Decimal;
      case Type.Time:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimeSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimeMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimeMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimeNanosecond;
        }
        return Type.Time;
      case Type.Timestamp:
        switch (type.unit) {
          case TimeUnit.SECOND:
            return Type.TimestampSecond;
          case TimeUnit.MILLISECOND:
            return Type.TimestampMillisecond;
          case TimeUnit.MICROSECOND:
            return Type.TimestampMicrosecond;
          case TimeUnit.NANOSECOND:
            return Type.TimestampNanosecond;
        }
        return Type.Timestamp;
      case Type.Date:
        switch (type.unit) {
          case DateUnit.DAY:
            return Type.DateDay;
          case DateUnit.MILLISECOND:
            return Type.DateMillisecond;
        }
        return Type.Date;
      case Type.Interval:
        switch (type.unit) {
          case IntervalUnit.DAY_TIME:
            return Type.IntervalDayTime;
          case IntervalUnit.YEAR_MONTH:
            return Type.IntervalYearMonth;
        }
        return Type.Interval;
      case Type.Map:
        return Type.Map;
      case Type.List:
        return Type.List;
      case Type.Struct:
        return Type.Struct;
      case Type.Union:
        switch (type.mode) {
          case UnionMode.Dense:
            return Type.DenseUnion;
          case UnionMode.Sparse:
            return Type.SparseUnion;
        }
        return Type.Union;
      case Type.FixedSizeBinary:
        return Type.FixedSizeBinary;
      case Type.FixedSizeList:
        return Type.FixedSizeList;
      case Type.Dictionary:
        return Type.Dictionary;
    }
    throw new Error(`Unrecognized type '${Type[type.typeId]}'`);
  }
  Visitor.prototype.visitInt8 = null;
  Visitor.prototype.visitInt16 = null;
  Visitor.prototype.visitInt32 = null;
  Visitor.prototype.visitInt64 = null;
  Visitor.prototype.visitUint8 = null;
  Visitor.prototype.visitUint16 = null;
  Visitor.prototype.visitUint32 = null;
  Visitor.prototype.visitUint64 = null;
  Visitor.prototype.visitFloat16 = null;
  Visitor.prototype.visitFloat32 = null;
  Visitor.prototype.visitFloat64 = null;
  Visitor.prototype.visitDateDay = null;
  Visitor.prototype.visitDateMillisecond = null;
  Visitor.prototype.visitTimestampSecond = null;
  Visitor.prototype.visitTimestampMillisecond = null;
  Visitor.prototype.visitTimestampMicrosecond = null;
  Visitor.prototype.visitTimestampNanosecond = null;
  Visitor.prototype.visitTimeSecond = null;
  Visitor.prototype.visitTimeMillisecond = null;
  Visitor.prototype.visitTimeMicrosecond = null;
  Visitor.prototype.visitTimeNanosecond = null;
  Visitor.prototype.visitDenseUnion = null;
  Visitor.prototype.visitSparseUnion = null;
  Visitor.prototype.visitIntervalDayTime = null;
  Visitor.prototype.visitIntervalYearMonth = null;

  // ../../node_modules/apache-arrow/util/math.mjs
  var math_exports = {};
  __export(math_exports, {
    float64ToUint16: () => float64ToUint16,
    uint16ToFloat64: () => uint16ToFloat64
  });
  var f64 = new Float64Array(1);
  var u32 = new Uint32Array(f64.buffer);
  function uint16ToFloat64(h) {
    const expo = (h & 31744) >> 10;
    const sigf = (h & 1023) / 1024;
    const sign = Math.pow(-1, (h & 32768) >> 15);
    switch (expo) {
      case 31:
        return sign * (sigf ? Number.NaN : 1 / 0);
      case 0:
        return sign * (sigf ? 6103515625e-14 * sigf : 0);
    }
    return sign * Math.pow(2, expo - 15) * (1 + sigf);
  }
  function float64ToUint16(d) {
    if (d !== d) {
      return 32256;
    }
    f64[0] = d;
    const sign = (u32[1] & 2147483648) >> 16 & 65535;
    let expo = u32[1] & 2146435072, sigf = 0;
    if (expo >= 1089470464) {
      if (u32[0] > 0) {
        expo = 31744;
      } else {
        expo = (expo & 2080374784) >> 16;
        sigf = (u32[1] & 1048575) >> 10;
      }
    } else if (expo <= 1056964608) {
      sigf = 1048576 + (u32[1] & 1048575);
      sigf = 1048576 + (sigf << (expo >> 20) - 998) >> 21;
      expo = 0;
    } else {
      expo = expo - 1056964608 >> 10;
      sigf = (u32[1] & 1048575) + 512 >> 10;
    }
    return sign | expo | sigf & 65535;
  }

  // ../../node_modules/apache-arrow/visitor/set.mjs
  var SetVisitor = class extends Visitor {
  };
  function wrapSet(fn) {
    return (data, _1, _2) => {
      if (data.setValid(_1, _2 != null)) {
        return fn(data, _1, _2);
      }
    };
  }
  var setEpochMsToDays = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs / 864e5);
  };
  var setEpochMsToMillisecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs % 4294967296);
    data[index + 1] = Math.trunc(epochMs / 4294967296);
  };
  var setEpochMsToMicrosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs * 1e3 % 4294967296);
    data[index + 1] = Math.trunc(epochMs * 1e3 / 4294967296);
  };
  var setEpochMsToNanosecondsLong = (data, index, epochMs) => {
    data[index] = Math.trunc(epochMs * 1e6 % 4294967296);
    data[index + 1] = Math.trunc(epochMs * 1e6 / 4294967296);
  };
  var setVariableWidthBytes = (values, valueOffsets, index, value) => {
    if (index + 1 < valueOffsets.length) {
      const { [index]: x, [index + 1]: y } = valueOffsets;
      values.set(value.subarray(0, y - x), x);
    }
  };
  var setBool = ({ offset, values }, index, val) => {
    const idx = offset + index;
    val ? values[idx >> 3] |= 1 << idx % 8 : values[idx >> 3] &= ~(1 << idx % 8);
  };
  var setInt = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat = ({ values }, index, value) => {
    values[index] = value;
  };
  var setFloat16 = ({ values }, index, value) => {
    values[index] = float64ToUint16(value);
  };
  var setAnyFloat = (data, index, value) => {
    switch (data.type.precision) {
      case Precision.HALF:
        return setFloat16(data, index, value);
      case Precision.SINGLE:
      case Precision.DOUBLE:
        return setFloat(data, index, value);
    }
  };
  var setDateDay = ({ values }, index, value) => {
    setEpochMsToDays(values, index, value.valueOf());
  };
  var setDateMillisecond = ({ values }, index, value) => {
    setEpochMsToMillisecondsLong(values, index * 2, value.valueOf());
  };
  var setFixedSizeBinary = ({ stride, values }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setBinary = ({ values, valueOffsets }, index, value) => setVariableWidthBytes(values, valueOffsets, index, value);
  var setUtf8 = ({ values, valueOffsets }, index, value) => {
    setVariableWidthBytes(values, valueOffsets, index, encodeUtf8(value));
  };
  var setDate = (data, index, value) => {
    data.type.unit === DateUnit.DAY ? setDateDay(data, index, value) : setDateMillisecond(data, index, value);
  };
  var setTimestampSecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value / 1e3);
  var setTimestampMillisecond = ({ values }, index, value) => setEpochMsToMillisecondsLong(values, index * 2, value);
  var setTimestampMicrosecond = ({ values }, index, value) => setEpochMsToMicrosecondsLong(values, index * 2, value);
  var setTimestampNanosecond = ({ values }, index, value) => setEpochMsToNanosecondsLong(values, index * 2, value);
  var setTimestamp = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimestampSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimestampMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimestampMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimestampNanosecond(data, index, value);
    }
  };
  var setTimeSecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMillisecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeMicrosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTimeNanosecond = ({ values }, index, value) => {
    values[index] = value;
  };
  var setTime = (data, index, value) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return setTimeSecond(data, index, value);
      case TimeUnit.MILLISECOND:
        return setTimeMillisecond(data, index, value);
      case TimeUnit.MICROSECOND:
        return setTimeMicrosecond(data, index, value);
      case TimeUnit.NANOSECOND:
        return setTimeNanosecond(data, index, value);
    }
  };
  var setDecimal = ({ values, stride }, index, value) => {
    values.set(value.subarray(0, stride), stride * index);
  };
  var setList = (data, index, value) => {
    const values = data.children[0];
    const valueOffsets = data.valueOffsets;
    const set = instance.getVisitFn(values);
    if (Array.isArray(value)) {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value[++idx]);
      }
    } else {
      for (let idx = -1, itr = valueOffsets[index], end = valueOffsets[index + 1]; itr < end; ) {
        set(values, itr++, value.get(++idx));
      }
    }
  };
  var setMap = (data, index, value) => {
    const values = data.children[0];
    const { valueOffsets } = data;
    const set = instance.getVisitFn(values);
    let { [index]: idx, [index + 1]: end } = valueOffsets;
    const entries = value instanceof Map ? value.entries() : Object.entries(value);
    for (const val of entries) {
      set(values, idx, val);
      if (++idx >= end)
        break;
    }
  };
  var _setStructArrayValue = (o, v) => (set, c, _, i) => c && set(c, o, v[i]);
  var _setStructVectorValue = (o, v) => (set, c, _, i) => c && set(c, o, v.get(i));
  var _setStructMapValue = (o, v) => (set, c, f, _) => c && set(c, o, v.get(f.name));
  var _setStructObjectValue = (o, v) => (set, c, f, _) => c && set(c, o, v[f.name]);
  var setStruct = (data, index, value) => {
    const childSetters = data.type.children.map((f) => instance.getVisitFn(f.type));
    const set = value instanceof Map ? _setStructMapValue(index, value) : value instanceof Vector ? _setStructVectorValue(index, value) : Array.isArray(value) ? _setStructArrayValue(index, value) : _setStructObjectValue(index, value);
    data.type.children.forEach((f, i) => set(childSetters[i], data.children[i], f, i));
  };
  var setUnion = (data, index, value) => {
    data.type.mode === UnionMode.Dense ? setDenseUnion(data, index, value) : setSparseUnion(data, index, value);
  };
  var setDenseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, data.valueOffsets[index], value);
  };
  var setSparseUnion = (data, index, value) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    instance.visit(child, index, value);
  };
  var setDictionary = (data, index, value) => {
    var _a5;
    (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.set(data.values[index], value);
  };
  var setIntervalValue = (data, index, value) => {
    data.type.unit === IntervalUnit.DAY_TIME ? setIntervalDayTime(data, index, value) : setIntervalYearMonth(data, index, value);
  };
  var setIntervalDayTime = ({ values }, index, value) => {
    values.set(value.subarray(0, 2), 2 * index);
  };
  var setIntervalYearMonth = ({ values }, index, value) => {
    values[index] = value[0] * 12 + value[1] % 12;
  };
  var setFixedSizeList = (data, index, value) => {
    const { stride } = data;
    const child = data.children[0];
    const set = instance.getVisitFn(child);
    if (Array.isArray(value)) {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value[idx]);
      }
    } else {
      for (let idx = -1, offset = index * stride; ++idx < stride; ) {
        set(child, offset + idx, value.get(idx));
      }
    }
  };
  SetVisitor.prototype.visitBool = wrapSet(setBool);
  SetVisitor.prototype.visitInt = wrapSet(setInt);
  SetVisitor.prototype.visitInt8 = wrapSet(setInt);
  SetVisitor.prototype.visitInt16 = wrapSet(setInt);
  SetVisitor.prototype.visitInt32 = wrapSet(setInt);
  SetVisitor.prototype.visitInt64 = wrapSet(setInt);
  SetVisitor.prototype.visitUint8 = wrapSet(setInt);
  SetVisitor.prototype.visitUint16 = wrapSet(setInt);
  SetVisitor.prototype.visitUint32 = wrapSet(setInt);
  SetVisitor.prototype.visitUint64 = wrapSet(setInt);
  SetVisitor.prototype.visitFloat = wrapSet(setAnyFloat);
  SetVisitor.prototype.visitFloat16 = wrapSet(setFloat16);
  SetVisitor.prototype.visitFloat32 = wrapSet(setFloat);
  SetVisitor.prototype.visitFloat64 = wrapSet(setFloat);
  SetVisitor.prototype.visitUtf8 = wrapSet(setUtf8);
  SetVisitor.prototype.visitBinary = wrapSet(setBinary);
  SetVisitor.prototype.visitFixedSizeBinary = wrapSet(setFixedSizeBinary);
  SetVisitor.prototype.visitDate = wrapSet(setDate);
  SetVisitor.prototype.visitDateDay = wrapSet(setDateDay);
  SetVisitor.prototype.visitDateMillisecond = wrapSet(setDateMillisecond);
  SetVisitor.prototype.visitTimestamp = wrapSet(setTimestamp);
  SetVisitor.prototype.visitTimestampSecond = wrapSet(setTimestampSecond);
  SetVisitor.prototype.visitTimestampMillisecond = wrapSet(setTimestampMillisecond);
  SetVisitor.prototype.visitTimestampMicrosecond = wrapSet(setTimestampMicrosecond);
  SetVisitor.prototype.visitTimestampNanosecond = wrapSet(setTimestampNanosecond);
  SetVisitor.prototype.visitTime = wrapSet(setTime);
  SetVisitor.prototype.visitTimeSecond = wrapSet(setTimeSecond);
  SetVisitor.prototype.visitTimeMillisecond = wrapSet(setTimeMillisecond);
  SetVisitor.prototype.visitTimeMicrosecond = wrapSet(setTimeMicrosecond);
  SetVisitor.prototype.visitTimeNanosecond = wrapSet(setTimeNanosecond);
  SetVisitor.prototype.visitDecimal = wrapSet(setDecimal);
  SetVisitor.prototype.visitList = wrapSet(setList);
  SetVisitor.prototype.visitStruct = wrapSet(setStruct);
  SetVisitor.prototype.visitUnion = wrapSet(setUnion);
  SetVisitor.prototype.visitDenseUnion = wrapSet(setDenseUnion);
  SetVisitor.prototype.visitSparseUnion = wrapSet(setSparseUnion);
  SetVisitor.prototype.visitDictionary = wrapSet(setDictionary);
  SetVisitor.prototype.visitInterval = wrapSet(setIntervalValue);
  SetVisitor.prototype.visitIntervalDayTime = wrapSet(setIntervalDayTime);
  SetVisitor.prototype.visitIntervalYearMonth = wrapSet(setIntervalYearMonth);
  SetVisitor.prototype.visitFixedSizeList = wrapSet(setFixedSizeList);
  SetVisitor.prototype.visitMap = wrapSet(setMap);
  var instance = new SetVisitor();

  // ../../node_modules/apache-arrow/row/struct.mjs
  var kParent = Symbol.for("parent");
  var kRowIndex = Symbol.for("rowIndex");
  var StructRow = class {
    constructor(parent, rowIndex) {
      this[kParent] = parent;
      this[kRowIndex] = rowIndex;
      return new Proxy(this, new StructRowProxyHandler());
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const i = this[kRowIndex];
      const parent = this[kParent];
      const keys = parent.type.children;
      const json = {};
      for (let j = -1, n = keys.length; ++j < n; ) {
        json[keys[j].name] = instance2.visit(parent.children[j], i);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
    [Symbol.iterator]() {
      return new StructRowIterator(this[kParent], this[kRowIndex]);
    }
  };
  var StructRowIterator = class {
    constructor(data, rowIndex) {
      this.childIndex = 0;
      this.children = data.children;
      this.rowIndex = rowIndex;
      this.childFields = data.type.children;
      this.numChildren = this.childFields.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i = this.childIndex;
      if (i < this.numChildren) {
        this.childIndex = i + 1;
        return {
          done: false,
          value: [
            this.childFields[i].name,
            instance2.visit(this.children[i], this.rowIndex)
          ]
        };
      }
      return { done: true, value: null };
    }
  };
  Object.defineProperties(StructRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kParent]: { writable: true, enumerable: false, configurable: false, value: null },
    [kRowIndex]: { writable: true, enumerable: false, configurable: false, value: -1 }
  });
  var StructRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kParent].type.children.map((f) => f.name);
    }
    has(row, key) {
      return row[kParent].type.children.findIndex((f) => f.name === key) !== -1;
    }
    getOwnPropertyDescriptor(row, key) {
      if (row[kParent].type.children.findIndex((f) => f.name === key) !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        const val = instance2.visit(row[kParent].children[idx], row[kRowIndex]);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kParent].type.children.findIndex((f) => f.name === key);
      if (idx !== -1) {
        instance.visit(row[kParent].children[idx], row[kRowIndex], val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key) || typeof key === "symbol") {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };

  // ../../node_modules/apache-arrow/visitor/get.mjs
  var GetVisitor = class extends Visitor {
  };
  function wrapGet(fn) {
    return (data, _1) => data.getValid(_1) ? fn(data, _1) : null;
  }
  var epochDaysToMs = (data, index) => 864e5 * data[index];
  var epochMillisecondsLongToMs = (data, index) => 4294967296 * data[index + 1] + (data[index] >>> 0);
  var epochMicrosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e3) + (data[index] >>> 0) / 1e3;
  var epochNanosecondsLongToMs = (data, index) => 4294967296 * (data[index + 1] / 1e6) + (data[index] >>> 0) / 1e6;
  var epochMillisecondsToDate = (epochMs) => new Date(epochMs);
  var epochDaysToDate = (data, index) => epochMillisecondsToDate(epochDaysToMs(data, index));
  var epochMillisecondsLongToDate = (data, index) => epochMillisecondsToDate(epochMillisecondsLongToMs(data, index));
  var getNull = (_data, _index) => null;
  var getVariableWidthBytes = (values, valueOffsets, index) => {
    if (index + 1 >= valueOffsets.length) {
      return null;
    }
    const x = valueOffsets[index];
    const y = valueOffsets[index + 1];
    return values.subarray(x, y);
  };
  var getBool = ({ offset, values }, index) => {
    const idx = offset + index;
    const byte = values[idx >> 3];
    return (byte & 1 << idx % 8) !== 0;
  };
  var getDateDay = ({ values }, index) => epochDaysToDate(values, index);
  var getDateMillisecond = ({ values }, index) => epochMillisecondsLongToDate(values, index * 2);
  var getNumeric = ({ stride, values }, index) => values[stride * index];
  var getFloat16 = ({ stride, values }, index) => uint16ToFloat64(values[stride * index]);
  var getBigInts = ({ values }, index) => values[index];
  var getFixedSizeBinary = ({ stride, values }, index) => values.subarray(stride * index, stride * (index + 1));
  var getBinary = ({ values, valueOffsets }, index) => getVariableWidthBytes(values, valueOffsets, index);
  var getUtf8 = ({ values, valueOffsets }, index) => {
    const bytes = getVariableWidthBytes(values, valueOffsets, index);
    return bytes !== null ? decodeUtf8(bytes) : null;
  };
  var getInt = ({ values }, index) => values[index];
  var getFloat = ({ type, values }, index) => type.precision !== Precision.HALF ? values[index] : uint16ToFloat64(values[index]);
  var getDate = (data, index) => data.type.unit === DateUnit.DAY ? getDateDay(data, index) : getDateMillisecond(data, index);
  var getTimestampSecond = ({ values }, index) => 1e3 * epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMillisecond = ({ values }, index) => epochMillisecondsLongToMs(values, index * 2);
  var getTimestampMicrosecond = ({ values }, index) => epochMicrosecondsLongToMs(values, index * 2);
  var getTimestampNanosecond = ({ values }, index) => epochNanosecondsLongToMs(values, index * 2);
  var getTimestamp = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimestampSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimestampMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimestampMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimestampNanosecond(data, index);
    }
  };
  var getTimeSecond = ({ values }, index) => values[index];
  var getTimeMillisecond = ({ values }, index) => values[index];
  var getTimeMicrosecond = ({ values }, index) => values[index];
  var getTimeNanosecond = ({ values }, index) => values[index];
  var getTime = (data, index) => {
    switch (data.type.unit) {
      case TimeUnit.SECOND:
        return getTimeSecond(data, index);
      case TimeUnit.MILLISECOND:
        return getTimeMillisecond(data, index);
      case TimeUnit.MICROSECOND:
        return getTimeMicrosecond(data, index);
      case TimeUnit.NANOSECOND:
        return getTimeNanosecond(data, index);
    }
  };
  var getDecimal = ({ values, stride }, index) => BN.decimal(values.subarray(stride * index, stride * (index + 1)));
  var getList = (data, index) => {
    const { valueOffsets, stride, children } = data;
    const { [index * stride]: begin, [index * stride + 1]: end } = valueOffsets;
    const child = children[0];
    const slice = child.slice(begin, end - begin);
    return new Vector([slice]);
  };
  var getMap = (data, index) => {
    const { valueOffsets, children } = data;
    const { [index]: begin, [index + 1]: end } = valueOffsets;
    const child = children[0];
    return new MapRow(child.slice(begin, end - begin));
  };
  var getStruct = (data, index) => {
    return new StructRow(data, index);
  };
  var getUnion = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnion(data, index) : getSparseUnion(data, index);
  };
  var getDenseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, data.valueOffsets[index]);
  };
  var getSparseUnion = (data, index) => {
    const childIndex = data.type.typeIdToChildIndex[data.typeIds[index]];
    const child = data.children[childIndex];
    return instance2.visit(child, index);
  };
  var getDictionary = (data, index) => {
    var _a5;
    return (_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.get(data.values[index]);
  };
  var getInterval = (data, index) => data.type.unit === IntervalUnit.DAY_TIME ? getIntervalDayTime(data, index) : getIntervalYearMonth(data, index);
  var getIntervalDayTime = ({ values }, index) => values.subarray(2 * index, 2 * (index + 1));
  var getIntervalYearMonth = ({ values }, index) => {
    const interval = values[index];
    const int32s = new Int32Array(2);
    int32s[0] = Math.trunc(interval / 12);
    int32s[1] = Math.trunc(interval % 12);
    return int32s;
  };
  var getFixedSizeList = (data, index) => {
    const { stride, children } = data;
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    return new Vector([slice]);
  };
  GetVisitor.prototype.visitNull = wrapGet(getNull);
  GetVisitor.prototype.visitBool = wrapGet(getBool);
  GetVisitor.prototype.visitInt = wrapGet(getInt);
  GetVisitor.prototype.visitInt8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitInt64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitUint8 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint16 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUint64 = wrapGet(getBigInts);
  GetVisitor.prototype.visitFloat = wrapGet(getFloat);
  GetVisitor.prototype.visitFloat16 = wrapGet(getFloat16);
  GetVisitor.prototype.visitFloat32 = wrapGet(getNumeric);
  GetVisitor.prototype.visitFloat64 = wrapGet(getNumeric);
  GetVisitor.prototype.visitUtf8 = wrapGet(getUtf8);
  GetVisitor.prototype.visitBinary = wrapGet(getBinary);
  GetVisitor.prototype.visitFixedSizeBinary = wrapGet(getFixedSizeBinary);
  GetVisitor.prototype.visitDate = wrapGet(getDate);
  GetVisitor.prototype.visitDateDay = wrapGet(getDateDay);
  GetVisitor.prototype.visitDateMillisecond = wrapGet(getDateMillisecond);
  GetVisitor.prototype.visitTimestamp = wrapGet(getTimestamp);
  GetVisitor.prototype.visitTimestampSecond = wrapGet(getTimestampSecond);
  GetVisitor.prototype.visitTimestampMillisecond = wrapGet(getTimestampMillisecond);
  GetVisitor.prototype.visitTimestampMicrosecond = wrapGet(getTimestampMicrosecond);
  GetVisitor.prototype.visitTimestampNanosecond = wrapGet(getTimestampNanosecond);
  GetVisitor.prototype.visitTime = wrapGet(getTime);
  GetVisitor.prototype.visitTimeSecond = wrapGet(getTimeSecond);
  GetVisitor.prototype.visitTimeMillisecond = wrapGet(getTimeMillisecond);
  GetVisitor.prototype.visitTimeMicrosecond = wrapGet(getTimeMicrosecond);
  GetVisitor.prototype.visitTimeNanosecond = wrapGet(getTimeNanosecond);
  GetVisitor.prototype.visitDecimal = wrapGet(getDecimal);
  GetVisitor.prototype.visitList = wrapGet(getList);
  GetVisitor.prototype.visitStruct = wrapGet(getStruct);
  GetVisitor.prototype.visitUnion = wrapGet(getUnion);
  GetVisitor.prototype.visitDenseUnion = wrapGet(getDenseUnion);
  GetVisitor.prototype.visitSparseUnion = wrapGet(getSparseUnion);
  GetVisitor.prototype.visitDictionary = wrapGet(getDictionary);
  GetVisitor.prototype.visitInterval = wrapGet(getInterval);
  GetVisitor.prototype.visitIntervalDayTime = wrapGet(getIntervalDayTime);
  GetVisitor.prototype.visitIntervalYearMonth = wrapGet(getIntervalYearMonth);
  GetVisitor.prototype.visitFixedSizeList = wrapGet(getFixedSizeList);
  GetVisitor.prototype.visitMap = wrapGet(getMap);
  var instance2 = new GetVisitor();

  // ../../node_modules/apache-arrow/row/map.mjs
  var kKeys = Symbol.for("keys");
  var kVals = Symbol.for("vals");
  var MapRow = class {
    constructor(slice) {
      this[kKeys] = new Vector([slice.children[0]]).memoize();
      this[kVals] = slice.children[1];
      return new Proxy(this, new MapRowProxyHandler());
    }
    [Symbol.iterator]() {
      return new MapRowIterator(this[kKeys], this[kVals]);
    }
    get size() {
      return this[kKeys].length;
    }
    toArray() {
      return Object.values(this.toJSON());
    }
    toJSON() {
      const keys = this[kKeys];
      const vals = this[kVals];
      const json = {};
      for (let i = -1, n = keys.length; ++i < n; ) {
        json[keys.get(i)] = instance2.visit(vals, i);
      }
      return json;
    }
    toString() {
      return `{${[...this].map(([key, val]) => `${valueToString(key)}: ${valueToString(val)}`).join(", ")}}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return this.toString();
    }
  };
  var MapRowIterator = class {
    constructor(keys, vals) {
      this.keys = keys;
      this.vals = vals;
      this.keyIndex = 0;
      this.numKeys = keys.length;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const i = this.keyIndex;
      if (i === this.numKeys) {
        return { done: true, value: null };
      }
      this.keyIndex++;
      return {
        done: false,
        value: [
          this.keys.get(i),
          instance2.visit(this.vals, i)
        ]
      };
    }
  };
  var MapRowProxyHandler = class {
    isExtensible() {
      return false;
    }
    deleteProperty() {
      return false;
    }
    preventExtensions() {
      return true;
    }
    ownKeys(row) {
      return row[kKeys].toArray().map(String);
    }
    has(row, key) {
      return row[kKeys].includes(key);
    }
    getOwnPropertyDescriptor(row, key) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        return { writable: true, enumerable: true, configurable: true };
      }
      return;
    }
    get(row, key) {
      if (Reflect.has(row, key)) {
        return row[key];
      }
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        const val = instance2.visit(Reflect.get(row, kVals), idx);
        Reflect.set(row, key, val);
        return val;
      }
    }
    set(row, key, val) {
      const idx = row[kKeys].indexOf(key);
      if (idx !== -1) {
        instance.visit(Reflect.get(row, kVals), idx, val);
        return Reflect.set(row, key, val);
      } else if (Reflect.has(row, key)) {
        return Reflect.set(row, key, val);
      }
      return false;
    }
  };
  Object.defineProperties(MapRow.prototype, {
    [Symbol.toStringTag]: { enumerable: false, configurable: false, value: "Row" },
    [kKeys]: { writable: true, enumerable: false, configurable: false, value: null },
    [kVals]: { writable: true, enumerable: false, configurable: false, value: null }
  });

  // ../../node_modules/apache-arrow/util/vector.mjs
  function clampIndex(source, index, then) {
    const length = source.length;
    const adjust = index > -1 ? index : length + index % length;
    return then ? then(source, adjust) : adjust;
  }
  var tmp;
  function clampRange(source, begin, end, then) {
    const { length: len = 0 } = source;
    let lhs = typeof begin !== "number" ? 0 : begin;
    let rhs = typeof end !== "number" ? len : end;
    lhs < 0 && (lhs = (lhs % len + len) % len);
    rhs < 0 && (rhs = (rhs % len + len) % len);
    rhs < lhs && (tmp = lhs, lhs = rhs, rhs = tmp);
    rhs > len && (rhs = len);
    return then ? then(source, lhs, rhs) : [lhs, rhs];
  }
  var isNaNFast = (value) => value !== value;
  function createElementComparator(search) {
    const typeofSearch = typeof search;
    if (typeofSearch !== "object" || search === null) {
      if (isNaNFast(search)) {
        return isNaNFast;
      }
      return (value) => value === search;
    }
    if (search instanceof Date) {
      const valueOfSearch = search.valueOf();
      return (value) => value instanceof Date ? value.valueOf() === valueOfSearch : false;
    }
    if (ArrayBuffer.isView(search)) {
      return (value) => value ? compareArrayLike(search, value) : false;
    }
    if (search instanceof Map) {
      return createMapComparator(search);
    }
    if (Array.isArray(search)) {
      return createArrayLikeComparator(search);
    }
    if (search instanceof Vector) {
      return createVectorComparator(search);
    }
    return createObjectComparator(search, true);
  }
  function createArrayLikeComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs[i]);
    }
    return createSubElementsComparator(comparators);
  }
  function createMapComparator(lhs) {
    let i = -1;
    const comparators = [];
    for (const v of lhs.values())
      comparators[++i] = createElementComparator(v);
    return createSubElementsComparator(comparators);
  }
  function createVectorComparator(lhs) {
    const comparators = [];
    for (let i = -1, n = lhs.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs.get(i));
    }
    return createSubElementsComparator(comparators);
  }
  function createObjectComparator(lhs, allowEmpty = false) {
    const keys = Object.keys(lhs);
    if (!allowEmpty && keys.length === 0) {
      return () => false;
    }
    const comparators = [];
    for (let i = -1, n = keys.length; ++i < n; ) {
      comparators[i] = createElementComparator(lhs[keys[i]]);
    }
    return createSubElementsComparator(comparators, keys);
  }
  function createSubElementsComparator(comparators, keys) {
    return (rhs) => {
      if (!rhs || typeof rhs !== "object") {
        return false;
      }
      switch (rhs.constructor) {
        case Array:
          return compareArray(comparators, rhs);
        case Map:
          return compareObject(comparators, rhs, rhs.keys());
        case MapRow:
        case StructRow:
        case Object:
        case void 0:
          return compareObject(comparators, rhs, keys || Object.keys(rhs));
      }
      return rhs instanceof Vector ? compareVector(comparators, rhs) : false;
    };
  }
  function compareArray(comparators, arr) {
    const n = comparators.length;
    if (arr.length !== n) {
      return false;
    }
    for (let i = -1; ++i < n; ) {
      if (!comparators[i](arr[i])) {
        return false;
      }
    }
    return true;
  }
  function compareVector(comparators, vec) {
    const n = comparators.length;
    if (vec.length !== n) {
      return false;
    }
    for (let i = -1; ++i < n; ) {
      if (!comparators[i](vec.get(i))) {
        return false;
      }
    }
    return true;
  }
  function compareObject(comparators, obj, keys) {
    const lKeyItr = keys[Symbol.iterator]();
    const rKeyItr = obj instanceof Map ? obj.keys() : Object.keys(obj)[Symbol.iterator]();
    const rValItr = obj instanceof Map ? obj.values() : Object.values(obj)[Symbol.iterator]();
    let i = 0;
    const n = comparators.length;
    let rVal = rValItr.next();
    let lKey = lKeyItr.next();
    let rKey = rKeyItr.next();
    for (; i < n && !lKey.done && !rKey.done && !rVal.done; ++i, lKey = lKeyItr.next(), rKey = rKeyItr.next(), rVal = rValItr.next()) {
      if (lKey.value !== rKey.value || !comparators[i](rVal.value)) {
        break;
      }
    }
    if (i === n && lKey.done && rKey.done && rVal.done) {
      return true;
    }
    lKeyItr.return && lKeyItr.return();
    rKeyItr.return && rKeyItr.return();
    rValItr.return && rValItr.return();
    return false;
  }

  // ../../node_modules/apache-arrow/util/bit.mjs
  var bit_exports = {};
  __export(bit_exports, {
    BitIterator: () => BitIterator,
    getBit: () => getBit,
    getBool: () => getBool2,
    packBools: () => packBools,
    popcnt_array: () => popcnt_array,
    popcnt_bit_range: () => popcnt_bit_range,
    popcnt_uint32: () => popcnt_uint32,
    setBool: () => setBool2,
    truncateBitmap: () => truncateBitmap
  });
  function getBool2(_data, _index, byte, bit) {
    return (byte & 1 << bit) !== 0;
  }
  function getBit(_data, _index, byte, bit) {
    return (byte & 1 << bit) >> bit;
  }
  function setBool2(bytes, index, value) {
    return value ? !!(bytes[index >> 3] |= 1 << index % 8) || true : !(bytes[index >> 3] &= ~(1 << index % 8)) && false;
  }
  function truncateBitmap(offset, length, bitmap) {
    const alignedSize = bitmap.byteLength + 7 & ~7;
    if (offset > 0 || bitmap.byteLength < alignedSize) {
      const bytes = new Uint8Array(alignedSize);
      bytes.set(offset % 8 === 0 ? bitmap.subarray(offset >> 3) : packBools(new BitIterator(bitmap, offset, length, null, getBool2)).subarray(0, alignedSize));
      return bytes;
    }
    return bitmap;
  }
  function packBools(values) {
    const xs = [];
    let i = 0, bit = 0, byte = 0;
    for (const value of values) {
      value && (byte |= 1 << bit);
      if (++bit === 8) {
        xs[i++] = byte;
        byte = bit = 0;
      }
    }
    if (i === 0 || bit > 0) {
      xs[i++] = byte;
    }
    const b = new Uint8Array(xs.length + 7 & ~7);
    b.set(xs);
    return b;
  }
  var BitIterator = class {
    constructor(bytes, begin, length, context, get) {
      this.bytes = bytes;
      this.length = length;
      this.context = context;
      this.get = get;
      this.bit = begin % 8;
      this.byteIndex = begin >> 3;
      this.byte = bytes[this.byteIndex++];
      this.index = 0;
    }
    next() {
      if (this.index < this.length) {
        if (this.bit === 8) {
          this.bit = 0;
          this.byte = this.bytes[this.byteIndex++];
        }
        return {
          value: this.get(this.context, this.index++, this.byte, this.bit++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function popcnt_bit_range(data, lhs, rhs) {
    if (rhs - lhs <= 0) {
      return 0;
    }
    if (rhs - lhs < 8) {
      let sum2 = 0;
      for (const bit of new BitIterator(data, lhs, rhs - lhs, data, getBit)) {
        sum2 += bit;
      }
      return sum2;
    }
    const rhsInside = rhs >> 3 << 3;
    const lhsInside = lhs + (lhs % 8 === 0 ? 0 : 8 - lhs % 8);
    return popcnt_bit_range(data, lhs, lhsInside) + popcnt_bit_range(data, rhsInside, rhs) + popcnt_array(data, lhsInside >> 3, rhsInside - lhsInside >> 3);
  }
  function popcnt_array(arr, byteOffset, byteLength) {
    let cnt = 0, pos = Math.trunc(byteOffset);
    const view = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    const len = byteLength === void 0 ? arr.byteLength : pos + byteLength;
    while (len - pos >= 4) {
      cnt += popcnt_uint32(view.getUint32(pos));
      pos += 4;
    }
    while (len - pos >= 2) {
      cnt += popcnt_uint32(view.getUint16(pos));
      pos += 2;
    }
    while (len - pos >= 1) {
      cnt += popcnt_uint32(view.getUint8(pos));
      pos += 1;
    }
    return cnt;
  }
  function popcnt_uint32(uint32) {
    let i = Math.trunc(uint32);
    i = i - (i >>> 1 & 1431655765);
    i = (i & 858993459) + (i >>> 2 & 858993459);
    return (i + (i >>> 4) & 252645135) * 16843009 >>> 24;
  }

  // ../../node_modules/apache-arrow/data.mjs
  var kUnknownNullCount = -1;
  var Data = class {
    constructor(type, offset, length, nullCount, buffers, children = [], dictionary) {
      this.type = type;
      this.children = children;
      this.dictionary = dictionary;
      this.offset = Math.floor(Math.max(offset || 0, 0));
      this.length = Math.floor(Math.max(length || 0, 0));
      this._nullCount = Math.floor(Math.max(nullCount || 0, -1));
      let buffer;
      if (buffers instanceof Data) {
        this.stride = buffers.stride;
        this.values = buffers.values;
        this.typeIds = buffers.typeIds;
        this.nullBitmap = buffers.nullBitmap;
        this.valueOffsets = buffers.valueOffsets;
      } else {
        this.stride = strideForType(type);
        if (buffers) {
          (buffer = buffers[0]) && (this.valueOffsets = buffer);
          (buffer = buffers[1]) && (this.values = buffer);
          (buffer = buffers[2]) && (this.nullBitmap = buffer);
          (buffer = buffers[3]) && (this.typeIds = buffer);
        }
      }
      this.nullable = this._nullCount !== 0 && this.nullBitmap && this.nullBitmap.byteLength > 0;
    }
    get typeId() {
      return this.type.typeId;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get buffers() {
      return [this.valueOffsets, this.values, this.nullBitmap, this.typeIds];
    }
    get byteLength() {
      let byteLength = 0;
      const { valueOffsets, values, nullBitmap, typeIds } = this;
      valueOffsets && (byteLength += valueOffsets.byteLength);
      values && (byteLength += values.byteLength);
      nullBitmap && (byteLength += nullBitmap.byteLength);
      typeIds && (byteLength += typeIds.byteLength);
      return this.children.reduce((byteLength2, child) => byteLength2 + child.byteLength, byteLength);
    }
    get nullCount() {
      let nullCount = this._nullCount;
      let nullBitmap;
      if (nullCount <= kUnknownNullCount && (nullBitmap = this.nullBitmap)) {
        this._nullCount = nullCount = this.length - popcnt_bit_range(nullBitmap, this.offset, this.offset + this.length);
      }
      return nullCount;
    }
    getValid(index) {
      if (this.nullable && this.nullCount > 0) {
        const pos = this.offset + index;
        const val = this.nullBitmap[pos >> 3];
        return (val & 1 << pos % 8) !== 0;
      }
      return true;
    }
    setValid(index, value) {
      if (!this.nullable) {
        return value;
      }
      if (!this.nullBitmap || this.nullBitmap.byteLength <= index >> 3) {
        const { nullBitmap: nullBitmap2 } = this._changeLengthAndBackfillNullBitmap(this.length);
        Object.assign(this, { nullBitmap: nullBitmap2, _nullCount: 0 });
      }
      const { nullBitmap, offset } = this;
      const pos = offset + index >> 3;
      const bit = (offset + index) % 8;
      const val = nullBitmap[pos] >> bit & 1;
      value ? val === 0 && (nullBitmap[pos] |= 1 << bit, this._nullCount = this.nullCount + 1) : val === 1 && (nullBitmap[pos] &= ~(1 << bit), this._nullCount = this.nullCount - 1);
      return value;
    }
    clone(type = this.type, offset = this.offset, length = this.length, nullCount = this._nullCount, buffers = this, children = this.children) {
      return new Data(type, offset, length, nullCount, buffers, children, this.dictionary);
    }
    slice(offset, length) {
      const { stride, typeId, children } = this;
      const nullCount = +(this._nullCount === 0) - 1;
      const childStride = typeId === 16 ? stride : 1;
      const buffers = this._sliceBuffers(offset, length, stride, typeId);
      return this.clone(
        this.type,
        this.offset + offset,
        length,
        nullCount,
        buffers,
        children.length === 0 || this.valueOffsets ? children : this._sliceChildren(children, childStride * offset, childStride * length)
      );
    }
    _changeLengthAndBackfillNullBitmap(newLength) {
      if (this.typeId === Type.Null) {
        return this.clone(this.type, 0, newLength, 0);
      }
      const { length, nullCount } = this;
      const bitmap = new Uint8Array((newLength + 63 & ~63) >> 3).fill(255, 0, length >> 3);
      bitmap[length >> 3] = (1 << length - (length & ~7)) - 1;
      if (nullCount > 0) {
        bitmap.set(truncateBitmap(this.offset, length, this.nullBitmap), 0);
      }
      const buffers = this.buffers;
      buffers[BufferType.VALIDITY] = bitmap;
      return this.clone(this.type, 0, newLength, nullCount + (newLength - length), buffers);
    }
    _sliceBuffers(offset, length, stride, typeId) {
      let arr;
      const { buffers } = this;
      (arr = buffers[BufferType.TYPE]) && (buffers[BufferType.TYPE] = arr.subarray(offset, offset + length));
      (arr = buffers[BufferType.OFFSET]) && (buffers[BufferType.OFFSET] = arr.subarray(offset, offset + length + 1)) || (arr = buffers[BufferType.DATA]) && (buffers[BufferType.DATA] = typeId === 6 ? arr : arr.subarray(stride * offset, stride * (offset + length)));
      return buffers;
    }
    _sliceChildren(children, offset, length) {
      return children.map((child) => child.slice(offset, length));
    }
  };
  Data.prototype.children = Object.freeze([]);
  var MakeDataVisitor = class extends Visitor {
    visit(props) {
      return this.getVisitFn(props["type"]).call(this, props);
    }
    visitNull(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["length"]: length = 0 } = props;
      return new Data(type, offset, length, 0);
    }
    visitBool(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length >> 3, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitInt(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitFloat(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitUtf8(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const data = toUint8Array(props["data"]);
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, data, nullBitmap]);
    }
    visitFixedSizeBinary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitDate(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitTimestamp(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitTime(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitDecimal(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
    visitStruct(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { length = children.reduce((len, { length: length2 }) => Math.max(len, length2), 0), nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], children);
    }
    visitUnion(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["children"]: children = [] } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const typeIds = toArrayBufferView(type.ArrayType, props["typeIds"]);
      const { ["length"]: length = typeIds.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      if (DataType.isSparseUnion(type)) {
        return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap, typeIds], children);
      }
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap, typeIds], children);
    }
    visitDictionary(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.indices.ArrayType, props["data"]);
      const { ["dictionary"]: dictionary = new Vector([new MakeDataVisitor().visit({ type: type.dictionary })]) } = props;
      const { ["length"]: length = data.length, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap], [], dictionary);
    }
    visitInterval(props) {
      const { ["type"]: type, ["offset"]: offset = 0 } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const data = toArrayBufferView(type.ArrayType, props["data"]);
      const { ["length"]: length = data.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, data, nullBitmap]);
    }
    visitFixedSizeList(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.valueType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const { ["length"]: length = child.length / strideForType(type), ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [void 0, void 0, nullBitmap], [child]);
    }
    visitMap(props) {
      const { ["type"]: type, ["offset"]: offset = 0, ["child"]: child = new MakeDataVisitor().visit({ type: type.childType }) } = props;
      const nullBitmap = toUint8Array(props["nullBitmap"]);
      const valueOffsets = toInt32Array(props["valueOffsets"]);
      const { ["length"]: length = valueOffsets.length - 1, ["nullCount"]: nullCount = props["nullBitmap"] ? -1 : 0 } = props;
      return new Data(type, offset, length, nullCount, [valueOffsets, void 0, nullBitmap], [child]);
    }
  };
  function makeData(props) {
    return new MakeDataVisitor().visit(props);
  }

  // ../../node_modules/apache-arrow/util/chunk.mjs
  var ChunkedIterator = class {
    constructor(numChunks = 0, getChunkIterator) {
      this.numChunks = numChunks;
      this.getChunkIterator = getChunkIterator;
      this.chunkIndex = 0;
      this.chunkIterator = this.getChunkIterator(0);
    }
    next() {
      while (this.chunkIndex < this.numChunks) {
        const next = this.chunkIterator.next();
        if (!next.done) {
          return next;
        }
        if (++this.chunkIndex < this.numChunks) {
          this.chunkIterator = this.getChunkIterator(this.chunkIndex);
        }
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  function computeChunkNullCounts(chunks) {
    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);
  }
  function computeChunkOffsets(chunks) {
    return chunks.reduce((offsets, chunk, index) => {
      offsets[index + 1] = offsets[index] + chunk.length;
      return offsets;
    }, new Uint32Array(chunks.length + 1));
  }
  function sliceChunks(chunks, offsets, begin, end) {
    const slices = [];
    for (let i = -1, n = chunks.length; ++i < n; ) {
      const chunk = chunks[i];
      const offset = offsets[i];
      const { length } = chunk;
      if (offset >= end) {
        break;
      }
      if (begin >= offset + length) {
        continue;
      }
      if (offset >= begin && offset + length <= end) {
        slices.push(chunk);
        continue;
      }
      const from = Math.max(0, begin - offset);
      const to = Math.min(end - offset, length);
      slices.push(chunk.slice(from, to - from));
    }
    if (slices.length === 0) {
      slices.push(chunks[0].slice(0, 0));
    }
    return slices;
  }
  function binarySearch(chunks, offsets, idx, fn) {
    let lhs = 0, mid = 0, rhs = offsets.length - 1;
    do {
      if (lhs >= rhs - 1) {
        return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;
      }
      mid = lhs + Math.trunc((rhs - lhs) * 0.5);
      idx < offsets[mid] ? rhs = mid : lhs = mid;
    } while (lhs < rhs);
  }
  function isChunkedValid(data, index) {
    return data.getValid(index);
  }
  function wrapChunkedCall1(fn) {
    function chunkedFn(chunks, i, j) {
      return fn(chunks[i], j);
    }
    return function(index) {
      const data = this.data;
      return binarySearch(data, this._offsets, index, chunkedFn);
    };
  }
  function wrapChunkedCall2(fn) {
    let _2;
    function chunkedFn(chunks, i, j) {
      return fn(chunks[i], j, _2);
    }
    return function(index, value) {
      const data = this.data;
      _2 = value;
      const result = binarySearch(data, this._offsets, index, chunkedFn);
      _2 = void 0;
      return result;
    };
  }
  function wrapChunkedIndexOf(indexOf) {
    let _1;
    function chunkedIndexOf(data, chunkIndex, fromIndex) {
      let begin = fromIndex, index = 0, total = 0;
      for (let i = chunkIndex - 1, n = data.length; ++i < n; ) {
        const chunk = data[i];
        if (~(index = indexOf(chunk, _1, begin))) {
          return total + index;
        }
        begin = 0;
        total += chunk.length;
      }
      return -1;
    }
    return function(element, offset) {
      _1 = element;
      const data = this.data;
      const result = typeof offset !== "number" ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);
      _1 = void 0;
      return result;
    };
  }

  // ../../node_modules/apache-arrow/visitor/indexof.mjs
  var IndexOfVisitor = class extends Visitor {
  };
  function nullIndexOf(data, searchElement) {
    return searchElement === null && data.length > 0 ? 0 : -1;
  }
  function indexOfNull(data, fromIndex) {
    const { nullBitmap } = data;
    if (!nullBitmap || data.nullCount <= 0) {
      return -1;
    }
    let i = 0;
    for (const isValid of new BitIterator(nullBitmap, data.offset + (fromIndex || 0), data.length, nullBitmap, getBool2)) {
      if (!isValid) {
        return i;
      }
      ++i;
    }
    return -1;
  }
  function indexOfValue(data, searchElement, fromIndex) {
    if (searchElement === void 0) {
      return -1;
    }
    if (searchElement === null) {
      return indexOfNull(data, fromIndex);
    }
    const get = instance2.getVisitFn(data);
    const compare = createElementComparator(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
      if (compare(get(data, i))) {
        return i;
      }
    }
    return -1;
  }
  function indexOfUnion(data, searchElement, fromIndex) {
    const get = instance2.getVisitFn(data);
    const compare = createElementComparator(searchElement);
    for (let i = (fromIndex || 0) - 1, n = data.length; ++i < n; ) {
      if (compare(get(data, i))) {
        return i;
      }
    }
    return -1;
  }
  IndexOfVisitor.prototype.visitNull = nullIndexOf;
  IndexOfVisitor.prototype.visitBool = indexOfValue;
  IndexOfVisitor.prototype.visitInt = indexOfValue;
  IndexOfVisitor.prototype.visitInt8 = indexOfValue;
  IndexOfVisitor.prototype.visitInt16 = indexOfValue;
  IndexOfVisitor.prototype.visitInt32 = indexOfValue;
  IndexOfVisitor.prototype.visitInt64 = indexOfValue;
  IndexOfVisitor.prototype.visitUint8 = indexOfValue;
  IndexOfVisitor.prototype.visitUint16 = indexOfValue;
  IndexOfVisitor.prototype.visitUint32 = indexOfValue;
  IndexOfVisitor.prototype.visitUint64 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat = indexOfValue;
  IndexOfVisitor.prototype.visitFloat16 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat32 = indexOfValue;
  IndexOfVisitor.prototype.visitFloat64 = indexOfValue;
  IndexOfVisitor.prototype.visitUtf8 = indexOfValue;
  IndexOfVisitor.prototype.visitBinary = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeBinary = indexOfValue;
  IndexOfVisitor.prototype.visitDate = indexOfValue;
  IndexOfVisitor.prototype.visitDateDay = indexOfValue;
  IndexOfVisitor.prototype.visitDateMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestamp = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimestampNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTime = indexOfValue;
  IndexOfVisitor.prototype.visitTimeSecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMillisecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeMicrosecond = indexOfValue;
  IndexOfVisitor.prototype.visitTimeNanosecond = indexOfValue;
  IndexOfVisitor.prototype.visitDecimal = indexOfValue;
  IndexOfVisitor.prototype.visitList = indexOfValue;
  IndexOfVisitor.prototype.visitStruct = indexOfValue;
  IndexOfVisitor.prototype.visitUnion = indexOfValue;
  IndexOfVisitor.prototype.visitDenseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitSparseUnion = indexOfUnion;
  IndexOfVisitor.prototype.visitDictionary = indexOfValue;
  IndexOfVisitor.prototype.visitInterval = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalDayTime = indexOfValue;
  IndexOfVisitor.prototype.visitIntervalYearMonth = indexOfValue;
  IndexOfVisitor.prototype.visitFixedSizeList = indexOfValue;
  IndexOfVisitor.prototype.visitMap = indexOfValue;
  var instance3 = new IndexOfVisitor();

  // ../../node_modules/apache-arrow/visitor/iterator.mjs
  var IteratorVisitor = class extends Visitor {
  };
  function vectorIterator(vector) {
    const { type } = vector;
    if (vector.nullCount === 0 && vector.stride === 1 && (type.typeId === Type.Timestamp || type instanceof Int_ && type.bitWidth !== 64 || type instanceof Time_ && type.bitWidth !== 64 || type instanceof Float && type.precision !== Precision.HALF)) {
      return new ChunkedIterator(vector.data.length, (chunkIndex) => {
        const data = vector.data[chunkIndex];
        return data.values.subarray(0, data.length)[Symbol.iterator]();
      });
    }
    let offset = 0;
    return new ChunkedIterator(vector.data.length, (chunkIndex) => {
      const data = vector.data[chunkIndex];
      const length = data.length;
      const inner = vector.slice(offset, offset + length);
      offset += length;
      return new VectorIterator(inner);
    });
  }
  var VectorIterator = class {
    constructor(vector) {
      this.vector = vector;
      this.index = 0;
    }
    next() {
      if (this.index < this.vector.length) {
        return {
          value: this.vector.get(this.index++)
        };
      }
      return { done: true, value: null };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  IteratorVisitor.prototype.visitNull = vectorIterator;
  IteratorVisitor.prototype.visitBool = vectorIterator;
  IteratorVisitor.prototype.visitInt = vectorIterator;
  IteratorVisitor.prototype.visitInt8 = vectorIterator;
  IteratorVisitor.prototype.visitInt16 = vectorIterator;
  IteratorVisitor.prototype.visitInt32 = vectorIterator;
  IteratorVisitor.prototype.visitInt64 = vectorIterator;
  IteratorVisitor.prototype.visitUint8 = vectorIterator;
  IteratorVisitor.prototype.visitUint16 = vectorIterator;
  IteratorVisitor.prototype.visitUint32 = vectorIterator;
  IteratorVisitor.prototype.visitUint64 = vectorIterator;
  IteratorVisitor.prototype.visitFloat = vectorIterator;
  IteratorVisitor.prototype.visitFloat16 = vectorIterator;
  IteratorVisitor.prototype.visitFloat32 = vectorIterator;
  IteratorVisitor.prototype.visitFloat64 = vectorIterator;
  IteratorVisitor.prototype.visitUtf8 = vectorIterator;
  IteratorVisitor.prototype.visitBinary = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeBinary = vectorIterator;
  IteratorVisitor.prototype.visitDate = vectorIterator;
  IteratorVisitor.prototype.visitDateDay = vectorIterator;
  IteratorVisitor.prototype.visitDateMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestamp = vectorIterator;
  IteratorVisitor.prototype.visitTimestampSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimestampNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitTime = vectorIterator;
  IteratorVisitor.prototype.visitTimeSecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMillisecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeMicrosecond = vectorIterator;
  IteratorVisitor.prototype.visitTimeNanosecond = vectorIterator;
  IteratorVisitor.prototype.visitDecimal = vectorIterator;
  IteratorVisitor.prototype.visitList = vectorIterator;
  IteratorVisitor.prototype.visitStruct = vectorIterator;
  IteratorVisitor.prototype.visitUnion = vectorIterator;
  IteratorVisitor.prototype.visitDenseUnion = vectorIterator;
  IteratorVisitor.prototype.visitSparseUnion = vectorIterator;
  IteratorVisitor.prototype.visitDictionary = vectorIterator;
  IteratorVisitor.prototype.visitInterval = vectorIterator;
  IteratorVisitor.prototype.visitIntervalDayTime = vectorIterator;
  IteratorVisitor.prototype.visitIntervalYearMonth = vectorIterator;
  IteratorVisitor.prototype.visitFixedSizeList = vectorIterator;
  IteratorVisitor.prototype.visitMap = vectorIterator;
  var instance4 = new IteratorVisitor();

  // ../../node_modules/apache-arrow/visitor/bytelength.mjs
  var sum = (x, y) => x + y;
  var GetByteLengthVisitor = class extends Visitor {
    visitNull(____, _) {
      return 0;
    }
    visitInt(data, _) {
      return data.type.bitWidth / 8;
    }
    visitFloat(data, _) {
      return data.type.ArrayType.BYTES_PER_ELEMENT;
    }
    visitBool(____, _) {
      return 1 / 8;
    }
    visitDecimal(data, _) {
      return data.type.bitWidth / 8;
    }
    visitDate(data, _) {
      return (data.type.unit + 1) * 4;
    }
    visitTime(data, _) {
      return data.type.bitWidth / 8;
    }
    visitTimestamp(data, _) {
      return data.type.unit === TimeUnit.SECOND ? 4 : 8;
    }
    visitInterval(data, _) {
      return (data.type.unit + 1) * 4;
    }
    visitStruct(data, i) {
      return data.children.reduce((total, child) => total + instance5.visit(child, i), 0);
    }
    visitFixedSizeBinary(data, _) {
      return data.type.byteWidth;
    }
    visitMap(data, i) {
      return 8 + data.children.reduce((total, child) => total + instance5.visit(child, i), 0);
    }
    visitDictionary(data, i) {
      var _a5;
      return data.type.indices.bitWidth / 8 + (((_a5 = data.dictionary) === null || _a5 === void 0 ? void 0 : _a5.getByteLength(data.values[i])) || 0);
    }
  };
  var getUtf8ByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getBinaryByteLength = ({ valueOffsets }, index) => {
    return 8 + (valueOffsets[index + 1] - valueOffsets[index]);
  };
  var getListByteLength = ({ valueOffsets, stride, children }, index) => {
    const child = children[0];
    const { [index * stride]: start } = valueOffsets;
    const { [index * stride + 1]: end } = valueOffsets;
    const visit = instance5.getVisitFn(child.type);
    const slice = child.slice(start, end - start);
    let size = 8;
    for (let idx = -1, len = end - start; ++idx < len; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getFixedSizeListByteLength = ({ stride, children }, index) => {
    const child = children[0];
    const slice = child.slice(index * stride, stride);
    const visit = instance5.getVisitFn(child.type);
    let size = 0;
    for (let idx = -1, len = slice.length; ++idx < len; ) {
      size += visit(slice, idx);
    }
    return size;
  };
  var getUnionByteLength = (data, index) => {
    return data.type.mode === UnionMode.Dense ? getDenseUnionByteLength(data, index) : getSparseUnionByteLength(data, index);
  };
  var getDenseUnionByteLength = ({ type, children, typeIds, valueOffsets }, index) => {
    const childIndex = type.typeIdToChildIndex[typeIds[index]];
    return 8 + instance5.visit(children[childIndex], valueOffsets[index]);
  };
  var getSparseUnionByteLength = ({ children }, index) => {
    return 4 + instance5.visitMany(children, children.map(() => index)).reduce(sum, 0);
  };
  GetByteLengthVisitor.prototype.visitUtf8 = getUtf8ByteLength;
  GetByteLengthVisitor.prototype.visitBinary = getBinaryByteLength;
  GetByteLengthVisitor.prototype.visitList = getListByteLength;
  GetByteLengthVisitor.prototype.visitFixedSizeList = getFixedSizeListByteLength;
  GetByteLengthVisitor.prototype.visitUnion = getUnionByteLength;
  GetByteLengthVisitor.prototype.visitDenseUnion = getDenseUnionByteLength;
  GetByteLengthVisitor.prototype.visitSparseUnion = getSparseUnionByteLength;
  var instance5 = new GetByteLengthVisitor();

  // ../../node_modules/apache-arrow/vector.mjs
  var _a2;
  var visitorsByTypeId = {};
  var vectorPrototypesByTypeId = {};
  var Vector = class {
    constructor(input) {
      var _b2, _c2, _d2;
      const data = input[0] instanceof Vector ? input.flatMap((x) => x.data) : input;
      if (data.length === 0 || data.some((x) => !(x instanceof Data))) {
        throw new TypeError("Vector constructor expects an Array of Data instances.");
      }
      const type = (_b2 = data[0]) === null || _b2 === void 0 ? void 0 : _b2.type;
      switch (data.length) {
        case 0:
          this._offsets = [0];
          break;
        case 1: {
          const { get, set, indexOf, byteLength } = visitorsByTypeId[type.typeId];
          const unchunkedData = data[0];
          this.isValid = (index) => isChunkedValid(unchunkedData, index);
          this.get = (index) => get(unchunkedData, index);
          this.set = (index, value) => set(unchunkedData, index, value);
          this.indexOf = (index) => indexOf(unchunkedData, index);
          this.getByteLength = (index) => byteLength(unchunkedData, index);
          this._offsets = [0, unchunkedData.length];
          break;
        }
        default:
          Object.setPrototypeOf(this, vectorPrototypesByTypeId[type.typeId]);
          this._offsets = computeChunkOffsets(data);
          break;
      }
      this.data = data;
      this.type = type;
      this.stride = strideForType(type);
      this.numChildren = (_d2 = (_c2 = type.children) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
      this.length = this._offsets[this._offsets.length - 1];
    }
    get byteLength() {
      if (this._byteLength === -1) {
        this._byteLength = this.data.reduce((byteLength, data) => byteLength + data.byteLength, 0);
      }
      return this._byteLength;
    }
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get [Symbol.toStringTag]() {
      return `${this.VectorName}<${this.type[Symbol.toStringTag]}>`;
    }
    get VectorName() {
      return `${Type[this.type.typeId]}Vector`;
    }
    isValid(index) {
      return false;
    }
    get(index) {
      return null;
    }
    set(index, value) {
      return;
    }
    indexOf(element, offset) {
      return -1;
    }
    includes(element, offset) {
      return this.indexOf(element, offset) > 0;
    }
    getByteLength(index) {
      return 0;
    }
    [Symbol.iterator]() {
      return instance4.visit(this);
    }
    concat(...others) {
      return new Vector(this.data.concat(others.flatMap((x) => x.data).flat(Number.POSITIVE_INFINITY)));
    }
    slice(begin, end) {
      return new Vector(clampRange(this, begin, end, ({ data, _offsets }, begin2, end2) => sliceChunks(data, _offsets, begin2, end2)));
    }
    toJSON() {
      return [...this];
    }
    toArray() {
      const { type, data, length, stride, ArrayType } = this;
      switch (type.typeId) {
        case Type.Int:
        case Type.Float:
        case Type.Decimal:
        case Type.Time:
        case Type.Timestamp:
          switch (data.length) {
            case 0:
              return new ArrayType();
            case 1:
              return data[0].values.subarray(0, length * stride);
            default:
              return data.reduce((memo, { values, length: chunk_length }) => {
                memo.array.set(values.subarray(0, chunk_length * stride), memo.offset);
                memo.offset += chunk_length * stride;
                return memo;
              }, { array: new ArrayType(length * stride), offset: 0 }).array;
          }
      }
      return [...this];
    }
    toString() {
      return `[${[...this].join(",")}]`;
    }
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.type.children) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.numChildren) {
        return new Vector(this.data.map(({ children }) => children[index]));
      }
      return null;
    }
    get isMemoized() {
      if (DataType.isDictionary(this.type)) {
        return this.data[0].dictionary.isMemoized;
      }
      return false;
    }
    memoize() {
      if (DataType.isDictionary(this.type)) {
        const dictionary = new MemoizedVector(this.data[0].dictionary);
        const newData = this.data.map((data) => {
          const cloned = data.clone();
          cloned.dictionary = dictionary;
          return cloned;
        });
        return new Vector(newData);
      }
      return new MemoizedVector(this);
    }
    unmemoize() {
      if (DataType.isDictionary(this.type) && this.isMemoized) {
        const dictionary = this.data[0].dictionary.unmemoize();
        const newData = this.data.map((data) => {
          const newData2 = data.clone();
          newData2.dictionary = dictionary;
          return newData2;
        });
        return new Vector(newData);
      }
      return this;
    }
  };
  _a2 = Symbol.toStringTag;
  Vector[_a2] = ((proto) => {
    proto.type = DataType.prototype;
    proto.data = [];
    proto.length = 0;
    proto.stride = 1;
    proto.numChildren = 0;
    proto._nullCount = -1;
    proto._byteLength = -1;
    proto._offsets = new Uint32Array([0]);
    proto[Symbol.isConcatSpreadable] = true;
    const typeIds = Object.keys(Type).map((T) => Type[T]).filter((T) => typeof T === "number" && T !== Type.NONE);
    for (const typeId of typeIds) {
      const get = instance2.getVisitFnByTypeId(typeId);
      const set = instance.getVisitFnByTypeId(typeId);
      const indexOf = instance3.getVisitFnByTypeId(typeId);
      const byteLength = instance5.getVisitFnByTypeId(typeId);
      visitorsByTypeId[typeId] = { get, set, indexOf, byteLength };
      vectorPrototypesByTypeId[typeId] = Object.create(proto, {
        ["isValid"]: { value: wrapChunkedCall1(isChunkedValid) },
        ["get"]: { value: wrapChunkedCall1(instance2.getVisitFnByTypeId(typeId)) },
        ["set"]: { value: wrapChunkedCall2(instance.getVisitFnByTypeId(typeId)) },
        ["indexOf"]: { value: wrapChunkedIndexOf(instance3.getVisitFnByTypeId(typeId)) },
        ["getByteLength"]: { value: wrapChunkedCall1(instance5.getVisitFnByTypeId(typeId)) }
      });
    }
    return "Vector";
  })(Vector.prototype);
  var MemoizedVector = class extends Vector {
    constructor(vector) {
      super(vector.data);
      const get = this.get;
      const set = this.set;
      const slice = this.slice;
      const cache = new Array(this.length);
      Object.defineProperty(this, "get", {
        value(index) {
          const cachedValue = cache[index];
          if (cachedValue !== void 0) {
            return cachedValue;
          }
          const value = get.call(this, index);
          cache[index] = value;
          return value;
        }
      });
      Object.defineProperty(this, "set", {
        value(index, value) {
          set.call(this, index, value);
          cache[index] = value;
        }
      });
      Object.defineProperty(this, "slice", {
        value: (begin, end) => new MemoizedVector(slice.call(this, begin, end))
      });
      Object.defineProperty(this, "isMemoized", { value: true });
      Object.defineProperty(this, "unmemoize", {
        value: () => new Vector(this.data)
      });
      Object.defineProperty(this, "memoize", {
        value: () => this
      });
    }
  };
  function makeVector(init) {
    if (init) {
      if (init instanceof Data) {
        return new Vector([init]);
      }
      if (init instanceof Vector) {
        return new Vector(init.data);
      }
      if (init.type instanceof DataType) {
        return new Vector([makeData(init)]);
      }
      if (Array.isArray(init)) {
        return new Vector(init.flatMap((v) => unwrapInputs(v)));
      }
      if (ArrayBuffer.isView(init)) {
        if (init instanceof DataView) {
          init = new Uint8Array(init.buffer);
        }
        const props = { offset: 0, length: init.length, nullCount: 0, data: init };
        if (init instanceof Int8Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int8() }))]);
        }
        if (init instanceof Int16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int16() }))]);
        }
        if (init instanceof Int32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int32() }))]);
        }
        if (init instanceof BigInt64ArrayCtor) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Int64() }))]);
        }
        if (init instanceof Uint8Array || init instanceof Uint8ClampedArray) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint8() }))]);
        }
        if (init instanceof Uint16Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint16() }))]);
        }
        if (init instanceof Uint32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint32() }))]);
        }
        if (init instanceof BigUint64ArrayCtor) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Uint64() }))]);
        }
        if (init instanceof Float32Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float32() }))]);
        }
        if (init instanceof Float64Array) {
          return new Vector([makeData(Object.assign(Object.assign({}, props), { type: new Float64() }))]);
        }
        throw new Error("Unrecognized input");
      }
    }
    throw new Error("Unrecognized input");
  }
  function unwrapInputs(x) {
    return x instanceof Data ? [x] : x instanceof Vector ? x.data : makeVector(x).data;
  }

  // ../../node_modules/apache-arrow/builder/valid.mjs
  function createIsValidFunction(nullValues) {
    if (!nullValues || nullValues.length <= 0) {
      return function isValid(value) {
        return true;
      };
    }
    let fnBody = "";
    const noNaNs = nullValues.filter((x) => x === x);
    if (noNaNs.length > 0) {
      fnBody = `
    switch (x) {${noNaNs.map((x) => `
        case ${valueToCase(x)}:`).join("")}
            return false;
    }`;
    }
    if (nullValues.length !== noNaNs.length) {
      fnBody = `if (x !== x) return false;
${fnBody}`;
    }
    return new Function(`x`, `${fnBody}
return true;`);
  }
  function valueToCase(x) {
    if (typeof x !== "bigint") {
      return valueToString(x);
    } else if (BigIntAvailable) {
      return `${valueToString(x)}n`;
    }
    return `"${valueToString(x)}"`;
  }

  // ../../node_modules/apache-arrow/builder/buffer.mjs
  var roundLengthUpToNearest64Bytes = (len, BPE) => (Math.ceil(len) * BPE + 63 & ~63 || 64) / BPE;
  var sliceOrExtendArray = (arr, len = 0) => arr.length >= len ? arr.subarray(0, len) : memcpy(new arr.constructor(len), arr, 0);
  var BufferBuilder = class {
    constructor(buffer, stride = 1) {
      this.buffer = buffer;
      this.stride = stride;
      this.BYTES_PER_ELEMENT = buffer.BYTES_PER_ELEMENT;
      this.ArrayType = buffer.constructor;
      this._resize(this.length = Math.ceil(buffer.length / stride));
    }
    get byteLength() {
      return Math.ceil(this.length * this.stride) * this.BYTES_PER_ELEMENT;
    }
    get reservedLength() {
      return this.buffer.length / this.stride;
    }
    get reservedByteLength() {
      return this.buffer.byteLength;
    }
    set(index, value) {
      return this;
    }
    append(value) {
      return this.set(this.length, value);
    }
    reserve(extra) {
      if (extra > 0) {
        this.length += extra;
        const stride = this.stride;
        const length = this.length * stride;
        const reserved = this.buffer.length;
        if (length >= reserved) {
          this._resize(reserved === 0 ? roundLengthUpToNearest64Bytes(length * 1, this.BYTES_PER_ELEMENT) : roundLengthUpToNearest64Bytes(length * 2, this.BYTES_PER_ELEMENT));
        }
      }
      return this;
    }
    flush(length = this.length) {
      length = roundLengthUpToNearest64Bytes(length * this.stride, this.BYTES_PER_ELEMENT);
      const array = sliceOrExtendArray(this.buffer, length);
      this.clear();
      return array;
    }
    clear() {
      this.length = 0;
      this._resize(0);
      return this;
    }
    _resize(newLength) {
      return this.buffer = memcpy(new this.ArrayType(newLength), this.buffer);
    }
  };
  BufferBuilder.prototype.offset = 0;
  var DataBufferBuilder = class extends BufferBuilder {
    last() {
      return this.get(this.length - 1);
    }
    get(index) {
      return this.buffer[index];
    }
    set(index, value) {
      this.reserve(index - this.length + 1);
      this.buffer[index * this.stride] = value;
      return this;
    }
  };
  var BitmapBufferBuilder = class extends DataBufferBuilder {
    constructor(data = new Uint8Array(0)) {
      super(data, 1 / 8);
      this.numValid = 0;
    }
    get numInvalid() {
      return this.length - this.numValid;
    }
    get(idx) {
      return this.buffer[idx >> 3] >> idx % 8 & 1;
    }
    set(idx, val) {
      const { buffer } = this.reserve(idx - this.length + 1);
      const byte = idx >> 3, bit = idx % 8, cur = buffer[byte] >> bit & 1;
      val ? cur === 0 && (buffer[byte] |= 1 << bit, ++this.numValid) : cur === 1 && (buffer[byte] &= ~(1 << bit), --this.numValid);
      return this;
    }
    clear() {
      this.numValid = 0;
      return super.clear();
    }
  };
  var OffsetsBufferBuilder = class extends DataBufferBuilder {
    constructor(data = new Int32Array(1)) {
      super(data, 1);
    }
    append(value) {
      return this.set(this.length - 1, value);
    }
    set(index, value) {
      const offset = this.length - 1;
      const buffer = this.reserve(index - offset + 1).buffer;
      if (offset < index++) {
        buffer.fill(buffer[offset], offset, index);
      }
      buffer[index] = buffer[index - 1] + value;
      return this;
    }
    flush(length = this.length - 1) {
      if (length > this.length) {
        this.set(length - 1, 0);
      }
      return super.flush(length + 1);
    }
  };

  // ../../node_modules/apache-arrow/builder.mjs
  var Builder = class {
    constructor({ "type": type, "nullValues": nulls }) {
      this.length = 0;
      this.finished = false;
      this.type = type;
      this.children = [];
      this.nullValues = nulls;
      this.stride = strideForType(type);
      this._nulls = new BitmapBufferBuilder();
      if (nulls && nulls.length > 0) {
        this._isValid = createIsValidFunction(nulls);
      }
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(options) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    toVector() {
      return new Vector([this.flush()]);
    }
    get ArrayType() {
      return this.type.ArrayType;
    }
    get nullCount() {
      return this._nulls.numInvalid;
    }
    get numChildren() {
      return this.children.length;
    }
    get byteLength() {
      let size = 0;
      const { _offsets, _values, _nulls, _typeIds, children } = this;
      _offsets && (size += _offsets.byteLength);
      _values && (size += _values.byteLength);
      _nulls && (size += _nulls.byteLength);
      _typeIds && (size += _typeIds.byteLength);
      return children.reduce((size2, child) => size2 + child.byteLength, size);
    }
    get reservedLength() {
      return this._nulls.reservedLength;
    }
    get reservedByteLength() {
      let size = 0;
      this._offsets && (size += this._offsets.reservedByteLength);
      this._values && (size += this._values.reservedByteLength);
      this._nulls && (size += this._nulls.reservedByteLength);
      this._typeIds && (size += this._typeIds.reservedByteLength);
      return this.children.reduce((size2, child) => size2 + child.reservedByteLength, size);
    }
    get valueOffsets() {
      return this._offsets ? this._offsets.buffer : null;
    }
    get values() {
      return this._values ? this._values.buffer : null;
    }
    get nullBitmap() {
      return this._nulls ? this._nulls.buffer : null;
    }
    get typeIds() {
      return this._typeIds ? this._typeIds.buffer : null;
    }
    append(value) {
      return this.set(this.length, value);
    }
    isValid(value) {
      return this._isValid(value);
    }
    set(index, value) {
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value);
      }
      return this;
    }
    setValue(index, value) {
      this._setValue(this, index, value);
    }
    setValid(index, valid) {
      this.length = this._nulls.set(index, +valid).length;
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      throw new Error(`Cannot append children to non-nested type "${this.type}"`);
    }
    getChildAt(index) {
      return this.children[index] || null;
    }
    flush() {
      let data;
      let typeIds;
      let nullBitmap;
      let valueOffsets;
      const { type, length, nullCount, _typeIds, _offsets, _values, _nulls } = this;
      if (typeIds = _typeIds === null || _typeIds === void 0 ? void 0 : _typeIds.flush(length)) {
        valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length);
      } else if (valueOffsets = _offsets === null || _offsets === void 0 ? void 0 : _offsets.flush(length)) {
        data = _values === null || _values === void 0 ? void 0 : _values.flush(_offsets.last());
      } else {
        data = _values === null || _values === void 0 ? void 0 : _values.flush(length);
      }
      if (nullCount > 0) {
        nullBitmap = _nulls === null || _nulls === void 0 ? void 0 : _nulls.flush(length);
      }
      const children = this.children.map((child) => child.flush());
      this.clear();
      return makeData({
        type,
        length,
        nullCount,
        children,
        "child": children[0],
        data,
        typeIds,
        nullBitmap,
        valueOffsets
      });
    }
    finish() {
      this.finished = true;
      for (const child of this.children)
        child.finish();
      return this;
    }
    clear() {
      var _a5, _b2, _c2, _d2;
      this.length = 0;
      (_a5 = this._nulls) === null || _a5 === void 0 ? void 0 : _a5.clear();
      (_b2 = this._values) === null || _b2 === void 0 ? void 0 : _b2.clear();
      (_c2 = this._offsets) === null || _c2 === void 0 ? void 0 : _c2.clear();
      (_d2 = this._typeIds) === null || _d2 === void 0 ? void 0 : _d2.clear();
      for (const child of this.children)
        child.clear();
      return this;
    }
  };
  Builder.prototype.length = 1;
  Builder.prototype.stride = 1;
  Builder.prototype.children = null;
  Builder.prototype.finished = false;
  Builder.prototype.nullValues = null;
  Builder.prototype._isValid = () => true;
  var FixedWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._values = new DataBufferBuilder(new this.ArrayType(0), this.stride);
    }
    setValue(index, value) {
      const values = this._values;
      values.reserve(index - values.length + 1);
      return super.setValue(index, value);
    }
  };
  var VariableWidthBuilder = class extends Builder {
    constructor(opts) {
      super(opts);
      this._pendingLength = 0;
      this._offsets = new OffsetsBufferBuilder();
    }
    setValue(index, value) {
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.length);
      this._pendingLength += value instanceof MapRow ? value[kKeys].length : value.length;
      pending.set(index, value);
    }
    setValid(index, isValid) {
      if (!super.setValid(index, isValid)) {
        (this._pending || (this._pending = /* @__PURE__ */ new Map())).set(index, void 0);
        return false;
      }
      return true;
    }
    clear() {
      this._pendingLength = 0;
      this._pending = void 0;
      return super.clear();
    }
    flush() {
      this._flush();
      return super.flush();
    }
    finish() {
      this._flush();
      return super.finish();
    }
    _flush() {
      const pending = this._pending;
      const pendingLength = this._pendingLength;
      this._pendingLength = 0;
      this._pending = void 0;
      if (pending && pending.size > 0) {
        this._flushPending(pending, pendingLength);
      }
      return this;
    }
  };

  // ../../node_modules/apache-arrow/fb/block.mjs
  var Block = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    metaDataLength() {
      return this.bb.readInt32(this.bb_pos + 8);
    }
    bodyLength() {
      return this.bb.readInt64(this.bb_pos + 16);
    }
    static sizeOf() {
      return 24;
    }
    static createBlock(builder, offset, metaDataLength, bodyLength) {
      builder.prep(8, 24);
      builder.writeInt64(bodyLength);
      builder.pad(4);
      builder.writeInt32(metaDataLength);
      builder.writeInt64(offset);
      return builder.offset();
    }
  };

  // ../../node_modules/flatbuffers/mjs/constants.js
  var SIZEOF_SHORT = 2;
  var SIZEOF_INT = 4;
  var FILE_IDENTIFIER_LENGTH = 4;
  var SIZE_PREFIX_LENGTH = 4;

  // ../../node_modules/flatbuffers/mjs/utils.js
  var int32 = new Int32Array(2);
  var float32 = new Float32Array(int32.buffer);
  var float64 = new Float64Array(int32.buffer);
  var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

  // ../../node_modules/flatbuffers/mjs/long.js
  var Long = class {
    constructor(low, high) {
      this.low = low | 0;
      this.high = high | 0;
    }
    static create(low, high) {
      return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);
    }
    toFloat64() {
      return (this.low >>> 0) + this.high * 4294967296;
    }
    equals(other) {
      return this.low == other.low && this.high == other.high;
    }
  };
  Long.ZERO = new Long(0, 0);

  // ../../node_modules/flatbuffers/mjs/encoding.js
  var Encoding;
  (function(Encoding2) {
    Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
  })(Encoding || (Encoding = {}));

  // ../../node_modules/flatbuffers/mjs/byte-buffer.js
  var ByteBuffer = class {
    constructor(bytes_) {
      this.bytes_ = bytes_;
      this.position_ = 0;
    }
    static allocate(byte_size) {
      return new ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
      this.position_ = 0;
    }
    bytes() {
      return this.bytes_;
    }
    position() {
      return this.position_;
    }
    setPosition(position) {
      this.position_ = position;
    }
    capacity() {
      return this.bytes_.length;
    }
    readInt8(offset) {
      return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
      return this.bytes_[offset];
    }
    readInt16(offset) {
      return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
      return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
      return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
      return new Long(this.readInt32(offset), this.readInt32(offset + 4));
    }
    readUint64(offset) {
      return new Long(this.readUint32(offset), this.readUint32(offset + 4));
    }
    readFloat32(offset) {
      int32[0] = this.readInt32(offset);
      return float32[0];
    }
    readFloat64(offset) {
      int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
      int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
      return float64[0];
    }
    writeInt8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
      this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
      this.bytes_[offset] = value;
      this.bytes_[offset + 1] = value >> 8;
      this.bytes_[offset + 2] = value >> 16;
      this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
      this.writeInt32(offset, value.low);
      this.writeInt32(offset + 4, value.high);
    }
    writeUint64(offset, value) {
      this.writeUint32(offset, value.low);
      this.writeUint32(offset + 4, value.high);
    }
    writeFloat32(offset, value) {
      float32[0] = value;
      this.writeInt32(offset, int32[0]);
    }
    writeFloat64(offset, value) {
      float64[0] = value;
      this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
      this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    }
    getBufferIdentifier() {
      if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
      }
      let result = "";
      for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
        result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
      }
      return result;
    }
    __offset(bb_pos, vtable_offset) {
      const vtable = bb_pos - this.readInt32(bb_pos);
      return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    __union(t, offset) {
      t.bb_pos = offset + this.readInt32(offset);
      t.bb = this;
      return t;
    }
    __string(offset, opt_encoding) {
      offset += this.readInt32(offset);
      const length = this.readInt32(offset);
      let result = "";
      let i = 0;
      offset += SIZEOF_INT;
      if (opt_encoding === Encoding.UTF8_BYTES) {
        return this.bytes_.subarray(offset, offset + length);
      }
      while (i < length) {
        let codePoint;
        const a = this.readUint8(offset + i++);
        if (a < 192) {
          codePoint = a;
        } else {
          const b = this.readUint8(offset + i++);
          if (a < 224) {
            codePoint = (a & 31) << 6 | b & 63;
          } else {
            const c = this.readUint8(offset + i++);
            if (a < 240) {
              codePoint = (a & 15) << 12 | (b & 63) << 6 | c & 63;
            } else {
              const d = this.readUint8(offset + i++);
              codePoint = (a & 7) << 18 | (b & 63) << 12 | (c & 63) << 6 | d & 63;
            }
          }
        }
        if (codePoint < 65536) {
          result += String.fromCharCode(codePoint);
        } else {
          codePoint -= 65536;
          result += String.fromCharCode((codePoint >> 10) + 55296, (codePoint & (1 << 10) - 1) + 56320);
        }
      }
      return result;
    }
    __union_with_string(o, offset) {
      if (typeof o === "string") {
        return this.__string(offset);
      }
      return this.__union(o, offset);
    }
    __indirect(offset) {
      return offset + this.readInt32(offset);
    }
    __vector(offset) {
      return offset + this.readInt32(offset) + SIZEOF_INT;
    }
    __vector_len(offset) {
      return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
      if (ident.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
        if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
          return false;
        }
      }
      return true;
    }
    createLong(low, high) {
      return Long.create(low, high);
    }
    createScalarList(listAccessor, listLength) {
      const ret = [];
      for (let i = 0; i < listLength; ++i) {
        if (listAccessor(i) !== null) {
          ret.push(listAccessor(i));
        }
      }
      return ret;
    }
    createObjList(listAccessor, listLength) {
      const ret = [];
      for (let i = 0; i < listLength; ++i) {
        const val = listAccessor(i);
        if (val !== null) {
          ret.push(val.unpack());
        }
      }
      return ret;
    }
  };

  // ../../node_modules/flatbuffers/mjs/builder.js
  var Builder2 = class {
    constructor(opt_initial_size) {
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
      let initial_size;
      if (!opt_initial_size) {
        initial_size = 1024;
      } else {
        initial_size = opt_initial_size;
      }
      this.bb = ByteBuffer.allocate(initial_size);
      this.space = initial_size;
    }
    clear() {
      this.bb.clear();
      this.space = this.bb.capacity();
      this.minalign = 1;
      this.vtable = null;
      this.vtable_in_use = 0;
      this.isNested = false;
      this.object_start = 0;
      this.vtables = [];
      this.vector_num_elems = 0;
      this.force_defaults = false;
      this.string_maps = null;
    }
    forceDefaults(forceDefaults) {
      this.force_defaults = forceDefaults;
    }
    dataBuffer() {
      return this.bb;
    }
    asUint8Array() {
      return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    prep(size, additional_bytes) {
      if (size > this.minalign) {
        this.minalign = size;
      }
      const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
      while (this.space < align_size + size + additional_bytes) {
        const old_buf_size = this.bb.capacity();
        this.bb = Builder2.growByteBuffer(this.bb);
        this.space += this.bb.capacity() - old_buf_size;
      }
      this.pad(align_size);
    }
    pad(byte_size) {
      for (let i = 0; i < byte_size; i++) {
        this.bb.writeInt8(--this.space, 0);
      }
    }
    writeInt8(value) {
      this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
      this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
      this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
      this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
      this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
      this.bb.writeFloat64(this.space -= 8, value);
    }
    addInt8(value) {
      this.prep(1, 0);
      this.writeInt8(value);
    }
    addInt16(value) {
      this.prep(2, 0);
      this.writeInt16(value);
    }
    addInt32(value) {
      this.prep(4, 0);
      this.writeInt32(value);
    }
    addInt64(value) {
      this.prep(8, 0);
      this.writeInt64(value);
    }
    addFloat32(value) {
      this.prep(4, 0);
      this.writeFloat32(value);
    }
    addFloat64(value) {
      this.prep(8, 0);
      this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt8(value);
        this.slot(voffset);
      }
    }
    addFieldInt16(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt16(value);
        this.slot(voffset);
      }
    }
    addFieldInt32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addInt32(value);
        this.slot(voffset);
      }
    }
    addFieldInt64(voffset, value, defaultValue) {
      if (this.force_defaults || !value.equals(defaultValue)) {
        this.addInt64(value);
        this.slot(voffset);
      }
    }
    addFieldFloat32(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat32(value);
        this.slot(voffset);
      }
    }
    addFieldFloat64(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addFloat64(value);
        this.slot(voffset);
      }
    }
    addFieldOffset(voffset, value, defaultValue) {
      if (this.force_defaults || value != defaultValue) {
        this.addOffset(value);
        this.slot(voffset);
      }
    }
    addFieldStruct(voffset, value, defaultValue) {
      if (value != defaultValue) {
        this.nested(value);
        this.slot(voffset);
      }
    }
    nested(obj) {
      if (obj != this.offset()) {
        throw new Error("FlatBuffers: struct must be serialized inline.");
      }
    }
    notNested() {
      if (this.isNested) {
        throw new Error("FlatBuffers: object serialization must not be nested.");
      }
    }
    slot(voffset) {
      if (this.vtable !== null)
        this.vtable[voffset] = this.offset();
    }
    offset() {
      return this.bb.capacity() - this.space;
    }
    static growByteBuffer(bb) {
      const old_buf_size = bb.capacity();
      if (old_buf_size & 3221225472) {
        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
      }
      const new_buf_size = old_buf_size << 1;
      const nbb = ByteBuffer.allocate(new_buf_size);
      nbb.setPosition(new_buf_size - old_buf_size);
      nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
      return nbb;
    }
    addOffset(offset) {
      this.prep(SIZEOF_INT, 0);
      this.writeInt32(this.offset() - offset + SIZEOF_INT);
    }
    startObject(numfields) {
      this.notNested();
      if (this.vtable == null) {
        this.vtable = [];
      }
      this.vtable_in_use = numfields;
      for (let i = 0; i < numfields; i++) {
        this.vtable[i] = 0;
      }
      this.isNested = true;
      this.object_start = this.offset();
    }
    endObject() {
      if (this.vtable == null || !this.isNested) {
        throw new Error("FlatBuffers: endObject called without startObject");
      }
      this.addInt32(0);
      const vtableloc = this.offset();
      let i = this.vtable_in_use - 1;
      for (; i >= 0 && this.vtable[i] == 0; i--) {
      }
      const trimmed_size = i + 1;
      for (; i >= 0; i--) {
        this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
      }
      const standard_fields = 2;
      this.addInt16(vtableloc - this.object_start);
      const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
      this.addInt16(len);
      let existing_vtable = 0;
      const vt1 = this.space;
      outer_loop:
        for (i = 0; i < this.vtables.length; i++) {
          const vt2 = this.bb.capacity() - this.vtables[i];
          if (len == this.bb.readInt16(vt2)) {
            for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
              if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                continue outer_loop;
              }
            }
            existing_vtable = this.vtables[i];
            break;
          }
        }
      if (existing_vtable) {
        this.space = this.bb.capacity() - vtableloc;
        this.bb.writeInt32(this.space, existing_vtable - vtableloc);
      } else {
        this.vtables.push(this.offset());
        this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
      }
      this.isNested = false;
      return vtableloc;
    }
    finish(root_table, opt_file_identifier, opt_size_prefix) {
      const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
      if (opt_file_identifier) {
        const file_identifier = opt_file_identifier;
        this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
        if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
          throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
        }
        for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
          this.writeInt8(file_identifier.charCodeAt(i));
        }
      }
      this.prep(this.minalign, SIZEOF_INT + size_prefix);
      this.addOffset(root_table);
      if (size_prefix) {
        this.addInt32(this.bb.capacity() - this.space);
      }
      this.bb.setPosition(this.space);
    }
    finishSizePrefixed(root_table, opt_file_identifier) {
      this.finish(root_table, opt_file_identifier, true);
    }
    requiredField(table, field) {
      const table_start = this.bb.capacity() - table;
      const vtable_start = table_start - this.bb.readInt32(table_start);
      const ok = this.bb.readInt16(vtable_start + field) != 0;
      if (!ok) {
        throw new Error("FlatBuffers: field " + field + " must be set");
      }
    }
    startVector(elem_size, num_elems, alignment) {
      this.notNested();
      this.vector_num_elems = num_elems;
      this.prep(SIZEOF_INT, elem_size * num_elems);
      this.prep(alignment, elem_size * num_elems);
    }
    endVector() {
      this.writeInt32(this.vector_num_elems);
      return this.offset();
    }
    createSharedString(s) {
      if (!s) {
        return 0;
      }
      if (!this.string_maps) {
        this.string_maps = /* @__PURE__ */ new Map();
      }
      if (this.string_maps.has(s)) {
        return this.string_maps.get(s);
      }
      const offset = this.createString(s);
      this.string_maps.set(s, offset);
      return offset;
    }
    createString(s) {
      if (!s) {
        return 0;
      }
      let utf8;
      if (s instanceof Uint8Array) {
        utf8 = s;
      } else {
        utf8 = [];
        let i = 0;
        while (i < s.length) {
          let codePoint;
          const a = s.charCodeAt(i++);
          if (a < 55296 || a >= 56320) {
            codePoint = a;
          } else {
            const b = s.charCodeAt(i++);
            codePoint = (a << 10) + b + (65536 - (55296 << 10) - 56320);
          }
          if (codePoint < 128) {
            utf8.push(codePoint);
          } else {
            if (codePoint < 2048) {
              utf8.push(codePoint >> 6 & 31 | 192);
            } else {
              if (codePoint < 65536) {
                utf8.push(codePoint >> 12 & 15 | 224);
              } else {
                utf8.push(codePoint >> 18 & 7 | 240, codePoint >> 12 & 63 | 128);
              }
              utf8.push(codePoint >> 6 & 63 | 128);
            }
            utf8.push(codePoint & 63 | 128);
          }
        }
      }
      this.addInt8(0);
      this.startVector(1, utf8.length, 1);
      this.bb.setPosition(this.space -= utf8.length);
      for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
        bytes[offset++] = utf8[i];
      }
      return this.endVector();
    }
    createLong(low, high) {
      return Long.create(low, high);
    }
    createObjectOffset(obj) {
      if (obj === null) {
        return 0;
      }
      if (typeof obj === "string") {
        return this.createString(obj);
      } else {
        return obj.pack(this);
      }
    }
    createObjectOffsetList(list) {
      const ret = [];
      for (let i = 0; i < list.length; ++i) {
        const val = list[i];
        if (val !== null) {
          ret.push(this.createObjectOffset(val));
        } else {
          throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
        }
      }
      return ret;
    }
    createStructOffsetList(list, startFunc) {
      startFunc(this, list.length);
      this.createObjectOffsetList(list);
      return this.endVector();
    }
  };

  // ../../node_modules/apache-arrow/fb/key-value.mjs
  var KeyValue = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsKeyValue(bb, obj) {
      return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsKeyValue(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    key(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    value(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startKeyValue(builder) {
      builder.startObject(2);
    }
    static addKey(builder, keyOffset) {
      builder.addFieldOffset(0, keyOffset, 0);
    }
    static addValue(builder, valueOffset) {
      builder.addFieldOffset(1, valueOffset, 0);
    }
    static endKeyValue(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createKeyValue(builder, keyOffset, valueOffset) {
      KeyValue.startKeyValue(builder);
      KeyValue.addKey(builder, keyOffset);
      KeyValue.addValue(builder, valueOffset);
      return KeyValue.endKeyValue(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/metadata-version.mjs
  var MetadataVersion2;
  (function(MetadataVersion3) {
    MetadataVersion3[MetadataVersion3["V1"] = 0] = "V1";
    MetadataVersion3[MetadataVersion3["V2"] = 1] = "V2";
    MetadataVersion3[MetadataVersion3["V3"] = 2] = "V3";
    MetadataVersion3[MetadataVersion3["V4"] = 3] = "V4";
    MetadataVersion3[MetadataVersion3["V5"] = 4] = "V5";
  })(MetadataVersion2 || (MetadataVersion2 = {}));

  // ../../node_modules/apache-arrow/fb/endianness.mjs
  var Endianness;
  (function(Endianness2) {
    Endianness2[Endianness2["Little"] = 0] = "Little";
    Endianness2[Endianness2["Big"] = 1] = "Big";
  })(Endianness || (Endianness = {}));

  // ../../node_modules/apache-arrow/fb/dictionary-kind.mjs
  var DictionaryKind;
  (function(DictionaryKind2) {
    DictionaryKind2[DictionaryKind2["DenseArray"] = 0] = "DenseArray";
  })(DictionaryKind || (DictionaryKind = {}));

  // ../../node_modules/apache-arrow/fb/int.mjs
  var Int = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsInt(bb, obj) {
      return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInt(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    isSigned() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startInt(builder) {
      builder.startObject(2);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(0, bitWidth, 0);
    }
    static addIsSigned(builder, isSigned) {
      builder.addFieldInt8(1, +isSigned, 0);
    }
    static endInt(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInt(builder, bitWidth, isSigned) {
      Int.startInt(builder);
      Int.addBitWidth(builder, bitWidth);
      Int.addIsSigned(builder, isSigned);
      return Int.endInt(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/dictionary-encoding.mjs
  var DictionaryEncoding = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryEncoding(bb, obj) {
      return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryEncoding(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    indexType(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isOrdered() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    dictionaryKind() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DictionaryKind.DenseArray;
    }
    static startDictionaryEncoding(builder) {
      builder.startObject(4);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, builder.createLong(0, 0));
    }
    static addIndexType(builder, indexTypeOffset) {
      builder.addFieldOffset(1, indexTypeOffset, 0);
    }
    static addIsOrdered(builder, isOrdered) {
      builder.addFieldInt8(2, +isOrdered, 0);
    }
    static addDictionaryKind(builder, dictionaryKind) {
      builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
    }
    static endDictionaryEncoding(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/binary.mjs
  var Binary2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBinary(bb, obj) {
      return (obj || new Binary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Binary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBinary(builder) {
      builder.startObject(0);
    }
    static endBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBinary(builder) {
      Binary2.startBinary(builder);
      return Binary2.endBinary(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/bool.mjs
  var Bool2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBool(bb, obj) {
      return (obj || new Bool2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBool(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Bool2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startBool(builder) {
      builder.startObject(0);
    }
    static endBool(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBool(builder) {
      Bool2.startBool(builder);
      return Bool2.endBool(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/date-unit.mjs
  var DateUnit2;
  (function(DateUnit3) {
    DateUnit3[DateUnit3["DAY"] = 0] = "DAY";
    DateUnit3[DateUnit3["MILLISECOND"] = 1] = "MILLISECOND";
  })(DateUnit2 || (DateUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/date.mjs
  var Date2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDate(bb, obj) {
      return (obj || new Date2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDate(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Date2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : DateUnit2.MILLISECOND;
    }
    static startDate(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, DateUnit2.MILLISECOND);
    }
    static endDate(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDate(builder, unit) {
      Date2.startDate(builder);
      Date2.addUnit(builder, unit);
      return Date2.endDate(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/decimal.mjs
  var Decimal2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDecimal(bb, obj) {
      return (obj || new Decimal2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDecimal(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Decimal2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    scale() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    }
    static startDecimal(builder) {
      builder.startObject(3);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt32(0, precision, 0);
    }
    static addScale(builder, scale) {
      builder.addFieldInt32(1, scale, 0);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(2, bitWidth, 128);
    }
    static endDecimal(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createDecimal(builder, precision, scale, bitWidth) {
      Decimal2.startDecimal(builder);
      Decimal2.addPrecision(builder, precision);
      Decimal2.addScale(builder, scale);
      Decimal2.addBitWidth(builder, bitWidth);
      return Decimal2.endDecimal(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/time-unit.mjs
  var TimeUnit2;
  (function(TimeUnit3) {
    TimeUnit3[TimeUnit3["SECOND"] = 0] = "SECOND";
    TimeUnit3[TimeUnit3["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit3[TimeUnit3["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit3[TimeUnit3["NANOSECOND"] = 3] = "NANOSECOND";
  })(TimeUnit2 || (TimeUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/fixed-size-binary.mjs
  var FixedSizeBinary2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeBinary(bb, obj) {
      return (obj || new FixedSizeBinary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeBinary(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FixedSizeBinary2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    byteWidth() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeBinary(builder) {
      builder.startObject(1);
    }
    static addByteWidth(builder, byteWidth) {
      builder.addFieldInt32(0, byteWidth, 0);
    }
    static endFixedSizeBinary(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeBinary(builder, byteWidth) {
      FixedSizeBinary2.startFixedSizeBinary(builder);
      FixedSizeBinary2.addByteWidth(builder, byteWidth);
      return FixedSizeBinary2.endFixedSizeBinary(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/fixed-size-list.mjs
  var FixedSizeList2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFixedSizeList(bb, obj) {
      return (obj || new FixedSizeList2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFixedSizeList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FixedSizeList2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    listSize() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
    static startFixedSizeList(builder) {
      builder.startObject(1);
    }
    static addListSize(builder, listSize) {
      builder.addFieldInt32(0, listSize, 0);
    }
    static endFixedSizeList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFixedSizeList(builder, listSize) {
      FixedSizeList2.startFixedSizeList(builder);
      FixedSizeList2.addListSize(builder, listSize);
      return FixedSizeList2.endFixedSizeList(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/precision.mjs
  var Precision2;
  (function(Precision3) {
    Precision3[Precision3["HALF"] = 0] = "HALF";
    Precision3[Precision3["SINGLE"] = 1] = "SINGLE";
    Precision3[Precision3["DOUBLE"] = 2] = "DOUBLE";
  })(Precision2 || (Precision2 = {}));

  // ../../node_modules/apache-arrow/fb/floating-point.mjs
  var FloatingPoint = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFloatingPoint(bb, obj) {
      return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFloatingPoint(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    precision() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Precision2.HALF;
    }
    static startFloatingPoint(builder) {
      builder.startObject(1);
    }
    static addPrecision(builder, precision) {
      builder.addFieldInt16(0, precision, Precision2.HALF);
    }
    static endFloatingPoint(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createFloatingPoint(builder, precision) {
      FloatingPoint.startFloatingPoint(builder);
      FloatingPoint.addPrecision(builder, precision);
      return FloatingPoint.endFloatingPoint(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/interval-unit.mjs
  var IntervalUnit2;
  (function(IntervalUnit3) {
    IntervalUnit3[IntervalUnit3["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit3[IntervalUnit3["DAY_TIME"] = 1] = "DAY_TIME";
    IntervalUnit3[IntervalUnit3["MONTH_DAY_NANO"] = 2] = "MONTH_DAY_NANO";
  })(IntervalUnit2 || (IntervalUnit2 = {}));

  // ../../node_modules/apache-arrow/fb/interval.mjs
  var Interval = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsInterval(bb, obj) {
      return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsInterval(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : IntervalUnit2.YEAR_MONTH;
    }
    static startInterval(builder) {
      builder.startObject(1);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, IntervalUnit2.YEAR_MONTH);
    }
    static endInterval(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createInterval(builder, unit) {
      Interval.startInterval(builder);
      Interval.addUnit(builder, unit);
      return Interval.endInterval(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/list.mjs
  var List2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsList(bb, obj) {
      return (obj || new List2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsList(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new List2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startList(builder) {
      builder.startObject(0);
    }
    static endList(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createList(builder) {
      List2.startList(builder);
      return List2.endList(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/map.mjs
  var Map2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsMap(bb, obj) {
      return (obj || new Map2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMap(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Map2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    keysSorted() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startMap(builder) {
      builder.startObject(1);
    }
    static addKeysSorted(builder, keysSorted) {
      builder.addFieldInt8(0, +keysSorted, 0);
    }
    static endMap(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createMap(builder, keysSorted) {
      Map2.startMap(builder);
      Map2.addKeysSorted(builder, keysSorted);
      return Map2.endMap(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/null.mjs
  var Null2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsNull(bb, obj) {
      return (obj || new Null2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsNull(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Null2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startNull(builder) {
      builder.startObject(0);
    }
    static endNull(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createNull(builder) {
      Null2.startNull(builder);
      return Null2.endNull(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/struct_.mjs
  var Struct_ = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsStruct_(bb, obj) {
      return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsStruct_(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startStruct_(builder) {
      builder.startObject(0);
    }
    static endStruct_(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createStruct_(builder) {
      Struct_.startStruct_(builder);
      return Struct_.endStruct_(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/time.mjs
  var Time = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsTime(bb, obj) {
      return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTime(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.MILLISECOND;
    }
    bitWidth() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    }
    static startTime(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.MILLISECOND);
    }
    static addBitWidth(builder, bitWidth) {
      builder.addFieldInt32(1, bitWidth, 32);
    }
    static endTime(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTime(builder, unit, bitWidth) {
      Time.startTime(builder);
      Time.addUnit(builder, unit);
      Time.addBitWidth(builder, bitWidth);
      return Time.endTime(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/timestamp.mjs
  var Timestamp = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsTimestamp(bb, obj) {
      return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsTimestamp(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    unit() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : TimeUnit2.SECOND;
    }
    timezone(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    static startTimestamp(builder) {
      builder.startObject(2);
    }
    static addUnit(builder, unit) {
      builder.addFieldInt16(0, unit, TimeUnit2.SECOND);
    }
    static addTimezone(builder, timezoneOffset) {
      builder.addFieldOffset(1, timezoneOffset, 0);
    }
    static endTimestamp(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createTimestamp(builder, unit, timezoneOffset) {
      Timestamp.startTimestamp(builder);
      Timestamp.addUnit(builder, unit);
      Timestamp.addTimezone(builder, timezoneOffset);
      return Timestamp.endTimestamp(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/union-mode.mjs
  var UnionMode2;
  (function(UnionMode3) {
    UnionMode3[UnionMode3["Sparse"] = 0] = "Sparse";
    UnionMode3[UnionMode3["Dense"] = 1] = "Dense";
  })(UnionMode2 || (UnionMode2 = {}));

  // ../../node_modules/apache-arrow/fb/union.mjs
  var Union = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsUnion(bb, obj) {
      return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUnion(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    mode() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : UnionMode2.Sparse;
    }
    typeIds(index) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
    typeIdsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    typeIdsArray() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
    static startUnion(builder) {
      builder.startObject(2);
    }
    static addMode(builder, mode) {
      builder.addFieldInt16(0, mode, UnionMode2.Sparse);
    }
    static addTypeIds(builder, typeIdsOffset) {
      builder.addFieldOffset(1, typeIdsOffset, 0);
    }
    static createTypeIdsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt32(data[i]);
      }
      return builder.endVector();
    }
    static startTypeIdsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endUnion(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUnion(builder, mode, typeIdsOffset) {
      Union.startUnion(builder);
      Union.addMode(builder, mode);
      Union.addTypeIds(builder, typeIdsOffset);
      return Union.endUnion(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/utf8.mjs
  var Utf82 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsUtf8(bb, obj) {
      return (obj || new Utf82()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsUtf8(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Utf82()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static startUtf8(builder) {
      builder.startObject(0);
    }
    static endUtf8(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createUtf8(builder) {
      Utf82.startUtf8(builder);
      return Utf82.endUtf8(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/type.mjs
  var Type2;
  (function(Type3) {
    Type3[Type3["NONE"] = 0] = "NONE";
    Type3[Type3["Null"] = 1] = "Null";
    Type3[Type3["Int"] = 2] = "Int";
    Type3[Type3["FloatingPoint"] = 3] = "FloatingPoint";
    Type3[Type3["Binary"] = 4] = "Binary";
    Type3[Type3["Utf8"] = 5] = "Utf8";
    Type3[Type3["Bool"] = 6] = "Bool";
    Type3[Type3["Decimal"] = 7] = "Decimal";
    Type3[Type3["Date"] = 8] = "Date";
    Type3[Type3["Time"] = 9] = "Time";
    Type3[Type3["Timestamp"] = 10] = "Timestamp";
    Type3[Type3["Interval"] = 11] = "Interval";
    Type3[Type3["List"] = 12] = "List";
    Type3[Type3["Struct_"] = 13] = "Struct_";
    Type3[Type3["Union"] = 14] = "Union";
    Type3[Type3["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type3[Type3["FixedSizeList"] = 16] = "FixedSizeList";
    Type3[Type3["Map"] = 17] = "Map";
    Type3[Type3["Duration"] = 18] = "Duration";
    Type3[Type3["LargeBinary"] = 19] = "LargeBinary";
    Type3[Type3["LargeUtf8"] = 20] = "LargeUtf8";
    Type3[Type3["LargeList"] = 21] = "LargeList";
  })(Type2 || (Type2 = {}));

  // ../../node_modules/apache-arrow/fb/field.mjs
  var Field = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsField(bb, obj) {
      return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsField(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    name(optionalEncoding) {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
    nullable() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    typeType() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : Type2.NONE;
    }
    type(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    dictionary(obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    children(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    childrenLength() {
      const offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startField(builder) {
      builder.startObject(7);
    }
    static addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
    static addNullable(builder, nullable) {
      builder.addFieldInt8(1, +nullable, 0);
    }
    static addTypeType(builder, typeType) {
      builder.addFieldInt8(2, typeType, Type2.NONE);
    }
    static addType(builder, typeOffset) {
      builder.addFieldOffset(3, typeOffset, 0);
    }
    static addDictionary(builder, dictionaryOffset) {
      builder.addFieldOffset(4, dictionaryOffset, 0);
    }
    static addChildren(builder, childrenOffset) {
      builder.addFieldOffset(5, childrenOffset, 0);
    }
    static createChildrenVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startChildrenVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(6, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endField(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/schema.mjs
  var Schema = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsSchema(bb, obj) {
      return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsSchema(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    endianness() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : Endianness.Little;
    }
    fields(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    fieldsLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    features(index) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);
    }
    featuresLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startSchema(builder) {
      builder.startObject(4);
    }
    static addEndianness(builder, endianness) {
      builder.addFieldInt16(0, endianness, Endianness.Little);
    }
    static addFields(builder, fieldsOffset) {
      builder.addFieldOffset(1, fieldsOffset, 0);
    }
    static createFieldsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startFieldsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(2, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static addFeatures(builder, featuresOffset) {
      builder.addFieldOffset(3, featuresOffset, 0);
    }
    static createFeaturesVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addInt64(data[i]);
      }
      return builder.endVector();
    }
    static startFeaturesVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
    static endSchema(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishSchemaBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedSchemaBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createSchema(builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
      Schema.startSchema(builder);
      Schema.addEndianness(builder, endianness);
      Schema.addFields(builder, fieldsOffset);
      Schema.addCustomMetadata(builder, customMetadataOffset);
      Schema.addFeatures(builder, featuresOffset);
      return Schema.endSchema(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/footer.mjs
  var Footer = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsFooter(bb, obj) {
      return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsFooter(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Footer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    schema(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new Schema()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    dictionaries(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    dictionariesLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    recordBatches(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new Block()).__init(this.bb.__vector(this.bb_pos + offset) + index * 24, this.bb) : null;
    }
    recordBatchesLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startFooter(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addSchema(builder, schemaOffset) {
      builder.addFieldOffset(1, schemaOffset, 0);
    }
    static addDictionaries(builder, dictionariesOffset) {
      builder.addFieldOffset(2, dictionariesOffset, 0);
    }
    static startDictionariesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addRecordBatches(builder, recordBatchesOffset) {
      builder.addFieldOffset(3, recordBatchesOffset, 0);
    }
    static startRecordBatchesVector(builder, numElems) {
      builder.startVector(24, numElems, 8);
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endFooter(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishFooterBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedFooterBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
  };

  // ../../node_modules/apache-arrow/schema.mjs
  var Schema2 = class {
    constructor(fields = [], metadata, dictionaries) {
      this.fields = fields || [];
      this.metadata = metadata || /* @__PURE__ */ new Map();
      if (!dictionaries) {
        dictionaries = generateDictionaryMap(fields);
      }
      this.dictionaries = dictionaries;
    }
    get [Symbol.toStringTag]() {
      return "Schema";
    }
    get names() {
      return this.fields.map((f) => f.name);
    }
    toString() {
      return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(", ")} }>`;
    }
    select(fieldNames) {
      const names = new Set(fieldNames);
      const fields = this.fields.filter((f) => names.has(f.name));
      return new Schema2(fields, this.metadata);
    }
    selectAt(fieldIndices) {
      const fields = fieldIndices.map((i) => this.fields[i]).filter(Boolean);
      return new Schema2(fields, this.metadata);
    }
    assign(...args) {
      const other = args[0] instanceof Schema2 ? args[0] : Array.isArray(args[0]) ? new Schema2(args[0]) : new Schema2(args);
      const curFields = [...this.fields];
      const metadata = mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), this.metadata), other.metadata);
      const newFields = other.fields.filter((f2) => {
        const i = curFields.findIndex((f) => f.name === f2.name);
        return ~i ? (curFields[i] = f2.clone({
          metadata: mergeMaps(mergeMaps(/* @__PURE__ */ new Map(), curFields[i].metadata), f2.metadata)
        })) && false : true;
      });
      const newDictionaries = generateDictionaryMap(newFields, /* @__PURE__ */ new Map());
      return new Schema2([...curFields, ...newFields], metadata, new Map([...this.dictionaries, ...newDictionaries]));
    }
  };
  Schema2.prototype.fields = null;
  Schema2.prototype.metadata = null;
  Schema2.prototype.dictionaries = null;
  var Field2 = class {
    constructor(name, type, nullable = false, metadata) {
      this.name = name;
      this.type = type;
      this.nullable = nullable;
      this.metadata = metadata || /* @__PURE__ */ new Map();
    }
    static new(...args) {
      let [name, type, nullable, metadata] = args;
      if (args[0] && typeof args[0] === "object") {
        ({ name } = args[0]);
        type === void 0 && (type = args[0].type);
        nullable === void 0 && (nullable = args[0].nullable);
        metadata === void 0 && (metadata = args[0].metadata);
      }
      return new Field2(`${name}`, type, nullable, metadata);
    }
    get typeId() {
      return this.type.typeId;
    }
    get [Symbol.toStringTag]() {
      return "Field";
    }
    toString() {
      return `${this.name}: ${this.type}`;
    }
    clone(...args) {
      let [name, type, nullable, metadata] = args;
      !args[0] || typeof args[0] !== "object" ? [name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args : { name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata } = args[0];
      return Field2.new(name, type, nullable, metadata);
    }
  };
  Field2.prototype.type = null;
  Field2.prototype.name = null;
  Field2.prototype.nullable = null;
  Field2.prototype.metadata = null;
  function mergeMaps(m1, m2) {
    return new Map([...m1 || /* @__PURE__ */ new Map(), ...m2 || /* @__PURE__ */ new Map()]);
  }
  function generateDictionaryMap(fields, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const field = fields[i];
      const type = field.type;
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          dictionaries.set(type.id, type.dictionary);
        } else if (dictionaries.get(type.id) !== type.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        generateDictionaryMap(type.children, dictionaries);
      }
    }
    return dictionaries;
  }

  // ../../node_modules/apache-arrow/ipc/metadata/file.mjs
  var Long2 = Long;
  var Builder3 = Builder2;
  var ByteBuffer2 = ByteBuffer;
  var Footer_ = class {
    constructor(schema, version = MetadataVersion.V4, recordBatches, dictionaryBatches) {
      this.schema = schema;
      this.version = version;
      recordBatches && (this._recordBatches = recordBatches);
      dictionaryBatches && (this._dictionaryBatches = dictionaryBatches);
    }
    static decode(buf) {
      buf = new ByteBuffer2(toUint8Array(buf));
      const footer = Footer.getRootAsFooter(buf);
      const schema = Schema2.decode(footer.schema());
      return new OffHeapFooter(schema, footer);
    }
    static encode(footer) {
      const b = new Builder3();
      const schemaOffset = Schema2.encode(b, footer.schema);
      Footer.startRecordBatchesVector(b, footer.numRecordBatches);
      for (const rb of [...footer.recordBatches()].slice().reverse()) {
        FileBlock.encode(b, rb);
      }
      const recordBatchesOffset = b.endVector();
      Footer.startDictionariesVector(b, footer.numDictionaries);
      for (const db2 of [...footer.dictionaryBatches()].slice().reverse()) {
        FileBlock.encode(b, db2);
      }
      const dictionaryBatchesOffset = b.endVector();
      Footer.startFooter(b);
      Footer.addSchema(b, schemaOffset);
      Footer.addVersion(b, MetadataVersion.V4);
      Footer.addRecordBatches(b, recordBatchesOffset);
      Footer.addDictionaries(b, dictionaryBatchesOffset);
      Footer.finishFooterBuffer(b, Footer.endFooter(b));
      return b.asUint8Array();
    }
    get numRecordBatches() {
      return this._recordBatches.length;
    }
    get numDictionaries() {
      return this._dictionaryBatches.length;
    }
    *recordBatches() {
      for (let block, i = -1, n = this.numRecordBatches; ++i < n; ) {
        if (block = this.getRecordBatch(i)) {
          yield block;
        }
      }
    }
    *dictionaryBatches() {
      for (let block, i = -1, n = this.numDictionaries; ++i < n; ) {
        if (block = this.getDictionaryBatch(i)) {
          yield block;
        }
      }
    }
    getRecordBatch(index) {
      return index >= 0 && index < this.numRecordBatches && this._recordBatches[index] || null;
    }
    getDictionaryBatch(index) {
      return index >= 0 && index < this.numDictionaries && this._dictionaryBatches[index] || null;
    }
  };
  var OffHeapFooter = class extends Footer_ {
    constructor(schema, _footer) {
      super(schema, _footer.version());
      this._footer = _footer;
    }
    get numRecordBatches() {
      return this._footer.recordBatchesLength();
    }
    get numDictionaries() {
      return this._footer.dictionariesLength();
    }
    getRecordBatch(index) {
      if (index >= 0 && index < this.numRecordBatches) {
        const fileBlock = this._footer.recordBatches(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
    getDictionaryBatch(index) {
      if (index >= 0 && index < this.numDictionaries) {
        const fileBlock = this._footer.dictionaries(index);
        if (fileBlock) {
          return FileBlock.decode(fileBlock);
        }
      }
      return null;
    }
  };
  var FileBlock = class {
    constructor(metaDataLength, bodyLength, offset) {
      this.metaDataLength = metaDataLength;
      this.offset = typeof offset === "number" ? offset : offset.low;
      this.bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
    }
    static decode(block) {
      return new FileBlock(block.metaDataLength(), block.bodyLength(), block.offset());
    }
    static encode(b, fileBlock) {
      const { metaDataLength } = fileBlock;
      const offset = new Long2(fileBlock.offset, 0);
      const bodyLength = new Long2(fileBlock.bodyLength, 0);
      return Block.createBlock(b, offset, metaDataLength, bodyLength);
    }
  };

  // ../../node_modules/apache-arrow/io/interfaces.mjs
  var ITERATOR_DONE = Object.freeze({ done: true, value: void 0 });
  var ArrowJSON = class {
    constructor(_json) {
      this._json = _json;
    }
    get schema() {
      return this._json["schema"];
    }
    get batches() {
      return this._json["batches"] || [];
    }
    get dictionaries() {
      return this._json["dictionaries"] || [];
    }
  };
  var ReadableInterop = class {
    tee() {
      return this._getDOMStream().tee();
    }
    pipe(writable, options) {
      return this._getNodeStream().pipe(writable, options);
    }
    pipeTo(writable, options) {
      return this._getDOMStream().pipeTo(writable, options);
    }
    pipeThrough(duplex, options) {
      return this._getDOMStream().pipeThrough(duplex, options);
    }
    _getDOMStream() {
      return this._DOMStream || (this._DOMStream = this.toDOMStream());
    }
    _getNodeStream() {
      return this._nodeStream || (this._nodeStream = this.toNodeStream());
    }
  };
  var AsyncQueue = class extends ReadableInterop {
    constructor() {
      super();
      this._values = [];
      this.resolvers = [];
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    get closed() {
      return this._closedPromise;
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    write(value) {
      if (this._ensureOpen()) {
        this.resolvers.length <= 0 ? this._values.push(value) : this.resolvers.shift().resolve({ done: false, value });
      }
    }
    abort(value) {
      if (this._closedPromiseResolve) {
        this.resolvers.length <= 0 ? this._error = { error: value } : this.resolvers.shift().reject({ done: true, value });
      }
    }
    close() {
      if (this._closedPromiseResolve) {
        const { resolvers } = this;
        while (resolvers.length > 0) {
          resolvers.shift().resolve(ITERATOR_DONE);
        }
        this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    toDOMStream(options) {
      return adapters_default.toDOMStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    toNodeStream(options) {
      return adapters_default.toNodeStream(this._closedPromiseResolve || this._error ? this : this._values, options);
    }
    throw(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.abort(_);
        return ITERATOR_DONE;
      });
    }
    return(_) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return ITERATOR_DONE;
      });
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(..._args) {
      if (this._values.length > 0) {
        return Promise.resolve({ done: false, value: this._values.shift() });
      } else if (this._error) {
        return Promise.reject({ done: true, value: this._error.error });
      } else if (!this._closedPromiseResolve) {
        return Promise.resolve(ITERATOR_DONE);
      } else {
        return new Promise((resolve, reject) => {
          this.resolvers.push({ resolve, reject });
        });
      }
    }
    _ensureOpen() {
      if (this._closedPromiseResolve) {
        return true;
      }
      throw new Error(`AsyncQueue is closed`);
    }
  };

  // ../../node_modules/apache-arrow/io/stream.mjs
  var AsyncByteQueue = class extends AsyncQueue {
    write(value) {
      if ((value = toUint8Array(value)).byteLength > 0) {
        return super.write(value);
      }
    }
    toString(sync = false) {
      return sync ? decodeUtf8(this.toUint8Array(true)) : this.toUint8Array(false).then(decodeUtf8);
    }
    toUint8Array(sync = false) {
      return sync ? joinUint8Arrays(this._values)[0] : (() => __awaiter(this, void 0, void 0, function* () {
        var e_1, _a5;
        const buffers = [];
        let byteLength = 0;
        try {
          for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {
            const chunk = _c2.value;
            buffers.push(chunk);
            byteLength += chunk.byteLength;
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a5 = _b2.return))
              yield _a5.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return joinUint8Arrays(buffers, byteLength)[0];
      }))();
    }
  };
  var ByteStream = class {
    constructor(source) {
      if (source) {
        this.source = new ByteStreamSource(adapters_default.fromIterable(source));
      }
    }
    [Symbol.iterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var AsyncByteStream = class {
    constructor(source) {
      if (source instanceof AsyncByteStream) {
        this.source = source.source;
      } else if (source instanceof AsyncByteQueue) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isReadableNodeStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromNodeStream(source));
      } else if (isReadableDOMStream(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source));
      } else if (isFetchResponse(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromDOMStream(source.body));
      } else if (isIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromIterable(source));
      } else if (isPromise(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      } else if (isAsyncIterable(source)) {
        this.source = new AsyncByteStreamSource(adapters_default.fromAsyncIterable(source));
      }
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next(value) {
      return this.source.next(value);
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    get closed() {
      return this.source.closed;
    }
    cancel(reason) {
      return this.source.cancel(reason);
    }
    peek(size) {
      return this.source.peek(size);
    }
    read(size) {
      return this.source.read(size);
    }
  };
  var ByteStreamSource = class {
    constructor(source) {
      this.source = source;
    }
    cancel(reason) {
      this.return(reason);
    }
    peek(size) {
      return this.next(size, "peek").value;
    }
    read(size) {
      return this.next(size, "read").value;
    }
    next(size, cmd = "read") {
      return this.source.next({ cmd, size });
    }
    throw(value) {
      return Object.create(this.source.throw && this.source.throw(value) || ITERATOR_DONE);
    }
    return(value) {
      return Object.create(this.source.return && this.source.return(value) || ITERATOR_DONE);
    }
  };
  var AsyncByteStreamSource = class {
    constructor(source) {
      this.source = source;
      this._closedPromise = new Promise((r) => this._closedPromiseResolve = r);
    }
    cancel(reason) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.return(reason);
      });
    }
    get closed() {
      return this._closedPromise;
    }
    read(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "read")).value;
      });
    }
    peek(size) {
      return __awaiter(this, void 0, void 0, function* () {
        return (yield this.next(size, "peek")).value;
      });
    }
    next(size, cmd = "read") {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.next({ cmd, size });
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.throw && (yield this.source.throw(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        const result = this.source.return && (yield this.source.return(value)) || ITERATOR_DONE;
        this._closedPromiseResolve && this._closedPromiseResolve();
        this._closedPromiseResolve = void 0;
        return Object.create(result);
      });
    }
  };

  // ../../node_modules/apache-arrow/io/file.mjs
  var RandomAccessFile = class extends ByteStream {
    constructor(buffer, byteLength) {
      super();
      this.position = 0;
      this.buffer = toUint8Array(buffer);
      this.size = typeof byteLength === "undefined" ? this.buffer.byteLength : byteLength;
    }
    readInt32(position) {
      const { buffer, byteOffset } = this.readAt(position, 4);
      return new DataView(buffer, byteOffset).getInt32(0, true);
    }
    seek(position) {
      this.position = Math.min(position, this.size);
      return position < this.size;
    }
    read(nBytes) {
      const { buffer, size, position } = this;
      if (buffer && position < size) {
        if (typeof nBytes !== "number") {
          nBytes = Number.POSITIVE_INFINITY;
        }
        this.position = Math.min(size, position + Math.min(size - position, nBytes));
        return buffer.subarray(position, this.position);
      }
      return null;
    }
    readAt(position, nBytes) {
      const buf = this.buffer;
      const end = Math.min(this.size, position + nBytes);
      return buf ? buf.subarray(position, end) : new Uint8Array(nBytes);
    }
    close() {
      this.buffer && (this.buffer = null);
    }
    throw(value) {
      this.close();
      return { done: true, value };
    }
    return(value) {
      this.close();
      return { done: true, value };
    }
  };
  var AsyncRandomAccessFile = class extends AsyncByteStream {
    constructor(file, byteLength) {
      super();
      this.position = 0;
      this._handle = file;
      if (typeof byteLength === "number") {
        this.size = byteLength;
      } else {
        this._pending = (() => __awaiter(this, void 0, void 0, function* () {
          this.size = (yield file.stat()).size;
          delete this._pending;
        }))();
      }
    }
    readInt32(position) {
      return __awaiter(this, void 0, void 0, function* () {
        const { buffer, byteOffset } = yield this.readAt(position, 4);
        return new DataView(buffer, byteOffset).getInt32(0, true);
      });
    }
    seek(position) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        this.position = Math.min(position, this.size);
        return position < this.size;
      });
    }
    read(nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size, position } = this;
        if (file && position < size) {
          if (typeof nBytes !== "number") {
            nBytes = Number.POSITIVE_INFINITY;
          }
          let pos = position, offset = 0, bytesRead = 0;
          const end = Math.min(size, pos + Math.min(size - pos, nBytes));
          const buffer = new Uint8Array(Math.max(0, (this.position = end) - pos));
          while ((pos += bytesRead) < end && (offset += bytesRead) < buffer.byteLength) {
            ({ bytesRead } = yield file.read(buffer, offset, buffer.byteLength - offset, pos));
          }
          return buffer;
        }
        return null;
      });
    }
    readAt(position, nBytes) {
      return __awaiter(this, void 0, void 0, function* () {
        this._pending && (yield this._pending);
        const { _handle: file, size } = this;
        if (file && position + nBytes < size) {
          const end = Math.min(size, position + nBytes);
          const buffer = new Uint8Array(end - position);
          return (yield file.read(buffer, 0, nBytes, position)).buffer;
        }
        return new Uint8Array(nBytes);
      });
    }
    close() {
      return __awaiter(this, void 0, void 0, function* () {
        const f = this._handle;
        this._handle = null;
        f && (yield f.close());
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.close();
        return { done: true, value };
      });
    }
  };

  // ../../node_modules/apache-arrow/util/int.mjs
  var int_exports = {};
  __export(int_exports, {
    BaseInt64: () => BaseInt64,
    Int128: () => Int128,
    Int64: () => Int642,
    Uint64: () => Uint642
  });
  var carryBit16 = 1 << 16;
  function intAsHex(value) {
    if (value < 0) {
      value = 4294967295 + value + 1;
    }
    return `0x${value.toString(16)}`;
  }
  var kInt32DecimalDigits = 8;
  var kPowersOfTen = [
    1,
    10,
    100,
    1e3,
    1e4,
    1e5,
    1e6,
    1e7,
    1e8
  ];
  var BaseInt64 = class {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return this.buffer[1];
    }
    low() {
      return this.buffer[0];
    }
    _times(other) {
      const L = new Uint32Array([
        this.buffer[1] >>> 16,
        this.buffer[1] & 65535,
        this.buffer[0] >>> 16,
        this.buffer[0] & 65535
      ]);
      const R = new Uint32Array([
        other.buffer[1] >>> 16,
        other.buffer[1] & 65535,
        other.buffer[0] >>> 16,
        other.buffer[0] & 65535
      ]);
      let product = L[3] * R[3];
      this.buffer[0] = product & 65535;
      let sum2 = product >>> 16;
      product = L[2] * R[3];
      sum2 += product;
      product = L[3] * R[2] >>> 0;
      sum2 += product;
      this.buffer[0] += sum2 << 16;
      this.buffer[1] = sum2 >>> 0 < product ? carryBit16 : 0;
      this.buffer[1] += sum2 >>> 16;
      this.buffer[1] += L[1] * R[3] + L[2] * R[2] + L[3] * R[1];
      this.buffer[1] += L[0] * R[3] + L[1] * R[2] + L[2] * R[1] + L[3] * R[0] << 16;
      return this;
    }
    _plus(other) {
      const sum2 = this.buffer[0] + other.buffer[0] >>> 0;
      this.buffer[1] += other.buffer[1];
      if (sum2 < this.buffer[0] >>> 0) {
        ++this.buffer[1];
      }
      this.buffer[0] = sum2;
    }
    lessThan(other) {
      return this.buffer[1] < other.buffer[1] || this.buffer[1] === other.buffer[1] && this.buffer[0] < other.buffer[0];
    }
    equals(other) {
      return this.buffer[1] === other.buffer[1] && this.buffer[0] == other.buffer[0];
    }
    greaterThan(other) {
      return other.lessThan(this);
    }
    hex() {
      return `${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
  };
  var Uint642 = class extends BaseInt64 {
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    static from(val, out_buffer = new Uint32Array(2)) {
      return Uint642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return Uint642.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const length = str.length;
      const out = new Uint642(out_buffer);
      for (let posn = 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new Uint642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new Uint642(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return out;
    }
    static convertArray(values) {
      const data = new Uint32Array(values.length * 2);
      for (let i = -1, n = values.length; ++i < n; ) {
        Uint642.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
      }
      return data;
    }
    static multiply(left, right) {
      const rtrn = new Uint642(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    static add(left, right) {
      const rtrn = new Uint642(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int642 = class extends BaseInt64 {
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      return this;
    }
    times(other) {
      this._times(other);
      return this;
    }
    plus(other) {
      this._plus(other);
      return this;
    }
    lessThan(other) {
      const this_high = this.buffer[1] << 0;
      const other_high = other.buffer[1] << 0;
      return this_high < other_high || this_high === other_high && this.buffer[0] < other.buffer[0];
    }
    static from(val, out_buffer = new Uint32Array(2)) {
      return Int642.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(2)) {
      return Int642.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(2)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out = new Int642(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new Int642(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0]));
        const multiple = new Int642(new Uint32Array([kPowersOfTen[group], 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return negate ? out.negate() : out;
    }
    static convertArray(values) {
      const data = new Uint32Array(values.length * 2);
      for (let i = -1, n = values.length; ++i < n; ) {
        Int642.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 2 * i * 4, 2));
      }
      return data;
    }
    static multiply(left, right) {
      const rtrn = new Int642(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    static add(left, right) {
      const rtrn = new Int642(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
  };
  var Int128 = class {
    constructor(buffer) {
      this.buffer = buffer;
    }
    high() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
    }
    low() {
      return new Int642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset, 2));
    }
    negate() {
      this.buffer[0] = ~this.buffer[0] + 1;
      this.buffer[1] = ~this.buffer[1];
      this.buffer[2] = ~this.buffer[2];
      this.buffer[3] = ~this.buffer[3];
      if (this.buffer[0] == 0) {
        ++this.buffer[1];
      }
      if (this.buffer[1] == 0) {
        ++this.buffer[2];
      }
      if (this.buffer[2] == 0) {
        ++this.buffer[3];
      }
      return this;
    }
    times(other) {
      const L0 = new Uint642(new Uint32Array([this.buffer[3], 0]));
      const L1 = new Uint642(new Uint32Array([this.buffer[2], 0]));
      const L2 = new Uint642(new Uint32Array([this.buffer[1], 0]));
      const L3 = new Uint642(new Uint32Array([this.buffer[0], 0]));
      const R0 = new Uint642(new Uint32Array([other.buffer[3], 0]));
      const R1 = new Uint642(new Uint32Array([other.buffer[2], 0]));
      const R2 = new Uint642(new Uint32Array([other.buffer[1], 0]));
      const R3 = new Uint642(new Uint32Array([other.buffer[0], 0]));
      let product = Uint642.multiply(L3, R3);
      this.buffer[0] = product.low();
      const sum2 = new Uint642(new Uint32Array([product.high(), 0]));
      product = Uint642.multiply(L2, R3);
      sum2.plus(product);
      product = Uint642.multiply(L3, R2);
      sum2.plus(product);
      this.buffer[1] = sum2.low();
      this.buffer[3] = sum2.lessThan(product) ? 1 : 0;
      this.buffer[2] = sum2.high();
      const high = new Uint642(new Uint32Array(this.buffer.buffer, this.buffer.byteOffset + 8, 2));
      high.plus(Uint642.multiply(L1, R3)).plus(Uint642.multiply(L2, R2)).plus(Uint642.multiply(L3, R1));
      this.buffer[3] += Uint642.multiply(L0, R3).plus(Uint642.multiply(L1, R2)).plus(Uint642.multiply(L2, R1)).plus(Uint642.multiply(L3, R0)).low();
      return this;
    }
    plus(other) {
      const sums = new Uint32Array(4);
      sums[3] = this.buffer[3] + other.buffer[3] >>> 0;
      sums[2] = this.buffer[2] + other.buffer[2] >>> 0;
      sums[1] = this.buffer[1] + other.buffer[1] >>> 0;
      sums[0] = this.buffer[0] + other.buffer[0] >>> 0;
      if (sums[0] < this.buffer[0] >>> 0) {
        ++sums[1];
      }
      if (sums[1] < this.buffer[1] >>> 0) {
        ++sums[2];
      }
      if (sums[2] < this.buffer[2] >>> 0) {
        ++sums[3];
      }
      this.buffer[3] = sums[3];
      this.buffer[2] = sums[2];
      this.buffer[1] = sums[1];
      this.buffer[0] = sums[0];
      return this;
    }
    hex() {
      return `${intAsHex(this.buffer[3])} ${intAsHex(this.buffer[2])} ${intAsHex(this.buffer[1])} ${intAsHex(this.buffer[0])}`;
    }
    static multiply(left, right) {
      const rtrn = new Int128(new Uint32Array(left.buffer));
      return rtrn.times(right);
    }
    static add(left, right) {
      const rtrn = new Int128(new Uint32Array(left.buffer));
      return rtrn.plus(right);
    }
    static from(val, out_buffer = new Uint32Array(4)) {
      return Int128.fromString(typeof val === "string" ? val : val.toString(), out_buffer);
    }
    static fromNumber(num, out_buffer = new Uint32Array(4)) {
      return Int128.fromString(num.toString(), out_buffer);
    }
    static fromString(str, out_buffer = new Uint32Array(4)) {
      const negate = str.startsWith("-");
      const length = str.length;
      const out = new Int128(out_buffer);
      for (let posn = negate ? 1 : 0; posn < length; ) {
        const group = kInt32DecimalDigits < length - posn ? kInt32DecimalDigits : length - posn;
        const chunk = new Int128(new Uint32Array([Number.parseInt(str.slice(posn, posn + group), 10), 0, 0, 0]));
        const multiple = new Int128(new Uint32Array([kPowersOfTen[group], 0, 0, 0]));
        out.times(multiple);
        out.plus(chunk);
        posn += group;
      }
      return negate ? out.negate() : out;
    }
    static convertArray(values) {
      const data = new Uint32Array(values.length * 4);
      for (let i = -1, n = values.length; ++i < n; ) {
        Int128.from(values[i], new Uint32Array(data.buffer, data.byteOffset + 4 * 4 * i, 4));
      }
      return data;
    }
  };

  // ../../node_modules/apache-arrow/visitor/vectorloader.mjs
  var VectorLoader = class extends Visitor {
    constructor(bytes, nodes, buffers, dictionaries) {
      super();
      this.nodesIndex = -1;
      this.buffersIndex = -1;
      this.bytes = bytes;
      this.nodes = nodes;
      this.buffers = buffers;
      this.dictionaries = dictionaries;
    }
    visit(node) {
      return super.visit(node instanceof Field2 ? node.type : node);
    }
    visitNull(type, { length } = this.nextFieldNode()) {
      return makeData({ type, length });
    }
    visitBool(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitInt(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFloat(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitUtf8(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), data: this.readData(type) });
    }
    visitFixedSizeBinary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDate(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTimestamp(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitTime(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitDecimal(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    visitStruct(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), children: this.visitMany(type.children) });
    }
    visitUnion(type) {
      return type.mode === UnionMode.Sparse ? this.visitSparseUnion(type) : this.visitDenseUnion(type);
    }
    visitDenseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), valueOffsets: this.readOffsets(type), children: this.visitMany(type.children) });
    }
    visitSparseUnion(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), typeIds: this.readTypeIds(type), children: this.visitMany(type.children) });
    }
    visitDictionary(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type.indices), dictionary: this.readDictionary(type) });
    }
    visitInterval(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), data: this.readData(type) });
    }
    visitFixedSizeList(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), "child": this.visit(type.children[0]) });
    }
    visitMap(type, { length, nullCount } = this.nextFieldNode()) {
      return makeData({ type, length, nullCount, nullBitmap: this.readNullBitmap(type, nullCount), valueOffsets: this.readOffsets(type), "child": this.visit(type.children[0]) });
    }
    nextFieldNode() {
      return this.nodes[++this.nodesIndex];
    }
    nextBufferRange() {
      return this.buffers[++this.buffersIndex];
    }
    readNullBitmap(type, nullCount, buffer = this.nextBufferRange()) {
      return nullCount > 0 && this.readData(type, buffer) || new Uint8Array(0);
    }
    readOffsets(type, buffer) {
      return this.readData(type, buffer);
    }
    readTypeIds(type, buffer) {
      return this.readData(type, buffer);
    }
    readData(_type, { length, offset } = this.nextBufferRange()) {
      return this.bytes.subarray(offset, offset + length);
    }
    readDictionary(type) {
      return this.dictionaries.get(type.id);
    }
  };
  var JSONVectorLoader = class extends VectorLoader {
    constructor(sources, nodes, buffers, dictionaries) {
      super(new Uint8Array(0), nodes, buffers, dictionaries);
      this.sources = sources;
    }
    readNullBitmap(_type, nullCount, { offset } = this.nextBufferRange()) {
      return nullCount <= 0 ? new Uint8Array(0) : packBools(this.sources[offset]);
    }
    readOffsets(_type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(Int32Array, this.sources[offset]));
    }
    readTypeIds(type, { offset } = this.nextBufferRange()) {
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, this.sources[offset]));
    }
    readData(type, { offset } = this.nextBufferRange()) {
      const { sources } = this;
      if (DataType.isTimestamp(type)) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if ((DataType.isInt(type) || DataType.isTime(type)) && type.bitWidth === 64) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDate(type) && type.unit === DateUnit.MILLISECOND) {
        return toArrayBufferView(Uint8Array, Int642.convertArray(sources[offset]));
      } else if (DataType.isDecimal(type)) {
        return toArrayBufferView(Uint8Array, Int128.convertArray(sources[offset]));
      } else if (DataType.isBinary(type) || DataType.isFixedSizeBinary(type)) {
        return binaryDataFromJSON(sources[offset]);
      } else if (DataType.isBool(type)) {
        return packBools(sources[offset]);
      } else if (DataType.isUtf8(type)) {
        return encodeUtf8(sources[offset].join(""));
      }
      return toArrayBufferView(Uint8Array, toArrayBufferView(type.ArrayType, sources[offset].map((x) => +x)));
    }
  };
  function binaryDataFromJSON(values) {
    const joined = values.join("");
    const data = new Uint8Array(joined.length / 2);
    for (let i = 0; i < joined.length; i += 2) {
      data[i >> 1] = Number.parseInt(joined.slice(i, i + 2), 16);
    }
    return data;
  }

  // ../../node_modules/apache-arrow/builder/binary.mjs
  var BinaryBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, toUint8Array(value));
    }
    _flushPending(pending, pendingLength) {
      const offsets = this._offsets;
      const data = this._values.reserve(pendingLength).buffer;
      let offset = 0;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          const length = value.length;
          data.set(value, offset);
          offsets.set(index, length);
          offset += length;
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/bool.mjs
  var BoolBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._values = new BitmapBufferBuilder();
    }
    setValue(index, value) {
      this._values.set(index, +value);
    }
  };

  // ../../node_modules/apache-arrow/builder/date.mjs
  var DateBuilder = class extends FixedWidthBuilder {
  };
  DateBuilder.prototype._setValue = setDate;
  var DateDayBuilder = class extends DateBuilder {
  };
  DateDayBuilder.prototype._setValue = setDateDay;
  var DateMillisecondBuilder = class extends DateBuilder {
  };
  DateMillisecondBuilder.prototype._setValue = setDateMillisecond;

  // ../../node_modules/apache-arrow/builder/decimal.mjs
  var DecimalBuilder = class extends FixedWidthBuilder {
  };
  DecimalBuilder.prototype._setValue = setDecimal;

  // ../../node_modules/apache-arrow/builder/dictionary.mjs
  var DictionaryBuilder = class extends Builder {
    constructor({ "type": type, "nullValues": nulls, "dictionaryHashFunction": hashFn }) {
      super({ type: new Dictionary(type.dictionary, type.indices, type.id, type.isOrdered) });
      this._nulls = null;
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      this.indices = makeBuilder({ "type": this.type.indices, "nullValues": nulls });
      this.dictionary = makeBuilder({ "type": this.type.dictionary, "nullValues": null });
      if (typeof hashFn === "function") {
        this.valueToKey = hashFn;
      }
    }
    get values() {
      return this.indices.values;
    }
    get nullCount() {
      return this.indices.nullCount;
    }
    get nullBitmap() {
      return this.indices.nullBitmap;
    }
    get byteLength() {
      return this.indices.byteLength + this.dictionary.byteLength;
    }
    get reservedLength() {
      return this.indices.reservedLength + this.dictionary.reservedLength;
    }
    get reservedByteLength() {
      return this.indices.reservedByteLength + this.dictionary.reservedByteLength;
    }
    isValid(value) {
      return this.indices.isValid(value);
    }
    setValid(index, valid) {
      const indices = this.indices;
      valid = indices.setValid(index, valid);
      this.length = indices.length;
      return valid;
    }
    setValue(index, value) {
      const keysToIndices = this._keysToIndices;
      const key = this.valueToKey(value);
      let idx = keysToIndices[key];
      if (idx === void 0) {
        keysToIndices[key] = idx = this._dictionaryOffset + this.dictionary.append(value).length - 1;
      }
      return this.indices.setValue(index, idx);
    }
    flush() {
      const type = this.type;
      const prev = this._dictionary;
      const curr = this.dictionary.toVector();
      const data = this.indices.flush().clone(type);
      data.dictionary = prev ? prev.concat(curr) : curr;
      this.finished || (this._dictionaryOffset += curr.length);
      this._dictionary = data.dictionary;
      this.clear();
      return data;
    }
    finish() {
      this.indices.finish();
      this.dictionary.finish();
      this._dictionaryOffset = 0;
      this._keysToIndices = /* @__PURE__ */ Object.create(null);
      return super.finish();
    }
    clear() {
      this.indices.clear();
      this.dictionary.clear();
      return super.clear();
    }
    valueToKey(val) {
      return typeof val === "string" ? val : `${val}`;
    }
  };

  // ../../node_modules/apache-arrow/builder/fixedsizebinary.mjs
  var FixedSizeBinaryBuilder = class extends FixedWidthBuilder {
  };
  FixedSizeBinaryBuilder.prototype._setValue = setFixedSizeBinary;

  // ../../node_modules/apache-arrow/builder/fixedsizelist.mjs
  var FixedSizeListBuilder = class extends Builder {
    setValue(index, value) {
      const [child] = this.children;
      const start = index * this.stride;
      for (let i = -1, n = value.length; ++i < n; ) {
        child.set(start + i, value[i]);
      }
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("FixedSizeListBuilder can only have one child.");
      }
      const childIndex = this.children.push(child);
      this.type = new FixedSizeList(this.type.listSize, new Field2(name, child.type, true));
      return childIndex;
    }
  };

  // ../../node_modules/apache-arrow/builder/float.mjs
  var FloatBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Float16Builder = class extends FloatBuilder {
    setValue(index, value) {
      super.setValue(index, float64ToUint16(value));
    }
  };
  var Float32Builder = class extends FloatBuilder {
  };
  var Float64Builder = class extends FloatBuilder {
  };

  // ../../node_modules/apache-arrow/builder/interval.mjs
  var IntervalBuilder = class extends FixedWidthBuilder {
  };
  IntervalBuilder.prototype._setValue = setIntervalValue;
  var IntervalDayTimeBuilder = class extends IntervalBuilder {
  };
  IntervalDayTimeBuilder.prototype._setValue = setIntervalDayTime;
  var IntervalYearMonthBuilder = class extends IntervalBuilder {
  };
  IntervalYearMonthBuilder.prototype._setValue = setIntervalYearMonth;

  // ../../node_modules/apache-arrow/builder/int.mjs
  var IntBuilder = class extends FixedWidthBuilder {
    setValue(index, value) {
      this._values.set(index, value);
    }
  };
  var Int8Builder = class extends IntBuilder {
  };
  var Int16Builder = class extends IntBuilder {
  };
  var Int32Builder = class extends IntBuilder {
  };
  var Int64Builder = class extends IntBuilder {
  };
  var Uint8Builder = class extends IntBuilder {
  };
  var Uint16Builder = class extends IntBuilder {
  };
  var Uint32Builder = class extends IntBuilder {
  };
  var Uint64Builder = class extends IntBuilder {
  };

  // ../../node_modules/apache-arrow/builder/list.mjs
  var ListBuilder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._offsets = new OffsetsBufferBuilder();
    }
    addChild(child, name = "0") {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new List(new Field2(name, child.type, true));
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (typeof value === "undefined") {
          offsets.set(index, 0);
        } else {
          const n = value.length;
          const start = offsets.set(index, n).buffer[index];
          for (let i = -1; ++i < n; ) {
            child.set(start + i, value[i]);
          }
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/map.mjs
  var MapBuilder = class extends VariableWidthBuilder {
    set(index, value) {
      return super.set(index, value);
    }
    setValue(index, value) {
      const row = value instanceof Map ? value : new Map(Object.entries(value));
      const pending = this._pending || (this._pending = /* @__PURE__ */ new Map());
      const current = pending.get(index);
      current && (this._pendingLength -= current.size);
      this._pendingLength += row.size;
      pending.set(index, row);
    }
    addChild(child, name = `${this.numChildren}`) {
      if (this.numChildren > 0) {
        throw new Error("ListBuilder can only have one child.");
      }
      this.children[this.numChildren] = child;
      this.type = new Map_(new Field2(name, child.type, true), this.type.keysSorted);
      return this.numChildren - 1;
    }
    _flushPending(pending) {
      const offsets = this._offsets;
      const [child] = this.children;
      for (const [index, value] of pending) {
        if (value === void 0) {
          offsets.set(index, 0);
        } else {
          let { [index]: idx, [index + 1]: end } = offsets.set(index, value.size).buffer;
          for (const val of value.entries()) {
            child.set(idx, val);
            if (++idx >= end)
              break;
          }
        }
      }
    }
  };

  // ../../node_modules/apache-arrow/builder/null.mjs
  var NullBuilder = class extends Builder {
    setValue(index, value) {
    }
    setValid(index, valid) {
      this.length = Math.max(index + 1, this.length);
      return valid;
    }
  };

  // ../../node_modules/apache-arrow/builder/struct.mjs
  var StructBuilder = class extends Builder {
    setValue(index, value) {
      const { children, type } = this;
      switch (Array.isArray(value) || value.constructor) {
        case true:
          return type.children.forEach((_, i) => children[i].set(index, value[i]));
        case Map:
          return type.children.forEach((f, i) => children[i].set(index, value.get(f.name)));
        default:
          return type.children.forEach((f, i) => children[i].set(index, value[f.name]));
      }
    }
    setValid(index, valid) {
      if (!super.setValid(index, valid)) {
        this.children.forEach((child) => child.setValid(index, valid));
      }
      return valid;
    }
    addChild(child, name = `${this.numChildren}`) {
      const childIndex = this.children.push(child);
      this.type = new Struct([...this.type.children, new Field2(name, child.type, true)]);
      return childIndex;
    }
  };

  // ../../node_modules/apache-arrow/builder/timestamp.mjs
  var TimestampBuilder = class extends FixedWidthBuilder {
  };
  TimestampBuilder.prototype._setValue = setTimestamp;
  var TimestampSecondBuilder = class extends TimestampBuilder {
  };
  TimestampSecondBuilder.prototype._setValue = setTimestampSecond;
  var TimestampMillisecondBuilder = class extends TimestampBuilder {
  };
  TimestampMillisecondBuilder.prototype._setValue = setTimestampMillisecond;
  var TimestampMicrosecondBuilder = class extends TimestampBuilder {
  };
  TimestampMicrosecondBuilder.prototype._setValue = setTimestampMicrosecond;
  var TimestampNanosecondBuilder = class extends TimestampBuilder {
  };
  TimestampNanosecondBuilder.prototype._setValue = setTimestampNanosecond;

  // ../../node_modules/apache-arrow/builder/time.mjs
  var TimeBuilder = class extends FixedWidthBuilder {
  };
  TimeBuilder.prototype._setValue = setTime;
  var TimeSecondBuilder = class extends TimeBuilder {
  };
  TimeSecondBuilder.prototype._setValue = setTimeSecond;
  var TimeMillisecondBuilder = class extends TimeBuilder {
  };
  TimeMillisecondBuilder.prototype._setValue = setTimeMillisecond;
  var TimeMicrosecondBuilder = class extends TimeBuilder {
  };
  TimeMicrosecondBuilder.prototype._setValue = setTimeMicrosecond;
  var TimeNanosecondBuilder = class extends TimeBuilder {
  };
  TimeNanosecondBuilder.prototype._setValue = setTimeNanosecond;

  // ../../node_modules/apache-arrow/builder/union.mjs
  var UnionBuilder = class extends Builder {
    constructor(options) {
      super(options);
      this._typeIds = new DataBufferBuilder(new Int8Array(0), 1);
      if (typeof options["valueToChildTypeId"] === "function") {
        this._valueToChildTypeId = options["valueToChildTypeId"];
      }
    }
    get typeIdToChildIndex() {
      return this.type.typeIdToChildIndex;
    }
    append(value, childTypeId) {
      return this.set(this.length, value, childTypeId);
    }
    set(index, value, childTypeId) {
      if (childTypeId === void 0) {
        childTypeId = this._valueToChildTypeId(this, value, index);
      }
      if (this.setValid(index, this.isValid(value))) {
        this.setValue(index, value, childTypeId);
      }
      return this;
    }
    setValue(index, value, childTypeId) {
      this._typeIds.set(index, childTypeId);
      const childIndex = this.type.typeIdToChildIndex[childTypeId];
      const child = this.children[childIndex];
      child === null || child === void 0 ? void 0 : child.set(index, value);
    }
    addChild(child, name = `${this.children.length}`) {
      const childTypeId = this.children.push(child);
      const { type: { children, mode, typeIds } } = this;
      const fields = [...children, new Field2(name, child.type)];
      this.type = new Union_(mode, [...typeIds, childTypeId], fields);
      return childTypeId;
    }
    _valueToChildTypeId(builder, value, offset) {
      throw new Error(`Cannot map UnionBuilder value to child typeId. Pass the \`childTypeId\` as the second argument to unionBuilder.append(), or supply a \`valueToChildTypeId\` function as part of the UnionBuilder constructor options.`);
    }
  };
  var SparseUnionBuilder = class extends UnionBuilder {
  };
  var DenseUnionBuilder = class extends UnionBuilder {
    constructor(options) {
      super(options);
      this._offsets = new DataBufferBuilder(new Int32Array(0));
    }
    setValue(index, value, childTypeId) {
      const id = this._typeIds.set(index, childTypeId).buffer[index];
      const child = this.getChildAt(this.type.typeIdToChildIndex[id]);
      const denseIndex = this._offsets.set(index, child.length).buffer[index];
      child === null || child === void 0 ? void 0 : child.set(denseIndex, value);
    }
  };

  // ../../node_modules/apache-arrow/builder/utf8.mjs
  var Utf8Builder = class extends VariableWidthBuilder {
    constructor(opts) {
      super(opts);
      this._values = new BufferBuilder(new Uint8Array(0));
    }
    get byteLength() {
      let size = this._pendingLength + this.length * 4;
      this._offsets && (size += this._offsets.byteLength);
      this._values && (size += this._values.byteLength);
      this._nulls && (size += this._nulls.byteLength);
      return size;
    }
    setValue(index, value) {
      return super.setValue(index, encodeUtf8(value));
    }
    _flushPending(pending, pendingLength) {
    }
  };
  Utf8Builder.prototype._flushPending = BinaryBuilder.prototype._flushPending;

  // ../../node_modules/apache-arrow/visitor/builderctor.mjs
  var GetBuilderCtor = class extends Visitor {
    visitNull() {
      return NullBuilder;
    }
    visitBool() {
      return BoolBuilder;
    }
    visitInt() {
      return IntBuilder;
    }
    visitInt8() {
      return Int8Builder;
    }
    visitInt16() {
      return Int16Builder;
    }
    visitInt32() {
      return Int32Builder;
    }
    visitInt64() {
      return Int64Builder;
    }
    visitUint8() {
      return Uint8Builder;
    }
    visitUint16() {
      return Uint16Builder;
    }
    visitUint32() {
      return Uint32Builder;
    }
    visitUint64() {
      return Uint64Builder;
    }
    visitFloat() {
      return FloatBuilder;
    }
    visitFloat16() {
      return Float16Builder;
    }
    visitFloat32() {
      return Float32Builder;
    }
    visitFloat64() {
      return Float64Builder;
    }
    visitUtf8() {
      return Utf8Builder;
    }
    visitBinary() {
      return BinaryBuilder;
    }
    visitFixedSizeBinary() {
      return FixedSizeBinaryBuilder;
    }
    visitDate() {
      return DateBuilder;
    }
    visitDateDay() {
      return DateDayBuilder;
    }
    visitDateMillisecond() {
      return DateMillisecondBuilder;
    }
    visitTimestamp() {
      return TimestampBuilder;
    }
    visitTimestampSecond() {
      return TimestampSecondBuilder;
    }
    visitTimestampMillisecond() {
      return TimestampMillisecondBuilder;
    }
    visitTimestampMicrosecond() {
      return TimestampMicrosecondBuilder;
    }
    visitTimestampNanosecond() {
      return TimestampNanosecondBuilder;
    }
    visitTime() {
      return TimeBuilder;
    }
    visitTimeSecond() {
      return TimeSecondBuilder;
    }
    visitTimeMillisecond() {
      return TimeMillisecondBuilder;
    }
    visitTimeMicrosecond() {
      return TimeMicrosecondBuilder;
    }
    visitTimeNanosecond() {
      return TimeNanosecondBuilder;
    }
    visitDecimal() {
      return DecimalBuilder;
    }
    visitList() {
      return ListBuilder;
    }
    visitStruct() {
      return StructBuilder;
    }
    visitUnion() {
      return UnionBuilder;
    }
    visitDenseUnion() {
      return DenseUnionBuilder;
    }
    visitSparseUnion() {
      return SparseUnionBuilder;
    }
    visitDictionary() {
      return DictionaryBuilder;
    }
    visitInterval() {
      return IntervalBuilder;
    }
    visitIntervalDayTime() {
      return IntervalDayTimeBuilder;
    }
    visitIntervalYearMonth() {
      return IntervalYearMonthBuilder;
    }
    visitFixedSizeList() {
      return FixedSizeListBuilder;
    }
    visitMap() {
      return MapBuilder;
    }
  };
  var instance6 = new GetBuilderCtor();

  // ../../node_modules/apache-arrow/visitor/typecomparator.mjs
  var TypeComparator = class extends Visitor {
    compareSchemas(schema, other) {
      return schema === other || other instanceof schema.constructor && this.compareManyFields(schema.fields, other.fields);
    }
    compareManyFields(fields, others) {
      return fields === others || Array.isArray(fields) && Array.isArray(others) && fields.length === others.length && fields.every((f, i) => this.compareFields(f, others[i]));
    }
    compareFields(field, other) {
      return field === other || other instanceof field.constructor && field.name === other.name && field.nullable === other.nullable && this.visit(field.type, other.type);
    }
  };
  function compareConstructor(type, other) {
    return other instanceof type.constructor;
  }
  function compareAny(type, other) {
    return type === other || compareConstructor(type, other);
  }
  function compareInt(type, other) {
    return type === other || compareConstructor(type, other) && type.bitWidth === other.bitWidth && type.isSigned === other.isSigned;
  }
  function compareFloat(type, other) {
    return type === other || compareConstructor(type, other) && type.precision === other.precision;
  }
  function compareFixedSizeBinary(type, other) {
    return type === other || compareConstructor(type, other) && type.byteWidth === other.byteWidth;
  }
  function compareDate(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareTimestamp(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.timezone === other.timezone;
  }
  function compareTime(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit && type.bitWidth === other.bitWidth;
  }
  function compareList(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareStruct(type, other) {
    return type === other || compareConstructor(type, other) && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareUnion(type, other) {
    return type === other || compareConstructor(type, other) && type.mode === other.mode && type.typeIds.every((x, i) => x === other.typeIds[i]) && instance7.compareManyFields(type.children, other.children);
  }
  function compareDictionary(type, other) {
    return type === other || compareConstructor(type, other) && type.id === other.id && type.isOrdered === other.isOrdered && instance7.visit(type.indices, other.indices) && instance7.visit(type.dictionary, other.dictionary);
  }
  function compareInterval(type, other) {
    return type === other || compareConstructor(type, other) && type.unit === other.unit;
  }
  function compareFixedSizeList(type, other) {
    return type === other || compareConstructor(type, other) && type.listSize === other.listSize && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  function compareMap(type, other) {
    return type === other || compareConstructor(type, other) && type.keysSorted === other.keysSorted && type.children.length === other.children.length && instance7.compareManyFields(type.children, other.children);
  }
  TypeComparator.prototype.visitNull = compareAny;
  TypeComparator.prototype.visitBool = compareAny;
  TypeComparator.prototype.visitInt = compareInt;
  TypeComparator.prototype.visitInt8 = compareInt;
  TypeComparator.prototype.visitInt16 = compareInt;
  TypeComparator.prototype.visitInt32 = compareInt;
  TypeComparator.prototype.visitInt64 = compareInt;
  TypeComparator.prototype.visitUint8 = compareInt;
  TypeComparator.prototype.visitUint16 = compareInt;
  TypeComparator.prototype.visitUint32 = compareInt;
  TypeComparator.prototype.visitUint64 = compareInt;
  TypeComparator.prototype.visitFloat = compareFloat;
  TypeComparator.prototype.visitFloat16 = compareFloat;
  TypeComparator.prototype.visitFloat32 = compareFloat;
  TypeComparator.prototype.visitFloat64 = compareFloat;
  TypeComparator.prototype.visitUtf8 = compareAny;
  TypeComparator.prototype.visitBinary = compareAny;
  TypeComparator.prototype.visitFixedSizeBinary = compareFixedSizeBinary;
  TypeComparator.prototype.visitDate = compareDate;
  TypeComparator.prototype.visitDateDay = compareDate;
  TypeComparator.prototype.visitDateMillisecond = compareDate;
  TypeComparator.prototype.visitTimestamp = compareTimestamp;
  TypeComparator.prototype.visitTimestampSecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMillisecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampMicrosecond = compareTimestamp;
  TypeComparator.prototype.visitTimestampNanosecond = compareTimestamp;
  TypeComparator.prototype.visitTime = compareTime;
  TypeComparator.prototype.visitTimeSecond = compareTime;
  TypeComparator.prototype.visitTimeMillisecond = compareTime;
  TypeComparator.prototype.visitTimeMicrosecond = compareTime;
  TypeComparator.prototype.visitTimeNanosecond = compareTime;
  TypeComparator.prototype.visitDecimal = compareAny;
  TypeComparator.prototype.visitList = compareList;
  TypeComparator.prototype.visitStruct = compareStruct;
  TypeComparator.prototype.visitUnion = compareUnion;
  TypeComparator.prototype.visitDenseUnion = compareUnion;
  TypeComparator.prototype.visitSparseUnion = compareUnion;
  TypeComparator.prototype.visitDictionary = compareDictionary;
  TypeComparator.prototype.visitInterval = compareInterval;
  TypeComparator.prototype.visitIntervalDayTime = compareInterval;
  TypeComparator.prototype.visitIntervalYearMonth = compareInterval;
  TypeComparator.prototype.visitFixedSizeList = compareFixedSizeList;
  TypeComparator.prototype.visitMap = compareMap;
  var instance7 = new TypeComparator();
  function compareSchemas(schema, other) {
    return instance7.compareSchemas(schema, other);
  }
  function compareFields(field, other) {
    return instance7.compareFields(field, other);
  }
  function compareTypes(type, other) {
    return instance7.visit(type, other);
  }

  // ../../node_modules/apache-arrow/factories.mjs
  function makeBuilder(options) {
    const type = options.type;
    const builder = new (instance6.getVisitFn(type)())(options);
    if (type.children && type.children.length > 0) {
      const children = options["children"] || [];
      const defaultOptions = { "nullValues": options["nullValues"] };
      const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : ({ name }) => children[name] || defaultOptions;
      for (const [index, field] of type.children.entries()) {
        const { type: type2 } = field;
        const opts = getChildOptions(field, index);
        builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), { type: type2 })));
      }
    }
    return builder;
  }
  function vectorFromArray(init, type) {
    if (init instanceof Data || init instanceof Vector || init.type instanceof DataType || ArrayBuffer.isView(init)) {
      return makeVector(init);
    }
    const options = { type: type !== null && type !== void 0 ? type : inferType(init), nullValues: [null] };
    const chunks = [...builderThroughIterable(options)(init)];
    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));
    if (DataType.isDictionary(vector.type)) {
      return vector.memoize();
    }
    return vector;
  }
  function inferType(value) {
    if (value.length === 0) {
      return new Null();
    }
    let nullsCount = 0;
    let arraysCount = 0;
    let objectsCount = 0;
    let numbersCount = 0;
    let stringsCount = 0;
    let bigintsCount = 0;
    let booleansCount = 0;
    let datesCount = 0;
    for (const val of value) {
      if (val == null) {
        ++nullsCount;
        continue;
      }
      switch (typeof val) {
        case "bigint":
          ++bigintsCount;
          continue;
        case "boolean":
          ++booleansCount;
          continue;
        case "number":
          ++numbersCount;
          continue;
        case "string":
          ++stringsCount;
          continue;
        case "object":
          if (Array.isArray(val)) {
            ++arraysCount;
          } else if (Object.prototype.toString.call(val) === "[object Date]") {
            ++datesCount;
          } else {
            ++objectsCount;
          }
          continue;
      }
      throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected");
    }
    if (numbersCount + nullsCount === value.length) {
      return new Float64();
    } else if (stringsCount + nullsCount === value.length) {
      return new Dictionary(new Utf8(), new Int32());
    } else if (bigintsCount + nullsCount === value.length) {
      return new Int64();
    } else if (booleansCount + nullsCount === value.length) {
      return new Bool();
    } else if (datesCount + nullsCount === value.length) {
      return new DateMillisecond();
    } else if (arraysCount + nullsCount === value.length) {
      const array = value;
      const childType = inferType(array[array.findIndex((ary) => ary != null)]);
      if (array.every((ary) => ary == null || compareTypes(childType, inferType(ary)))) {
        return new List(new Field2("", childType, true));
      }
    } else if (objectsCount + nullsCount === value.length) {
      const fields = /* @__PURE__ */ new Map();
      for (const row of value) {
        for (const key of Object.keys(row)) {
          if (!fields.has(key) && row[key] != null) {
            fields.set(key, new Field2(key, inferType([row[key]]), true));
          }
        }
      }
      return new Struct([...fields.values()]);
    }
    throw new TypeError("Unable to infer Vector type from input values, explicit type declaration expected");
  }
  function builderThroughIterable(options) {
    const { ["queueingStrategy"]: queueingStrategy = "count" } = options;
    const { ["highWaterMark"]: highWaterMark = queueingStrategy !== "bytes" ? Number.POSITIVE_INFINITY : Math.pow(2, 14) } = options;
    const sizeProperty = queueingStrategy !== "bytes" ? "length" : "byteLength";
    return function* (source) {
      let numChunks = 0;
      const builder = makeBuilder(options);
      for (const value of source) {
        if (builder.append(value)[sizeProperty] >= highWaterMark) {
          ++numChunks && (yield builder.toVector());
        }
      }
      if (builder.finish().length > 0 || numChunks === 0) {
        yield builder.toVector();
      }
    };
  }

  // ../../node_modules/apache-arrow/util/recordbatch.mjs
  function distributeVectorsIntoRecordBatches(schema, vecs) {
    return uniformlyDistributeChunksAcrossRecordBatches(schema, vecs.map((v) => v.data.concat()));
  }
  function uniformlyDistributeChunksAcrossRecordBatches(schema, cols) {
    const fields = [...schema.fields];
    const batches = [];
    const memo = { numBatches: cols.reduce((n, c) => Math.max(n, c.length), 0) };
    let numBatches = 0, batchLength = 0;
    let i = -1;
    const numColumns = cols.length;
    let child, children = [];
    while (memo.numBatches-- > 0) {
      for (batchLength = Number.POSITIVE_INFINITY, i = -1; ++i < numColumns; ) {
        children[i] = child = cols[i].shift();
        batchLength = Math.min(batchLength, child ? child.length : batchLength);
      }
      if (Number.isFinite(batchLength)) {
        children = distributeChildren(fields, batchLength, children, cols, memo);
        if (batchLength > 0) {
          batches[numBatches++] = makeData({
            type: new Struct(fields),
            length: batchLength,
            nullCount: 0,
            children: children.slice()
          });
        }
      }
    }
    return [
      schema = schema.assign(fields),
      batches.map((data) => new RecordBatch(schema, data))
    ];
  }
  function distributeChildren(fields, batchLength, children, columns, memo) {
    var _a5;
    const nullBitmapSize = (batchLength + 63 & ~63) >> 3;
    for (let i = -1, n = columns.length; ++i < n; ) {
      const child = children[i];
      const length = child === null || child === void 0 ? void 0 : child.length;
      if (length >= batchLength) {
        if (length === batchLength) {
          children[i] = child;
        } else {
          children[i] = child.slice(0, batchLength);
          memo.numBatches = Math.max(memo.numBatches, columns[i].unshift(child.slice(batchLength, length - batchLength)));
        }
      } else {
        const field = fields[i];
        fields[i] = field.clone({ nullable: true });
        children[i] = (_a5 = child === null || child === void 0 ? void 0 : child._changeLengthAndBackfillNullBitmap(batchLength)) !== null && _a5 !== void 0 ? _a5 : makeData({
          type: field.type,
          length: batchLength,
          nullCount: batchLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return children;
  }

  // ../../node_modules/apache-arrow/table.mjs
  var _a3;
  var Table = class {
    constructor(...args) {
      var _b2, _c2;
      if (args.length === 0) {
        this.batches = [];
        this.schema = new Schema2([]);
        this._offsets = [0];
        return this;
      }
      let schema;
      let offsets;
      if (args[0] instanceof Schema2) {
        schema = args.shift();
      }
      if (args[args.length - 1] instanceof Uint32Array) {
        offsets = args.pop();
      }
      const unwrap = (x) => {
        if (x) {
          if (x instanceof RecordBatch) {
            return [x];
          } else if (x instanceof Table) {
            return x.batches;
          } else if (x instanceof Data) {
            if (x.type instanceof Struct) {
              return [new RecordBatch(new Schema2(x.type.children), x)];
            }
          } else if (Array.isArray(x)) {
            return x.flatMap((v) => unwrap(v));
          } else if (typeof x[Symbol.iterator] === "function") {
            return [...x].flatMap((v) => unwrap(v));
          } else if (typeof x === "object") {
            const keys = Object.keys(x);
            const vecs = keys.map((k) => new Vector([x[k]]));
            const schema2 = new Schema2(keys.map((k, i) => new Field2(String(k), vecs[i].type)));
            const [, batches2] = distributeVectorsIntoRecordBatches(schema2, vecs);
            return batches2.length === 0 ? [new RecordBatch(x)] : batches2;
          }
        }
        return [];
      };
      const batches = args.flatMap((v) => unwrap(v));
      schema = (_c2 = schema !== null && schema !== void 0 ? schema : (_b2 = batches[0]) === null || _b2 === void 0 ? void 0 : _b2.schema) !== null && _c2 !== void 0 ? _c2 : new Schema2([]);
      if (!(schema instanceof Schema2)) {
        throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
      }
      for (const batch of batches) {
        if (!(batch instanceof RecordBatch)) {
          throw new TypeError("Table constructor expects a [Schema, RecordBatch[]] pair.");
        }
        if (!compareSchemas(schema, batch.schema)) {
          throw new TypeError("Table and inner RecordBatch schemas must be equivalent.");
        }
      }
      this.schema = schema;
      this.batches = batches;
      this._offsets = offsets !== null && offsets !== void 0 ? offsets : computeChunkOffsets(this.data);
    }
    get data() {
      return this.batches.map(({ data }) => data);
    }
    get numCols() {
      return this.schema.fields.length;
    }
    get numRows() {
      return this.data.reduce((numRows, data) => numRows + data.length, 0);
    }
    get nullCount() {
      if (this._nullCount === -1) {
        this._nullCount = computeChunkNullCounts(this.data);
      }
      return this._nullCount;
    }
    isValid(index) {
      return false;
    }
    get(index) {
      return null;
    }
    set(index, value) {
      return;
    }
    indexOf(element, offset) {
      return -1;
    }
    getByteLength(index) {
      return 0;
    }
    [Symbol.iterator]() {
      if (this.batches.length > 0) {
        return instance4.visit(new Vector(this.data));
      }
      return new Array(0)[Symbol.iterator]();
    }
    toArray() {
      return [...this];
    }
    toString() {
      return `[
  ${this.toArray().join(",\n  ")}
]`;
    }
    concat(...others) {
      const schema = this.schema;
      const data = this.data.concat(others.flatMap(({ data: data2 }) => data2));
      return new Table(schema, data.map((data2) => new RecordBatch(schema, data2)));
    }
    slice(begin, end) {
      const schema = this.schema;
      [begin, end] = clampRange({ length: this.numRows }, begin, end);
      const data = sliceChunks(this.data, this._offsets, begin, end);
      return new Table(schema, data.map((chunk) => new RecordBatch(schema, chunk)));
    }
    getChild(name) {
      return this.getChildAt(this.schema.fields.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        const data = this.data.map((data2) => data2.children[index]);
        if (data.length === 0) {
          const { type } = this.schema.fields[index];
          const empty = makeData({ type, length: 0, nullCount: 0 });
          data.push(empty._changeLengthAndBackfillNullBitmap(this.numRows));
        }
        return new Vector(data);
      }
      return null;
    }
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let batches = [...this.batches];
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const field = fields[index].clone({ type: child.type });
        const children = this.schema.fields.map((_, i) => this.getChildAt(i));
        [fields[index], children[index]] = [field, child];
        [schema, batches] = distributeVectorsIntoRecordBatches(schema, children);
      }
      return new Table(schema, batches);
    }
    select(columnNames) {
      const nameToIndex = this.schema.fields.reduce((m, f, i) => m.set(f.name, i), /* @__PURE__ */ new Map());
      return this.selectAt(columnNames.map((columnName) => nameToIndex.get(columnName)).filter((x) => x > -1));
    }
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const data = this.batches.map((batch) => batch.selectAt(columnIndices));
      return new Table(schema, data);
    }
    assign(other) {
      const fields = this.schema.fields;
      const [indices, oldToNew] = other.schema.fields.reduce((memo, f2, newIdx) => {
        const [indices2, oldToNew2] = memo;
        const i = fields.findIndex((f) => f.name === f2.name);
        ~i ? oldToNew2[i] = newIdx : indices2.push(newIdx);
        return memo;
      }, [[], []]);
      const schema = this.schema.assign(other.schema);
      const columns = [
        ...fields.map((_, i) => [i, oldToNew[i]]).map(([i, j]) => j === void 0 ? this.getChildAt(i) : other.getChildAt(j)),
        ...indices.map((i) => other.getChildAt(i))
      ].filter(Boolean);
      return new Table(...distributeVectorsIntoRecordBatches(schema, columns));
    }
  };
  _a3 = Symbol.toStringTag;
  Table[_a3] = ((proto) => {
    proto.schema = null;
    proto.batches = [];
    proto._offsets = new Uint32Array([0]);
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    proto["isValid"] = wrapChunkedCall1(isChunkedValid);
    proto["get"] = wrapChunkedCall1(instance2.getVisitFn(Type.Struct));
    proto["set"] = wrapChunkedCall2(instance.getVisitFn(Type.Struct));
    proto["indexOf"] = wrapChunkedIndexOf(instance3.getVisitFn(Type.Struct));
    proto["getByteLength"] = wrapChunkedCall1(instance5.getVisitFn(Type.Struct));
    return "Table";
  })(Table.prototype);

  // ../../node_modules/apache-arrow/recordbatch.mjs
  var _a4;
  var RecordBatch = class {
    constructor(...args) {
      switch (args.length) {
        case 2: {
          [this.schema] = args;
          if (!(this.schema instanceof Schema2)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [
            ,
            this.data = makeData({
              nullCount: 0,
              type: new Struct(this.schema.fields),
              children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))
            })
          ] = args;
          if (!(this.data instanceof Data)) {
            throw new TypeError("RecordBatch constructor expects a [Schema, Data] pair.");
          }
          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);
          break;
        }
        case 1: {
          const [obj] = args;
          const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {
            memo.children[i] = obj[name];
            memo.length = Math.max(memo.length, obj[name].length);
            memo.fields[i] = Field2.new({ name, type: obj[name].type, nullable: true });
            return memo;
          }, {
            length: 0,
            fields: new Array(),
            children: new Array()
          });
          const schema = new Schema2(fields);
          const data = makeData({ type: new Struct(fields), length, children, nullCount: 0 });
          [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);
          break;
        }
        default:
          throw new TypeError("RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.");
      }
    }
    get dictionaries() {
      return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));
    }
    get numCols() {
      return this.schema.fields.length;
    }
    get numRows() {
      return this.data.length;
    }
    get nullCount() {
      return this.data.nullCount;
    }
    isValid(index) {
      return this.data.getValid(index);
    }
    get(index) {
      return instance2.visit(this.data, index);
    }
    set(index, value) {
      return instance.visit(this.data, index, value);
    }
    indexOf(element, offset) {
      return instance3.visit(this.data, element, offset);
    }
    getByteLength(index) {
      return instance5.visit(this.data, index);
    }
    [Symbol.iterator]() {
      return instance4.visit(new Vector([this.data]));
    }
    toArray() {
      return [...this];
    }
    concat(...others) {
      return new Table(this.schema, [this, ...others]);
    }
    slice(begin, end) {
      const [slice] = new Vector([this.data]).slice(begin, end).data;
      return new RecordBatch(this.schema, slice);
    }
    getChild(name) {
      var _b2;
      return this.getChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name));
    }
    getChildAt(index) {
      if (index > -1 && index < this.schema.fields.length) {
        return new Vector([this.data.children[index]]);
      }
      return null;
    }
    setChild(name, child) {
      var _b2;
      return this.setChildAt((_b2 = this.schema.fields) === null || _b2 === void 0 ? void 0 : _b2.findIndex((f) => f.name === name), child);
    }
    setChildAt(index, child) {
      let schema = this.schema;
      let data = this.data;
      if (index > -1 && index < this.numCols) {
        if (!child) {
          child = new Vector([makeData({ type: new Null(), length: this.numRows })]);
        }
        const fields = schema.fields.slice();
        const children = data.children.slice();
        const field = fields[index].clone({ type: child.type });
        [fields[index], children[index]] = [field, child.data[0]];
        schema = new Schema2(fields, new Map(this.schema.metadata));
        data = makeData({ type: new Struct(fields), children });
      }
      return new RecordBatch(schema, data);
    }
    select(columnNames) {
      const schema = this.schema.select(columnNames);
      const type = new Struct(schema.fields);
      const children = [];
      for (const name of columnNames) {
        const index = this.schema.fields.findIndex((f) => f.name === name);
        if (~index) {
          children[index] = this.data.children[index];
        }
      }
      return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));
    }
    selectAt(columnIndices) {
      const schema = this.schema.selectAt(columnIndices);
      const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);
      const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });
      return new RecordBatch(schema, subset);
    }
  };
  _a4 = Symbol.toStringTag;
  RecordBatch[_a4] = ((proto) => {
    proto._nullCount = -1;
    proto[Symbol.isConcatSpreadable] = true;
    return "RecordBatch";
  })(RecordBatch.prototype);
  function ensureSameLengthData(schema, chunks, maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)) {
    var _b2;
    const fields = [...schema.fields];
    const children = [...chunks];
    const nullBitmapSize = (maxLength + 63 & ~63) >> 3;
    for (const [idx, field] of schema.fields.entries()) {
      const chunk = chunks[idx];
      if (!chunk || chunk.length !== maxLength) {
        fields[idx] = field.clone({ nullable: true });
        children[idx] = (_b2 = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b2 !== void 0 ? _b2 : makeData({
          type: field.type,
          length: maxLength,
          nullCount: maxLength,
          nullBitmap: new Uint8Array(nullBitmapSize)
        });
      }
    }
    return [
      schema.assign(fields),
      makeData({ type: new Struct(fields), length: maxLength, children })
    ];
  }
  function collectDictionaries(fields, children, dictionaries = /* @__PURE__ */ new Map()) {
    for (let i = -1, n = fields.length; ++i < n; ) {
      const field = fields[i];
      const type = field.type;
      const data = children[i];
      if (DataType.isDictionary(type)) {
        if (!dictionaries.has(type.id)) {
          if (data.dictionary) {
            dictionaries.set(type.id, data.dictionary);
          }
        } else if (dictionaries.get(type.id) !== data.dictionary) {
          throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);
        }
      }
      if (type.children && type.children.length > 0) {
        collectDictionaries(type.children, data.children, dictionaries);
      }
    }
    return dictionaries;
  }
  var _InternalEmptyPlaceholderRecordBatch = class extends RecordBatch {
    constructor(schema) {
      const children = schema.fields.map((f) => makeData({ type: f.type }));
      const data = makeData({ type: new Struct(schema.fields), nullCount: 0, children });
      super(schema, data);
    }
  };

  // ../../node_modules/apache-arrow/fb/body-compression-method.mjs
  var BodyCompressionMethod;
  (function(BodyCompressionMethod2) {
    BodyCompressionMethod2[BodyCompressionMethod2["BUFFER"] = 0] = "BUFFER";
  })(BodyCompressionMethod || (BodyCompressionMethod = {}));

  // ../../node_modules/apache-arrow/fb/compression-type.mjs
  var CompressionType;
  (function(CompressionType2) {
    CompressionType2[CompressionType2["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType2[CompressionType2["ZSTD"] = 1] = "ZSTD";
  })(CompressionType || (CompressionType = {}));

  // ../../node_modules/apache-arrow/fb/body-compression.mjs
  var BodyCompression = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsBodyCompression(bb, obj) {
      return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsBodyCompression(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    codec() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : CompressionType.LZ4_FRAME;
    }
    method() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt8(this.bb_pos + offset) : BodyCompressionMethod.BUFFER;
    }
    static startBodyCompression(builder) {
      builder.startObject(2);
    }
    static addCodec(builder, codec) {
      builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
    }
    static addMethod(builder, method2) {
      builder.addFieldInt8(1, method2, BodyCompressionMethod.BUFFER);
    }
    static endBodyCompression(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static createBodyCompression(builder, codec, method2) {
      BodyCompression.startBodyCompression(builder);
      BodyCompression.addCodec(builder, codec);
      BodyCompression.addMethod(builder, method2);
      return BodyCompression.endBodyCompression(builder);
    }
  };

  // ../../node_modules/apache-arrow/fb/buffer.mjs
  var Buffer2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    offset() {
      return this.bb.readInt64(this.bb_pos);
    }
    length() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createBuffer(builder, offset, length) {
      builder.prep(8, 16);
      builder.writeInt64(length);
      builder.writeInt64(offset);
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/fb/field-node.mjs
  var FieldNode = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    length() {
      return this.bb.readInt64(this.bb_pos);
    }
    nullCount() {
      return this.bb.readInt64(this.bb_pos + 8);
    }
    static sizeOf() {
      return 16;
    }
    static createFieldNode(builder, length, null_count) {
      builder.prep(8, 16);
      builder.writeInt64(null_count);
      builder.writeInt64(length);
      return builder.offset();
    }
  };

  // ../../node_modules/apache-arrow/fb/record-batch.mjs
  var RecordBatch2 = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsRecordBatch(bb, obj) {
      return (obj || new RecordBatch2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsRecordBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new RecordBatch2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    length() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    nodes(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    nodesLength() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    buffers(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new Buffer2()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    }
    buffersLength() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    compression(obj) {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    static startRecordBatch(builder) {
      builder.startObject(4);
    }
    static addLength(builder, length) {
      builder.addFieldInt64(0, length, builder.createLong(0, 0));
    }
    static addNodes(builder, nodesOffset) {
      builder.addFieldOffset(1, nodesOffset, 0);
    }
    static startNodesVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addBuffers(builder, buffersOffset) {
      builder.addFieldOffset(2, buffersOffset, 0);
    }
    static startBuffersVector(builder, numElems) {
      builder.startVector(16, numElems, 8);
    }
    static addCompression(builder, compressionOffset) {
      builder.addFieldOffset(3, compressionOffset, 0);
    }
    static endRecordBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/dictionary-batch.mjs
  var DictionaryBatch = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsDictionaryBatch(bb, obj) {
      return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsDictionaryBatch(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    id() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    data(obj) {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? (obj || new RecordBatch2()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
    isDelta() {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
    static startDictionaryBatch(builder) {
      builder.startObject(3);
    }
    static addId(builder, id) {
      builder.addFieldInt64(0, id, builder.createLong(0, 0));
    }
    static addData(builder, dataOffset) {
      builder.addFieldOffset(1, dataOffset, 0);
    }
    static addIsDelta(builder, isDelta) {
      builder.addFieldInt8(2, +isDelta, 0);
    }
    static endDictionaryBatch(builder) {
      const offset = builder.endObject();
      return offset;
    }
  };

  // ../../node_modules/apache-arrow/fb/message-header.mjs
  var MessageHeader2;
  (function(MessageHeader3) {
    MessageHeader3[MessageHeader3["NONE"] = 0] = "NONE";
    MessageHeader3[MessageHeader3["Schema"] = 1] = "Schema";
    MessageHeader3[MessageHeader3["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader3[MessageHeader3["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader3[MessageHeader3["Tensor"] = 4] = "Tensor";
    MessageHeader3[MessageHeader3["SparseTensor"] = 5] = "SparseTensor";
  })(MessageHeader2 || (MessageHeader2 = {}));

  // ../../node_modules/apache-arrow/fb/message.mjs
  var Message = class {
    constructor() {
      this.bb = null;
      this.bb_pos = 0;
    }
    __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
    static getRootAsMessage(bb, obj) {
      return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    static getSizePrefixedRootAsMessage(bb, obj) {
      bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
      return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
    version() {
      const offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readInt16(this.bb_pos + offset) : MetadataVersion2.V1;
    }
    headerType() {
      const offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : MessageHeader2.NONE;
    }
    header(obj) {
      const offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    }
    bodyLength() {
      const offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    }
    customMetadata(index, obj) {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
    customMetadataLength() {
      const offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
    static startMessage(builder) {
      builder.startObject(5);
    }
    static addVersion(builder, version) {
      builder.addFieldInt16(0, version, MetadataVersion2.V1);
    }
    static addHeaderType(builder, headerType) {
      builder.addFieldInt8(1, headerType, MessageHeader2.NONE);
    }
    static addHeader(builder, headerOffset) {
      builder.addFieldOffset(2, headerOffset, 0);
    }
    static addBodyLength(builder, bodyLength) {
      builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));
    }
    static addCustomMetadata(builder, customMetadataOffset) {
      builder.addFieldOffset(4, customMetadataOffset, 0);
    }
    static createCustomMetadataVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (let i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
    static startCustomMetadataVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
    static endMessage(builder) {
      const offset = builder.endObject();
      return offset;
    }
    static finishMessageBuffer(builder, offset) {
      builder.finish(offset);
    }
    static finishSizePrefixedMessageBuffer(builder, offset) {
      builder.finish(offset, void 0, true);
    }
    static createMessage(builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
      Message.startMessage(builder);
      Message.addVersion(builder, version);
      Message.addHeaderType(builder, headerType);
      Message.addHeader(builder, headerOffset);
      Message.addBodyLength(builder, bodyLength);
      Message.addCustomMetadata(builder, customMetadataOffset);
      return Message.endMessage(builder);
    }
  };

  // ../../node_modules/apache-arrow/visitor/typeassembler.mjs
  var Long3 = Long;
  var TypeAssembler = class extends Visitor {
    visit(node, builder) {
      return node == null || builder == null ? void 0 : super.visit(node, builder);
    }
    visitNull(_node, b) {
      Null2.startNull(b);
      return Null2.endNull(b);
    }
    visitInt(node, b) {
      Int.startInt(b);
      Int.addBitWidth(b, node.bitWidth);
      Int.addIsSigned(b, node.isSigned);
      return Int.endInt(b);
    }
    visitFloat(node, b) {
      FloatingPoint.startFloatingPoint(b);
      FloatingPoint.addPrecision(b, node.precision);
      return FloatingPoint.endFloatingPoint(b);
    }
    visitBinary(_node, b) {
      Binary2.startBinary(b);
      return Binary2.endBinary(b);
    }
    visitBool(_node, b) {
      Bool2.startBool(b);
      return Bool2.endBool(b);
    }
    visitUtf8(_node, b) {
      Utf82.startUtf8(b);
      return Utf82.endUtf8(b);
    }
    visitDecimal(node, b) {
      Decimal2.startDecimal(b);
      Decimal2.addScale(b, node.scale);
      Decimal2.addPrecision(b, node.precision);
      Decimal2.addBitWidth(b, node.bitWidth);
      return Decimal2.endDecimal(b);
    }
    visitDate(node, b) {
      Date2.startDate(b);
      Date2.addUnit(b, node.unit);
      return Date2.endDate(b);
    }
    visitTime(node, b) {
      Time.startTime(b);
      Time.addUnit(b, node.unit);
      Time.addBitWidth(b, node.bitWidth);
      return Time.endTime(b);
    }
    visitTimestamp(node, b) {
      const timezone = node.timezone && b.createString(node.timezone) || void 0;
      Timestamp.startTimestamp(b);
      Timestamp.addUnit(b, node.unit);
      if (timezone !== void 0) {
        Timestamp.addTimezone(b, timezone);
      }
      return Timestamp.endTimestamp(b);
    }
    visitInterval(node, b) {
      Interval.startInterval(b);
      Interval.addUnit(b, node.unit);
      return Interval.endInterval(b);
    }
    visitList(_node, b) {
      List2.startList(b);
      return List2.endList(b);
    }
    visitStruct(_node, b) {
      Struct_.startStruct_(b);
      return Struct_.endStruct_(b);
    }
    visitUnion(node, b) {
      Union.startTypeIdsVector(b, node.typeIds.length);
      const typeIds = Union.createTypeIdsVector(b, node.typeIds);
      Union.startUnion(b);
      Union.addMode(b, node.mode);
      Union.addTypeIds(b, typeIds);
      return Union.endUnion(b);
    }
    visitDictionary(node, b) {
      const indexType = this.visit(node.indices, b);
      DictionaryEncoding.startDictionaryEncoding(b);
      DictionaryEncoding.addId(b, new Long3(node.id, 0));
      DictionaryEncoding.addIsOrdered(b, node.isOrdered);
      if (indexType !== void 0) {
        DictionaryEncoding.addIndexType(b, indexType);
      }
      return DictionaryEncoding.endDictionaryEncoding(b);
    }
    visitFixedSizeBinary(node, b) {
      FixedSizeBinary2.startFixedSizeBinary(b);
      FixedSizeBinary2.addByteWidth(b, node.byteWidth);
      return FixedSizeBinary2.endFixedSizeBinary(b);
    }
    visitFixedSizeList(node, b) {
      FixedSizeList2.startFixedSizeList(b);
      FixedSizeList2.addListSize(b, node.listSize);
      return FixedSizeList2.endFixedSizeList(b);
    }
    visitMap(node, b) {
      Map2.startMap(b);
      Map2.addKeysSorted(b, node.keysSorted);
      return Map2.endMap(b);
    }
  };
  var instance8 = new TypeAssembler();

  // ../../node_modules/apache-arrow/ipc/metadata/json.mjs
  function schemaFromJSON(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    return new Schema2(schemaFieldsFromJSON(_schema, dictionaries), customMetadataFromJSON(_schema["customMetadata"]), dictionaries);
  }
  function recordBatchFromJSON(b) {
    return new RecordBatch3(b["count"], fieldNodesFromJSON(b["columns"]), buffersFromJSON(b["columns"]));
  }
  function dictionaryBatchFromJSON(b) {
    return new DictionaryBatch2(recordBatchFromJSON(b["data"]), b["id"], b["isDelta"]);
  }
  function schemaFieldsFromJSON(_schema, dictionaries) {
    return (_schema["fields"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldChildrenFromJSON(_field, dictionaries) {
    return (_field["children"] || []).filter(Boolean).map((f) => Field2.fromJSON(f, dictionaries));
  }
  function fieldNodesFromJSON(xs) {
    return (xs || []).reduce((fieldNodes, column) => [
      ...fieldNodes,
      new FieldNode2(column["count"], nullCountFromJSON(column["VALIDITY"])),
      ...fieldNodesFromJSON(column["children"])
    ], []);
  }
  function buffersFromJSON(xs, buffers = []) {
    for (let i = -1, n = (xs || []).length; ++i < n; ) {
      const column = xs[i];
      column["VALIDITY"] && buffers.push(new BufferRegion(buffers.length, column["VALIDITY"].length));
      column["TYPE"] && buffers.push(new BufferRegion(buffers.length, column["TYPE"].length));
      column["OFFSET"] && buffers.push(new BufferRegion(buffers.length, column["OFFSET"].length));
      column["DATA"] && buffers.push(new BufferRegion(buffers.length, column["DATA"].length));
      buffers = buffersFromJSON(column["children"], buffers);
    }
    return buffers;
  }
  function nullCountFromJSON(validity) {
    return (validity || []).reduce((sum2, val) => sum2 + +(val === 0), 0);
  }
  function fieldFromJSON(_field, dictionaries) {
    let id;
    let keys;
    let field;
    let dictMeta;
    let type;
    let dictType;
    if (!dictionaries || !(dictMeta = _field["dictionary"])) {
      type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries));
      field = new Field2(_field["name"], type, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    } else if (!dictionaries.has(id = dictMeta["id"])) {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictionaries.set(id, type = typeFromJSON(_field, fieldChildrenFromJSON(_field, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    } else {
      keys = (keys = dictMeta["indexType"]) ? indexTypeFromJSON(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta["isOrdered"]);
      field = new Field2(_field["name"], dictType, _field["nullable"], customMetadataFromJSON(_field["customMetadata"]));
    }
    return field || null;
  }
  function customMetadataFromJSON(_metadata) {
    return new Map(Object.entries(_metadata || {}));
  }
  function indexTypeFromJSON(_type) {
    return new Int_(_type["isSigned"], _type["bitWidth"]);
  }
  function typeFromJSON(f, children) {
    const typeId = f["type"]["name"];
    switch (typeId) {
      case "NONE":
        return new Null();
      case "null":
        return new Null();
      case "binary":
        return new Binary();
      case "utf8":
        return new Utf8();
      case "bool":
        return new Bool();
      case "list":
        return new List((children || [])[0]);
      case "struct":
        return new Struct(children || []);
      case "struct_":
        return new Struct(children || []);
    }
    switch (typeId) {
      case "int": {
        const t = f["type"];
        return new Int_(t["isSigned"], t["bitWidth"]);
      }
      case "floatingpoint": {
        const t = f["type"];
        return new Float(Precision[t["precision"]]);
      }
      case "decimal": {
        const t = f["type"];
        return new Decimal(t["scale"], t["precision"], t["bitWidth"]);
      }
      case "date": {
        const t = f["type"];
        return new Date_(DateUnit[t["unit"]]);
      }
      case "time": {
        const t = f["type"];
        return new Time_(TimeUnit[t["unit"]], t["bitWidth"]);
      }
      case "timestamp": {
        const t = f["type"];
        return new Timestamp_(TimeUnit[t["unit"]], t["timezone"]);
      }
      case "interval": {
        const t = f["type"];
        return new Interval_(IntervalUnit[t["unit"]]);
      }
      case "union": {
        const t = f["type"];
        return new Union_(UnionMode[t["mode"]], t["typeIds"] || [], children || []);
      }
      case "fixedsizebinary": {
        const t = f["type"];
        return new FixedSizeBinary(t["byteWidth"]);
      }
      case "fixedsizelist": {
        const t = f["type"];
        return new FixedSizeList(t["listSize"], (children || [])[0]);
      }
      case "map": {
        const t = f["type"];
        return new Map_((children || [])[0], t["keysSorted"]);
      }
    }
    throw new Error(`Unrecognized type: "${typeId}"`);
  }

  // ../../node_modules/apache-arrow/ipc/metadata/message.mjs
  var Long4 = Long;
  var Builder4 = Builder2;
  var ByteBuffer3 = ByteBuffer;
  var Message2 = class {
    constructor(bodyLength, version, headerType, header) {
      this._version = version;
      this._headerType = headerType;
      this.body = new Uint8Array(0);
      header && (this._createHeader = () => header);
      this._bodyLength = typeof bodyLength === "number" ? bodyLength : bodyLength.low;
    }
    static fromJSON(msg, headerType) {
      const message = new Message2(0, MetadataVersion.V4, headerType);
      message._createHeader = messageHeaderFromJSON(msg, headerType);
      return message;
    }
    static decode(buf) {
      buf = new ByteBuffer3(toUint8Array(buf));
      const _message = Message.getRootAsMessage(buf);
      const bodyLength = _message.bodyLength();
      const version = _message.version();
      const headerType = _message.headerType();
      const message = new Message2(bodyLength, version, headerType);
      message._createHeader = decodeMessageHeader(_message, headerType);
      return message;
    }
    static encode(message) {
      const b = new Builder4();
      let headerOffset = -1;
      if (message.isSchema()) {
        headerOffset = Schema2.encode(b, message.header());
      } else if (message.isRecordBatch()) {
        headerOffset = RecordBatch3.encode(b, message.header());
      } else if (message.isDictionaryBatch()) {
        headerOffset = DictionaryBatch2.encode(b, message.header());
      }
      Message.startMessage(b);
      Message.addVersion(b, MetadataVersion.V4);
      Message.addHeader(b, headerOffset);
      Message.addHeaderType(b, message.headerType);
      Message.addBodyLength(b, new Long4(message.bodyLength, 0));
      Message.finishMessageBuffer(b, Message.endMessage(b));
      return b.asUint8Array();
    }
    static from(header, bodyLength = 0) {
      if (header instanceof Schema2) {
        return new Message2(0, MetadataVersion.V4, MessageHeader.Schema, header);
      }
      if (header instanceof RecordBatch3) {
        return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.RecordBatch, header);
      }
      if (header instanceof DictionaryBatch2) {
        return new Message2(bodyLength, MetadataVersion.V4, MessageHeader.DictionaryBatch, header);
      }
      throw new Error(`Unrecognized Message header: ${header}`);
    }
    get type() {
      return this.headerType;
    }
    get version() {
      return this._version;
    }
    get headerType() {
      return this._headerType;
    }
    get bodyLength() {
      return this._bodyLength;
    }
    header() {
      return this._createHeader();
    }
    isSchema() {
      return this.headerType === MessageHeader.Schema;
    }
    isRecordBatch() {
      return this.headerType === MessageHeader.RecordBatch;
    }
    isDictionaryBatch() {
      return this.headerType === MessageHeader.DictionaryBatch;
    }
  };
  var RecordBatch3 = class {
    constructor(length, nodes, buffers) {
      this._nodes = nodes;
      this._buffers = buffers;
      this._length = typeof length === "number" ? length : length.low;
    }
    get nodes() {
      return this._nodes;
    }
    get length() {
      return this._length;
    }
    get buffers() {
      return this._buffers;
    }
  };
  var DictionaryBatch2 = class {
    constructor(data, id, isDelta = false) {
      this._data = data;
      this._isDelta = isDelta;
      this._id = typeof id === "number" ? id : id.low;
    }
    get id() {
      return this._id;
    }
    get data() {
      return this._data;
    }
    get isDelta() {
      return this._isDelta;
    }
    get length() {
      return this.data.length;
    }
    get nodes() {
      return this.data.nodes;
    }
    get buffers() {
      return this.data.buffers;
    }
  };
  var BufferRegion = class {
    constructor(offset, length) {
      this.offset = typeof offset === "number" ? offset : offset.low;
      this.length = typeof length === "number" ? length : length.low;
    }
  };
  var FieldNode2 = class {
    constructor(length, nullCount) {
      this.length = typeof length === "number" ? length : length.low;
      this.nullCount = typeof nullCount === "number" ? nullCount : nullCount.low;
    }
  };
  function messageHeaderFromJSON(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.fromJSON(message);
        case MessageHeader.RecordBatch:
          return RecordBatch3.fromJSON(message);
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.fromJSON(message);
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  function decodeMessageHeader(message, type) {
    return () => {
      switch (type) {
        case MessageHeader.Schema:
          return Schema2.decode(message.header(new Schema()));
        case MessageHeader.RecordBatch:
          return RecordBatch3.decode(message.header(new RecordBatch2()), message.version());
        case MessageHeader.DictionaryBatch:
          return DictionaryBatch2.decode(message.header(new DictionaryBatch()), message.version());
      }
      throw new Error(`Unrecognized Message type: { name: ${MessageHeader[type]}, type: ${type} }`);
    };
  }
  Field2["encode"] = encodeField;
  Field2["decode"] = decodeField;
  Field2["fromJSON"] = fieldFromJSON;
  Schema2["encode"] = encodeSchema;
  Schema2["decode"] = decodeSchema;
  Schema2["fromJSON"] = schemaFromJSON;
  RecordBatch3["encode"] = encodeRecordBatch;
  RecordBatch3["decode"] = decodeRecordBatch;
  RecordBatch3["fromJSON"] = recordBatchFromJSON;
  DictionaryBatch2["encode"] = encodeDictionaryBatch;
  DictionaryBatch2["decode"] = decodeDictionaryBatch;
  DictionaryBatch2["fromJSON"] = dictionaryBatchFromJSON;
  FieldNode2["encode"] = encodeFieldNode;
  FieldNode2["decode"] = decodeFieldNode;
  BufferRegion["encode"] = encodeBufferRegion;
  BufferRegion["decode"] = decodeBufferRegion;
  function decodeSchema(_schema, dictionaries = /* @__PURE__ */ new Map()) {
    const fields = decodeSchemaFields(_schema, dictionaries);
    return new Schema2(fields, decodeCustomMetadata(_schema), dictionaries);
  }
  function decodeRecordBatch(batch, version = MetadataVersion.V4) {
    if (batch.compression() !== null) {
      throw new Error("Record batch compression not implemented");
    }
    return new RecordBatch3(batch.length(), decodeFieldNodes(batch), decodeBuffers(batch, version));
  }
  function decodeDictionaryBatch(batch, version = MetadataVersion.V4) {
    return new DictionaryBatch2(RecordBatch3.decode(batch.data(), version), batch.id(), batch.isDelta());
  }
  function decodeBufferRegion(b) {
    return new BufferRegion(b.offset(), b.length());
  }
  function decodeFieldNode(f) {
    return new FieldNode2(f.length(), f.nullCount());
  }
  function decodeFieldNodes(batch) {
    const nodes = [];
    for (let f, i = -1, j = -1, n = batch.nodesLength(); ++i < n; ) {
      if (f = batch.nodes(i)) {
        nodes[++j] = FieldNode2.decode(f);
      }
    }
    return nodes;
  }
  function decodeBuffers(batch, version) {
    const bufferRegions = [];
    for (let b, i = -1, j = -1, n = batch.buffersLength(); ++i < n; ) {
      if (b = batch.buffers(i)) {
        if (version < MetadataVersion.V4) {
          b.bb_pos += 8 * (i + 1);
        }
        bufferRegions[++j] = BufferRegion.decode(b);
      }
    }
    return bufferRegions;
  }
  function decodeSchemaFields(schema, dictionaries) {
    const fields = [];
    for (let f, i = -1, j = -1, n = schema.fieldsLength(); ++i < n; ) {
      if (f = schema.fields(i)) {
        fields[++j] = Field2.decode(f, dictionaries);
      }
    }
    return fields;
  }
  function decodeFieldChildren(field, dictionaries) {
    const children = [];
    for (let f, i = -1, j = -1, n = field.childrenLength(); ++i < n; ) {
      if (f = field.children(i)) {
        children[++j] = Field2.decode(f, dictionaries);
      }
    }
    return children;
  }
  function decodeField(f, dictionaries) {
    let id;
    let field;
    let type;
    let keys;
    let dictType;
    let dictMeta;
    if (!dictionaries || !(dictMeta = f.dictionary())) {
      type = decodeFieldType(f, decodeFieldChildren(f, dictionaries));
      field = new Field2(f.name(), type, f.nullable(), decodeCustomMetadata(f));
    } else if (!dictionaries.has(id = dictMeta.id().low)) {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictionaries.set(id, type = decodeFieldType(f, decodeFieldChildren(f, dictionaries)));
      dictType = new Dictionary(type, keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    } else {
      keys = (keys = dictMeta.indexType()) ? decodeIndexType(keys) : new Int32();
      dictType = new Dictionary(dictionaries.get(id), keys, id, dictMeta.isOrdered());
      field = new Field2(f.name(), dictType, f.nullable(), decodeCustomMetadata(f));
    }
    return field || null;
  }
  function decodeCustomMetadata(parent) {
    const data = /* @__PURE__ */ new Map();
    if (parent) {
      for (let entry, key, i = -1, n = Math.trunc(parent.customMetadataLength()); ++i < n; ) {
        if ((entry = parent.customMetadata(i)) && (key = entry.key()) != null) {
          data.set(key, entry.value());
        }
      }
    }
    return data;
  }
  function decodeIndexType(_type) {
    return new Int_(_type.isSigned(), _type.bitWidth());
  }
  function decodeFieldType(f, children) {
    const typeId = f.typeType();
    switch (typeId) {
      case Type2["NONE"]:
        return new Null();
      case Type2["Null"]:
        return new Null();
      case Type2["Binary"]:
        return new Binary();
      case Type2["Utf8"]:
        return new Utf8();
      case Type2["Bool"]:
        return new Bool();
      case Type2["List"]:
        return new List((children || [])[0]);
      case Type2["Struct_"]:
        return new Struct(children || []);
    }
    switch (typeId) {
      case Type2["Int"]: {
        const t = f.type(new Int());
        return new Int_(t.isSigned(), t.bitWidth());
      }
      case Type2["FloatingPoint"]: {
        const t = f.type(new FloatingPoint());
        return new Float(t.precision());
      }
      case Type2["Decimal"]: {
        const t = f.type(new Decimal2());
        return new Decimal(t.scale(), t.precision(), t.bitWidth());
      }
      case Type2["Date"]: {
        const t = f.type(new Date2());
        return new Date_(t.unit());
      }
      case Type2["Time"]: {
        const t = f.type(new Time());
        return new Time_(t.unit(), t.bitWidth());
      }
      case Type2["Timestamp"]: {
        const t = f.type(new Timestamp());
        return new Timestamp_(t.unit(), t.timezone());
      }
      case Type2["Interval"]: {
        const t = f.type(new Interval());
        return new Interval_(t.unit());
      }
      case Type2["Union"]: {
        const t = f.type(new Union());
        return new Union_(t.mode(), t.typeIdsArray() || [], children || []);
      }
      case Type2["FixedSizeBinary"]: {
        const t = f.type(new FixedSizeBinary2());
        return new FixedSizeBinary(t.byteWidth());
      }
      case Type2["FixedSizeList"]: {
        const t = f.type(new FixedSizeList2());
        return new FixedSizeList(t.listSize(), (children || [])[0]);
      }
      case Type2["Map"]: {
        const t = f.type(new Map2());
        return new Map_((children || [])[0], t.keysSorted());
      }
    }
    throw new Error(`Unrecognized type: "${Type2[typeId]}" (${typeId})`);
  }
  function encodeSchema(b, schema) {
    const fieldOffsets = schema.fields.map((f) => Field2.encode(b, f));
    Schema.startFieldsVector(b, fieldOffsets.length);
    const fieldsVectorOffset = Schema.createFieldsVector(b, fieldOffsets);
    const metadataOffset = !(schema.metadata && schema.metadata.size > 0) ? -1 : Schema.createCustomMetadataVector(b, [...schema.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    Schema.startSchema(b);
    Schema.addFields(b, fieldsVectorOffset);
    Schema.addEndianness(b, platformIsLittleEndian ? Endianness.Little : Endianness.Big);
    if (metadataOffset !== -1) {
      Schema.addCustomMetadata(b, metadataOffset);
    }
    return Schema.endSchema(b);
  }
  function encodeField(b, field) {
    let nameOffset = -1;
    let typeOffset = -1;
    let dictionaryOffset = -1;
    const type = field.type;
    let typeId = field.typeId;
    if (!DataType.isDictionary(type)) {
      typeOffset = instance8.visit(type, b);
    } else {
      typeId = type.dictionary.typeId;
      dictionaryOffset = instance8.visit(type, b);
      typeOffset = instance8.visit(type.dictionary, b);
    }
    const childOffsets = (type.children || []).map((f) => Field2.encode(b, f));
    const childrenVectorOffset = Field.createChildrenVector(b, childOffsets);
    const metadataOffset = !(field.metadata && field.metadata.size > 0) ? -1 : Field.createCustomMetadataVector(b, [...field.metadata].map(([k, v]) => {
      const key = b.createString(`${k}`);
      const val = b.createString(`${v}`);
      KeyValue.startKeyValue(b);
      KeyValue.addKey(b, key);
      KeyValue.addValue(b, val);
      return KeyValue.endKeyValue(b);
    }));
    if (field.name) {
      nameOffset = b.createString(field.name);
    }
    Field.startField(b);
    Field.addType(b, typeOffset);
    Field.addTypeType(b, typeId);
    Field.addChildren(b, childrenVectorOffset);
    Field.addNullable(b, !!field.nullable);
    if (nameOffset !== -1) {
      Field.addName(b, nameOffset);
    }
    if (dictionaryOffset !== -1) {
      Field.addDictionary(b, dictionaryOffset);
    }
    if (metadataOffset !== -1) {
      Field.addCustomMetadata(b, metadataOffset);
    }
    return Field.endField(b);
  }
  function encodeRecordBatch(b, recordBatch) {
    const nodes = recordBatch.nodes || [];
    const buffers = recordBatch.buffers || [];
    RecordBatch2.startNodesVector(b, nodes.length);
    for (const n of nodes.slice().reverse())
      FieldNode2.encode(b, n);
    const nodesVectorOffset = b.endVector();
    RecordBatch2.startBuffersVector(b, buffers.length);
    for (const b_ of buffers.slice().reverse())
      BufferRegion.encode(b, b_);
    const buffersVectorOffset = b.endVector();
    RecordBatch2.startRecordBatch(b);
    RecordBatch2.addLength(b, new Long4(recordBatch.length, 0));
    RecordBatch2.addNodes(b, nodesVectorOffset);
    RecordBatch2.addBuffers(b, buffersVectorOffset);
    return RecordBatch2.endRecordBatch(b);
  }
  function encodeDictionaryBatch(b, dictionaryBatch) {
    const dataOffset = RecordBatch3.encode(b, dictionaryBatch.data);
    DictionaryBatch.startDictionaryBatch(b);
    DictionaryBatch.addId(b, new Long4(dictionaryBatch.id, 0));
    DictionaryBatch.addIsDelta(b, dictionaryBatch.isDelta);
    DictionaryBatch.addData(b, dataOffset);
    return DictionaryBatch.endDictionaryBatch(b);
  }
  function encodeFieldNode(b, node) {
    return FieldNode.createFieldNode(b, new Long4(node.length, 0), new Long4(node.nullCount, 0));
  }
  function encodeBufferRegion(b, node) {
    return Buffer2.createBuffer(b, new Long4(node.offset, 0), new Long4(node.length, 0));
  }
  var platformIsLittleEndian = (() => {
    const buffer = new ArrayBuffer(2);
    new DataView(buffer).setInt16(0, 256, true);
    return new Int16Array(buffer)[0] === 256;
  })();

  // ../../node_modules/apache-arrow/ipc/message.mjs
  var invalidMessageType = (type) => `Expected ${MessageHeader[type]} Message in stream, but was null or length 0.`;
  var nullMessage = (type) => `Header pointer of flatbuffer-encoded ${MessageHeader[type]} Message is null or length 0.`;
  var invalidMessageMetadata = (expected, actual) => `Expected to read ${expected} metadata bytes, but only read ${actual}.`;
  var invalidMessageBodyLength = (expected, actual) => `Expected to read ${expected} bytes for message body, but only read ${actual}.`;
  var MessageReader = class {
    constructor(source) {
      this.source = source instanceof ByteStream ? source : new ByteStream(source);
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      let r;
      if ((r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if (r.value === -1 && (r = this.readMetadataLength()).done) {
        return ITERATOR_DONE;
      }
      if ((r = this.readMetadata(r.value)).done) {
        return ITERATOR_DONE;
      }
      return r;
    }
    throw(value) {
      return this.source.throw(value);
    }
    return(value) {
      return this.source.return(value);
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readMessageBody(bodyLength) {
      if (bodyLength <= 0) {
        return new Uint8Array(0);
      }
      const buf = toUint8Array(this.source.read(bodyLength));
      if (buf.byteLength < bodyLength) {
        throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
      }
      return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
    }
    readSchema(throwIfNull = false) {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (throwIfNull && !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
    readMetadataLength() {
      const buf = this.source.read(PADDING);
      const bb = buf && new ByteBuffer(buf);
      const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
      return { done: len === 0, value: len };
    }
    readMetadata(metadataLength) {
      const buf = this.source.read(metadataLength);
      if (!buf) {
        return ITERATOR_DONE;
      }
      if (buf.byteLength < metadataLength) {
        throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
      }
      return { done: false, value: Message2.decode(buf) };
    }
  };
  var AsyncMessageReader = class {
    constructor(source, byteLength) {
      this.source = source instanceof AsyncByteStream ? source : isFileHandle(source) ? new AsyncRandomAccessFile(source, byteLength) : new AsyncByteStream(source);
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if (r.value === -1 && (r = yield this.readMetadataLength()).done) {
          return ITERATOR_DONE;
        }
        if ((r = yield this.readMetadata(r.value)).done) {
          return ITERATOR_DONE;
        }
        return r;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.throw(value);
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this.source.return(value);
      });
    }
    readMessage(type) {
      return __awaiter(this, void 0, void 0, function* () {
        let r;
        if ((r = yield this.next()).done) {
          return null;
        }
        if (type != null && r.value.headerType !== type) {
          throw new Error(invalidMessageType(type));
        }
        return r.value;
      });
    }
    readMessageBody(bodyLength) {
      return __awaiter(this, void 0, void 0, function* () {
        if (bodyLength <= 0) {
          return new Uint8Array(0);
        }
        const buf = toUint8Array(yield this.source.read(bodyLength));
        if (buf.byteLength < bodyLength) {
          throw new Error(invalidMessageBodyLength(bodyLength, buf.byteLength));
        }
        return buf.byteOffset % 8 === 0 && buf.byteOffset + buf.byteLength <= buf.buffer.byteLength ? buf : buf.slice();
      });
    }
    readSchema(throwIfNull = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const type = MessageHeader.Schema;
        const message = yield this.readMessage(type);
        const schema = message === null || message === void 0 ? void 0 : message.header();
        if (throwIfNull && !schema) {
          throw new Error(nullMessage(type));
        }
        return schema;
      });
    }
    readMetadataLength() {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(PADDING);
        const bb = buf && new ByteBuffer(buf);
        const len = (bb === null || bb === void 0 ? void 0 : bb.readInt32(0)) || 0;
        return { done: len === 0, value: len };
      });
    }
    readMetadata(metadataLength) {
      return __awaiter(this, void 0, void 0, function* () {
        const buf = yield this.source.read(metadataLength);
        if (!buf) {
          return ITERATOR_DONE;
        }
        if (buf.byteLength < metadataLength) {
          throw new Error(invalidMessageMetadata(metadataLength, buf.byteLength));
        }
        return { done: false, value: Message2.decode(buf) };
      });
    }
  };
  var JSONMessageReader = class extends MessageReader {
    constructor(source) {
      super(new Uint8Array(0));
      this._schema = false;
      this._body = [];
      this._batchIndex = 0;
      this._dictionaryIndex = 0;
      this._json = source instanceof ArrowJSON ? source : new ArrowJSON(source);
    }
    next() {
      const { _json } = this;
      if (!this._schema) {
        this._schema = true;
        const message = Message2.fromJSON(_json.schema, MessageHeader.Schema);
        return { done: false, value: message };
      }
      if (this._dictionaryIndex < _json.dictionaries.length) {
        const batch = _json.dictionaries[this._dictionaryIndex++];
        this._body = batch["data"]["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.DictionaryBatch);
        return { done: false, value: message };
      }
      if (this._batchIndex < _json.batches.length) {
        const batch = _json.batches[this._batchIndex++];
        this._body = batch["columns"];
        const message = Message2.fromJSON(batch, MessageHeader.RecordBatch);
        return { done: false, value: message };
      }
      this._body = [];
      return ITERATOR_DONE;
    }
    readMessageBody(_bodyLength) {
      return flattenDataSources(this._body);
      function flattenDataSources(xs) {
        return (xs || []).reduce((buffers, column) => [
          ...buffers,
          ...column["VALIDITY"] && [column["VALIDITY"]] || [],
          ...column["TYPE"] && [column["TYPE"]] || [],
          ...column["OFFSET"] && [column["OFFSET"]] || [],
          ...column["DATA"] && [column["DATA"]] || [],
          ...flattenDataSources(column["children"])
        ], []);
      }
    }
    readMessage(type) {
      let r;
      if ((r = this.next()).done) {
        return null;
      }
      if (type != null && r.value.headerType !== type) {
        throw new Error(invalidMessageType(type));
      }
      return r.value;
    }
    readSchema() {
      const type = MessageHeader.Schema;
      const message = this.readMessage(type);
      const schema = message === null || message === void 0 ? void 0 : message.header();
      if (!message || !schema) {
        throw new Error(nullMessage(type));
      }
      return schema;
    }
  };
  var PADDING = 4;
  var MAGIC_STR = "ARROW1";
  var MAGIC = new Uint8Array(MAGIC_STR.length);
  for (let i = 0; i < MAGIC_STR.length; i += 1) {
    MAGIC[i] = MAGIC_STR.codePointAt(i);
  }
  function checkForMagicArrowString(buffer, index = 0) {
    for (let i = -1, n = MAGIC.length; ++i < n; ) {
      if (MAGIC[i] !== buffer[index + i]) {
        return false;
      }
    }
    return true;
  }
  var magicLength = MAGIC.length;
  var magicAndPadding = magicLength + PADDING;
  var magicX2AndPadding = magicLength * 2 + PADDING;

  // ../../node_modules/apache-arrow/ipc/reader.mjs
  var RecordBatchReader = class extends ReadableInterop {
    constructor(impl) {
      super();
      this._impl = impl;
    }
    get closed() {
      return this._impl.closed;
    }
    get schema() {
      return this._impl.schema;
    }
    get autoDestroy() {
      return this._impl.autoDestroy;
    }
    get dictionaries() {
      return this._impl.dictionaries;
    }
    get numDictionaries() {
      return this._impl.numDictionaries;
    }
    get numRecordBatches() {
      return this._impl.numRecordBatches;
    }
    get footer() {
      return this._impl.isFile() ? this._impl.footer : null;
    }
    isSync() {
      return this._impl.isSync();
    }
    isAsync() {
      return this._impl.isAsync();
    }
    isFile() {
      return this._impl.isFile();
    }
    isStream() {
      return this._impl.isStream();
    }
    next() {
      return this._impl.next();
    }
    throw(value) {
      return this._impl.throw(value);
    }
    return(value) {
      return this._impl.return(value);
    }
    cancel() {
      return this._impl.cancel();
    }
    reset(schema) {
      this._impl.reset(schema);
      this._DOMStream = void 0;
      this._nodeStream = void 0;
      return this;
    }
    open(options) {
      const opening = this._impl.open(options);
      return isPromise(opening) ? opening.then(() => this) : this;
    }
    readRecordBatch(index) {
      return this._impl.isFile() ? this._impl.readRecordBatch(index) : null;
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
    toDOMStream() {
      return adapters_default.toDOMStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this });
    }
    toNodeStream() {
      return adapters_default.toNodeStream(this.isSync() ? { [Symbol.iterator]: () => this } : { [Symbol.asyncIterator]: () => this }, { objectMode: true });
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    static from(source) {
      if (source instanceof RecordBatchReader) {
        return source;
      } else if (isArrowJSON(source)) {
        return fromArrowJSON(source);
      } else if (isFileHandle(source)) {
        return fromFileHandle(source);
      } else if (isPromise(source)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
          return yield RecordBatchReader.from(yield source);
        }))();
      } else if (isFetchResponse(source) || isReadableDOMStream(source) || isReadableNodeStream(source) || isAsyncIterable(source)) {
        return fromAsyncByteStream(new AsyncByteStream(source));
      }
      return fromByteStream(new ByteStream(source));
    }
    static readAll(source) {
      if (source instanceof RecordBatchReader) {
        return source.isSync() ? readAllSync(source) : readAllAsync(source);
      } else if (isArrowJSON(source) || ArrayBuffer.isView(source) || isIterable(source) || isIteratorResult(source)) {
        return readAllSync(source);
      }
      return readAllAsync(source);
    }
  };
  var RecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      return [...this];
    }
    [Symbol.iterator]() {
      return this._impl[Symbol.iterator]();
    }
    [Symbol.asyncIterator]() {
      return __asyncGenerator(this, arguments, function* _a5() {
        yield __await(yield* __asyncDelegator(__asyncValues(this[Symbol.iterator]())));
      });
    }
  };
  var AsyncRecordBatchStreamReader = class extends RecordBatchReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
    readAll() {
      var e_1, _a5;
      return __awaiter(this, void 0, void 0, function* () {
        const batches = new Array();
        try {
          for (var _b2 = __asyncValues(this), _c2; _c2 = yield _b2.next(), !_c2.done; ) {
            const batch = _c2.value;
            batches.push(batch);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c2 && !_c2.done && (_a5 = _b2.return))
              yield _a5.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return batches;
      });
    }
    [Symbol.iterator]() {
      throw new Error(`AsyncRecordBatchStreamReader is not Iterable`);
    }
    [Symbol.asyncIterator]() {
      return this._impl[Symbol.asyncIterator]();
    }
  };
  var RecordBatchFileReader = class extends RecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var AsyncRecordBatchFileReader = class extends AsyncRecordBatchStreamReader {
    constructor(_impl) {
      super(_impl);
      this._impl = _impl;
    }
  };
  var RecordBatchReaderImpl = class {
    constructor(dictionaries = /* @__PURE__ */ new Map()) {
      this.closed = false;
      this.autoDestroy = true;
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.dictionaries = dictionaries;
    }
    get numDictionaries() {
      return this._dictionaryIndex;
    }
    get numRecordBatches() {
      return this._recordBatchIndex;
    }
    isSync() {
      return false;
    }
    isAsync() {
      return false;
    }
    isFile() {
      return false;
    }
    isStream() {
      return false;
    }
    reset(schema) {
      this._dictionaryIndex = 0;
      this._recordBatchIndex = 0;
      this.schema = schema;
      this.dictionaries = /* @__PURE__ */ new Map();
      return this;
    }
    _loadRecordBatch(header, body) {
      const children = this._loadVectors(header, body, this.schema.fields);
      const data = makeData({ type: new Struct(this.schema.fields), length: header.length, children });
      return new RecordBatch(this.schema, data);
    }
    _loadDictionaryBatch(header, body) {
      const { id, isDelta } = header;
      const { dictionaries, schema } = this;
      const dictionary = dictionaries.get(id);
      if (isDelta || !dictionary) {
        const type = schema.dictionaries.get(id);
        const data = this._loadVectors(header.data, body, [type]);
        return (dictionary && isDelta ? dictionary.concat(new Vector(data)) : new Vector(data)).memoize();
      }
      return dictionary.memoize();
    }
    _loadVectors(header, body, types) {
      return new VectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
    }
  };
  var RecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = !isArrowJSON(source) ? new MessageReader(this._handle = source) : new JSONMessageReader(this._handle = source);
    }
    isSync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.iterator]() {
      return this;
    }
    cancel() {
      if (!this.closed && (this.closed = true)) {
        this.reset()._reader.return();
        this._reader = null;
        this.dictionaries = null;
      }
    }
    open(options) {
      if (!this.closed) {
        this.autoDestroy = shouldAutoDestroy(this, options);
        if (!(this.schema || (this.schema = this._reader.readSchema()))) {
          this.cancel();
        }
      }
      return this;
    }
    throw(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.throw(value);
      }
      return ITERATOR_DONE;
    }
    return(value) {
      if (!this.closed && this.autoDestroy && (this.closed = true)) {
        return this.reset()._reader.return(value);
      }
      return ITERATOR_DONE;
    }
    next() {
      if (this.closed) {
        return ITERATOR_DONE;
      }
      let message;
      const { _reader: reader } = this;
      while (message = this._readNextMessageAndValidate()) {
        if (message.isSchema()) {
          this.reset(message.header());
        } else if (message.isRecordBatch()) {
          this._recordBatchIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return { done: false, value: recordBatch };
        } else if (message.isDictionaryBatch()) {
          this._dictionaryIndex++;
          const header = message.header();
          const buffer = reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
      if (this.schema && this._recordBatchIndex === 0) {
        this._recordBatchIndex++;
        return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
      }
      return this.return();
    }
    _readNextMessageAndValidate(type) {
      return this._reader.readMessage(type);
    }
  };
  var AsyncRecordBatchStreamReaderImpl = class extends RecordBatchReaderImpl {
    constructor(source, dictionaries) {
      super(dictionaries);
      this._reader = new AsyncMessageReader(this._handle = source);
    }
    isAsync() {
      return true;
    }
    isStream() {
      return true;
    }
    [Symbol.asyncIterator]() {
      return this;
    }
    cancel() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && (this.closed = true)) {
          yield this.reset()._reader.return();
          this._reader = null;
          this.dictionaries = null;
        }
      });
    }
    open(options) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed) {
          this.autoDestroy = shouldAutoDestroy(this, options);
          if (!(this.schema || (this.schema = yield this._reader.readSchema()))) {
            yield this.cancel();
          }
        }
        return this;
      });
    }
    throw(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.throw(value);
        }
        return ITERATOR_DONE;
      });
    }
    return(value) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && this.autoDestroy && (this.closed = true)) {
          return yield this.reset()._reader.return(value);
        }
        return ITERATOR_DONE;
      });
    }
    next() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return ITERATOR_DONE;
        }
        let message;
        const { _reader: reader } = this;
        while (message = yield this._readNextMessageAndValidate()) {
          if (message.isSchema()) {
            yield this.reset(message.header());
          } else if (message.isRecordBatch()) {
            this._recordBatchIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return { done: false, value: recordBatch };
          } else if (message.isDictionaryBatch()) {
            this._dictionaryIndex++;
            const header = message.header();
            const buffer = yield reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
        if (this.schema && this._recordBatchIndex === 0) {
          this._recordBatchIndex++;
          return { done: false, value: new _InternalEmptyPlaceholderRecordBatch(this.schema) };
        }
        return yield this.return();
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield this._reader.readMessage(type);
      });
    }
  };
  var RecordBatchFileReaderImpl = class extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source instanceof RandomAccessFile ? source : new RandomAccessFile(source), dictionaries);
    }
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    isSync() {
      return true;
    }
    isFile() {
      return true;
    }
    open(options) {
      if (!this.closed && !this._footer) {
        this.schema = (this._footer = this._readFooter()).schema;
        for (const block of this._footer.dictionaryBatches()) {
          block && this._readDictionaryBatch(this._dictionaryIndex++);
        }
      }
      return super.open(options);
    }
    readRecordBatch(index) {
      var _a5;
      if (this.closed) {
        return null;
      }
      if (!this._footer) {
        this.open();
      }
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.RecordBatch);
        if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const recordBatch = this._loadRecordBatch(header, buffer);
          return recordBatch;
        }
      }
      return null;
    }
    _readDictionaryBatch(index) {
      var _a5;
      const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
      if (block && this._handle.seek(block.offset)) {
        const message = this._reader.readMessage(MessageHeader.DictionaryBatch);
        if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
          const header = message.header();
          const buffer = this._reader.readMessageBody(message.bodyLength);
          const vector = this._loadDictionaryBatch(header, buffer);
          this.dictionaries.set(header.id, vector);
        }
      }
    }
    _readFooter() {
      const { _handle } = this;
      const offset = _handle.size - magicAndPadding;
      const length = _handle.readInt32(offset);
      const buffer = _handle.readAt(offset - length, length);
      return Footer_.decode(buffer);
    }
    _readNextMessageAndValidate(type) {
      var _a5;
      if (!this._footer) {
        this.open();
      }
      if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(this._recordBatchIndex);
        if (block && this._handle.seek(block.offset)) {
          return this._reader.readMessage(type);
        }
      }
      return null;
    }
  };
  var AsyncRecordBatchFileReaderImpl = class extends AsyncRecordBatchStreamReaderImpl {
    constructor(source, ...rest) {
      const byteLength = typeof rest[0] !== "number" ? rest.shift() : void 0;
      const dictionaries = rest[0] instanceof Map ? rest.shift() : void 0;
      super(source instanceof AsyncRandomAccessFile ? source : new AsyncRandomAccessFile(source, byteLength), dictionaries);
    }
    get footer() {
      return this._footer;
    }
    get numDictionaries() {
      return this._footer ? this._footer.numDictionaries : 0;
    }
    get numRecordBatches() {
      return this._footer ? this._footer.numRecordBatches : 0;
    }
    isFile() {
      return true;
    }
    isAsync() {
      return true;
    }
    open(options) {
      const _super = Object.create(null, {
        open: { get: () => super.open }
      });
      return __awaiter(this, void 0, void 0, function* () {
        if (!this.closed && !this._footer) {
          this.schema = (this._footer = yield this._readFooter()).schema;
          for (const block of this._footer.dictionaryBatches()) {
            block && (yield this._readDictionaryBatch(this._dictionaryIndex++));
          }
        }
        return yield _super.open.call(this, options);
      });
    }
    readRecordBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        if (this.closed) {
          return null;
        }
        if (!this._footer) {
          yield this.open();
        }
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getRecordBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.RecordBatch);
          if (message === null || message === void 0 ? void 0 : message.isRecordBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const recordBatch = this._loadRecordBatch(header, buffer);
            return recordBatch;
          }
        }
        return null;
      });
    }
    _readDictionaryBatch(index) {
      var _a5;
      return __awaiter(this, void 0, void 0, function* () {
        const block = (_a5 = this._footer) === null || _a5 === void 0 ? void 0 : _a5.getDictionaryBatch(index);
        if (block && (yield this._handle.seek(block.offset))) {
          const message = yield this._reader.readMessage(MessageHeader.DictionaryBatch);
          if (message === null || message === void 0 ? void 0 : message.isDictionaryBatch()) {
            const header = message.header();
            const buffer = yield this._reader.readMessageBody(message.bodyLength);
            const vector = this._loadDictionaryBatch(header, buffer);
            this.dictionaries.set(header.id, vector);
          }
        }
      });
    }
    _readFooter() {
      return __awaiter(this, void 0, void 0, function* () {
        const { _handle } = this;
        _handle._pending && (yield _handle._pending);
        const offset = _handle.size - magicAndPadding;
        const length = yield _handle.readInt32(offset);
        const buffer = yield _handle.readAt(offset - length, length);
        return Footer_.decode(buffer);
      });
    }
    _readNextMessageAndValidate(type) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!this._footer) {
          yield this.open();
        }
        if (this._footer && this._recordBatchIndex < this.numRecordBatches) {
          const block = this._footer.getRecordBatch(this._recordBatchIndex);
          if (block && (yield this._handle.seek(block.offset))) {
            return yield this._reader.readMessage(type);
          }
        }
        return null;
      });
    }
  };
  var RecordBatchJSONReaderImpl = class extends RecordBatchStreamReaderImpl {
    constructor(source, dictionaries) {
      super(source, dictionaries);
    }
    _loadVectors(header, body, types) {
      return new JSONVectorLoader(body, header.nodes, header.buffers, this.dictionaries).visitMany(types);
    }
  };
  function shouldAutoDestroy(self2, options) {
    return options && typeof options["autoDestroy"] === "boolean" ? options["autoDestroy"] : self2["autoDestroy"];
  }
  function* readAllSync(source) {
    const reader = RecordBatchReader.from(source);
    try {
      if (!reader.open({ autoDestroy: false }).closed) {
        do {
          yield reader;
        } while (!reader.reset().open().closed);
      }
    } finally {
      reader.cancel();
    }
  }
  function readAllAsync(source) {
    return __asyncGenerator(this, arguments, function* readAllAsync_1() {
      const reader = yield __await(RecordBatchReader.from(source));
      try {
        if (!(yield __await(reader.open({ autoDestroy: false }))).closed) {
          do {
            yield yield __await(reader);
          } while (!(yield __await(reader.reset().open())).closed);
        }
      } finally {
        yield __await(reader.cancel());
      }
    });
  }
  function fromArrowJSON(source) {
    return new RecordBatchStreamReader(new RecordBatchJSONReaderImpl(source));
  }
  function fromByteStream(source) {
    const bytes = source.peek(magicLength + 7 & ~7);
    return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(source.read())) : new RecordBatchStreamReader(new RecordBatchStreamReaderImpl(function* () {
    }()));
  }
  function fromAsyncByteStream(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const bytes = yield source.peek(magicLength + 7 & ~7);
      return bytes && bytes.byteLength >= 4 ? !checkForMagicArrowString(bytes) ? new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(source)) : new RecordBatchFileReader(new RecordBatchFileReaderImpl(yield source.read())) : new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(function() {
        return __asyncGenerator(this, arguments, function* () {
        });
      }()));
    });
  }
  function fromFileHandle(source) {
    return __awaiter(this, void 0, void 0, function* () {
      const { size } = yield source.stat();
      const file = new AsyncRandomAccessFile(source, size);
      if (size >= magicX2AndPadding && checkForMagicArrowString(yield file.readAt(0, magicLength + 7 & ~7))) {
        return new AsyncRecordBatchFileReader(new AsyncRecordBatchFileReaderImpl(file));
      }
      return new AsyncRecordBatchStreamReader(new AsyncRecordBatchStreamReaderImpl(file));
    });
  }

  // ../../node_modules/apache-arrow/visitor/vectorassembler.mjs
  var VectorAssembler = class extends Visitor {
    constructor() {
      super();
      this._byteLength = 0;
      this._nodes = [];
      this._buffers = [];
      this._bufferRegions = [];
    }
    static assemble(...args) {
      const unwrap = (nodes) => nodes.flatMap((node) => Array.isArray(node) ? unwrap(node) : node instanceof RecordBatch ? node.data.children : node.data);
      const assembler = new VectorAssembler();
      assembler.visitMany(unwrap(args));
      return assembler;
    }
    visit(data) {
      if (data instanceof Vector) {
        this.visitMany(data.data);
        return this;
      }
      const { type } = data;
      if (!DataType.isDictionary(type)) {
        const { length, nullCount } = data;
        if (length > 2147483647) {
          throw new RangeError("Cannot write arrays larger than 2^31 - 1 in length");
        }
        if (!DataType.isNull(type)) {
          addBuffer.call(this, nullCount <= 0 ? new Uint8Array(0) : truncateBitmap(data.offset, length, data.nullBitmap));
        }
        this.nodes.push(new FieldNode2(length, nullCount));
      }
      return super.visit(data);
    }
    visitNull(_null) {
      return this;
    }
    visitDictionary(data) {
      return this.visit(data.clone(data.type.indices));
    }
    get nodes() {
      return this._nodes;
    }
    get buffers() {
      return this._buffers;
    }
    get byteLength() {
      return this._byteLength;
    }
    get bufferRegions() {
      return this._bufferRegions;
    }
  };
  function addBuffer(values) {
    const byteLength = values.byteLength + 7 & ~7;
    this.buffers.push(values);
    this.bufferRegions.push(new BufferRegion(this._byteLength, byteLength));
    this._byteLength += byteLength;
    return this;
  }
  function assembleUnion(data) {
    const { type, length, typeIds, valueOffsets } = data;
    addBuffer.call(this, typeIds);
    if (type.mode === UnionMode.Sparse) {
      return assembleNestedVector.call(this, data);
    } else if (type.mode === UnionMode.Dense) {
      if (data.offset <= 0) {
        addBuffer.call(this, valueOffsets);
        return assembleNestedVector.call(this, data);
      } else {
        const maxChildTypeId = typeIds.reduce((x, y) => Math.max(x, y), typeIds[0]);
        const childLengths = new Int32Array(maxChildTypeId + 1);
        const childOffsets = new Int32Array(maxChildTypeId + 1).fill(-1);
        const shiftedOffsets = new Int32Array(length);
        const unshiftedOffsets = rebaseValueOffsets(-valueOffsets[0], length, valueOffsets);
        for (let typeId, shift, index = -1; ++index < length; ) {
          if ((shift = childOffsets[typeId = typeIds[index]]) === -1) {
            shift = childOffsets[typeId] = unshiftedOffsets[typeId];
          }
          shiftedOffsets[index] = unshiftedOffsets[index] - shift;
          ++childLengths[typeId];
        }
        addBuffer.call(this, shiftedOffsets);
        for (let child, childIndex = -1, numChildren = type.children.length; ++childIndex < numChildren; ) {
          if (child = data.children[childIndex]) {
            const typeId = type.typeIds[childIndex];
            const childLength = Math.min(length, childLengths[typeId]);
            this.visit(child.slice(childOffsets[typeId], childLength));
          }
        }
      }
    }
    return this;
  }
  function assembleBoolVector(data) {
    let values;
    if (data.nullCount >= data.length) {
      return addBuffer.call(this, new Uint8Array(0));
    } else if ((values = data.values) instanceof Uint8Array) {
      return addBuffer.call(this, truncateBitmap(data.offset, data.length, values));
    }
    return addBuffer.call(this, packBools(data.values));
  }
  function assembleFlatVector(data) {
    return addBuffer.call(this, data.values.subarray(0, data.length * data.stride));
  }
  function assembleFlatListVector(data) {
    const { length, values, valueOffsets } = data;
    const firstOffset = valueOffsets[0];
    const lastOffset = valueOffsets[length];
    const byteLength = Math.min(lastOffset - firstOffset, values.byteLength - firstOffset);
    addBuffer.call(this, rebaseValueOffsets(-valueOffsets[0], length, valueOffsets));
    addBuffer.call(this, values.subarray(firstOffset, firstOffset + byteLength));
    return this;
  }
  function assembleListVector(data) {
    const { length, valueOffsets } = data;
    if (valueOffsets) {
      addBuffer.call(this, rebaseValueOffsets(valueOffsets[0], length, valueOffsets));
    }
    return this.visit(data.children[0]);
  }
  function assembleNestedVector(data) {
    return this.visitMany(data.type.children.map((_, i) => data.children[i]).filter(Boolean))[0];
  }
  VectorAssembler.prototype.visitBool = assembleBoolVector;
  VectorAssembler.prototype.visitInt = assembleFlatVector;
  VectorAssembler.prototype.visitFloat = assembleFlatVector;
  VectorAssembler.prototype.visitUtf8 = assembleFlatListVector;
  VectorAssembler.prototype.visitBinary = assembleFlatListVector;
  VectorAssembler.prototype.visitFixedSizeBinary = assembleFlatVector;
  VectorAssembler.prototype.visitDate = assembleFlatVector;
  VectorAssembler.prototype.visitTimestamp = assembleFlatVector;
  VectorAssembler.prototype.visitTime = assembleFlatVector;
  VectorAssembler.prototype.visitDecimal = assembleFlatVector;
  VectorAssembler.prototype.visitList = assembleListVector;
  VectorAssembler.prototype.visitStruct = assembleNestedVector;
  VectorAssembler.prototype.visitUnion = assembleUnion;
  VectorAssembler.prototype.visitInterval = assembleFlatVector;
  VectorAssembler.prototype.visitFixedSizeList = assembleListVector;
  VectorAssembler.prototype.visitMap = assembleListVector;

  // ../../node_modules/apache-arrow/ipc/writer.mjs
  var RecordBatchWriter = class extends ReadableInterop {
    constructor(options) {
      super();
      this._position = 0;
      this._started = false;
      this._sink = new AsyncByteQueue();
      this._schema = null;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      isObject(options) || (options = { autoDestroy: true, writeLegacyIpcFormat: false });
      this._autoDestroy = typeof options.autoDestroy === "boolean" ? options.autoDestroy : true;
      this._writeLegacyIpcFormat = typeof options.writeLegacyIpcFormat === "boolean" ? options.writeLegacyIpcFormat : false;
    }
    static throughNode(options) {
      throw new Error(`"throughNode" not available in this environment`);
    }
    static throughDOM(writableStrategy, readableStrategy) {
      throw new Error(`"throughDOM" not available in this environment`);
    }
    toString(sync = false) {
      return this._sink.toString(sync);
    }
    toUint8Array(sync = false) {
      return this._sink.toUint8Array(sync);
    }
    writeAll(input) {
      if (isPromise(input)) {
        return input.then((x) => this.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(this, input);
      }
      return writeAll(this, input);
    }
    get closed() {
      return this._sink.closed;
    }
    [Symbol.asyncIterator]() {
      return this._sink[Symbol.asyncIterator]();
    }
    toDOMStream(options) {
      return this._sink.toDOMStream(options);
    }
    toNodeStream(options) {
      return this._sink.toNodeStream(options);
    }
    close() {
      return this.reset()._sink.close();
    }
    abort(reason) {
      return this.reset()._sink.abort(reason);
    }
    finish() {
      this._autoDestroy ? this.close() : this.reset(this._sink, this._schema);
      return this;
    }
    reset(sink = this._sink, schema = null) {
      if (sink === this._sink || sink instanceof AsyncByteQueue) {
        this._sink = sink;
      } else {
        this._sink = new AsyncByteQueue();
        if (sink && isWritableDOMStream(sink)) {
          this.toDOMStream({ type: "bytes" }).pipeTo(sink);
        } else if (sink && isWritableNodeStream(sink)) {
          this.toNodeStream({ objectMode: false }).pipe(sink);
        }
      }
      if (this._started && this._schema) {
        this._writeFooter(this._schema);
      }
      this._started = false;
      this._dictionaryBlocks = [];
      this._recordBatchBlocks = [];
      this._dictionaryDeltaOffsets = /* @__PURE__ */ new Map();
      if (!schema || !compareSchemas(schema, this._schema)) {
        if (schema == null) {
          this._position = 0;
          this._schema = null;
        } else {
          this._started = true;
          this._schema = schema;
          this._writeSchema(schema);
        }
      }
      return this;
    }
    write(payload) {
      let schema = null;
      if (!this._sink) {
        throw new Error(`RecordBatchWriter is closed`);
      } else if (payload == null) {
        return this.finish() && void 0;
      } else if (payload instanceof Table && !(schema = payload.schema)) {
        return this.finish() && void 0;
      } else if (payload instanceof RecordBatch && !(schema = payload.schema)) {
        return this.finish() && void 0;
      }
      if (schema && !compareSchemas(schema, this._schema)) {
        if (this._started && this._autoDestroy) {
          return this.close();
        }
        this.reset(this._sink, schema);
      }
      if (payload instanceof RecordBatch) {
        if (!(payload instanceof _InternalEmptyPlaceholderRecordBatch)) {
          this._writeRecordBatch(payload);
        }
      } else if (payload instanceof Table) {
        this.writeAll(payload.batches);
      } else if (isIterable(payload)) {
        this.writeAll(payload);
      }
    }
    _writeMessage(message, alignment = 8) {
      const a = alignment - 1;
      const buffer = Message2.encode(message);
      const flatbufferSize = buffer.byteLength;
      const prefixSize = !this._writeLegacyIpcFormat ? 8 : 4;
      const alignedSize = flatbufferSize + prefixSize + a & ~a;
      const nPaddingBytes = alignedSize - flatbufferSize - prefixSize;
      if (message.headerType === MessageHeader.RecordBatch) {
        this._recordBatchBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      } else if (message.headerType === MessageHeader.DictionaryBatch) {
        this._dictionaryBlocks.push(new FileBlock(alignedSize, message.bodyLength, this._position));
      }
      if (!this._writeLegacyIpcFormat) {
        this._write(Int32Array.of(-1));
      }
      this._write(Int32Array.of(alignedSize - prefixSize));
      if (flatbufferSize > 0) {
        this._write(buffer);
      }
      return this._writePadding(nPaddingBytes);
    }
    _write(chunk) {
      if (this._started) {
        const buffer = toUint8Array(chunk);
        if (buffer && buffer.byteLength > 0) {
          this._sink.write(buffer);
          this._position += buffer.byteLength;
        }
      }
      return this;
    }
    _writeSchema(schema) {
      return this._writeMessage(Message2.from(schema));
    }
    _writeFooter(schema) {
      return this._writeLegacyIpcFormat ? this._write(Int32Array.of(0)) : this._write(Int32Array.of(-1, 0));
    }
    _writeMagic() {
      return this._write(MAGIC);
    }
    _writePadding(nBytes) {
      return nBytes > 0 ? this._write(new Uint8Array(nBytes)) : this;
    }
    _writeRecordBatch(batch) {
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(batch);
      const recordBatch = new RecordBatch3(batch.numRows, nodes, bufferRegions);
      const message = Message2.from(recordBatch, byteLength);
      return this._writeDictionaries(batch)._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeDictionaryBatch(dictionary, id, isDelta = false) {
      this._dictionaryDeltaOffsets.set(id, dictionary.length + (this._dictionaryDeltaOffsets.get(id) || 0));
      const { byteLength, nodes, bufferRegions, buffers } = VectorAssembler.assemble(new Vector([dictionary]));
      const recordBatch = new RecordBatch3(dictionary.length, nodes, bufferRegions);
      const dictionaryBatch = new DictionaryBatch2(recordBatch, id, isDelta);
      const message = Message2.from(dictionaryBatch, byteLength);
      return this._writeMessage(message)._writeBodyBuffers(buffers);
    }
    _writeBodyBuffers(buffers) {
      let buffer;
      let size, padding;
      for (let i = -1, n = buffers.length; ++i < n; ) {
        if ((buffer = buffers[i]) && (size = buffer.byteLength) > 0) {
          this._write(buffer);
          if ((padding = (size + 7 & ~7) - size) > 0) {
            this._writePadding(padding);
          }
        }
      }
      return this;
    }
    _writeDictionaries(batch) {
      for (let [id, dictionary] of batch.dictionaries) {
        let offset = this._dictionaryDeltaOffsets.get(id) || 0;
        if (offset === 0 || (dictionary = dictionary === null || dictionary === void 0 ? void 0 : dictionary.slice(offset)).length > 0) {
          for (const data of dictionary.data) {
            this._writeDictionaryBatch(data, id, offset > 0);
            offset += data.length;
          }
        }
      }
      return this;
    }
  };
  var RecordBatchStreamWriter = class extends RecordBatchWriter {
    static writeAll(input, options) {
      const writer = new RecordBatchStreamWriter(options);
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
  };
  var RecordBatchFileWriter = class extends RecordBatchWriter {
    static writeAll(input) {
      const writer = new RecordBatchFileWriter();
      if (isPromise(input)) {
        return input.then((x) => writer.writeAll(x));
      } else if (isAsyncIterable(input)) {
        return writeAllAsync(writer, input);
      }
      return writeAll(writer, input);
    }
    constructor() {
      super();
      this._autoDestroy = true;
    }
    _writeSchema(schema) {
      return this._writeMagic()._writePadding(2);
    }
    _writeFooter(schema) {
      const buffer = Footer_.encode(new Footer_(schema, MetadataVersion.V4, this._recordBatchBlocks, this._dictionaryBlocks));
      return super._writeFooter(schema)._write(buffer)._write(Int32Array.of(buffer.byteLength))._writeMagic();
    }
  };
  function writeAll(writer, input) {
    let chunks = input;
    if (input instanceof Table) {
      chunks = input.batches;
      writer.reset(void 0, input.schema);
    }
    for (const batch of chunks) {
      writer.write(batch);
    }
    return writer.finish();
  }
  function writeAllAsync(writer, batches) {
    var batches_1, batches_1_1;
    var e_1, _a5;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        for (batches_1 = __asyncValues(batches); batches_1_1 = yield batches_1.next(), !batches_1_1.done; ) {
          const batch = batches_1_1.value;
          writer.write(batch);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (batches_1_1 && !batches_1_1.done && (_a5 = batches_1.return))
            yield _a5.call(batches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return writer.finish();
    });
  }

  // ../../node_modules/apache-arrow/io/whatwg/iterable.mjs
  function toDOMStream(source, options) {
    if (isAsyncIterable(source)) {
      return asyncIterableAsReadableDOMStream(source, options);
    }
    if (isIterable(source)) {
      return iterableAsReadableDOMStream(source, options);
    }
    throw new Error(`toDOMStream() must be called with an Iterable or AsyncIterable`);
  }
  function iterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        next(controller, it2 || (it2 = source[Symbol.iterator]()));
      },
      pull(controller) {
        it2 ? next(controller, it2) : controller.close();
      },
      cancel() {
        ((it2 === null || it2 === void 0 ? void 0 : it2.return) && it2.return() || true) && (it2 = null);
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      let buf;
      let r = null;
      let size = controller.desiredSize || null;
      while (!(r = it3.next(bm ? size : null)).done) {
        if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
          size != null && bm && (size = size - buf.byteLength + 1);
          r.value = buf;
        }
        controller.enqueue(r.value);
        if (size != null && --size <= 0) {
          return;
        }
      }
      controller.close();
    }
  }
  function asyncIterableAsReadableDOMStream(source, options) {
    let it2 = null;
    const bm = (options === null || options === void 0 ? void 0 : options.type) === "bytes" || false;
    const hwm = (options === null || options === void 0 ? void 0 : options.highWaterMark) || Math.pow(2, 24);
    return new ReadableStream(Object.assign(Object.assign({}, options), {
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, it2 || (it2 = source[Symbol.asyncIterator]()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          it2 ? yield next(controller, it2) : controller.close();
        });
      },
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          ((it2 === null || it2 === void 0 ? void 0 : it2.return) && (yield it2.return()) || true) && (it2 = null);
        });
      }
    }), Object.assign({ highWaterMark: bm ? hwm : void 0 }, options));
    function next(controller, it3) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf;
        let r = null;
        let size = controller.desiredSize || null;
        while (!(r = yield it3.next(bm ? size : null)).done) {
          if (ArrayBuffer.isView(r.value) && (buf = toUint8Array(r.value))) {
            size != null && bm && (size = size - buf.byteLength + 1);
            r.value = buf;
          }
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/io/whatwg/builder.mjs
  function builderThroughDOMStream(options) {
    return new BuilderTransform(options);
  }
  var BuilderTransform = class {
    constructor(options) {
      this._numChunks = 0;
      this._finished = false;
      this._bufferedSize = 0;
      const { ["readableStrategy"]: readableStrategy, ["writableStrategy"]: writableStrategy, ["queueingStrategy"]: queueingStrategy = "count" } = options, builderOptions = __rest(options, ["readableStrategy", "writableStrategy", "queueingStrategy"]);
      this._controller = null;
      this._builder = makeBuilder(builderOptions);
      this._getSize = queueingStrategy !== "bytes" ? chunkLength : chunkByteLength;
      const { ["highWaterMark"]: readableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, readableStrategy);
      const { ["highWaterMark"]: writableHighWaterMark = queueingStrategy === "bytes" ? Math.pow(2, 14) : 1e3 } = Object.assign({}, writableStrategy);
      this["readable"] = new ReadableStream({
        ["cancel"]: () => {
          this._builder.clear();
        },
        ["pull"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        },
        ["start"]: (c) => {
          this._maybeFlush(this._builder, this._controller = c);
        }
      }, {
        "highWaterMark": readableHighWaterMark,
        "size": queueingStrategy !== "bytes" ? chunkLength : chunkByteLength
      });
      this["writable"] = new WritableStream({
        ["abort"]: () => {
          this._builder.clear();
        },
        ["write"]: () => {
          this._maybeFlush(this._builder, this._controller);
        },
        ["close"]: () => {
          this._maybeFlush(this._builder.finish(), this._controller);
        }
      }, {
        "highWaterMark": writableHighWaterMark,
        "size": (value) => this._writeValueAndReturnChunkSize(value)
      });
    }
    _writeValueAndReturnChunkSize(value) {
      const bufferedSize = this._bufferedSize;
      this._bufferedSize = this._getSize(this._builder.append(value));
      return this._bufferedSize - bufferedSize;
    }
    _maybeFlush(builder, controller) {
      if (controller == null) {
        return;
      }
      if (this._bufferedSize >= controller.desiredSize) {
        ++this._numChunks && this._enqueue(controller, builder.toVector());
      }
      if (builder.finished) {
        if (builder.length > 0 || this._numChunks === 0) {
          ++this._numChunks && this._enqueue(controller, builder.toVector());
        }
        if (!this._finished && (this._finished = true)) {
          this._enqueue(controller, null);
        }
      }
    }
    _enqueue(controller, chunk) {
      this._bufferedSize = 0;
      this._controller = null;
      chunk == null ? controller.close() : controller.enqueue(chunk);
    }
  };
  var chunkLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a5 !== void 0 ? _a5 : 0;
  };
  var chunkByteLength = (chunk) => {
    var _a5;
    return (_a5 = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a5 !== void 0 ? _a5 : 0;
  };

  // ../../node_modules/apache-arrow/io/whatwg/reader.mjs
  function recordBatchReaderThroughDOMStream(writableStrategy, readableStrategy) {
    const queue = new AsyncByteQueue();
    let reader = null;
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield queue.close();
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller, reader || (reader = yield open()));
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          reader ? yield next(controller, reader) : controller.close();
        });
      }
    });
    return { writable: new WritableStream(queue, Object.assign({ "highWaterMark": Math.pow(2, 14) }, writableStrategy)), readable };
    function open() {
      return __awaiter(this, void 0, void 0, function* () {
        return yield (yield RecordBatchReader.from(queue)).open(readableStrategy);
      });
    }
    function next(controller, reader2) {
      return __awaiter(this, void 0, void 0, function* () {
        let size = controller.desiredSize;
        let r = null;
        while (!(r = yield reader2.next()).done) {
          controller.enqueue(r.value);
          if (size != null && --size <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/io/whatwg/writer.mjs
  function recordBatchWriterThroughDOMStream(writableStrategy, readableStrategy) {
    const writer = new this(writableStrategy);
    const reader = new AsyncByteStream(writer);
    const readable = new ReadableStream({
      cancel() {
        return __awaiter(this, void 0, void 0, function* () {
          yield reader.cancel();
        });
      },
      pull(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      },
      start(controller) {
        return __awaiter(this, void 0, void 0, function* () {
          yield next(controller);
        });
      }
    }, Object.assign({ "highWaterMark": Math.pow(2, 14) }, readableStrategy));
    return { writable: new WritableStream(writer, writableStrategy), readable };
    function next(controller) {
      return __awaiter(this, void 0, void 0, function* () {
        let buf = null;
        let size = controller.desiredSize;
        while (buf = yield reader.read(size || null)) {
          controller.enqueue(buf);
          if (size != null && (size -= buf.byteLength) <= 0) {
            return;
          }
        }
        controller.close();
      });
    }
  }

  // ../../node_modules/apache-arrow/ipc/serialization.mjs
  function tableToIPC(table, type = "stream") {
    return (type === "stream" ? RecordBatchStreamWriter : RecordBatchFileWriter).writeAll(table).toUint8Array(true);
  }

  // ../../node_modules/apache-arrow/Arrow.mjs
  var util = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, bn_exports), int_exports), bit_exports), math_exports), buffer_exports), vector_exports), {
    compareSchemas,
    compareFields,
    compareTypes
  });

  // ../../node_modules/apache-arrow/Arrow.dom.mjs
  adapters_default.toDOMStream = toDOMStream;
  Builder["throughDOM"] = builderThroughDOMStream;
  RecordBatchReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchFileReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchStreamReader["throughDOM"] = recordBatchReaderThroughDOMStream;
  RecordBatchWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchFileWriter["throughDOM"] = recordBatchWriterThroughDOMStream;
  RecordBatchStreamWriter["throughDOM"] = recordBatchWriterThroughDOMStream;

  // src/bindings/connection.ts
  var DuckDBConnection = class {
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    close() {
      this._bindings.disconnect(this._conn);
    }
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    query(text) {
      const buffer = this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    async send(text) {
      let header = this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await new Promise((resolve, reject) => {
          try {
            resolve(this._bindings.pollPendingQuery(this._conn));
          } catch (e) {
            reject(e);
          }
        });
      }
      const iter = new ResultStreamIterator(this._bindings, this._conn, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
    cancelSent() {
      return this._bindings.cancelPendingQuery(this._conn);
    }
    getTableNames(query) {
      return this._bindings.getTableNames(this._conn, query);
    }
    prepare(text) {
      const stmt = this._bindings.createPrepared(this._conn, text);
      return new PreparedStatement(this._bindings, this._conn, stmt);
    }
    createScalarFunction(name, returns, func) {
      this._bindings.createScalarFunction(this._conn, name, returns, func);
    }
    insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      this.insertArrowFromIPCStream(buffer, options);
    }
    insertArrowFromIPCStream(buffer, options) {
      this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    insertCSVFromPath(path, options) {
      this._bindings.insertCSVFromPath(this._conn, path, options);
    }
    insertJSONFromPath(path, options) {
      this._bindings.insertJSONFromPath(this._conn, path, options);
    }
  };
  var ResultStreamIterator = class {
    constructor(bindings, conn, header) {
      this.bindings = bindings;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
    }
    next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      const bufferI8 = this.bindings.fetchQueryResults(this.conn);
      this._depleted = bufferI8.length == 0;
      return {
        done: this._depleted,
        value: bufferI8
      };
    }
    [Symbol.iterator]() {
      return this;
    }
  };
  var PreparedStatement = class {
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    close() {
      this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    query(...params) {
      const buffer = this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    send(...params) {
      const header = this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new ResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = RecordBatchReader.from(iter);
      console.assert(reader.isSync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/bindings/udf_runtime.ts
  var TEXT_ENCODER = new TextEncoder();
  var TEXT_DECODER = new TextDecoder("utf-8");
  function storeError(mod, response, message) {
    const msgBuffer = TEXT_ENCODER.encode(message);
    const heapAddr = mod._malloc(msgBuffer.byteLength);
    const heapArray = mod.HEAPU8.subarray(heapAddr, heapAddr + msgBuffer.byteLength);
    heapArray.set(msgBuffer);
    mod.HEAPF64[(response >> 3) + 0] = 1;
    mod.HEAPF64[(response >> 3) + 1] = heapAddr;
    mod.HEAPF64[(response >> 3) + 2] = heapArray.byteLength;
  }
  function getTypeSize(ptype) {
    switch (ptype) {
      case "UINT8":
      case "INT8":
        return 1;
      case "INT32":
      case "FLOAT":
        return 4;
      case "INT64":
      case "UINT64":
      case "DOUBLE":
      case "VARCHAR":
        return 8;
      default:
        return 0;
    }
  }
  function ptrToArray(mod, ptr, ptype, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n * getTypeSize(ptype));
    switch (ptype) {
      case "UINT8":
        return new Uint8Array(heap.buffer, heap.byteOffset, n);
      case "INT8":
        return new Int8Array(heap.buffer, heap.byteOffset, n);
      case "INT32":
        return new Int32Array(heap.buffer, heap.byteOffset, n);
      case "FLOAT":
        return new Float32Array(heap.buffer, heap.byteOffset, n);
      case "DOUBLE":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      case "VARCHAR":
        return new Float64Array(heap.buffer, heap.byteOffset, n);
      default:
        return new Array(0);
    }
  }
  function ptrToUint8Array(mod, ptr, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n);
    return new Uint8Array(heap.buffer, heap.byteOffset, n);
  }
  function ptrToFloat64Array(mod, ptr, n) {
    const heap = mod.HEAPU8.subarray(ptr, ptr + n * 8);
    return new Float64Array(heap.buffer, heap.byteOffset, n);
  }
  function callScalarUDF(runtime, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) {
    try {
      const udf = runtime._udfFunctions.get(funcId);
      if (!udf) {
        storeError(mod, response, "Unknown UDF with id: " + funcId);
        return;
      }
      const rawDesc = TEXT_DECODER.decode(mod.HEAPU8.subarray(descPtr, descPtr + descSize));
      const desc = JSON.parse(rawDesc);
      const ptrs = ptrToFloat64Array(mod, ptrsPtr, ptrsSize / 8);
      const buildResolver = (arg) => {
        let validity = null;
        if (arg.validityBuffer !== void 0) {
          validity = ptrToUint8Array(mod, ptrs[arg.validityBuffer], desc.rows);
        }
        switch (arg.physicalType) {
          case "VARCHAR": {
            if (arg.dataBuffer === null || arg.dataBuffer === void 0) {
              throw new Error("malformed data view, expected data buffer for VARCHAR argument");
            }
            if (arg.lengthBuffer === null || arg.lengthBuffer === void 0) {
              throw new Error("malformed data view, expected data length buffer for VARCHAR argument");
            }
            const raw = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            const strings = [];
            const stringLengths = ptrToFloat64Array(mod, ptrs[arg.lengthBuffer], desc.rows);
            for (let j = 0; j < desc.rows; ++j) {
              if (validity != null && !validity[j]) {
                strings.push(null);
                continue;
              }
              const subarray = mod.HEAPU8.subarray(
                raw[j],
                raw[j] + stringLengths[j]
              );
              const str = TEXT_DECODER.decode(subarray);
              strings.push(str);
            }
            return (row) => strings[row];
          }
          case "STRUCT": {
            const tmp2 = {};
            const children = [];
            for (let j = 0; j < (arg.children?.length || 0); ++j) {
              const attr = arg.children[j];
              const child = buildResolver(attr);
              children.push((row) => {
                tmp2[attr.name] = child(row);
              });
            }
            if (validity != null) {
              return (row) => {
                if (!validity[row]) {
                  return null;
                }
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            } else {
              return (row) => {
                for (const resolver of children) {
                  resolver(row);
                }
                return tmp2;
              };
            }
          }
          default: {
            if (arg.dataBuffer === void 0) {
              throw new Error(
                "malformed data view, expected data buffer for argument of type: " + arg.physicalType
              );
            }
            const data = ptrToArray(mod, ptrs[arg.dataBuffer], arg.physicalType, desc.rows);
            if (validity != null) {
              return (row) => !validity[row] ? null : data[row];
            } else {
              return (row) => data[row];
            }
          }
        }
      };
      const argResolvers = [];
      for (let i = 0; i < desc.args.length; ++i) {
        argResolvers.push(buildResolver(desc.args[i]));
      }
      const resultDataLen = desc.rows * getTypeSize(desc.ret.physicalType);
      const resultDataPtr = mod._malloc(resultDataLen);
      const resultData = ptrToArray(mod, resultDataPtr, desc.ret.physicalType, desc.rows);
      const resultValidityPtr = mod._malloc(desc.rows);
      const resultValidity = ptrToUint8Array(mod, resultValidityPtr, desc.rows);
      if (resultData.length == 0 || resultValidity.length == 0) {
        storeError(mod, response, "Can't create physical arrays for result");
        return;
      }
      let rawResultData = resultData;
      if (desc.ret.physicalType == "VARCHAR") {
        rawResultData = new Array(desc.rows);
      }
      const args = [];
      for (let i = 0; i < desc.args.length; ++i) {
        args.push(null);
      }
      for (let i = 0; i < desc.rows; ++i) {
        for (let j = 0; j < desc.args.length; ++j) {
          args[j] = argResolvers[j](i);
        }
        const res = udf.func(...args);
        rawResultData[i] = res;
        resultValidity[i] = res === void 0 || res === null ? 0 : 1;
      }
      let resultLengthsPtr = 0;
      switch (desc.ret.physicalType) {
        case "VARCHAR": {
          const resultDataUTF8 = new Array(0);
          resultLengthsPtr = mod._malloc(desc.rows * getTypeSize("DOUBLE"));
          const resultLengths = ptrToFloat64Array(mod, resultLengthsPtr, desc.rows);
          let totalLength = 0;
          for (let row = 0; row < desc.rows; ++row) {
            const utf8 = TEXT_ENCODER.encode(rawResultData[row] || "");
            resultDataUTF8.push(utf8);
            resultLengths[row] = utf8.length;
            totalLength += utf8.length;
          }
          const resultStringPtr = mod._malloc(totalLength);
          const resultStringBuf = mod.HEAPU8.subarray(resultStringPtr, resultStringPtr + totalLength);
          let writerOffset = 0;
          for (let row = 0; row < desc.rows; ++row) {
            resultData[row] = writerOffset;
            const resultUTF8 = resultDataUTF8[row];
            const writer = resultStringBuf.subarray(writerOffset, writerOffset + resultUTF8.length);
            writer.set(resultUTF8);
            writerOffset += resultUTF8.length;
          }
        }
      }
      const retLen = 3 * 8;
      const retPtr = mod._malloc(retLen);
      const retBuffer = ptrToFloat64Array(mod, retPtr, 3);
      retBuffer[0] = resultDataPtr;
      retBuffer[1] = resultValidityPtr;
      retBuffer[2] = resultLengthsPtr;
      mod.HEAPF64[(response >> 3) + 0] = 0;
      mod.HEAPF64[(response >> 3) + 1] = retPtr;
      mod.HEAPF64[(response >> 3) + 2] = 0;
    } catch (e) {
      storeError(mod, response, e.toString());
    }
  }

  // src/bindings/runtime.ts
  function TextDecoderWrapper() {
    const decoder3 = new TextDecoder();
    return (data) => {
      if (typeof SharedArrayBuffer !== "undefined" && data.buffer instanceof SharedArrayBuffer) {
        data = new Uint8Array(data);
      }
      return decoder3.decode(data);
    };
  }
  var decodeText = TextDecoderWrapper();
  function failWith(mod, msg) {
    console.error(`FAIL WITH: ${msg}`);
    mod.ccall("duckdb_web_fail_with", null, ["string"], [msg]);
  }
  function copyBuffer(mod, begin, length) {
    const buffer = mod.HEAPU8.subarray(begin, begin + length);
    const copy = new Uint8Array(new ArrayBuffer(buffer.byteLength));
    copy.set(buffer);
    return copy;
  }
  function readString(mod, begin, length) {
    return decodeText(mod.HEAPU8.subarray(begin, begin + length));
  }
  function callSRet(mod, funcName, argTypes, args) {
    const stackPointer = mod.stackSave();
    const response = mod.stackAlloc(3 * 8);
    argTypes.unshift("number");
    args.unshift(response);
    mod.ccall(funcName, null, argTypes, args);
    const status = mod.HEAPF64[(response >> 3) + 0];
    const data = mod.HEAPF64[(response >> 3) + 1];
    const dataSize = mod.HEAPF64[(response >> 3) + 2];
    mod.stackRestore(stackPointer);
    return [status, data, dataSize];
  }
  function dropResponseBuffers(mod) {
    mod.ccall("duckdb_web_clear_response", null, [], []);
  }

  // src/bindings/file_stats.ts
  var FileStatistics = class {
    constructor(u8array) {
      const f642 = new Float64Array(u8array.buffer, u8array.byteOffset, u8array.byteLength / 8);
      const blocks2 = new Uint8Array(new ArrayBuffer(u8array.byteLength));
      blocks2.set(u8array.subarray(7 * 8));
      this.totalFileReadsCold = f642[0];
      this.totalFileReadsAhead = f642[1];
      this.totalFileReadsCached = f642[2];
      this.totalFileWrites = f642[3];
      this.totalPageAccesses = f642[4];
      this.totalPageLoads = f642[5];
      this.blockSize = f642[6];
      this.blockStats = blocks2;
    }
    getBlockStats(index, out) {
      out = out || {
        file_reads_cold: 0,
        file_reads_ahead: 0,
        file_reads_cached: 0,
        file_writes: 0,
        page_accesses: 0,
        page_loads: 0
      };
      out.file_writes = this.blockStats[index * 3 + 0] & 15;
      out.file_reads_cold = this.blockStats[index * 3 + 0] >> 4;
      out.file_reads_ahead = this.blockStats[index * 3 + 1] & 15;
      out.file_reads_cached = this.blockStats[index * 3 + 1] >> 4;
      out.page_accesses = this.blockStats[index * 3 + 1] & 15;
      out.page_loads = this.blockStats[index * 3 + 1] >> 4;
      return out;
    }
  };

  // src/json_typedef.ts
  function arrowToSQLType(type) {
    switch (type.typeId) {
      case Type.Binary:
        return { sqlType: "binary" };
      case Type.Bool:
        return { sqlType: "bool" };
      case Type.Date:
        return { sqlType: "date" };
      case Type.DateDay:
        return { sqlType: "date32[d]" };
      case Type.DateMillisecond:
        return { sqlType: "date64[ms]" };
      case Type.Decimal: {
        const dec = type;
        return { sqlType: "decimal", precision: dec.precision, scale: dec.scale };
      }
      case Type.Float:
        return { sqlType: "float" };
      case Type.Float16:
        return { sqlType: "float16" };
      case Type.Float32:
        return { sqlType: "float32" };
      case Type.Float64:
        return { sqlType: "float64" };
      case Type.Int:
        return { sqlType: "int32" };
      case Type.Int16:
        return { sqlType: "int16" };
      case Type.Int32:
        return { sqlType: "int32" };
      case Type.Int64:
        return { sqlType: "int64" };
      case Type.Uint16:
        return { sqlType: "uint16" };
      case Type.Uint32:
        return { sqlType: "uint32" };
      case Type.Uint64:
        return { sqlType: "uint64" };
      case Type.Uint8:
        return { sqlType: "uint8" };
      case Type.IntervalDayTime:
        return { sqlType: "interval[dt]" };
      case Type.IntervalYearMonth:
        return { sqlType: "interval[m]" };
      case Type.List: {
        const list = type;
        return {
          sqlType: "list",
          valueType: arrowToSQLType(list.valueType)
        };
      }
      case Type.FixedSizeBinary: {
        const bin = type;
        return { sqlType: "fixedsizebinary", byteWidth: bin.byteWidth };
      }
      case Type.Null:
        return { sqlType: "null" };
      case Type.Utf8:
        return { sqlType: "utf8" };
      case Type.Struct: {
        const struct_ = type;
        return {
          sqlType: "struct",
          fields: struct_.children.map((c) => arrowToSQLField(c.name, c.type))
        };
      }
      case Type.Map: {
        const map_ = type;
        return {
          sqlType: "map",
          keyType: arrowToSQLType(map_.keyType),
          valueType: arrowToSQLType(map_.valueType)
        };
      }
      case Type.Time:
        return { sqlType: "time[s]" };
      case Type.TimeMicrosecond:
        return { sqlType: "time[us]" };
      case Type.TimeMillisecond:
        return { sqlType: "time[ms]" };
      case Type.TimeNanosecond:
        return { sqlType: "time[ns]" };
      case Type.TimeSecond:
        return { sqlType: "time[s]" };
      case Type.Timestamp: {
        const ts = type;
        return { sqlType: "timestamp", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampSecond: {
        const ts = type;
        return { sqlType: "timestamp[s]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMicrosecond: {
        const ts = type;
        return { sqlType: "timestamp[us]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampNanosecond: {
        const ts = type;
        return { sqlType: "timestamp[ns]", timezone: ts.timezone || void 0 };
      }
      case Type.TimestampMillisecond: {
        const ts = type;
        return { sqlType: "timestamp[ms]", timezone: ts.timezone || void 0 };
      }
    }
    throw new Error(`unsupported arrow type: ${type.toString()}`);
  }
  function arrowToSQLField(name, type) {
    const t = arrowToSQLType(type);
    t.name = name;
    return t;
  }

  // src/bindings/bindings_base.ts
  var TEXT_ENCODER2 = new TextEncoder();
  var DuckDBBindingsBase = class {
    constructor(logger, runtime) {
      this._instance = null;
      this._initPromise = null;
      this._initPromiseResolver = () => {
      };
      this.onInstantiationProgress = [];
      this._logger = logger;
      this._runtime = runtime;
      this._nextUDFId = 1;
    }
    get logger() {
      return this._logger;
    }
    get mod() {
      return this._instance;
    }
    get pthread() {
      return this.mod.PThread || null;
    }
    async instantiate(onProgress = (_) => {
    }) {
      if (this._instance != null) {
        return this;
      }
      if (this._initPromise != null) {
        this.onInstantiationProgress.push(onProgress);
        await this._initPromise;
      }
      this._initPromise = new Promise((resolve) => {
        this._initPromiseResolver = resolve;
      });
      this.onInstantiationProgress = [onProgress];
      this._instance = await this.instantiateImpl({
        print: console.log.bind(console),
        printErr: console.log.bind(console),
        onRuntimeInitialized: this._initPromiseResolver
      });
      await this._initPromise;
      this._initPromise = null;
      this.onInstantiationProgress = this.onInstantiationProgress.filter((x) => x != onProgress);
      return this;
    }
    open(config) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_open", ["string"], [JSON.stringify(config)]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    reset() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_reset", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    getVersion() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_get_version", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const version = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return version;
    }
    getFeatureFlags() {
      return this.mod.ccall("duckdb_web_get_feature_flags", "number", [], []);
    }
    tokenize(text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_tokenize", ["string"], [text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    connect() {
      const conn = this.mod.ccall("duckdb_web_connect", "number", [], []);
      return new DuckDBConnection(this, conn);
    }
    disconnect(conn) {
      this.mod.ccall("duckdb_web_disconnect", null, ["number"], [conn]);
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "dropUDFFunctions",
            connectionId: conn
          });
        }
      }
    }
    runQuery(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_query_run", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    startPendingQuery(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_pending_query_start", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    pollPendingQuery(conn) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_pending_query_poll", ["number"], [conn]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      if (d == 0) {
        return null;
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    cancelPendingQuery(conn) {
      return this.mod.ccall("duckdb_web_pending_query_cancel", "boolean", ["number"], [conn]);
    }
    fetchQueryResults(conn) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_query_fetch_results", ["number"], [conn]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    getTableNames(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_get_tablenames", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return JSON.parse(res);
    }
    createScalarFunction(conn, name, returns, func) {
      const decl = {
        functionId: this._nextUDFId,
        name,
        returnType: arrowToSQLType(returns)
      };
      const def = {
        functionId: decl.functionId,
        connectionId: conn,
        name,
        returnType: returns,
        func
      };
      this._nextUDFId += 1;
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_udf_scalar_create",
        ["number", "string"],
        [conn, JSON.stringify(decl)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._udfFunctions = (globalThis.DUCKDB_RUNTIME._udfFunctions || /* @__PURE__ */ new Map()).set(
        def.functionId,
        def
      );
      if (this.pthread) {
        for (const worker2 of [...this.pthread.runningWorkers, ...this.pthread.unusedWorkers]) {
          worker2.postMessage({
            cmd: "registerUDFFunction",
            udf: def
          });
        }
      }
    }
    createPrepared(conn, text) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_prepared_create", ["number", "string"], [conn, text]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      return d;
    }
    closePrepared(conn, statement) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_prepared_close", ["number", "number"], [conn, statement]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    runPrepared(conn, statement, params) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_run",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    sendPrepared(conn, statement, params) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_prepared_send",
        ["number", "number", "string"],
        [conn, statement, JSON.stringify(params)]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const res = copyBuffer(this.mod, d, n);
      dropResponseBuffers(this.mod);
      return res;
    }
    insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const bufferPtr = this.mod._malloc(buffer.length);
      const bufferOfs = this.mod.HEAPU8.subarray(bufferPtr, bufferPtr + buffer.length);
      bufferOfs.set(buffer);
      const optJSON = options ? JSON.stringify(options) : "";
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_arrow_from_ipc_stream",
        ["number", "number", "number", "string"],
        [conn, bufferPtr, buffer.length, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_csv_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        options.columnsFlat = [];
        for (const k in options.columns) {
          options.columnsFlat.push(arrowToSQLField(k, options.columns[k]));
        }
      }
      const opt = { ...options };
      opt.columns = opt.columnsFlat;
      delete opt.columnsFlat;
      const optJSON = JSON.stringify(opt);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_insert_json_from_path",
        ["number", "string", "string"],
        [conn, path, optJSON]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    globFiles(path) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_glob_file_infos", ["string"], [path]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const infoStr = readString(this.mod, d, n);
      dropResponseBuffers(this.mod);
      const info = JSON.parse(infoStr);
      if (info == null) {
        return [];
      }
      return info;
    }
    registerFileURL(name, url, proto, directIO = false) {
      if (url === void 0) {
        url = name;
      }
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string"],
        [name, url, proto, directIO]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    registerFileText(name, text) {
      const buffer = TEXT_ENCODER2.encode(text);
      this.registerFileBuffer(name, buffer);
    }
    registerFileBuffer(name, buffer) {
      const ptr = this.mod._malloc(buffer.length);
      const dst = this.mod.HEAPU8.subarray(ptr, ptr + buffer.length);
      dst.set(buffer);
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_buffer",
        ["string", "number", "number"],
        [name, ptr, buffer.length]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    registerFileHandle(name, handle, protocol, directIO) {
      const [s, d, n] = callSRet(
        this.mod,
        "duckdb_web_fs_register_file_url",
        ["string", "string", "number", "boolean"],
        [name, name, protocol, directIO]
      );
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
      globalThis.DUCKDB_RUNTIME._files = (globalThis.DUCKDB_RUNTIME._files || /* @__PURE__ */ new Map()).set(name, handle);
      if (this.pthread) {
        for (const worker2 of this.pthread.runningWorkers) {
          worker2.postMessage({
            cmd: "registerFileHandle",
            fileName: name,
            fileHandle: handle
          });
        }
        for (const worker2 of this.pthread.unusedWorkers) {
          worker2.postMessage({
            cmd: "dropFileHandle",
            fileName: name
          });
        }
      }
    }
    dropFile(name) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_file", ["string"], [name]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    dropFiles() {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_fs_drop_files", [], []);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    flushFiles() {
      this.mod.ccall("duckdb_web_flush_files", null, [], []);
    }
    copyFileToPath(name, path) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_path", ["string", "string"], [name, path]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      dropResponseBuffers(this.mod);
    }
    copyFileToBuffer(name) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_copy_file_to_buffer", ["string"], [name]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      const buffer = this.mod.HEAPU8.subarray(d, d + n);
      const copy = new Uint8Array(buffer.length);
      copy.set(buffer);
      dropResponseBuffers(this.mod);
      return copy;
    }
    collectFileStatistics(file, enable) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_collect_file_stats", ["string", "boolean"], [file, enable]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
    }
    exportFileStatistics(file) {
      const [s, d, n] = callSRet(this.mod, "duckdb_web_export_file_stats", ["string"], [file]);
      if (s !== 0 /* SUCCESS */) {
        throw new Error(readString(this.mod, d, n));
      }
      return new FileStatistics(this.mod.HEAPU8.subarray(d, d + n));
    }
  };

  // src/log.ts
  var VoidLogger = class {
    log(_entry) {
    }
  };

  // ../../node_modules/wasm-feature-detect/dist/esm/index.js
  var bulkMemory = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 3, 1, 0, 1, 10, 14, 1, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11]));
  var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
  var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));
  var threads = () => (async (e) => {
    try {
      return "undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(e);
    } catch (e2) {
      return false;
    }
  })(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11]));

  // src/platform.ts
  var isNode = () => typeof navigator === "undefined" ? true : false;
  var bigInt64Array = null;
  var wasmExceptions = null;
  var wasmThreads = null;
  var wasmSIMD = null;
  var wasmBulkMemory = null;
  async function getPlatformFeatures() {
    if (bigInt64Array == null) {
      bigInt64Array = typeof BigInt64Array != "undefined";
    }
    if (wasmExceptions == null) {
      wasmExceptions = await exceptions();
    }
    if (wasmThreads == null) {
      wasmThreads = await threads();
    }
    if (wasmSIMD == null) {
      wasmSIMD = await simd();
    }
    if (wasmBulkMemory == null) {
      wasmBulkMemory = await bulkMemory();
    }
    return {
      bigInt64Array,
      crossOriginIsolated: isNode() || globalThis.crossOriginIsolated || false,
      wasmExceptions,
      wasmSIMD,
      wasmThreads,
      wasmBulkMemory
    };
  }
  async function selectBundle(bundles) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (platform.wasmSIMD && platform.wasmThreads && platform.crossOriginIsolated && bundles.coi) {
        return {
          mainModule: bundles.coi.mainModule,
          mainWorker: bundles.coi.mainWorker,
          pthreadWorker: bundles.coi.pthreadWorker
        };
      }
      if (bundles.eh) {
        return {
          mainModule: bundles.eh.mainModule,
          mainWorker: bundles.eh.mainWorker,
          pthreadWorker: null
        };
      }
    }
    return {
      mainModule: bundles.mvp.mainModule,
      mainWorker: bundles.mvp.mainWorker,
      pthreadWorker: null
    };
  }

  // src/utils/s3_helper.ts
  var import_js_sha256 = __toESM(require_sha256());
  var getHTTPHost = function(config, url, bucket) {
    if (config?.endpoint?.startsWith("http")) {
      const httpHost = `${config?.endpoint}`;
      const offset = httpHost.indexOf("://") + 3;
      return httpHost.substring(offset);
    } else if (config?.endpoint) {
      return `${bucket}.${config?.endpoint}`;
    } else {
      return `${bucket}.s3.amazonaws.com`;
    }
  };
  function getS3Params(config, url, method2) {
    const parsedS3Url = parseS3Url(url);
    let path = parsedS3Url.path;
    if (isPathStyleAccess(config)) {
      path = `/${parsedS3Url.bucket}${path}`;
    }
    return {
      url: path,
      query: "",
      host: getHTTPHost(config, url, parsedS3Url.bucket),
      region: config?.region ?? "",
      service: "s3",
      method: method2,
      accessKeyId: config?.accessKeyId ?? "",
      secretAccessKey: config?.secretAccessKey ?? "",
      sessionToken: config?.sessionToken ?? "",
      dateNow: new Date().toISOString().replace(/-/g, "").split("T")[0],
      datetimeNow: new Date().toISOString().replace(/-/g, "").replace(/:/g, "").split(".")[0] + "Z"
    };
  }
  function uriEncode(input, encode_slash = false) {
    const hexDigit = "0123456789ABCDEF";
    let result = "";
    for (let i = 0; i < input.length; i++) {
      const ch = input[i];
      if (ch >= "A" && ch <= "Z" || ch >= "a" && ch <= "z" || ch >= "0" && ch <= "9" || ch == "_" || ch == "-" || ch == "~" || ch == ".") {
        result += ch;
      } else if (ch == "/") {
        if (encode_slash) {
          result += "%2F";
        } else {
          result += ch;
        }
      } else {
        result += "%";
        result += hexDigit[ch.charCodeAt(0) >> 4];
        result += hexDigit[ch.charCodeAt(0) & 15];
      }
    }
    return result;
  }
  function createS3Headers(params, payloadParams = null) {
    const payloadHash = payloadParams?.contentHash ?? "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    const res = /* @__PURE__ */ new Map();
    res.set("x-amz-date", params.datetimeNow);
    res.set("x-amz-content-sha256", payloadHash);
    if (params.sessionToken) {
      res.set("x-amz-security-token", params.sessionToken);
    }
    let signedHeaders = "";
    if (payloadParams?.contentType) {
      signedHeaders += "content-type;";
    }
    signedHeaders += "host;x-amz-content-sha256;x-amz-date";
    if (params.sessionToken) {
      signedHeaders += ";x-amz-security-token";
    }
    let canonicalRequest = params.method + "\n" + uriEncode(params.url) + "\n" + params.query;
    if (payloadParams?.contentType) {
      canonicalRequest += "\ncontent-type:" + payloadParams?.contentType;
    }
    canonicalRequest += "\nhost:" + params.host + "\nx-amz-content-sha256:" + payloadHash + "\nx-amz-date:" + params.datetimeNow;
    if (params.sessionToken && params.sessionToken.length > 0) {
      canonicalRequest += "\nx-amz-security-token:" + params.sessionToken;
    }
    canonicalRequest += "\n\n" + signedHeaders + "\n" + payloadHash;
    const canonicalRequestHashStr = (0, import_js_sha256.sha256)(canonicalRequest);
    const stringToSign = "AWS4-HMAC-SHA256\n" + params.datetimeNow + "\n" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request\n" + canonicalRequestHashStr;
    const signKey = "AWS4" + params.secretAccessKey;
    const kDate = import_js_sha256.sha256.hmac.arrayBuffer(signKey, params.dateNow);
    const kRegion = import_js_sha256.sha256.hmac.arrayBuffer(kDate, params.region);
    const kService = import_js_sha256.sha256.hmac.arrayBuffer(kRegion, params.service);
    const signingKey = import_js_sha256.sha256.hmac.arrayBuffer(kService, "aws4_request");
    const signature = import_js_sha256.sha256.hmac(signingKey, stringToSign);
    res.set("Authorization", "AWS4-HMAC-SHA256 Credential=" + params.accessKeyId + "/" + params.dateNow + "/" + params.region + "/" + params.service + "/aws4_request, SignedHeaders=" + signedHeaders + ", Signature=" + signature);
    return res;
  }
  var createS3HeadersFromS3Config = function(config, url, method2, contentType = null, payload = null) {
    const params = getS3Params(config, url, method2);
    const payloadParams = {
      contentType,
      contentHash: payload ? import_js_sha256.sha256.hex(payload) : null
    };
    return createS3Headers(params, payloadParams);
  };
  function addS3Headers(xhr, config, url, method2, contentType = null, payload = null) {
    if (config?.accessKeyId || config?.sessionToken) {
      const headers = createS3HeadersFromS3Config(config, url, method2, contentType, payload);
      headers.forEach((value, header) => {
        xhr.setRequestHeader(header, value);
      });
      if (contentType) {
        xhr.setRequestHeader("content-type", contentType);
      }
    }
  }
  function parseS3Url(url) {
    if (url.indexOf("s3://") != 0) {
      throw new Error("URL needs to start with s3://");
    }
    const slashPos = url.indexOf("/", 5);
    if (slashPos == -1) {
      throw new Error("URL needs to contain a '/' after the host");
    }
    const bucket = url.substring(5, slashPos);
    if (!bucket) {
      throw new Error("URL needs to contain a bucket name");
    }
    const path = url.substring(slashPos);
    if (!path) {
      throw new Error("URL needs to contain key");
    }
    return { bucket, path };
  }
  function isPathStyleAccess(config) {
    if (config?.endpoint?.startsWith("http")) {
      return true;
    }
    return false;
  }
  function getHTTPUrl(config, url) {
    const parsedUrl = parseS3Url(url);
    if (isPathStyleAccess(config)) {
      return `${config?.endpoint}/${parsedUrl.bucket}` + parsedUrl.path;
    }
    return "https://" + getHTTPHost(config, url, parsedUrl.bucket) + parsedUrl.path;
  }

  // src/bindings/runtime_browser.ts
  var BROWSER_RUNTIME = {
    _files: /* @__PURE__ */ new Map(),
    _fileInfoCache: /* @__PURE__ */ new Map(),
    _udfFunctions: /* @__PURE__ */ new Map(),
    _globalFileInfo: null,
    getFileInfo(mod, fileId) {
      try {
        const cached = BROWSER_RUNTIME._fileInfoCache.get(fileId);
        const [s, d, n] = callSRet(
          mod,
          "duckdb_web_fs_get_file_info_by_id",
          ["number", "number"],
          [fileId, cached?.cacheEpoch || 0]
        );
        if (s !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return cached;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info = JSON.parse(infoStr);
        if (info == null) {
          return null;
        }
        const file = { ...info, blob: null };
        BROWSER_RUNTIME._fileInfoCache.set(fileId, file);
        return file;
      } catch (e) {
        return null;
      }
    },
    getGlobalFileInfo(mod) {
      try {
        const [s, d, n] = callSRet(
          mod,
          "duckdb_web_get_global_file_info",
          ["number"],
          [BROWSER_RUNTIME._globalFileInfo?.cacheEpoch || 0]
        );
        if (s !== 0 /* SUCCESS */) {
          return null;
        } else if (n === 0) {
          return BROWSER_RUNTIME._globalFileInfo;
        }
        const infoStr = readString(mod, d, n);
        dropResponseBuffers(mod);
        const info = JSON.parse(infoStr);
        if (info == null) {
          return null;
        }
        BROWSER_RUNTIME._globalFileInfo = { ...info, blob: null };
        return BROWSER_RUNTIME._globalFileInfo;
      } catch (e) {
        return null;
      }
    },
    testPlatformFeature: (_mod, feature) => {
      switch (feature) {
        case 1:
          return typeof BigInt64Array !== "undefined";
        default:
          console.warn(`test for unknown feature: ${feature}`);
          return false;
      }
    },
    getDefaultDataProtocol(mod) {
      return 2 /* BROWSER_FILEREADER */;
    },
    openFile: (mod, fileId, flags) => {
      try {
        BROWSER_RUNTIME._fileInfoCache.delete(fileId);
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (flags & 1 /* FILE_FLAGS_READ */ && flags & 2 /* FILE_FLAGS_WRITE */) {
              throw new Error(
                `Opening file ${file.fileName} failed: cannot open file with both read and write flags set`
              );
            } else if (flags & 32 /* FILE_FLAGS_APPEND */) {
              throw new Error(
                `Opening file ${file.fileName} failed: appending to HTTP/S3 files is not supported`
              );
            } else if (flags & 2 /* FILE_FLAGS_WRITE */) {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.send(null);
              if (xhr.status != 200 && xhr.status != 404) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Unexpected return status from server (${xhr.status})`
                );
              } else if (xhr.status == 404 && !(flags & 8 /* FILE_FLAGS_FILE_CREATE */ || flags & 16 /* FILE_FLAGS_FILE_CREATE_NEW */)) {
                throw new Error(
                  `Opening file ${file.fileName} failed: Cannot write to non-existent file without FILE_FLAGS_FILE_CREATE or FILE_FLAGS_FILE_CREATE_NEW flag.`
                );
              }
              const data = mod._malloc(1);
              const src = new Uint8Array();
              mod.HEAPU8.set(src, data);
              const result = mod._malloc(2 * 8);
              mod.HEAPF64[(result >> 3) + 0] = 1;
              mod.HEAPF64[(result >> 3) + 1] = data;
              return result;
            } else if (flags != 1 /* FILE_FLAGS_READ */) {
              throw new Error(`Opening file ${file.fileName} failed: unsupported file flags: ${flags}`);
            }
            let contentLength = null;
            let error = null;
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("HEAD", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "HEAD");
              } else {
                xhr.open("HEAD", file.dataUrl, false);
              }
              xhr.setRequestHeader("Range", `bytes=0-`);
              xhr.send(null);
              contentLength = xhr.getResponseHeader("Content-Length");
              if (contentLength !== null && xhr.status == 206) {
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                mod.HEAPF64[(result >> 3) + 1] = 0;
                return result;
              }
            } catch (e) {
              error = e;
              console.warn(`HEAD request with range header failed: ${e}`);
            }
            if (file.allowFullHttpReads) {
              if (contentLength !== null && +contentLength > 1) {
                const xhr2 = new XMLHttpRequest();
                if (file.dataProtocol == 5 /* S3 */) {
                  xhr2.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                  addS3Headers(xhr2, file.s3Config, file.dataUrl, "GET");
                } else {
                  xhr2.open("GET", file.dataUrl, false);
                }
                xhr2.setRequestHeader("Range", `bytes=0-0`);
                xhr2.send(null);
                const contentLength2 = xhr2.getResponseHeader("Content-Length");
                if (xhr2.status == 206 && contentLength2 !== null && +contentLength2 == 1) {
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = +contentLength;
                  mod.HEAPF64[(result >> 3) + 1] = 0;
                  return result;
                }
                if (xhr2.status == 200 && contentLength2 !== null && +contentLength2 == +contentLength) {
                  console.warn(`fall back to full HTTP read for: ${file.dataUrl}`);
                  const data = mod._malloc(xhr2.response.byteLength);
                  const src = new Uint8Array(xhr2.response, 0, xhr2.response.byteLength);
                  mod.HEAPU8.set(src, data);
                  const result = mod._malloc(2 * 8);
                  mod.HEAPF64[(result >> 3) + 0] = xhr2.response.byteLength;
                  mod.HEAPF64[(result >> 3) + 1] = data;
                  return result;
                }
              }
              console.warn(`falling back to full HTTP read for: ${file.dataUrl}`);
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              if (xhr.status == 200) {
                const data = mod._malloc(xhr.response.byteLength);
                const src = new Uint8Array(xhr.response, 0, xhr.response.byteLength);
                mod.HEAPU8.set(src, data);
                const result = mod._malloc(2 * 8);
                mod.HEAPF64[(result >> 3) + 0] = xhr.response.byteLength;
                mod.HEAPF64[(result >> 3) + 1] = data;
                return result;
              }
            }
            if (error != null) {
              throw new Error(`Reading file ${file.fileName} failed with error: ${error}`);
            }
            return 0;
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (handle) {
              const result2 = mod._malloc(2 * 8);
              mod.HEAPF64[(result2 >> 3) + 0] = handle.size;
              mod.HEAPF64[(result2 >> 3) + 1] = 0;
              return result2;
            }
            console.warn(`Buffering missing file: ${file.fileName}`);
            const result = mod._malloc(2 * 8);
            const buffer = mod._malloc(1);
            mod.HEAPF64[(result >> 3) + 0] = 1;
            mod.HEAPF64[(result >> 3) + 1] = buffer;
            return result;
          }
        }
      } catch (e) {
        console.error(e.toString());
        failWith(mod, e.toString());
      }
      return 0;
    },
    glob: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          if (xhr.status != 200 && xhr.status !== 206) {
            if (!BROWSER_RUNTIME.getGlobalFileInfo(mod)?.allowFullHttpReads) {
              failWith(mod, `HEAD request failed: ${path}, with full http reads are disabled`);
              return;
            }
            const xhr2 = new XMLHttpRequest();
            if (path.startsWith("s3://")) {
              const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
              xhr2.open("GET", getHTTPUrl(globalInfo?.s3Config, path), false);
              addS3Headers(xhr2, globalInfo?.s3Config, path, "HEAD");
            } else {
              xhr2.open("GET", path, false);
            }
            xhr2.setRequestHeader("Range", `bytes=0-0`);
            xhr2.send(null);
            if (xhr2.status != 200 && xhr2.status !== 206) {
              failWith(mod, `HEAD and GET requests failed: ${path}`);
              return;
            }
            const contentLength = xhr2.getResponseHeader("Content-Length");
            if (contentLength && +contentLength > 1) {
              console.warn(`Range request for ${path} did not return a partial response: ${xhr2.status} "${xhr2.statusText}"`);
            }
          }
          mod.ccall("duckdb_web_fs_glob_add_path", null, ["string"], [path]);
        }
      } catch (e) {
        failWith(mod, e.toString());
        return 0;
      }
    },
    checkFile: (mod, pathPtr, pathLen) => {
      try {
        const path = readString(mod, pathPtr, pathLen);
        if (path.startsWith("http") || path.startsWith("s3://")) {
          const xhr = new XMLHttpRequest();
          if (path.startsWith("s3://")) {
            const globalInfo = BROWSER_RUNTIME.getGlobalFileInfo(mod);
            xhr.open("HEAD", getHTTPUrl(globalInfo?.s3Config, path), false);
            addS3Headers(xhr, globalInfo?.s3Config, path, "HEAD");
          } else {
            xhr.open("HEAD", path, false);
          }
          xhr.send(null);
          return xhr.status == 206 || xhr.status == 200;
        }
      } catch (e) {
        return false;
      }
      return false;
    },
    syncFile: (_mod, _fileId) => {
    },
    closeFile: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      BROWSER_RUNTIME._fileInfoCache.delete(fileId);
      switch (file?.dataProtocol) {
        case 0 /* BUFFER */:
        case 4 /* HTTP */:
        case 5 /* S3 */:
          break;
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle.flush();
        }
      }
    },
    truncateFile: (mod, fileId, newSize) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, `Cannot truncate a http file`);
          return;
        case 5 /* S3 */:
          failWith(mod, `Cannot truncate an s3 file`);
          return;
        case 0 /* BUFFER */:
        case 1 /* NODE_FS */:
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, `truncateFile not implemented`);
          return;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          return handle.truncate(newSize);
        }
      }
      return 0;
    },
    readFile(mod, fileId, buf, bytes, location) {
      if (bytes == 0) {
        return 0;
      }
      try {
        const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
        switch (file?.dataProtocol) {
          case 4 /* HTTP */:
          case 5 /* S3 */: {
            if (!file.dataUrl) {
              throw new Error(`Missing data URL for file ${fileId}`);
            }
            try {
              const xhr = new XMLHttpRequest();
              if (file.dataProtocol == 5 /* S3 */) {
                xhr.open("GET", getHTTPUrl(file?.s3Config, file.dataUrl), false);
                addS3Headers(xhr, file?.s3Config, file.dataUrl, "GET");
              } else {
                xhr.open("GET", file.dataUrl, false);
              }
              xhr.responseType = "arraybuffer";
              xhr.setRequestHeader("Range", `bytes=${location}-${location + bytes - 1}`);
              xhr.send(null);
              if (xhr.status == 206 || xhr.status == 200 && bytes == xhr.response.byteLength && location == 0) {
                const src = new Uint8Array(xhr.response, 0, Math.min(xhr.response.byteLength, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else if (xhr.status == 200) {
                console.warn(`Range request for ${file.dataUrl} did not return a partial response: ${xhr.status} "${xhr.statusText}"`);
                const src = new Uint8Array(xhr.response, location, Math.min(xhr.response.byteLength - location, bytes));
                mod.HEAPU8.set(src, buf);
                return src.byteLength;
              } else {
                throw new Error(
                  `Range request for ${file.dataUrl} did returned non-success status: ${xhr.status} "${xhr.statusText}"`
                );
              }
            } catch (e) {
              throw new Error(`Range request for ${file.dataUrl} failed with error: ${e}"`);
            }
          }
          case 2 /* BROWSER_FILEREADER */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle) {
              throw new Error(`No HTML5 file registered with name: ${file.fileName}`);
            }
            const sliced = handle.slice(location, location + bytes);
            const data = new Uint8Array(new FileReaderSync().readAsArrayBuffer(sliced));
            mod.HEAPU8.set(data, buf);
            return data.byteLength;
          }
          case 3 /* BROWSER_FSACCESS */: {
            const handle = BROWSER_RUNTIME._files?.get(file.fileName);
            if (!handle) {
              throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
            }
            const out = mod.HEAPU8.subarray(buf, buf + bytes);
            return handle.read(out, { at: location });
          }
        }
        return 0;
      } catch (e) {
        failWith(mod, e.toString());
        return 0;
      }
    },
    writeFile: (mod, fileId, buf, bytes, location) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 4 /* HTTP */:
          failWith(mod, "Cannot write to HTTP file");
          return 0;
        case 5 /* S3 */: {
          const buffer = mod.HEAPU8.subarray(buf, buf + bytes);
          const xhr = new XMLHttpRequest();
          xhr.open("PUT", getHTTPUrl(file?.s3Config, file.dataUrl), false);
          addS3Headers(xhr, file?.s3Config, file.dataUrl, "PUT", "", buffer);
          xhr.send(buffer);
          return bytes;
        }
        case 2 /* BROWSER_FILEREADER */:
          failWith(mod, "cannot write using the html5 file reader api");
          return 0;
        case 3 /* BROWSER_FSACCESS */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw new Error(`No OPFS access handle registered with name: ${file.fileName}`);
          }
          const input = mod.HEAPU8.subarray(buf, buf + bytes);
          return handle.write(input, { at: location });
        }
      }
      return 0;
    },
    getLastFileModificationTime: (mod, fileId) => {
      const file = BROWSER_RUNTIME.getFileInfo(mod, fileId);
      switch (file?.dataProtocol) {
        case 2 /* BROWSER_FILEREADER */: {
          const handle = BROWSER_RUNTIME._files?.get(file.fileName);
          if (!handle) {
            throw Error(`No handle available for file: ${file.fileName}`);
          }
          return 0;
        }
        case 4 /* HTTP */:
        case 5 /* S3 */:
          return new Date().getTime();
      }
      return 0;
    },
    checkDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`checkDirectory: ${path}`);
      return false;
    },
    createDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`createDirectory: ${path}`);
    },
    removeDirectory: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`removeDirectory: ${path}`);
    },
    listDirectoryEntries: (mod, pathPtr, pathLen) => {
      const path = readString(mod, pathPtr, pathLen);
      console.log(`listDirectoryEntries: ${path}`);
      return false;
    },
    moveFile: (mod, fromPtr, fromLen, toPtr, toLen) => {
      const from = readString(mod, fromPtr, fromLen);
      const to = readString(mod, toPtr, toLen);
      const handle = BROWSER_RUNTIME._files?.get(from);
      if (handle !== void 0) {
        BROWSER_RUNTIME._files.delete(handle);
        BROWSER_RUNTIME._files.set(to, handle);
      }
      for (const [key, value] of BROWSER_RUNTIME._fileInfoCache?.entries() || []) {
        if (value.dataUrl == from) {
          BROWSER_RUNTIME._fileInfoCache.delete(key);
          break;
        }
      }
      return true;
    },
    removeFile: (_mod, _pathPtr, _pathLen) => {
    },
    callScalarUDF: (mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize) => {
      callScalarUDF(BROWSER_RUNTIME, mod, response, funcId, descPtr, descSize, ptrsPtr, ptrsSize);
    }
  };
  var runtime_browser_default = BROWSER_RUNTIME;

  // src/bindings/duckdb-mvp.js
  var import_meta = {};
  var DuckDB = (() => {
    var _scriptDir = import_meta.url;
    return async function(DuckDB5 = {}) {
      var Module = typeof DuckDB5 != "undefined" ? DuckDB5 : {};
      var readyPromiseResolve, readyPromiseReject;
      Module["ready"] = new Promise((resolve, reject) => {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      ["_main", "_malloc", "_free", "_duckdb_web_clear_response", "_duckdb_web_collect_file_stats", "_duckdb_web_connect", "_duckdb_web_copy_file_to_buffer", "_duckdb_web_copy_file_to_path", "_duckdb_web_disconnect", "_duckdb_web_export_file_stats", "_duckdb_web_fail_with", "_duckdb_web_flush_file", "_duckdb_web_flush_files", "_duckdb_web_fs_drop_file", "_duckdb_web_fs_drop_files", "_duckdb_web_fs_get_file_info_by_id", "_duckdb_web_fs_get_file_info_by_name", "_duckdb_web_fs_glob_add_path", "_duckdb_web_fs_glob_file_infos", "_duckdb_web_fs_register_file_buffer", "_duckdb_web_fs_register_file_url", "_duckdb_web_get_feature_flags", "_duckdb_web_get_global_file_info", "_duckdb_web_get_tablenames", "_duckdb_web_get_version", "_duckdb_web_insert_arrow_from_ipc_stream", "_duckdb_web_insert_csv_from_path", "_duckdb_web_insert_json_from_path", "_duckdb_web_open", "_duckdb_web_pending_query_cancel", "_duckdb_web_pending_query_poll", "_duckdb_web_pending_query_start", "_duckdb_web_prepared_close", "_duckdb_web_prepared_create", "_duckdb_web_prepared_run", "_duckdb_web_prepared_send", "_duckdb_web_query_fetch_results", "_duckdb_web_query_run", "_duckdb_web_reset", "_duckdb_web_tokenize", "_duckdb_web_udf_scalar_create", "_fflush", "onRuntimeInitialized"].forEach((prop) => {
        if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) {
          Object.defineProperty(Module["ready"], prop, {
            get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
            set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
          });
        }
      });
      var moduleOverrides = Object.assign({}, Module);
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
      var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      if (Module["ENVIRONMENT"]) {
        throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
      }
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      if (ENVIRONMENT_IS_NODE) {
        if (typeof process == "undefined" || !process.release || process.release.name !== "node")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        var nodeVersion = process.versions.node;
        var numericVersion = nodeVersion.split(".").slice(0, 3);
        numericVersion = numericVersion[0] * 1e4 + numericVersion[1] * 100 + numericVersion[2].split("-")[0] * 1;
        var minVersion = 101900;
        if (numericVersion < 101900) {
          throw new Error("This emscripten-generated code requires node v10.19.19.0 (detected v" + nodeVersion + ")");
        }
        const { createRequire } = await import("module");
        var require2 = createRequire(import_meta.url);
        var fs = require2("fs");
        var nodePath = require2("path");
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = require2("url").fileURLToPath(new URL("./", import_meta.url));
        }
        read_ = (filename, binary) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          return fs.readFileSync(filename, binary ? void 0 : "utf8");
        };
        readBinary = (filename) => {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert(ret.buffer);
          return ret;
        };
        readAsync = (filename, onload, onerror, binary = true) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
            if (err2)
              onerror(err2);
            else
              onload(binary ? data.buffer : data);
          });
        };
        if (!Module["thisProgram"] && process.argv.length > 1) {
          thisProgram = process.argv[1].replace(/\\/g, "/");
        }
        arguments_ = process.argv.slice(2);
        quit_ = (status, toThrow) => {
          process.exitCode = status;
          throw toThrow;
        };
        Module["inspect"] = () => "[Emscripten Module object]";
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof process == "object" && typeof require2 === "function" || typeof window == "object" || typeof importScripts == "function")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        if (typeof read != "undefined") {
          read_ = (f) => {
            return read(f);
          };
        }
        readBinary = (f) => {
          let data;
          if (typeof readbuffer == "function") {
            return new Uint8Array(readbuffer(f));
          }
          data = read(f, "binary");
          assert(typeof data == "object");
          return data;
        };
        readAsync = (f, onload, onerror) => {
          setTimeout(() => onload(readBinary(f)), 0);
        };
        if (typeof clearTimeout == "undefined") {
          globalThis.clearTimeout = (id) => {
          };
        }
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit == "function") {
          quit_ = (status, toThrow) => {
            setTimeout(() => {
              if (!(toThrow instanceof ExitStatus)) {
                let toLog = toThrow;
                if (toThrow && typeof toThrow == "object" && toThrow.stack) {
                  toLog = [toThrow, toThrow.stack];
                }
                err(`exiting due to exception: ${toLog}`);
              }
              quit(status);
            });
            throw toThrow;
          };
        }
        if (typeof print != "undefined") {
          if (typeof console == "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        if (!(typeof window == "object" || typeof importScripts == "function"))
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        {
          read_ = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url, onload, onerror) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = (title) => document.title = title;
      } else {
        throw new Error("environment detection error");
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.error.bind(console);
      Object.assign(Module, moduleOverrides);
      moduleOverrides = null;
      checkIncomingModuleAPI();
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      legacyModuleProp("arguments", "arguments_");
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      legacyModuleProp("thisProgram", "thisProgram");
      if (Module["quit"])
        quit_ = Module["quit"];
      legacyModuleProp("quit", "quit_");
      assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
      assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
      assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
      assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
      assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
      legacyModuleProp("read", "read_");
      legacyModuleProp("readAsync", "readAsync");
      legacyModuleProp("readBinary", "readBinary");
      legacyModuleProp("setWindowTitle", "setWindowTitle");
      var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
      var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
      var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
      var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";
      assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      legacyModuleProp("wasmBinary", "wasmBinary");
      var noExitRuntime = Module["noExitRuntime"] || true;
      legacyModuleProp("noExitRuntime", "noExitRuntime");
      if (typeof WebAssembly != "object") {
        abort("no native wasm support detected");
      }
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed" + (text ? ": " + text : ""));
        }
      }
      var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateMemoryViews() {
        var b = wasmMemory.buffer;
        Module["HEAP8"] = HEAP8 = new Int8Array(b);
        Module["HEAP16"] = HEAP16 = new Int16Array(b);
        Module["HEAP32"] = HEAP32 = new Int32Array(b);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      }
      assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
      assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
      assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
      assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
      var wasmTable;
      function writeStackCookie() {
        var max = _emscripten_stack_get_end();
        assert((max & 3) == 0);
        if (max == 0) {
          max += 4;
        }
        HEAPU32[max >>> 2] = 34821223;
        HEAPU32[max + 4 >>> 2] = 2310721022;
        HEAPU32[0 >>> 2] = 1668509029;
      }
      function checkStackCookie() {
        if (ABORT)
          return;
        var max = _emscripten_stack_get_end();
        if (max == 0) {
          max += 4;
        }
        var cookie1 = HEAPU32[max >>> 2];
        var cookie2 = HEAPU32[max + 4 >>> 2];
        if (cookie1 != 34821223 || cookie2 != 2310721022) {
          abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
        }
        if (HEAPU32[0 >>> 2] != 1668509029) {
          abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
        }
      }
      (function() {
        var h16 = new Int16Array(1);
        var h8 = new Int8Array(h16.buffer);
        h16[0] = 25459;
        if (h8[0] !== 115 || h8[1] !== 99)
          throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
      })();
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATEXIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeKeepaliveCounter = 0;
      function keepRuntimeAlive() {
        return noExitRuntime || runtimeKeepaliveCounter > 0;
      }
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        assert(!runtimeInitialized);
        runtimeInitialized = true;
        checkStackCookie();
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        checkStackCookie();
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        checkStackCookie();
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnInit(cb) {
        __ATINIT__.unshift(cb);
      }
      function addOnPreMain(cb) {
        __ATMAIN__.unshift(cb);
      }
      function addOnExit(cb) {
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      var runDependencyTracking = {};
      function getUniqueRunDependency(id) {
        var orig = id;
        while (1) {
          if (!runDependencyTracking[id])
            return id;
          id = orig + Math.random();
        }
      }
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(!runDependencyTracking[id]);
          runDependencyTracking[id] = 1;
          if (runDependencyWatcher === null && typeof setInterval != "undefined") {
            runDependencyWatcher = setInterval(() => {
              if (ABORT) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
                return;
              }
              var shown = false;
              for (var dep in runDependencyTracking) {
                if (!shown) {
                  shown = true;
                  err("still waiting on run dependencies:");
                }
                err("dependency: " + dep);
              }
              if (shown) {
                err("(end of list)");
              }
            }, 1e4);
          }
        } else {
          err("warning: run dependency added without ID");
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(runDependencyTracking[id]);
          delete runDependencyTracking[id];
        } else {
          err("warning: run dependency removed without ID");
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what = "Aborted(" + what + ")";
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return filename.startsWith(dataURIPrefix);
      }
      function isFileURI(filename) {
        return filename.startsWith("file://");
      }
      function createExportWrapper(name, fixedasm) {
        return function() {
          var displayName = name;
          var asm2 = fixedasm;
          if (!fixedasm) {
            asm2 = Module["asm"];
          }
          assert(runtimeInitialized, "native function `" + displayName + "` called before runtime initialization");
          if (!asm2[name]) {
            assert(asm2[name], "exported native function `" + displayName + "` not found");
          }
          return asm2[name].apply(null, arguments);
        };
      }
      var wasmBinaryFile;
      if (Module["locateFile"]) {
        wasmBinaryFile = "./duckdb-mvp.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
      } else {
        wasmBinaryFile = new URL("./duckdb-mvp.wasm", import_meta.url).href;
      }
      function getBinary2(file) {
        try {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise(binaryFile) {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
          if (typeof fetch == "function") {
            return fetch(binaryFile, {
              credentials: "same-origin"
            }).then((response) => {
              if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + binaryFile + "'";
              }
              return response["arrayBuffer"]();
            }).catch(() => getBinary2(binaryFile));
          }
        }
        return Promise.resolve().then(() => getBinary2(binaryFile));
      }
      function instantiateArrayBuffer(binaryFile, imports, receiver) {
        return getBinaryPromise(binaryFile).then((binary) => {
          return WebAssembly.instantiate(binary, imports);
        }).then((instance9) => {
          return instance9;
        }).then(receiver, (reason) => {
          err("failed to asynchronously prepare wasm: " + reason);
          if (isFileURI(wasmBinaryFile)) {
            err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
          }
          abort(reason);
        });
      }
      function instantiateAsync(binary, binaryFile, imports, callback) {
        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
          return fetch(binaryFile, {
            credentials: "same-origin"
          }).then((response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          });
        } else {
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
      }
      function createWasm() {
        var info = {
          "env": wasmImports,
          "wasi_snapshot_preview1": wasmImports
        };
        function receiveInstance(instance9, module2) {
          var exports2 = instance9.exports;
          Module["asm"] = exports2;
          wasmMemory = Module["asm"]["memory"];
          assert(wasmMemory, "memory not found in wasm exports");
          updateMemoryViews();
          wasmTable = Module["asm"]["__indirect_function_table"];
          assert(wasmTable, "table not found in wasm exports");
          addOnInit(Module["asm"]["__wasm_call_ctors"]);
          removeRunDependency("wasm-instantiate");
          return exports2;
        }
        addRunDependency("wasm-instantiate");
        var trueModule = Module;
        function receiveInstantiationResult(result) {
          assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
          trueModule = null;
          receiveInstance(result["instance"]);
        }
        if (Module["instantiateWasm"]) {
          try {
            return Module["instantiateWasm"](info, receiveInstance);
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            readyPromiseReject(e);
          }
        }
        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
        return {};
      }
      var tempDouble;
      var tempI64;
      function legacyModuleProp(prop, newName) {
        if (!Object.getOwnPropertyDescriptor(Module, prop)) {
          Object.defineProperty(Module, prop, {
            configurable: true,
            get: function() {
              abort("Module." + prop + " has been replaced with plain " + newName + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
            }
          });
        }
      }
      function ignoredModuleProp(prop) {
        if (Object.getOwnPropertyDescriptor(Module, prop)) {
          abort("`Module." + prop + "` was supplied but `" + prop + "` not included in INCOMING_MODULE_JS_API");
        }
      }
      function isExportedByForceFilesystem(name) {
        return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
      }
      function missingGlobal(sym, msg) {
        if (typeof globalThis !== "undefined") {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
              return void 0;
            }
          });
        }
      }
      missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
      function missingLibrarySymbol(sym) {
        if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
              var librarySymbol = sym;
              if (!librarySymbol.startsWith("_")) {
                librarySymbol = "$" + sym;
              }
              msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              warnOnce(msg);
              return void 0;
            }
          });
        }
        unexportedRuntimeSymbol(sym);
      }
      function unexportedRuntimeSymbol(sym) {
        if (!Object.getOwnPropertyDescriptor(Module, sym)) {
          Object.defineProperty(Module, sym, {
            configurable: true,
            get: function() {
              var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              abort(msg);
            }
          });
        }
      }
      function dbg(text) {
        console.warn.apply(console, arguments);
      }
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          callbacks.shift()(Module);
        }
      }
      function getValue2(ptr, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            return HEAP8[ptr >>> 0];
          case "i8":
            return HEAP8[ptr >>> 0];
          case "i16":
            return HEAP16[ptr >>> 1];
          case "i32":
            return HEAP32[ptr >>> 2];
          case "i64":
            abort("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return HEAPF32[ptr >>> 2];
          case "double":
            return HEAPF64[ptr >>> 3];
          case "*":
            return HEAPU32[ptr >>> 2];
          default:
            abort(`invalid type for getValue: ${type}`);
        }
      }
      function ptrToString(ptr) {
        assert(typeof ptr === "number");
        return "0x" + ptr.toString(16).padStart(8, "0");
      }
      function setValue(ptr, value, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i8":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i16":
            HEAP16[ptr >>> 1] = value;
            break;
          case "i32":
            HEAP32[ptr >>> 2] = value;
            break;
          case "i64":
            abort("to do setValue(i64) use WASM_BIGINT");
          case "float":
            HEAPF32[ptr >>> 2] = value;
            break;
          case "double":
            HEAPF64[ptr >>> 3] = value;
            break;
          case "*":
            HEAPU32[ptr >>> 2] = value;
            break;
          default:
            abort(`invalid type for setValue: ${type}`);
        }
      }
      function warnOnce(text) {
        if (!warnOnce.shown)
          warnOnce.shown = {};
        if (!warnOnce.shown[text]) {
          warnOnce.shown[text] = 1;
          if (ENVIRONMENT_IS_NODE)
            text = "warning: " + text;
          err(text);
        }
      }
      function _XML_GetBuffer() {
        err("missing function: XML_GetBuffer");
        abort(-1);
      }
      function _XML_GetErrorCode() {
        err("missing function: XML_GetErrorCode");
        abort(-1);
      }
      function _XML_Parse() {
        err("missing function: XML_Parse");
        abort(-1);
      }
      function _XML_ParseBuffer() {
        err("missing function: XML_ParseBuffer");
        abort(-1);
      }
      function _XML_ParserCreate() {
        err("missing function: XML_ParserCreate");
        abort(-1);
      }
      function _XML_ParserFree() {
        err("missing function: XML_ParserFree");
        abort(-1);
      }
      function _XML_ResumeParser() {
        err("missing function: XML_ResumeParser");
        abort(-1);
      }
      function _XML_SetCharacterDataHandler() {
        err("missing function: XML_SetCharacterDataHandler");
        abort(-1);
      }
      function _XML_SetElementHandler() {
        err("missing function: XML_SetElementHandler");
        abort(-1);
      }
      function _XML_SetUserData() {
        err("missing function: XML_SetUserData");
        abort(-1);
      }
      function _XML_StopParser() {
        err("missing function: XML_StopParser");
        abort(-1);
      }
      function ExceptionInfo(excPtr) {
        this.excPtr = excPtr;
        this.ptr = excPtr - 24;
        this.set_type = function(type) {
          HEAPU32[this.ptr + 4 >>> 2] = type;
        };
        this.get_type = function() {
          return HEAPU32[this.ptr + 4 >>> 2];
        };
        this.set_destructor = function(destructor) {
          HEAPU32[this.ptr + 8 >>> 2] = destructor;
        };
        this.get_destructor = function() {
          return HEAPU32[this.ptr + 8 >>> 2];
        };
        this.set_caught = function(caught) {
          caught = caught ? 1 : 0;
          HEAP8[this.ptr + 12 >>> 0] = caught;
        };
        this.get_caught = function() {
          return HEAP8[this.ptr + 12 >>> 0] != 0;
        };
        this.set_rethrown = function(rethrown) {
          rethrown = rethrown ? 1 : 0;
          HEAP8[this.ptr + 13 >>> 0] = rethrown;
        };
        this.get_rethrown = function() {
          return HEAP8[this.ptr + 13 >>> 0] != 0;
        };
        this.init = function(type, destructor) {
          this.set_adjusted_ptr(0);
          this.set_type(type);
          this.set_destructor(destructor);
        };
        this.set_adjusted_ptr = function(adjustedPtr) {
          HEAPU32[this.ptr + 16 >>> 2] = adjustedPtr;
        };
        this.get_adjusted_ptr = function() {
          return HEAPU32[this.ptr + 16 >>> 2];
        };
        this.get_exception_ptr = function() {
          var isPointer = ___cxa_is_pointer_type(this.get_type());
          if (isPointer) {
            return HEAPU32[this.excPtr >>> 2];
          }
          var adjusted = this.get_adjusted_ptr();
          if (adjusted !== 0)
            return adjusted;
          return this.excPtr;
        };
      }
      var exceptionLast = 0;
      var uncaughtExceptionCount = 0;
      function ___cxa_throw(ptr, type, destructor) {
        var info = new ExceptionInfo(ptr);
        info.init(type, destructor);
        exceptionLast = ptr;
        uncaughtExceptionCount++;
        assert(false, "Exception thrown, but exception catching is not enabled. Compile with -sNO_DISABLE_EXCEPTION_CATCHING or -sEXCEPTION_CATCHING_ALLOWED=[..] to catch.");
      }
      var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html";
      function ___dlsym(handle, symbol, ra) {
        abort(dlopenMissingError);
      }
      var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
        idx >>>= 0;
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
          return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = "";
        while (idx < endPtr) {
          var u0 = heapOrArray[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heapOrArray[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heapOrArray[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            if ((u0 & 248) != 240)
              warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        assert(typeof ptr == "number");
        ptr >>>= 0;
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      var SYSCALLS = {
        varargs: void 0,
        get: function() {
          assert(SYSCALLS.varargs != void 0);
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        },
        getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }
      };
      function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
        assert(nfds <= 64, "nfds must be less than or equal to 64");
        assert(!exceptfds, "exceptfds not supported");
        var total = 0;
        var srcReadLow = readfds ? HEAP32[readfds >>> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2] : 0;
        var srcWriteLow = writefds ? HEAP32[writefds >>> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2] : 0;
        var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0;
        var dstReadLow = 0, dstReadHigh = 0;
        var dstWriteLow = 0, dstWriteHigh = 0;
        var dstExceptLow = 0, dstExceptHigh = 0;
        var allLow = (readfds ? HEAP32[readfds >>> 2] : 0) | (writefds ? HEAP32[writefds >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2] : 0);
        var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0);
        var check = function(fd2, low, high, val) {
          return fd2 < 32 ? low & val : high & val;
        };
        for (var fd = 0; fd < nfds; fd++) {
          var mask = 1 << fd % 32;
          if (!check(fd, allLow, allHigh, mask)) {
            continue;
          }
          var stream = SYSCALLS.getStreamFromFD(fd);
          var flags = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            flags = stream.stream_ops.poll(stream);
          }
          if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
            fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
            total++;
          }
          if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
            fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
            total++;
          }
          if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
            fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
            total++;
          }
        }
        if (readfds) {
          HEAP32[readfds >>> 2] = dstReadLow;
          HEAP32[readfds + 4 >>> 2] = dstReadHigh;
        }
        if (writefds) {
          HEAP32[writefds >>> 2] = dstWriteLow;
          HEAP32[writefds + 4 >>> 2] = dstWriteHigh;
        }
        if (exceptfds) {
          HEAP32[exceptfds >>> 2] = dstExceptLow;
          HEAP32[exceptfds + 4 >>> 2] = dstExceptHigh;
        }
        return total;
      }
      function SOCKFS() {
        err("missing function: $SOCKFS");
        abort(-1);
      }
      function FS() {
        err("missing function: $FS");
        abort(-1);
      }
      function getSocketFromFD(fd) {
        var socket = SOCKFS.getSocket(fd);
        if (!socket)
          throw new FS.ErrnoError(8);
        return socket;
      }
      function setErrNo(value) {
        HEAP32[___errno_location() >>> 2] = value;
        return value;
      }
      var Sockets = {
        BUFFER_SIZE: 10240,
        MAX_BUFFER_SIZE: 10485760,
        nextFd: 1,
        fds: {},
        nextport: 1,
        maxport: 65535,
        peer: null,
        connections: {},
        portmap: {},
        localAddr: 4261412874,
        addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
      };
      function inetNtop4(addr) {
        return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
      }
      function inetNtop6(ints) {
        var str = "";
        var word = 0;
        var longest = 0;
        var lastzero = 0;
        var zstart = 0;
        var len = 0;
        var i = 0;
        var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
        var hasipv4 = true;
        var v4part = "";
        for (i = 0; i < 5; i++) {
          if (parts[i] !== 0) {
            hasipv4 = false;
            break;
          }
        }
        if (hasipv4) {
          v4part = inetNtop4(parts[6] | parts[7] << 16);
          if (parts[5] === -1) {
            str = "::ffff:";
            str += v4part;
            return str;
          }
          if (parts[5] === 0) {
            str = "::";
            if (v4part === "0.0.0.0")
              v4part = "";
            if (v4part === "0.0.0.1")
              v4part = "1";
            str += v4part;
            return str;
          }
        }
        for (word = 0; word < 8; word++) {
          if (parts[word] === 0) {
            if (word - lastzero > 1) {
              len = 0;
            }
            lastzero = word;
            len++;
          }
          if (len > longest) {
            longest = len;
            zstart = word - longest + 1;
          }
        }
        for (word = 0; word < 8; word++) {
          if (longest > 1) {
            if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
              if (word === zstart) {
                str += ":";
                if (zstart === 0)
                  str += ":";
              }
              continue;
            }
          }
          str += Number(_ntohs(parts[word] & 65535)).toString(16);
          str += word < 7 ? ":" : "";
        }
        return str;
      }
      function readSockaddr(sa, salen) {
        var family = HEAP16[sa >>> 1];
        var port = _ntohs(HEAPU16[sa + 2 >>> 1]);
        var addr;
        switch (family) {
          case 2:
            if (salen !== 16) {
              return {
                errno: 28
              };
            }
            addr = HEAP32[sa + 4 >>> 2];
            addr = inetNtop4(addr);
            break;
          case 10:
            if (salen !== 28) {
              return {
                errno: 28
              };
            }
            addr = [HEAP32[sa + 8 >>> 2], HEAP32[sa + 12 >>> 2], HEAP32[sa + 16 >>> 2], HEAP32[sa + 20 >>> 2]];
            addr = inetNtop6(addr);
            break;
          default:
            return {
              errno: 5
            };
        }
        return {
          family,
          addr,
          port
        };
      }
      function inetPton4(str) {
        var b = str.split(".");
        for (var i = 0; i < 4; i++) {
          var tmp2 = Number(b[i]);
          if (isNaN(tmp2))
            return null;
          b[i] = tmp2;
        }
        return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
      }
      function jstoi_q(str) {
        return parseInt(str);
      }
      function inetPton6(str) {
        var words;
        var w, offset, z, i;
        var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
        var parts = [];
        if (!valid6regx.test(str)) {
          return null;
        }
        if (str === "::") {
          return [0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (str.startsWith("::")) {
          str = str.replace("::", "Z:");
        } else {
          str = str.replace("::", ":Z:");
        }
        if (str.indexOf(".") > 0) {
          str = str.replace(new RegExp("[.]", "g"), ":");
          words = str.split(":");
          words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
          words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
          words = words.slice(0, words.length - 2);
        } else {
          words = str.split(":");
        }
        offset = 0;
        z = 0;
        for (w = 0; w < words.length; w++) {
          if (typeof words[w] == "string") {
            if (words[w] === "Z") {
              for (z = 0; z < 8 - words.length + 1; z++) {
                parts[w + z] = 0;
              }
              offset = z - 1;
            } else {
              parts[w + offset] = _htons(parseInt(words[w], 16));
            }
          } else {
            parts[w + offset] = words[w];
          }
        }
        return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
      }
      var DNS = {
        address_map: {
          id: 1,
          addrs: {},
          names: {}
        },
        lookup_name: function(name) {
          var res = inetPton4(name);
          if (res !== null) {
            return name;
          }
          res = inetPton6(name);
          if (res !== null) {
            return name;
          }
          var addr;
          if (DNS.address_map.addrs[name]) {
            addr = DNS.address_map.addrs[name];
          } else {
            var id = DNS.address_map.id++;
            assert(id < 65535, "exceeded max address mappings of 65535");
            addr = "172.29." + (id & 255) + "." + (id & 65280);
            DNS.address_map.names[addr] = name;
            DNS.address_map.addrs[name] = addr;
          }
          return addr;
        },
        lookup_addr: function(addr) {
          if (DNS.address_map.names[addr]) {
            return DNS.address_map.names[addr];
          }
          return null;
        }
      };
      function getSocketAddress(addrp, addrlen, allowNull) {
        if (allowNull && addrp === 0)
          return null;
        var info = readSockaddr(addrp, addrlen);
        if (info.errno)
          throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      }
      function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.bind(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.connect(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_faccessat(dirfd, path, amode, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_fcntl64(fd, cmd, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_fstat64(fd, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function convertI32PairToI53Checked(lo, hi) {
        assert(lo == lo >>> 0 || lo == (lo | 0));
        assert(hi === (hi | 0));
        return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
      }
      function ___syscall_ftruncate64(fd, length_low, length_high) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
        outIdx >>>= 0;
        assert(typeof str === "string");
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++ >>> 0] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 192 | u >> 6;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 224 | u >> 12;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            if (u > 1114111)
              warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
            heap[outIdx++ >>> 0] = 240 | u >> 18;
            heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          }
        }
        heap[outIdx >>> 0] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      function ___syscall_getdents64(fd, dirp, count) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function zeroMemory(address, size) {
        HEAPU8.fill(0, address, address + size);
        return address;
      }
      function writeSockaddr(sa, family, addr, port, addrlen) {
        switch (family) {
          case 2:
            addr = inetPton4(addr);
            zeroMemory(sa, 16);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 16;
            }
            HEAP16[sa >>> 1] = family;
            HEAP32[sa + 4 >>> 2] = addr;
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          case 10:
            addr = inetPton6(addr);
            zeroMemory(sa, 28);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 28;
            }
            HEAP32[sa >>> 2] = family;
            HEAP32[sa + 8 >>> 2] = addr[0];
            HEAP32[sa + 12 >>> 2] = addr[1];
            HEAP32[sa + 16 >>> 2] = addr[2];
            HEAP32[sa + 20 >>> 2] = addr[3];
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          default:
            return 5;
        }
        return 0;
      }
      function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        if (!sock.daddr) {
          return -53;
        }
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
        assert(!errno);
        return 0;
      }
      function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
        var sock = getSocketFromFD(fd);
        if (level === 1) {
          if (optname === 4) {
            HEAP32[optval >>> 2] = sock.error;
            HEAP32[optlen >>> 2] = 4;
            sock.error = null;
            return 0;
          }
        }
        return -50;
      }
      function ___syscall_ioctl(fd, op, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_lstat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_mkdirat(dirfd, path, mode) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_newfstatat(dirfd, path, buf, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_openat(dirfd, path, flags, varargs) {
        SYSCALLS.varargs = varargs;
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
        var sock = getSocketFromFD(fd);
        var msg = sock.sock_ops.recvmsg(sock, len);
        if (!msg)
          return 0;
        if (addr) {
          var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
          assert(!errno);
        }
        HEAPU8.set(msg.buffer, buf >>> 0);
        return msg.buffer.byteLength;
      }
      function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_rmdir(path) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_socket(domain, type, protocol) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_stat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_unlinkat(dirfd, path, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      var nowIsMonotonic = true;
      function __emscripten_get_now_is_monotonic() {
        return nowIsMonotonic;
      }
      function readI53FromI64(ptr) {
        return HEAPU32[ptr >>> 2] + HEAP32[ptr + 4 >>> 2] * 4294967296;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      function ydayFromDate(date) {
        var leap = isLeapYear(date.getFullYear());
        var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
        var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
        return yday;
      }
      function __localtime_js(time, tmPtr) {
        var date = new Date(readI53FromI64(time) * 1e3);
        HEAP32[tmPtr >>> 2] = date.getSeconds();
        HEAP32[tmPtr + 4 >>> 2] = date.getMinutes();
        HEAP32[tmPtr + 8 >>> 2] = date.getHours();
        HEAP32[tmPtr + 12 >>> 2] = date.getDate();
        HEAP32[tmPtr + 16 >>> 2] = date.getMonth();
        HEAP32[tmPtr + 20 >>> 2] = date.getFullYear() - 1900;
        HEAP32[tmPtr + 24 >>> 2] = date.getDay();
        var yday = ydayFromDate(date) | 0;
        HEAP32[tmPtr + 28 >>> 2] = yday;
        HEAP32[tmPtr + 36 >>> 2] = -(date.getTimezoneOffset() * 60);
        var start = new Date(date.getFullYear(), 0, 1);
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var winterOffset = start.getTimezoneOffset();
        var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
        HEAP32[tmPtr + 32 >>> 2] = dst;
      }
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var c = str.charCodeAt(i);
          if (c <= 127) {
            len++;
          } else if (c <= 2047) {
            len += 2;
          } else if (c >= 55296 && c <= 57343) {
            len += 4;
            ++i;
          } else {
            len += 3;
          }
        }
        return len;
      }
      function stringToNewUTF8(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = _malloc(size);
        if (ret)
          stringToUTF8(str, ret, size);
        return ret;
      }
      function __tzset_js(timezone, daylight, tzname) {
        var currentYear = new Date().getFullYear();
        var winter = new Date(currentYear, 0, 1);
        var summer = new Date(currentYear, 6, 1);
        var winterOffset = winter.getTimezoneOffset();
        var summerOffset = summer.getTimezoneOffset();
        var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
        HEAPU32[timezone >>> 2] = stdTimezoneOffset * 60;
        HEAP32[daylight >>> 2] = Number(winterOffset != summerOffset);
        function extractZone(date) {
          var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
          return match ? match[1] : "GMT";
        }
        var winterName = extractZone(winter);
        var summerName = extractZone(summer);
        var winterNamePtr = stringToNewUTF8(winterName);
        var summerNamePtr = stringToNewUTF8(summerName);
        if (summerOffset < winterOffset) {
          HEAPU32[tzname >>> 2] = winterNamePtr;
          HEAPU32[tzname + 4 >>> 2] = summerNamePtr;
        } else {
          HEAPU32[tzname >>> 2] = summerNamePtr;
          HEAPU32[tzname + 4 >>> 2] = winterNamePtr;
        }
      }
      function _abort() {
        abort("native code called abort()");
      }
      function _dlopen(filename, flags) {
        abort(dlopenMissingError);
      }
      function _duckdb_web_fs_directory_create(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_list_files(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_remove(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_close(fileId) {
        return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
      }
      function _duckdb_web_fs_file_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_get_last_modified_time(fileId) {
        return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
      }
      function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
        return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
      }
      function _duckdb_web_fs_file_open(fileId, flags) {
        return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags);
      }
      function _duckdb_web_fs_file_read(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_file_truncate(fileId, newSize) {
        return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
      }
      function _duckdb_web_fs_file_write(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_get_default_data_protocol(Module2) {
        return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
      }
      function _duckdb_web_fs_glob(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
      }
      function _duckdb_web_test_platform_feature(feature) {
        return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
      }
      function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
        return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
      }
      function _emscripten_console_error(str) {
        assert(typeof str == "number");
        console.error(UTF8ToString(str));
      }
      function _emscripten_date_now() {
        return Date.now();
      }
      function getHeapMax() {
        return 4294901760;
      }
      function _emscripten_get_heap_max() {
        return getHeapMax();
      }
      var _emscripten_get_now;
      if (ENVIRONMENT_IS_NODE) {
        global.performance = require2("perf_hooks").performance;
      }
      _emscripten_get_now = () => performance.now();
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
      }
      function emscripten_realloc_buffer(size) {
        var b = wasmMemory.buffer;
        var pages = size - b.byteLength + 65535 >>> 16;
        try {
          wasmMemory.grow(pages);
          updateMemoryViews();
          return 1;
        } catch (e) {
          err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        assert(requestedSize > oldSize);
        var maxHeapSize = getHeapMax();
        if (requestedSize > maxHeapSize) {
          err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
          return false;
        }
        var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
        return false;
      }
      var ENV = {};
      function getExecutableName() {
        return thisProgram || "./this.program";
      }
      function getEnvStrings() {
        if (!getEnvStrings.strings) {
          var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
          var env = {
            "USER": "web_user",
            "LOGNAME": "web_user",
            "PATH": "/",
            "PWD": "/",
            "HOME": "/home/web_user",
            "LANG": lang,
            "_": getExecutableName()
          };
          for (var x in ENV) {
            if (ENV[x] === void 0)
              delete env[x];
            else
              env[x] = ENV[x];
          }
          var strings = [];
          for (var x in env) {
            strings.push(`${x}=${env[x]}`);
          }
          getEnvStrings.strings = strings;
        }
        return getEnvStrings.strings;
      }
      function stringToAscii(str, buffer) {
        for (var i = 0; i < str.length; ++i) {
          assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));
          HEAP8[buffer++ >>> 0] = str.charCodeAt(i);
        }
        HEAP8[buffer >>> 0] = 0;
      }
      function _environ_get(__environ, environ_buf) {
        var bufSize = 0;
        getEnvStrings().forEach(function(string, i) {
          var ptr = environ_buf + bufSize;
          HEAPU32[__environ + i * 4 >>> 2] = ptr;
          stringToAscii(string, ptr);
          bufSize += string.length + 1;
        });
        return 0;
      }
      function _environ_sizes_get(penviron_count, penviron_buf_size) {
        var strings = getEnvStrings();
        HEAPU32[penviron_count >>> 2] = strings.length;
        var bufSize = 0;
        strings.forEach(function(string) {
          bufSize += string.length + 1;
        });
        HEAPU32[penviron_buf_size >>> 2] = bufSize;
        return 0;
      }
      function _fd_close(fd) {
        abort("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_fdstat_get(fd, pbuf) {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          assert(fd == 0 || fd == 1 || fd == 2);
          var type = 2;
          if (fd == 0) {
            rightsBase = 2;
          } else if (fd == 1 || fd == 2) {
            rightsBase = 64;
          }
          flags = 1;
        }
        HEAP8[pbuf >>> 0] = type;
        HEAP16[pbuf + 2 >>> 1] = flags;
        tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2] = tempI64[0], HEAP32[pbuf + 12 >>> 2] = tempI64[1];
        tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2] = tempI64[0], HEAP32[pbuf + 20 >>> 2] = tempI64[1];
        return 0;
      }
      function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pread called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pwrite called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_read(fd, iov, iovcnt, pnum) {
        abort("fd_read called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        return 70;
      }
      function _fd_sync(fd) {
        abort("fd_sync called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      var printCharBuffers = [null, [], []];
      function printChar(stream, curr) {
        var buffer = printCharBuffers[stream];
        assert(buffer);
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      }
      function flush_NO_FILESYSTEM() {
        _fflush(0);
        if (printCharBuffers[1].length)
          printChar(1, 10);
        if (printCharBuffers[2].length)
          printChar(2, 10);
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        var num = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAPU32[iov >>> 2];
          var len = HEAPU32[iov + 4 >>> 2];
          iov += 8;
          for (var j = 0; j < len; j++) {
            printChar(fd, HEAPU8[ptr + j >>> 0]);
          }
          num += len;
        }
        HEAPU32[pnum >>> 2] = num;
        return 0;
      }
      function _getaddrinfo(node, service, hint, out2) {
        var addrs = [];
        var canon = null;
        var addr = 0;
        var port = 0;
        var flags = 0;
        var family = 0;
        var type = 0;
        var proto = 0;
        var ai, last;
        function allocaddrinfo(family2, type2, proto2, canon2, addr2, port2) {
          var sa, salen, ai2;
          var errno;
          salen = family2 === 10 ? 28 : 16;
          addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
          sa = _malloc(salen);
          errno = writeSockaddr(sa, family2, addr2, port2);
          assert(!errno);
          ai2 = _malloc(32);
          HEAP32[ai2 + 4 >>> 2] = family2;
          HEAP32[ai2 + 8 >>> 2] = type2;
          HEAP32[ai2 + 12 >>> 2] = proto2;
          HEAPU32[ai2 + 24 >>> 2] = canon2;
          HEAPU32[ai2 + 20 >>> 2] = sa;
          if (family2 === 10) {
            HEAP32[ai2 + 16 >>> 2] = 28;
          } else {
            HEAP32[ai2 + 16 >>> 2] = 16;
          }
          HEAP32[ai2 + 28 >>> 2] = 0;
          return ai2;
        }
        if (hint) {
          flags = HEAP32[hint >>> 2];
          family = HEAP32[hint + 4 >>> 2];
          type = HEAP32[hint + 8 >>> 2];
          proto = HEAP32[hint + 12 >>> 2];
        }
        if (type && !proto) {
          proto = type === 2 ? 17 : 6;
        }
        if (!type && proto) {
          type = proto === 17 ? 2 : 1;
        }
        if (proto === 0) {
          proto = 6;
        }
        if (type === 0) {
          type = 1;
        }
        if (!node && !service) {
          return -2;
        }
        if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
          return -1;
        }
        if (hint !== 0 && HEAP32[hint >>> 2] & 2 && !node) {
          return -1;
        }
        if (flags & 32) {
          return -2;
        }
        if (type !== 0 && type !== 1 && type !== 2) {
          return -7;
        }
        if (family !== 0 && family !== 2 && family !== 10) {
          return -6;
        }
        if (service) {
          service = UTF8ToString(service);
          port = parseInt(service, 10);
          if (isNaN(port)) {
            if (flags & 1024) {
              return -2;
            }
            return -8;
          }
        }
        if (!node) {
          if (family === 0) {
            family = 2;
          }
          if ((flags & 1) === 0) {
            if (family === 2) {
              addr = _htonl(2130706433);
            } else {
              addr = [0, 0, 0, 1];
            }
          }
          ai = allocaddrinfo(family, type, proto, null, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        node = UTF8ToString(node);
        addr = inetPton4(node);
        if (addr !== null) {
          if (family === 0 || family === 2) {
            family = 2;
          } else if (family === 10 && flags & 8) {
            addr = [0, 0, _htonl(65535), addr];
            family = 10;
          } else {
            return -2;
          }
        } else {
          addr = inetPton6(node);
          if (addr !== null) {
            if (family === 0 || family === 10) {
              family = 10;
            } else {
              return -2;
            }
          }
        }
        if (addr != null) {
          ai = allocaddrinfo(family, type, proto, node, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        if (flags & 4) {
          return -2;
        }
        node = DNS.lookup_name(node);
        addr = inetPton4(node);
        if (family === 0) {
          family = 2;
        } else if (family === 10) {
          addr = [0, 0, _htonl(65535), addr];
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAPU32[out2 >>> 2] = ai;
        return 0;
      }
      function initRandomFill() {
        if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
          return (view) => crypto.getRandomValues(view);
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = require2("crypto");
            var randomFillSync = crypto_module["randomFillSync"];
            if (randomFillSync) {
              return (view) => crypto_module["randomFillSync"](view);
            }
            var randomBytes = crypto_module["randomBytes"];
            return (view) => (view.set(randomBytes(view.byteLength)), view);
          } catch (e) {
          }
        }
        abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
      }
      function randomFill(view) {
        return (randomFill = initRandomFill())(view);
      }
      function _getentropy(buffer, size) {
        randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
        return 0;
      }
      function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
        var info = readSockaddr(sa, salen);
        if (info.errno) {
          return -6;
        }
        var port = info.port;
        var addr = info.addr;
        var overflowed = false;
        if (node && nodelen) {
          var lookup;
          if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
            if (flags & 8) {
              return -2;
            }
          } else {
            addr = lookup;
          }
          var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
          if (numBytesWrittenExclNull + 1 >= nodelen) {
            overflowed = true;
          }
        }
        if (serv && servlen) {
          port = "" + port;
          var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
          if (numBytesWrittenExclNull + 1 >= servlen) {
            overflowed = true;
          }
        }
        if (overflowed) {
          return -12;
        }
        return 0;
      }
      function arraySum(array, index) {
        var sum2 = 0;
        for (var i = 0; i <= index; sum2 += array[i++]) {
        }
        return sum2;
      }
      var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function addDays(date, days) {
        var newDate = new Date(date.getTime());
        while (days > 0) {
          var leap = isLeapYear(newDate.getFullYear());
          var currentMonth = newDate.getMonth();
          var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
          if (days > daysInCurrentMonth - newDate.getDate()) {
            days -= daysInCurrentMonth - newDate.getDate() + 1;
            newDate.setDate(1);
            if (currentMonth < 11) {
              newDate.setMonth(currentMonth + 1);
            } else {
              newDate.setMonth(0);
              newDate.setFullYear(newDate.getFullYear() + 1);
            }
          } else {
            newDate.setDate(newDate.getDate() + days);
            return newDate;
          }
        }
        return newDate;
      }
      function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull)
          u8array.length = numBytesWritten;
        return u8array;
      }
      function writeArrayToMemory(array, buffer) {
        assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
        HEAP8.set(array, buffer >>> 0);
      }
      function _strftime(s, maxsize, format, tm) {
        var tm_zone = HEAP32[tm + 40 >>> 2];
        var date = {
          tm_sec: HEAP32[tm >>> 2],
          tm_min: HEAP32[tm + 4 >>> 2],
          tm_hour: HEAP32[tm + 8 >>> 2],
          tm_mday: HEAP32[tm + 12 >>> 2],
          tm_mon: HEAP32[tm + 16 >>> 2],
          tm_year: HEAP32[tm + 20 >>> 2],
          tm_wday: HEAP32[tm + 24 >>> 2],
          tm_yday: HEAP32[tm + 28 >>> 2],
          tm_isdst: HEAP32[tm + 32 >>> 2],
          tm_gmtoff: HEAP32[tm + 36 >>> 2],
          tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
        };
        var pattern = UTF8ToString(format);
        var EXPANSION_RULES_1 = {
          "%c": "%a %b %d %H:%M:%S %Y",
          "%D": "%m/%d/%y",
          "%F": "%Y-%m-%d",
          "%h": "%b",
          "%r": "%I:%M:%S %p",
          "%R": "%H:%M",
          "%T": "%H:%M:%S",
          "%x": "%m/%d/%y",
          "%X": "%H:%M:%S",
          "%Ec": "%c",
          "%EC": "%C",
          "%Ex": "%m/%d/%y",
          "%EX": "%H:%M:%S",
          "%Ey": "%y",
          "%EY": "%Y",
          "%Od": "%d",
          "%Oe": "%e",
          "%OH": "%H",
          "%OI": "%I",
          "%Om": "%m",
          "%OM": "%M",
          "%OS": "%S",
          "%Ou": "%u",
          "%OU": "%U",
          "%OV": "%V",
          "%Ow": "%w",
          "%OW": "%W",
          "%Oy": "%y"
        };
        for (var rule in EXPANSION_RULES_1) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
        }
        var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        function leadingSomething(value, digits, character) {
          var str = typeof value == "number" ? value.toString() : value || "";
          while (str.length < digits) {
            str = character[0] + str;
          }
          return str;
        }
        function leadingNulls(value, digits) {
          return leadingSomething(value, digits, "0");
        }
        function compareByDay(date1, date2) {
          function sgn(value) {
            return value < 0 ? -1 : value > 0 ? 1 : 0;
          }
          var compare;
          if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
              compare = sgn(date1.getDate() - date2.getDate());
            }
          }
          return compare;
        }
        function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0:
              return new Date(janFourth.getFullYear() - 1, 11, 29);
            case 1:
              return janFourth;
            case 2:
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3:
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4:
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5:
              return new Date(janFourth.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(janFourth.getFullYear() - 1, 11, 30);
          }
        }
        function getWeekBasedYear(date2) {
          var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear() + 1;
            }
            return thisDate.getFullYear();
          }
          return thisDate.getFullYear() - 1;
        }
        var EXPANSION_RULES_2 = {
          "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          },
          "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          },
          "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          },
          "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          },
          "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          },
          "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          },
          "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          },
          "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          },
          "%G": function(date2) {
            return getWeekBasedYear(date2);
          },
          "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          },
          "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          },
          "%j": function(date2) {
            return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          },
          "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          },
          "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          },
          "%n": function() {
            return "\n";
          },
          "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            }
            return "PM";
          },
          "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          },
          "%t": function() {
            return "	";
          },
          "%u": function(date2) {
            return date2.tm_wday || 7;
          },
          "%U": function(date2) {
            var days = date2.tm_yday + 7 - date2.tm_wday;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%V": function(date2) {
            var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
            if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
              val++;
            }
            if (!val) {
              val = 52;
              var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
              if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                val++;
              }
            } else if (val == 53) {
              var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
              if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                val = 1;
            }
            return leadingNulls(val, 2);
          },
          "%w": function(date2) {
            return date2.tm_wday;
          },
          "%W": function(date2) {
            var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          },
          "%Y": function(date2) {
            return date2.tm_year + 1900;
          },
          "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          },
          "%Z": function(date2) {
            return date2.tm_zone;
          },
          "%%": function() {
            return "%";
          }
        };
        pattern = pattern.replace(/%%/g, "\0\0");
        for (var rule in EXPANSION_RULES_2) {
          if (pattern.includes(rule)) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
          }
        }
        pattern = pattern.replace(/\0\0/g, "%");
        var bytes = intArrayFromString(pattern, false);
        if (bytes.length > maxsize) {
          return 0;
        }
        writeArrayToMemory(bytes, s);
        return bytes.length - 1;
      }
      function _strftime_l(s, maxsize, format, tm, loc) {
        return _strftime(s, maxsize, format, tm);
      }
      function _ucnv_close_64() {
        err("missing function: ucnv_close_64");
        abort(-1);
      }
      function _ucnv_convertEx_64() {
        err("missing function: ucnv_convertEx_64");
        abort(-1);
      }
      function _ucnv_open_64() {
        err("missing function: ucnv_open_64");
        abort(-1);
      }
      function _ucnv_toAlgorithmic_64() {
        err("missing function: ucnv_toAlgorithmic_64");
        abort(-1);
      }
      function _ucsdet_close_64() {
        err("missing function: ucsdet_close_64");
        abort(-1);
      }
      function _ucsdet_detect_64() {
        err("missing function: ucsdet_detect_64");
        abort(-1);
      }
      function _ucsdet_getConfidence_64() {
        err("missing function: ucsdet_getConfidence_64");
        abort(-1);
      }
      function _ucsdet_getName_64() {
        err("missing function: ucsdet_getName_64");
        abort(-1);
      }
      function _ucsdet_open_64() {
        err("missing function: ucsdet_open_64");
        abort(-1);
      }
      function _ucsdet_setText_64() {
        err("missing function: ucsdet_setText_64");
        abort(-1);
      }
      function _unzClose() {
        err("missing function: unzClose");
        abort(-1);
      }
      function _unzCloseCurrentFile() {
        err("missing function: unzCloseCurrentFile");
        abort(-1);
      }
      function _unzGetCurrentFileInfo() {
        err("missing function: unzGetCurrentFileInfo");
        abort(-1);
      }
      function _unzGetCurrentFileInfo64() {
        err("missing function: unzGetCurrentFileInfo64");
        abort(-1);
      }
      function _unzGetGlobalInfo() {
        err("missing function: unzGetGlobalInfo");
        abort(-1);
      }
      function _unzGoToFirstFile() {
        err("missing function: unzGoToFirstFile");
        abort(-1);
      }
      function _unzGoToNextFile() {
        err("missing function: unzGoToNextFile");
        abort(-1);
      }
      function _unzLocateFile() {
        err("missing function: unzLocateFile");
        abort(-1);
      }
      function _unzOpen() {
        err("missing function: unzOpen");
        abort(-1);
      }
      function _unzOpen2() {
        err("missing function: unzOpen2");
        abort(-1);
      }
      function _unzOpenCurrentFile() {
        err("missing function: unzOpenCurrentFile");
        abort(-1);
      }
      function _unzReadCurrentFile() {
        err("missing function: unzReadCurrentFile");
        abort(-1);
      }
      function _proc_exit(code) {
        EXITSTATUS = code;
        if (!keepRuntimeAlive()) {
          if (Module["onExit"])
            Module["onExit"](code);
          ABORT = true;
        }
        quit_(code, new ExitStatus(code));
      }
      function exitJS(status, implicit) {
        EXITSTATUS = status;
        checkUnflushedContent();
        if (keepRuntimeAlive() && !implicit) {
          var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
          readyPromiseReject(msg);
          err(msg);
        }
        _proc_exit(status);
      }
      function handleException(e) {
        if (e instanceof ExitStatus || e == "unwind") {
          return EXITSTATUS;
        }
        checkStackCookie();
        if (e instanceof WebAssembly.RuntimeError) {
          if (_emscripten_stack_get_current() <= 0) {
            err("Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)");
          }
        }
        quit_(1, e);
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function stringToUTF8OnStack(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = stackAlloc(size);
        stringToUTF8(str, ret, size);
        return ret;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {
          "string": (str) => {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              ret2 = stringToUTF8OnStack(str);
            }
            return ret2;
          },
          "array": (arr) => {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          }
        };
        function convertReturnValue(ret2) {
          if (returnType === "string") {
            return UTF8ToString(ret2);
          }
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        assert(returnType !== "array", 'Return type should not be "array".');
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        function onDone(ret2) {
          if (stack !== 0)
            stackRestore(stack);
          return convertReturnValue(ret2);
        }
        ret = onDone(ret);
        return ret;
      }
      function checkIncomingModuleAPI() {
        ignoredModuleProp("fetchSettings");
      }
      var wasmImports = {
        "XML_GetBuffer": _XML_GetBuffer,
        "XML_GetErrorCode": _XML_GetErrorCode,
        "XML_Parse": _XML_Parse,
        "XML_ParseBuffer": _XML_ParseBuffer,
        "XML_ParserCreate": _XML_ParserCreate,
        "XML_ParserFree": _XML_ParserFree,
        "XML_ResumeParser": _XML_ResumeParser,
        "XML_SetCharacterDataHandler": _XML_SetCharacterDataHandler,
        "XML_SetElementHandler": _XML_SetElementHandler,
        "XML_SetUserData": _XML_SetUserData,
        "XML_StopParser": _XML_StopParser,
        "__cxa_throw": ___cxa_throw,
        "__dlsym": ___dlsym,
        "__syscall__newselect": ___syscall__newselect,
        "__syscall_bind": ___syscall_bind,
        "__syscall_connect": ___syscall_connect,
        "__syscall_faccessat": ___syscall_faccessat,
        "__syscall_fcntl64": ___syscall_fcntl64,
        "__syscall_fstat64": ___syscall_fstat64,
        "__syscall_ftruncate64": ___syscall_ftruncate64,
        "__syscall_getdents64": ___syscall_getdents64,
        "__syscall_getpeername": ___syscall_getpeername,
        "__syscall_getsockopt": ___syscall_getsockopt,
        "__syscall_ioctl": ___syscall_ioctl,
        "__syscall_lstat64": ___syscall_lstat64,
        "__syscall_mkdirat": ___syscall_mkdirat,
        "__syscall_newfstatat": ___syscall_newfstatat,
        "__syscall_openat": ___syscall_openat,
        "__syscall_recvfrom": ___syscall_recvfrom,
        "__syscall_renameat": ___syscall_renameat,
        "__syscall_rmdir": ___syscall_rmdir,
        "__syscall_sendto": ___syscall_sendto,
        "__syscall_socket": ___syscall_socket,
        "__syscall_stat64": ___syscall_stat64,
        "__syscall_unlinkat": ___syscall_unlinkat,
        "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
        "_localtime_js": __localtime_js,
        "_tzset_js": __tzset_js,
        "abort": _abort,
        "dlopen": _dlopen,
        "duckdb_web_fs_directory_create": _duckdb_web_fs_directory_create,
        "duckdb_web_fs_directory_exists": _duckdb_web_fs_directory_exists,
        "duckdb_web_fs_directory_list_files": _duckdb_web_fs_directory_list_files,
        "duckdb_web_fs_directory_remove": _duckdb_web_fs_directory_remove,
        "duckdb_web_fs_file_close": _duckdb_web_fs_file_close,
        "duckdb_web_fs_file_exists": _duckdb_web_fs_file_exists,
        "duckdb_web_fs_file_get_last_modified_time": _duckdb_web_fs_file_get_last_modified_time,
        "duckdb_web_fs_file_move": _duckdb_web_fs_file_move,
        "duckdb_web_fs_file_open": _duckdb_web_fs_file_open,
        "duckdb_web_fs_file_read": _duckdb_web_fs_file_read,
        "duckdb_web_fs_file_truncate": _duckdb_web_fs_file_truncate,
        "duckdb_web_fs_file_write": _duckdb_web_fs_file_write,
        "duckdb_web_fs_get_default_data_protocol": _duckdb_web_fs_get_default_data_protocol,
        "duckdb_web_fs_glob": _duckdb_web_fs_glob,
        "duckdb_web_test_platform_feature": _duckdb_web_test_platform_feature,
        "duckdb_web_udf_scalar_call": _duckdb_web_udf_scalar_call,
        "emscripten_console_error": _emscripten_console_error,
        "emscripten_date_now": _emscripten_date_now,
        "emscripten_get_heap_max": _emscripten_get_heap_max,
        "emscripten_get_now": _emscripten_get_now,
        "emscripten_memcpy_big": _emscripten_memcpy_big,
        "emscripten_resize_heap": _emscripten_resize_heap,
        "environ_get": _environ_get,
        "environ_sizes_get": _environ_sizes_get,
        "fd_close": _fd_close,
        "fd_fdstat_get": _fd_fdstat_get,
        "fd_pread": _fd_pread,
        "fd_pwrite": _fd_pwrite,
        "fd_read": _fd_read,
        "fd_seek": _fd_seek,
        "fd_sync": _fd_sync,
        "fd_write": _fd_write,
        "getaddrinfo": _getaddrinfo,
        "getentropy": _getentropy,
        "getnameinfo": _getnameinfo,
        "strftime_l": _strftime_l,
        "ucnv_close_64": _ucnv_close_64,
        "ucnv_convertEx_64": _ucnv_convertEx_64,
        "ucnv_open_64": _ucnv_open_64,
        "ucnv_toAlgorithmic_64": _ucnv_toAlgorithmic_64,
        "ucsdet_close_64": _ucsdet_close_64,
        "ucsdet_detect_64": _ucsdet_detect_64,
        "ucsdet_getConfidence_64": _ucsdet_getConfidence_64,
        "ucsdet_getName_64": _ucsdet_getName_64,
        "ucsdet_open_64": _ucsdet_open_64,
        "ucsdet_setText_64": _ucsdet_setText_64,
        "unzClose": _unzClose,
        "unzCloseCurrentFile": _unzCloseCurrentFile,
        "unzGetCurrentFileInfo": _unzGetCurrentFileInfo,
        "unzGetCurrentFileInfo64": _unzGetCurrentFileInfo64,
        "unzGetGlobalInfo": _unzGetGlobalInfo,
        "unzGoToFirstFile": _unzGoToFirstFile,
        "unzGoToNextFile": _unzGoToNextFile,
        "unzLocateFile": _unzLocateFile,
        "unzOpen": _unzOpen,
        "unzOpen2": _unzOpen2,
        "unzOpenCurrentFile": _unzOpenCurrentFile,
        "unzReadCurrentFile": _unzReadCurrentFile
      };
      var asm = createWasm();
      var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
      var _main = Module["_main"] = createExportWrapper("main");
      var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = createExportWrapper("duckdb_web_fs_glob_add_path");
      var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = createExportWrapper("duckdb_web_clear_response");
      var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = createExportWrapper("duckdb_web_fail_with");
      var _duckdb_web_reset = Module["_duckdb_web_reset"] = createExportWrapper("duckdb_web_reset");
      var _duckdb_web_connect = Module["_duckdb_web_connect"] = createExportWrapper("duckdb_web_connect");
      var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = createExportWrapper("duckdb_web_disconnect");
      var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = createExportWrapper("duckdb_web_flush_files");
      var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = createExportWrapper("duckdb_web_flush_file");
      var _duckdb_web_open = Module["_duckdb_web_open"] = createExportWrapper("duckdb_web_open");
      var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = createExportWrapper("duckdb_web_get_global_file_info");
      var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = createExportWrapper("duckdb_web_collect_file_stats");
      var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = createExportWrapper("duckdb_web_export_file_stats");
      var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = createExportWrapper("duckdb_web_fs_drop_file");
      var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = createExportWrapper("duckdb_web_fs_drop_files");
      var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = createExportWrapper("duckdb_web_fs_glob_file_infos");
      var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = createExportWrapper("duckdb_web_fs_get_file_info_by_id");
      var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = createExportWrapper("duckdb_web_fs_get_file_info_by_name");
      var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = createExportWrapper("duckdb_web_fs_register_file_url");
      var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = createExportWrapper("duckdb_web_fs_register_file_buffer");
      var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = createExportWrapper("duckdb_web_copy_file_to_buffer");
      var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = createExportWrapper("duckdb_web_copy_file_to_path");
      var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = createExportWrapper("duckdb_web_get_version");
      var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = createExportWrapper("duckdb_web_get_feature_flags");
      var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = createExportWrapper("duckdb_web_tokenize");
      var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = createExportWrapper("duckdb_web_udf_scalar_create");
      var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = createExportWrapper("duckdb_web_prepared_create");
      var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = createExportWrapper("duckdb_web_prepared_close");
      var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = createExportWrapper("duckdb_web_prepared_run");
      var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = createExportWrapper("duckdb_web_prepared_send");
      var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = createExportWrapper("duckdb_web_query_run");
      var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = createExportWrapper("duckdb_web_pending_query_start");
      var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = createExportWrapper("duckdb_web_pending_query_poll");
      var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = createExportWrapper("duckdb_web_pending_query_cancel");
      var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = createExportWrapper("duckdb_web_query_fetch_results");
      var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = createExportWrapper("duckdb_web_get_tablenames");
      var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = createExportWrapper("duckdb_web_insert_arrow_from_ipc_stream");
      var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = createExportWrapper("duckdb_web_insert_csv_from_path");
      var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = createExportWrapper("duckdb_web_insert_json_from_path");
      var ___errno_location = createExportWrapper("__errno_location");
      var _fflush = Module["_fflush"] = createExportWrapper("fflush");
      var _htonl = createExportWrapper("htonl");
      var _htons = createExportWrapper("htons");
      var _ntohs = createExportWrapper("ntohs");
      var _malloc = Module["_malloc"] = createExportWrapper("malloc");
      var _free = Module["_free"] = createExportWrapper("free");
      var _emscripten_stack_init = function() {
        return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
      };
      var _emscripten_stack_get_free = function() {
        return (_emscripten_stack_get_free = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
      };
      var _emscripten_stack_get_base = function() {
        return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
      };
      var _emscripten_stack_get_end = function() {
        return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
      };
      var stackSave = createExportWrapper("stackSave");
      var stackRestore = createExportWrapper("stackRestore");
      var stackAlloc = createExportWrapper("stackAlloc");
      var _emscripten_stack_get_current = function() {
        return (_emscripten_stack_get_current = Module["asm"]["emscripten_stack_get_current"]).apply(null, arguments);
      };
      var ___cxa_is_pointer_type = createExportWrapper("__cxa_is_pointer_type");
      var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
      var dynCall_iiiiij = Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij");
      var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj");
      var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj");
      var dynCall_viijii = Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii");
      var dynCall_viijji = Module["dynCall_viijji"] = createExportWrapper("dynCall_viijji");
      var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");
      var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");
      var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij");
      var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");
      var dynCall_vjjijij = Module["dynCall_vjjijij"] = createExportWrapper("dynCall_vjjijij");
      var dynCall_vijjji = Module["dynCall_vijjji"] = createExportWrapper("dynCall_vijjji");
      var dynCall_vjjii = Module["dynCall_vjjii"] = createExportWrapper("dynCall_vjjii");
      var dynCall_viiiiiji = Module["dynCall_viiiiiji"] = createExportWrapper("dynCall_viiiiiji");
      var dynCall_jiiiji = Module["dynCall_jiiiji"] = createExportWrapper("dynCall_jiiiji");
      var dynCall_jiiij = Module["dynCall_jiiij"] = createExportWrapper("dynCall_jiiij");
      var dynCall_jijjij = Module["dynCall_jijjij"] = createExportWrapper("dynCall_jijjij");
      var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij");
      var dynCall_vijjj = Module["dynCall_vijjj"] = createExportWrapper("dynCall_vijjj");
      var dynCall_vijj = Module["dynCall_vijj"] = createExportWrapper("dynCall_vijj");
      var dynCall_viijj = Module["dynCall_viijj"] = createExportWrapper("dynCall_viijj");
      var dynCall_jiijii = Module["dynCall_jiijii"] = createExportWrapper("dynCall_jiijii");
      var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");
      var dynCall_viijiiiii = Module["dynCall_viijiiiii"] = createExportWrapper("dynCall_viijiiiii");
      var dynCall_viijiiij = Module["dynCall_viijiiij"] = createExportWrapper("dynCall_viijiiij");
      var dynCall_vijiiiji = Module["dynCall_vijiiiji"] = createExportWrapper("dynCall_vijiiiji");
      var dynCall_viiiij = Module["dynCall_viiiij"] = createExportWrapper("dynCall_viiiij");
      var dynCall_jiiji = Module["dynCall_jiiji"] = createExportWrapper("dynCall_jiiji");
      var dynCall_viiijij = Module["dynCall_viiijij"] = createExportWrapper("dynCall_viiijij");
      var dynCall_viijiij = Module["dynCall_viijiij"] = createExportWrapper("dynCall_viijiij");
      var dynCall_viiiiijj = Module["dynCall_viiiiijj"] = createExportWrapper("dynCall_viiiiijj");
      var dynCall_viiijji = Module["dynCall_viiijji"] = createExportWrapper("dynCall_viiijji");
      var dynCall_vijii = Module["dynCall_vijii"] = createExportWrapper("dynCall_vijii");
      var dynCall_iiiiiji = Module["dynCall_iiiiiji"] = createExportWrapper("dynCall_iiiiiji");
      var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij");
      var dynCall_iiijj = Module["dynCall_iiijj"] = createExportWrapper("dynCall_iiijj");
      var dynCall_iijii = Module["dynCall_iijii"] = createExportWrapper("dynCall_iijii");
      var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");
      var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");
      var dynCall_viijjj = Module["dynCall_viijjj"] = createExportWrapper("dynCall_viijjj");
      var dynCall_viiijj = Module["dynCall_viiijj"] = createExportWrapper("dynCall_viiijj");
      var dynCall_jijj = Module["dynCall_jijj"] = createExportWrapper("dynCall_jijj");
      var dynCall_jiiiii = Module["dynCall_jiiiii"] = createExportWrapper("dynCall_jiiiii");
      var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");
      var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");
      var dynCall_viijij = Module["dynCall_viijij"] = createExportWrapper("dynCall_viijij");
      var dynCall_viiij = Module["dynCall_viiij"] = createExportWrapper("dynCall_viiij");
      var dynCall_j = Module["dynCall_j"] = createExportWrapper("dynCall_j");
      var dynCall_viiijiiiijj = Module["dynCall_viiijiiiijj"] = createExportWrapper("dynCall_viiijiiiijj");
      var dynCall_jiiiij = Module["dynCall_jiiiij"] = createExportWrapper("dynCall_jiiiij");
      var dynCall_jj = Module["dynCall_jj"] = createExportWrapper("dynCall_jj");
      var dynCall_ij = Module["dynCall_ij"] = createExportWrapper("dynCall_ij");
      var dynCall_ijjj = Module["dynCall_ijjj"] = createExportWrapper("dynCall_ijjj");
      var dynCall_jjjd = Module["dynCall_jjjd"] = createExportWrapper("dynCall_jjjd");
      var dynCall_jjjjjjd = Module["dynCall_jjjjjjd"] = createExportWrapper("dynCall_jjjjjjd");
      var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij");
      var dynCall_viiijiiijii = Module["dynCall_viiijiiijii"] = createExportWrapper("dynCall_viiijiiijii");
      var dynCall_viijijiiii = Module["dynCall_viijijiiii"] = createExportWrapper("dynCall_viijijiiii");
      var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji");
      var dynCall_jiiiijj = Module["dynCall_jiiiijj"] = createExportWrapper("dynCall_jiiiijj");
      var dynCall_viiiji = Module["dynCall_viiiji"] = createExportWrapper("dynCall_viiiji");
      var dynCall_viiiiji = Module["dynCall_viiiiji"] = createExportWrapper("dynCall_viiiiji");
      var dynCall_jijiiii = Module["dynCall_jijiiii"] = createExportWrapper("dynCall_jijiiii");
      var dynCall_viiijiji = Module["dynCall_viiijiji"] = createExportWrapper("dynCall_viiijiji");
      var dynCall_viijiji = Module["dynCall_viijiji"] = createExportWrapper("dynCall_viijiji");
      var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");
      Module["stackAlloc"] = stackAlloc;
      Module["stackSave"] = stackSave;
      Module["stackRestore"] = stackRestore;
      Module["ccall"] = ccall;
      var missingLibrarySymbols = ["getHostByName", "traverseStack", "getCallstack", "emscriptenLog", "convertPCtoSourceLocation", "readEmAsmArgs", "jstoi_s", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "HandleAllocator", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "cwrap", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "setMainLoop", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "__glGenObject", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory"];
      missingLibrarySymbols.forEach(missingLibrarySymbol);
      var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "ptrToString", "zeroMemory", "exitJS", "getHeapMax", "emscripten_realloc_buffer", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "UNWIND_CACHE", "readEmAsmArgsArray", "jstoi_q", "getExecutableName", "handleException", "readI53FromI64", "convertI32PairToI53Checked", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToNewUTF8", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "currentFullscreenStrategy", "restoreOldWindowedStyle", "ExitStatus", "getEnvStrings", "flush_NO_FILESYSTEM", "dlopenMissingError", "promiseMap", "uncaughtExceptionCount", "exceptionLast", "exceptionCaught", "ExceptionInfo", "Browser", "wget", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "emscripten_webgl_power_preferences", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "GLFW", "allocateUTF8", "allocateUTF8OnStack", "SOCKFS", "FS"];
      unexportedSymbols.forEach(unexportedRuntimeSymbol);
      var calledRun;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function callMain() {
        assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
        assert(__ATPRERUN__.length == 0, "cannot call main when preRun functions remain to be called");
        var entryFunction = _main;
        var argc = 0;
        var argv = 0;
        try {
          var ret = entryFunction(argc, argv);
          exitJS(ret, true);
          return ret;
        } catch (e) {
          return handleException(e);
        }
      }
      function stackCheckInit() {
        _emscripten_stack_init();
        writeStackCookie();
      }
      function run() {
        if (runDependencies > 0) {
          return;
        }
        stackCheckInit();
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          readyPromiseResolve(Module);
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (shouldRunNow)
            callMain();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
        checkStackCookie();
      }
      function checkUnflushedContent() {
        var oldOut = out;
        var oldErr = err;
        var has = false;
        out = err = (x) => {
          has = true;
        };
        try {
          flush_NO_FILESYSTEM();
        } catch (e) {
        }
        out = oldOut;
        err = oldErr;
        if (has) {
          warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");
          warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");
        }
      }
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"])
        shouldRunNow = false;
      run();
      return DuckDB5.ready;
    };
  })();
  var duckdb_mvp_default = DuckDB;

  // src/bindings/bindings_browser_base.ts
  var DuckDBBrowserBindings = class extends DuckDBBindingsBase {
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL) {
      super(logger, runtime);
      this.mainModuleURL = mainModuleURL;
      this.pthreadWorkerURL = pthreadWorkerURL;
    }
    locateFile(path, prefix) {
      if (path.endsWith(".wasm")) {
        return this.mainModuleURL;
      }
      if (path.endsWith(".worker.js")) {
        if (!this.pthreadWorkerURL) {
          throw new Error("Missing DuckDB worker URL!");
        }
        return this.pthreadWorkerURL;
      }
      throw new Error(`WASM instantiation requested unexpected file: prefix=${prefix} path=${path}`);
    }
    instantiateWasm(imports, success) {
      globalThis.DUCKDB_RUNTIME = this._runtime;
      const handlers = this.onInstantiationProgress;
      if (WebAssembly.instantiateStreaming) {
        if (typeof TransformStream === "function") {
          const fetchWithProgress = async () => {
            const request = new Request(this.mainModuleURL);
            const response2 = await fetch(request);
            const contentLengthHdr = response2.headers.get("content-length");
            const contentLength = contentLengthHdr ? parseInt(contentLengthHdr, 10) || 0 : 0;
            const start = new Date();
            const progress = {
              startedAt: start,
              updatedAt: start,
              bytesTotal: contentLength || 0,
              bytesLoaded: 0
            };
            const tracker = {
              transform(chunk, ctrl) {
                progress.bytesLoaded += chunk.byteLength;
                const now = new Date();
                if (now.getTime() - progress.updatedAt.getTime() < 20) {
                  progress.updatedAt = now;
                  ctrl.enqueue(chunk);
                  return;
                }
                for (const p of handlers) {
                  p(progress);
                }
                ctrl.enqueue(chunk);
              }
            };
            const ts = new TransformStream(tracker);
            return new Response(response2.body?.pipeThrough(ts), response2);
          };
          const response = fetchWithProgress();
          WebAssembly.instantiateStreaming(response, imports).then((output) => {
            success(output.instance, output.module);
          });
        } else {
          console.warn("instantiating without progress handler since transform streams are unavailable");
          const request = new Request(this.mainModuleURL);
          WebAssembly.instantiateStreaming(fetch(request), imports).then((output) => {
            success(output.instance, output.module);
          });
        }
      } else if (typeof XMLHttpRequest == "function") {
        const xhr = new XMLHttpRequest();
        const url = this.mainModuleURL;
        const start = new Date();
        const progress = {
          startedAt: start,
          updatedAt: start,
          bytesTotal: 0,
          bytesLoaded: 0
        };
        xhr.open("GET", url);
        xhr.responseType = "arraybuffer";
        xhr.onerror = (error) => {
          this.logger.log({
            timestamp: new Date(),
            level: 4 /* ERROR */,
            origin: 3 /* BINDINGS */,
            topic: 5 /* INSTANTIATE */,
            event: 2 /* ERROR */,
            value: "Failed to load WASM: " + error
          });
          throw new Error(error.toString());
        };
        xhr.onprogress = (e) => {
          progress.bytesTotal = e.total;
          progress.bytesLoaded = e.loaded;
          const now = new Date();
          if (now.getTime() - progress.updatedAt.getTime() < 20) {
            progress.updatedAt = now;
            return;
          }
          for (const p of handlers) {
            p(progress);
          }
        };
        xhr.onload = () => {
          WebAssembly.instantiate(xhr.response, imports).then((output) => {
            success(output.instance, output.module);
          }).catch((error) => {
            this.logger.log({
              timestamp: new Date(),
              level: 4 /* ERROR */,
              origin: 3 /* BINDINGS */,
              topic: 5 /* INSTANTIATE */,
              event: 2 /* ERROR */,
              value: "Failed to instantiate WASM: " + error
            });
            throw new Error(error);
          });
        };
        xhr.send();
      } else {
        console.warn("instantiating with manual fetch since streaming instantiation and xhrs are unavailable");
        const run = async () => {
          const request = new Request(this.mainModuleURL);
          const response = await fetch(request);
          const buffer = await response.arrayBuffer();
          WebAssembly.instantiate(buffer, imports).then((output) => {
            success(output.instance, output.module);
          });
        };
        run();
      }
      return [];
    }
  };

  // src/bindings/bindings_browser_mvp.ts
  var DuckDB2 = class extends DuckDBBrowserBindings {
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime, mainModuleURL, pthreadWorkerURL);
    }
    instantiateImpl(moduleOverrides) {
      return duckdb_mvp_default({
        ...moduleOverrides,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/bindings/duckdb-eh.js
  var import_meta2 = {};
  var DuckDB3 = (() => {
    var _scriptDir = import_meta2.url;
    return async function(DuckDB5 = {}) {
      var Module = typeof DuckDB5 != "undefined" ? DuckDB5 : {};
      var readyPromiseResolve, readyPromiseReject;
      Module["ready"] = new Promise((resolve, reject) => {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      ["_main", "_malloc", "_free", "_duckdb_web_clear_response", "_duckdb_web_collect_file_stats", "_duckdb_web_connect", "_duckdb_web_copy_file_to_buffer", "_duckdb_web_copy_file_to_path", "_duckdb_web_disconnect", "_duckdb_web_export_file_stats", "_duckdb_web_fail_with", "_duckdb_web_flush_file", "_duckdb_web_flush_files", "_duckdb_web_fs_drop_file", "_duckdb_web_fs_drop_files", "_duckdb_web_fs_get_file_info_by_id", "_duckdb_web_fs_get_file_info_by_name", "_duckdb_web_fs_glob_add_path", "_duckdb_web_fs_glob_file_infos", "_duckdb_web_fs_register_file_buffer", "_duckdb_web_fs_register_file_url", "_duckdb_web_get_feature_flags", "_duckdb_web_get_global_file_info", "_duckdb_web_get_tablenames", "_duckdb_web_get_version", "_duckdb_web_insert_arrow_from_ipc_stream", "_duckdb_web_insert_csv_from_path", "_duckdb_web_insert_json_from_path", "_duckdb_web_open", "_duckdb_web_pending_query_cancel", "_duckdb_web_pending_query_poll", "_duckdb_web_pending_query_start", "_duckdb_web_prepared_close", "_duckdb_web_prepared_create", "_duckdb_web_prepared_run", "_duckdb_web_prepared_send", "_duckdb_web_query_fetch_results", "_duckdb_web_query_run", "_duckdb_web_reset", "_duckdb_web_tokenize", "_duckdb_web_udf_scalar_create", "getExceptionMessage", "___get_exception_message", "___cpp_exception", "___cxa_increment_exception_refcount", "___cxa_decrement_exception_refcount", "___thrown_object_from_unwind_exception", "_fflush", "onRuntimeInitialized"].forEach((prop) => {
        if (!Object.getOwnPropertyDescriptor(Module["ready"], prop)) {
          Object.defineProperty(Module["ready"], prop, {
            get: () => abort("You are getting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),
            set: () => abort("You are setting " + prop + " on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")
          });
        }
      });
      var moduleOverrides = Object.assign({}, Module);
      var arguments_ = [];
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof importScripts == "function";
      var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string";
      var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
      if (Module["ENVIRONMENT"]) {
        throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
      }
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module["locateFile"]) {
          return Module["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var read_, readAsync, readBinary, setWindowTitle;
      if (ENVIRONMENT_IS_NODE) {
        if (typeof process == "undefined" || !process.release || process.release.name !== "node")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        var nodeVersion = process.versions.node;
        var numericVersion = nodeVersion.split(".").slice(0, 3);
        numericVersion = numericVersion[0] * 1e4 + numericVersion[1] * 100 + numericVersion[2].split("-")[0] * 1;
        var minVersion = 101900;
        if (numericVersion < 101900) {
          throw new Error("This emscripten-generated code requires node v10.19.19.0 (detected v" + nodeVersion + ")");
        }
        const { createRequire } = await import("module");
        var require2 = createRequire(import_meta2.url);
        var fs = require2("fs");
        var nodePath = require2("path");
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = nodePath.dirname(scriptDirectory) + "/";
        } else {
          scriptDirectory = require2("url").fileURLToPath(new URL("./", import_meta2.url));
        }
        read_ = (filename, binary) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          return fs.readFileSync(filename, binary ? void 0 : "utf8");
        };
        readBinary = (filename) => {
          var ret = read_(filename, true);
          if (!ret.buffer) {
            ret = new Uint8Array(ret);
          }
          assert(ret.buffer);
          return ret;
        };
        readAsync = (filename, onload, onerror, binary = true) => {
          filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);
          fs.readFile(filename, binary ? void 0 : "utf8", (err2, data) => {
            if (err2)
              onerror(err2);
            else
              onload(binary ? data.buffer : data);
          });
        };
        if (!Module["thisProgram"] && process.argv.length > 1) {
          thisProgram = process.argv[1].replace(/\\/g, "/");
        }
        arguments_ = process.argv.slice(2);
        quit_ = (status, toThrow) => {
          process.exitCode = status;
          throw toThrow;
        };
        Module["inspect"] = () => "[Emscripten Module object]";
      } else if (ENVIRONMENT_IS_SHELL) {
        if (typeof process == "object" && typeof require2 === "function" || typeof window == "object" || typeof importScripts == "function")
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        if (typeof read != "undefined") {
          read_ = (f) => {
            return read(f);
          };
        }
        readBinary = (f) => {
          let data;
          if (typeof readbuffer == "function") {
            return new Uint8Array(readbuffer(f));
          }
          data = read(f, "binary");
          assert(typeof data == "object");
          return data;
        };
        readAsync = (f, onload, onerror) => {
          setTimeout(() => onload(readBinary(f)), 0);
        };
        if (typeof clearTimeout == "undefined") {
          globalThis.clearTimeout = (id) => {
          };
        }
        if (typeof scriptArgs != "undefined") {
          arguments_ = scriptArgs;
        } else if (typeof arguments != "undefined") {
          arguments_ = arguments;
        }
        if (typeof quit == "function") {
          quit_ = (status, toThrow) => {
            setTimeout(() => {
              if (!(toThrow instanceof ExitStatus)) {
                let toLog = toThrow;
                if (toThrow && typeof toThrow == "object" && toThrow.stack) {
                  toLog = [toThrow, toThrow.stack];
                }
                err(`exiting due to exception: ${toLog}`);
              }
              quit(status);
            });
            throw toThrow;
          };
        }
        if (typeof print != "undefined") {
          if (typeof console == "undefined")
            console = {};
          console.log = print;
          console.warn = console.error = typeof printErr != "undefined" ? printErr : print;
        }
      } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptDir) {
          scriptDirectory = _scriptDir;
        }
        if (scriptDirectory.indexOf("blob:") !== 0) {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        } else {
          scriptDirectory = "";
        }
        if (!(typeof window == "object" || typeof importScripts == "function"))
          throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
        {
          read_ = (url) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send(null);
            return xhr.responseText;
          };
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url, onload, onerror) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = () => {
              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                onload(xhr.response);
                return;
              }
              onerror();
            };
            xhr.onerror = onerror;
            xhr.send(null);
          };
        }
        setWindowTitle = (title) => document.title = title;
      } else {
        throw new Error("environment detection error");
      }
      var out = Module["print"] || console.log.bind(console);
      var err = Module["printErr"] || console.error.bind(console);
      Object.assign(Module, moduleOverrides);
      moduleOverrides = null;
      checkIncomingModuleAPI();
      if (Module["arguments"])
        arguments_ = Module["arguments"];
      legacyModuleProp("arguments", "arguments_");
      if (Module["thisProgram"])
        thisProgram = Module["thisProgram"];
      legacyModuleProp("thisProgram", "thisProgram");
      if (Module["quit"])
        quit_ = Module["quit"];
      legacyModuleProp("quit", "quit_");
      assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
      assert(typeof Module["read"] == "undefined", "Module.read option was removed (modify read_ in JS)");
      assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
      assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
      assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify setWindowTitle in JS)");
      assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
      legacyModuleProp("read", "read_");
      legacyModuleProp("readAsync", "readAsync");
      legacyModuleProp("readBinary", "readBinary");
      legacyModuleProp("setWindowTitle", "setWindowTitle");
      var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
      var PROXYFS = "PROXYFS is no longer included by default; build with -lproxyfs.js";
      var WORKERFS = "WORKERFS is no longer included by default; build with -lworkerfs.js";
      var NODEFS = "NODEFS is no longer included by default; build with -lnodefs.js";
      assert(!ENVIRONMENT_IS_SHELL, "shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable.");
      var wasmBinary;
      if (Module["wasmBinary"])
        wasmBinary = Module["wasmBinary"];
      legacyModuleProp("wasmBinary", "wasmBinary");
      var noExitRuntime = Module["noExitRuntime"] || true;
      legacyModuleProp("noExitRuntime", "noExitRuntime");
      if (typeof WebAssembly != "object") {
        abort("no native wasm support detected");
      }
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS;
      function assert(condition, text) {
        if (!condition) {
          abort("Assertion failed" + (text ? ": " + text : ""));
        }
      }
      var HEAP, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateMemoryViews() {
        var b = wasmMemory.buffer;
        Module["HEAP8"] = HEAP8 = new Int8Array(b);
        Module["HEAP16"] = HEAP16 = new Int16Array(b);
        Module["HEAP32"] = HEAP32 = new Int32Array(b);
        Module["HEAPU8"] = HEAPU8 = new Uint8Array(b);
        Module["HEAPU16"] = HEAPU16 = new Uint16Array(b);
        Module["HEAPU32"] = HEAPU32 = new Uint32Array(b);
        Module["HEAPF32"] = HEAPF32 = new Float32Array(b);
        Module["HEAPF64"] = HEAPF64 = new Float64Array(b);
      }
      assert(!Module["STACK_SIZE"], "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
      assert(typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0, "JS engine does not provide full typed array support");
      assert(!Module["wasmMemory"], "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
      assert(!Module["INITIAL_MEMORY"], "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
      var wasmTable;
      function writeStackCookie() {
        var max = _emscripten_stack_get_end();
        assert((max & 3) == 0);
        if (max == 0) {
          max += 4;
        }
        HEAPU32[max >>> 2] = 34821223;
        HEAPU32[max + 4 >>> 2] = 2310721022;
        HEAPU32[0 >>> 2] = 1668509029;
      }
      function checkStackCookie() {
        if (ABORT)
          return;
        var max = _emscripten_stack_get_end();
        if (max == 0) {
          max += 4;
        }
        var cookie1 = HEAPU32[max >>> 2];
        var cookie2 = HEAPU32[max + 4 >>> 2];
        if (cookie1 != 34821223 || cookie2 != 2310721022) {
          abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
        }
        if (HEAPU32[0 >>> 2] != 1668509029) {
          abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
        }
      }
      (function() {
        var h16 = new Int16Array(1);
        var h8 = new Int8Array(h16.buffer);
        h16[0] = 25459;
        if (h8[0] !== 115 || h8[1] !== 99)
          throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
      })();
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATEXIT__ = [];
      var __ATPOSTRUN__ = [];
      var runtimeInitialized = false;
      var runtimeKeepaliveCounter = 0;
      function keepRuntimeAlive() {
        return noExitRuntime || runtimeKeepaliveCounter > 0;
      }
      function preRun() {
        if (Module["preRun"]) {
          if (typeof Module["preRun"] == "function")
            Module["preRun"] = [Module["preRun"]];
          while (Module["preRun"].length) {
            addOnPreRun(Module["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        assert(!runtimeInitialized);
        runtimeInitialized = true;
        checkStackCookie();
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        checkStackCookie();
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        checkStackCookie();
        if (Module["postRun"]) {
          if (typeof Module["postRun"] == "function")
            Module["postRun"] = [Module["postRun"]];
          while (Module["postRun"].length) {
            addOnPostRun(Module["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnInit(cb) {
        __ATINIT__.unshift(cb);
      }
      function addOnPreMain(cb) {
        __ATMAIN__.unshift(cb);
      }
      function addOnExit(cb) {
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      assert(Math.imul, "This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.fround, "This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.clz32, "This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      assert(Math.trunc, "This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");
      var runDependencies = 0;
      var runDependencyWatcher = null;
      var dependenciesFulfilled = null;
      var runDependencyTracking = {};
      function getUniqueRunDependency(id) {
        var orig = id;
        while (1) {
          if (!runDependencyTracking[id])
            return id;
          id = orig + Math.random();
        }
      }
      function addRunDependency(id) {
        runDependencies++;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(!runDependencyTracking[id]);
          runDependencyTracking[id] = 1;
          if (runDependencyWatcher === null && typeof setInterval != "undefined") {
            runDependencyWatcher = setInterval(() => {
              if (ABORT) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
                return;
              }
              var shown = false;
              for (var dep in runDependencyTracking) {
                if (!shown) {
                  shown = true;
                  err("still waiting on run dependencies:");
                }
                err("dependency: " + dep);
              }
              if (shown) {
                err("(end of list)");
              }
            }, 1e4);
          }
        } else {
          err("warning: run dependency added without ID");
        }
      }
      function removeRunDependency(id) {
        runDependencies--;
        if (Module["monitorRunDependencies"]) {
          Module["monitorRunDependencies"](runDependencies);
        }
        if (id) {
          assert(runDependencyTracking[id]);
          delete runDependencyTracking[id];
        } else {
          err("warning: run dependency removed without ID");
        }
        if (runDependencies == 0) {
          if (runDependencyWatcher !== null) {
            clearInterval(runDependencyWatcher);
            runDependencyWatcher = null;
          }
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      function abort(what) {
        if (Module["onAbort"]) {
          Module["onAbort"](what);
        }
        what = "Aborted(" + what + ")";
        err(what);
        ABORT = true;
        EXITSTATUS = 1;
        if (runtimeInitialized) {
          ___trap();
        }
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      function isDataURI(filename) {
        return filename.startsWith(dataURIPrefix);
      }
      function isFileURI(filename) {
        return filename.startsWith("file://");
      }
      function createExportWrapper(name, fixedasm) {
        return function() {
          var displayName = name;
          var asm2 = fixedasm;
          if (!fixedasm) {
            asm2 = Module["asm"];
          }
          assert(runtimeInitialized, "native function `" + displayName + "` called before runtime initialization");
          if (!asm2[name]) {
            assert(asm2[name], "exported native function `" + displayName + "` not found");
          }
          return asm2[name].apply(null, arguments);
        };
      }
      var wasmBinaryFile;
      if (Module["locateFile"]) {
        wasmBinaryFile = "./duckdb-eh.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
      } else {
        wasmBinaryFile = new URL("./duckdb-eh.wasm", import_meta2.url).href;
      }
      function getBinary2(file) {
        try {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          if (readBinary) {
            return readBinary(file);
          }
          throw "both async and sync fetching of the wasm failed";
        } catch (err2) {
          abort(err2);
        }
      }
      function getBinaryPromise(binaryFile) {
        if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
          if (typeof fetch == "function") {
            return fetch(binaryFile, {
              credentials: "same-origin"
            }).then((response) => {
              if (!response["ok"]) {
                throw "failed to load wasm binary file at '" + binaryFile + "'";
              }
              return response["arrayBuffer"]();
            }).catch(() => getBinary2(binaryFile));
          }
        }
        return Promise.resolve().then(() => getBinary2(binaryFile));
      }
      function instantiateArrayBuffer(binaryFile, imports, receiver) {
        return getBinaryPromise(binaryFile).then((binary) => {
          return WebAssembly.instantiate(binary, imports);
        }).then((instance9) => {
          return instance9;
        }).then(receiver, (reason) => {
          err("failed to asynchronously prepare wasm: " + reason);
          if (isFileURI(wasmBinaryFile)) {
            err("warning: Loading from a file URI (" + wasmBinaryFile + ") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing");
          }
          abort(reason);
        });
      }
      function instantiateAsync(binary, binaryFile, imports, callback) {
        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == "function") {
          return fetch(binaryFile, {
            credentials: "same-origin"
          }).then((response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err("wasm streaming compile failed: " + reason);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          });
        } else {
          return instantiateArrayBuffer(binaryFile, imports, callback);
        }
      }
      function createWasm() {
        var info = {
          "env": wasmImports,
          "wasi_snapshot_preview1": wasmImports
        };
        function receiveInstance(instance9, module2) {
          var exports2 = instance9.exports;
          Module["asm"] = exports2;
          wasmMemory = Module["asm"]["memory"];
          assert(wasmMemory, "memory not found in wasm exports");
          updateMemoryViews();
          wasmTable = Module["asm"]["__indirect_function_table"];
          assert(wasmTable, "table not found in wasm exports");
          addOnInit(Module["asm"]["__wasm_call_ctors"]);
          removeRunDependency("wasm-instantiate");
          return exports2;
        }
        addRunDependency("wasm-instantiate");
        var trueModule = Module;
        function receiveInstantiationResult(result) {
          assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
          trueModule = null;
          receiveInstance(result["instance"]);
        }
        if (Module["instantiateWasm"]) {
          try {
            return Module["instantiateWasm"](info, receiveInstance);
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);
            readyPromiseReject(e);
          }
        }
        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
        return {};
      }
      var tempDouble;
      var tempI64;
      function legacyModuleProp(prop, newName) {
        if (!Object.getOwnPropertyDescriptor(Module, prop)) {
          Object.defineProperty(Module, prop, {
            configurable: true,
            get: function() {
              abort("Module." + prop + " has been replaced with plain " + newName + " (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)");
            }
          });
        }
      }
      function ignoredModuleProp(prop) {
        if (Object.getOwnPropertyDescriptor(Module, prop)) {
          abort("`Module." + prop + "` was supplied but `" + prop + "` not included in INCOMING_MODULE_JS_API");
        }
      }
      function isExportedByForceFilesystem(name) {
        return name === "FS_createPath" || name === "FS_createDataFile" || name === "FS_createPreloadedFile" || name === "FS_unlink" || name === "addRunDependency" || name === "FS_createLazyFile" || name === "FS_createDevice" || name === "removeRunDependency";
      }
      function missingGlobal(sym, msg) {
        if (typeof globalThis !== "undefined") {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              warnOnce("`" + sym + "` is not longer defined by emscripten. " + msg);
              return void 0;
            }
          });
        }
      }
      missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
      function missingLibrarySymbol(sym) {
        if (typeof globalThis !== "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
          Object.defineProperty(globalThis, sym, {
            configurable: true,
            get: function() {
              var msg = "`" + sym + "` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line";
              var librarySymbol = sym;
              if (!librarySymbol.startsWith("_")) {
                librarySymbol = "$" + sym;
              }
              msg += " (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE=" + librarySymbol + ")";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              warnOnce(msg);
              return void 0;
            }
          });
        }
        unexportedRuntimeSymbol(sym);
      }
      function unexportedRuntimeSymbol(sym) {
        if (!Object.getOwnPropertyDescriptor(Module, sym)) {
          Object.defineProperty(Module, sym, {
            configurable: true,
            get: function() {
              var msg = "'" + sym + "' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the FAQ)";
              if (isExportedByForceFilesystem(sym)) {
                msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
              }
              abort(msg);
            }
          });
        }
      }
      function dbg(text) {
        console.warn.apply(console, arguments);
      }
      function ExitStatus(status) {
        this.name = "ExitStatus";
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
      function callRuntimeCallbacks(callbacks) {
        while (callbacks.length > 0) {
          callbacks.shift()(Module);
        }
      }
      function getCppExceptionTag() {
        return Module["asm"]["__cpp_exception"];
      }
      function getCppExceptionThrownObjectFromWebAssemblyException(ex) {
        var unwind_header = ex.getArg(getCppExceptionTag(), 0);
        return ___thrown_object_from_unwind_exception(unwind_header);
      }
      function decrementExceptionRefcount(ex) {
        var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
        ___cxa_decrement_exception_refcount(ptr);
      }
      function withStackSave(f) {
        var stack = stackSave();
        var ret = f();
        stackRestore(stack);
        return ret;
      }
      var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
      function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {
        idx >>>= 0;
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx))
          ++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
          return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = "";
        while (idx < endPtr) {
          var u0 = heapOrArray[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heapOrArray[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heapOrArray[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            if ((u0 & 248) != 240)
              warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str;
      }
      function UTF8ToString(ptr, maxBytesToRead) {
        assert(typeof ptr == "number");
        ptr >>>= 0;
        return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      }
      function getExceptionMessageCommon(ptr) {
        return withStackSave(function() {
          var type_addr_addr = stackAlloc(4);
          var message_addr_addr = stackAlloc(4);
          ___get_exception_message(ptr, type_addr_addr, message_addr_addr);
          var type_addr = HEAPU32[type_addr_addr >>> 2];
          var message_addr = HEAPU32[message_addr_addr >>> 2];
          var type = UTF8ToString(type_addr);
          _free(type_addr);
          var message;
          if (message_addr) {
            message = UTF8ToString(message_addr);
            _free(message_addr);
          }
          return [type, message];
        });
      }
      function getExceptionMessage(ex) {
        var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
        return getExceptionMessageCommon(ptr);
      }
      Module["getExceptionMessage"] = getExceptionMessage;
      function getValue2(ptr, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            return HEAP8[ptr >>> 0];
          case "i8":
            return HEAP8[ptr >>> 0];
          case "i16":
            return HEAP16[ptr >>> 1];
          case "i32":
            return HEAP32[ptr >>> 2];
          case "i64":
            abort("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return HEAPF32[ptr >>> 2];
          case "double":
            return HEAPF64[ptr >>> 3];
          case "*":
            return HEAPU32[ptr >>> 2];
          default:
            abort(`invalid type for getValue: ${type}`);
        }
      }
      function incrementExceptionRefcount(ex) {
        var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
        ___cxa_increment_exception_refcount(ptr);
      }
      function ptrToString(ptr) {
        assert(typeof ptr === "number");
        return "0x" + ptr.toString(16).padStart(8, "0");
      }
      function setValue(ptr, value, type = "i8") {
        if (type.endsWith("*"))
          type = "*";
        switch (type) {
          case "i1":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i8":
            HEAP8[ptr >>> 0] = value;
            break;
          case "i16":
            HEAP16[ptr >>> 1] = value;
            break;
          case "i32":
            HEAP32[ptr >>> 2] = value;
            break;
          case "i64":
            abort("to do setValue(i64) use WASM_BIGINT");
          case "float":
            HEAPF32[ptr >>> 2] = value;
            break;
          case "double":
            HEAPF64[ptr >>> 3] = value;
            break;
          case "*":
            HEAPU32[ptr >>> 2] = value;
            break;
          default:
            abort(`invalid type for setValue: ${type}`);
        }
      }
      function warnOnce(text) {
        if (!warnOnce.shown)
          warnOnce.shown = {};
        if (!warnOnce.shown[text]) {
          warnOnce.shown[text] = 1;
          if (ENVIRONMENT_IS_NODE)
            text = "warning: " + text;
          err(text);
        }
      }
      function _XML_GetBuffer() {
        err("missing function: XML_GetBuffer");
        abort(-1);
      }
      function _XML_GetErrorCode() {
        err("missing function: XML_GetErrorCode");
        abort(-1);
      }
      function _XML_Parse() {
        err("missing function: XML_Parse");
        abort(-1);
      }
      function _XML_ParseBuffer() {
        err("missing function: XML_ParseBuffer");
        abort(-1);
      }
      function _XML_ParserCreate() {
        err("missing function: XML_ParserCreate");
        abort(-1);
      }
      function _XML_ParserFree() {
        err("missing function: XML_ParserFree");
        abort(-1);
      }
      function _XML_ResumeParser() {
        err("missing function: XML_ResumeParser");
        abort(-1);
      }
      function _XML_SetCharacterDataHandler() {
        err("missing function: XML_SetCharacterDataHandler");
        abort(-1);
      }
      function _XML_SetElementHandler() {
        err("missing function: XML_SetElementHandler");
        abort(-1);
      }
      function _XML_SetUserData() {
        err("missing function: XML_SetUserData");
        abort(-1);
      }
      function _XML_StopParser() {
        err("missing function: XML_StopParser");
        abort(-1);
      }
      function ___assert_fail(condition, filename, line, func) {
        abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      }
      var dlopenMissingError = "To use dlopen, you need enable dynamic linking, see https://emscripten.org/docs/compiling/Dynamic-Linking.html";
      function ___dlsym(handle, symbol, ra) {
        abort(dlopenMissingError);
      }
      var SYSCALLS = {
        varargs: void 0,
        get: function() {
          assert(SYSCALLS.varargs != void 0);
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        },
        getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }
      };
      function ___syscall__newselect(nfds, readfds, writefds, exceptfds, timeout) {
        assert(nfds <= 64, "nfds must be less than or equal to 64");
        assert(!exceptfds, "exceptfds not supported");
        var total = 0;
        var srcReadLow = readfds ? HEAP32[readfds >>> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >>> 2] : 0;
        var srcWriteLow = writefds ? HEAP32[writefds >>> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >>> 2] : 0;
        var srcExceptLow = exceptfds ? HEAP32[exceptfds >>> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0;
        var dstReadLow = 0, dstReadHigh = 0;
        var dstWriteLow = 0, dstWriteHigh = 0;
        var dstExceptLow = 0, dstExceptHigh = 0;
        var allLow = (readfds ? HEAP32[readfds >>> 2] : 0) | (writefds ? HEAP32[writefds >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds >>> 2] : 0);
        var allHigh = (readfds ? HEAP32[readfds + 4 >>> 2] : 0) | (writefds ? HEAP32[writefds + 4 >>> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >>> 2] : 0);
        var check = function(fd2, low, high, val) {
          return fd2 < 32 ? low & val : high & val;
        };
        for (var fd = 0; fd < nfds; fd++) {
          var mask = 1 << fd % 32;
          if (!check(fd, allLow, allHigh, mask)) {
            continue;
          }
          var stream = SYSCALLS.getStreamFromFD(fd);
          var flags = SYSCALLS.DEFAULT_POLLMASK;
          if (stream.stream_ops.poll) {
            flags = stream.stream_ops.poll(stream);
          }
          if (flags & 1 && check(fd, srcReadLow, srcReadHigh, mask)) {
            fd < 32 ? dstReadLow = dstReadLow | mask : dstReadHigh = dstReadHigh | mask;
            total++;
          }
          if (flags & 4 && check(fd, srcWriteLow, srcWriteHigh, mask)) {
            fd < 32 ? dstWriteLow = dstWriteLow | mask : dstWriteHigh = dstWriteHigh | mask;
            total++;
          }
          if (flags & 2 && check(fd, srcExceptLow, srcExceptHigh, mask)) {
            fd < 32 ? dstExceptLow = dstExceptLow | mask : dstExceptHigh = dstExceptHigh | mask;
            total++;
          }
        }
        if (readfds) {
          HEAP32[readfds >>> 2] = dstReadLow;
          HEAP32[readfds + 4 >>> 2] = dstReadHigh;
        }
        if (writefds) {
          HEAP32[writefds >>> 2] = dstWriteLow;
          HEAP32[writefds + 4 >>> 2] = dstWriteHigh;
        }
        if (exceptfds) {
          HEAP32[exceptfds >>> 2] = dstExceptLow;
          HEAP32[exceptfds + 4 >>> 2] = dstExceptHigh;
        }
        return total;
      }
      function SOCKFS() {
        err("missing function: $SOCKFS");
        abort(-1);
      }
      function FS() {
        err("missing function: $FS");
        abort(-1);
      }
      function getSocketFromFD(fd) {
        var socket = SOCKFS.getSocket(fd);
        if (!socket)
          throw new FS.ErrnoError(8);
        return socket;
      }
      function setErrNo(value) {
        HEAP32[___errno_location() >>> 2] = value;
        return value;
      }
      var Sockets = {
        BUFFER_SIZE: 10240,
        MAX_BUFFER_SIZE: 10485760,
        nextFd: 1,
        fds: {},
        nextport: 1,
        maxport: 65535,
        peer: null,
        connections: {},
        portmap: {},
        localAddr: 4261412874,
        addrPool: [33554442, 50331658, 67108874, 83886090, 100663306, 117440522, 134217738, 150994954, 167772170, 184549386, 201326602, 218103818, 234881034]
      };
      function inetNtop4(addr) {
        return (addr & 255) + "." + (addr >> 8 & 255) + "." + (addr >> 16 & 255) + "." + (addr >> 24 & 255);
      }
      function inetNtop6(ints) {
        var str = "";
        var word = 0;
        var longest = 0;
        var lastzero = 0;
        var zstart = 0;
        var len = 0;
        var i = 0;
        var parts = [ints[0] & 65535, ints[0] >> 16, ints[1] & 65535, ints[1] >> 16, ints[2] & 65535, ints[2] >> 16, ints[3] & 65535, ints[3] >> 16];
        var hasipv4 = true;
        var v4part = "";
        for (i = 0; i < 5; i++) {
          if (parts[i] !== 0) {
            hasipv4 = false;
            break;
          }
        }
        if (hasipv4) {
          v4part = inetNtop4(parts[6] | parts[7] << 16);
          if (parts[5] === -1) {
            str = "::ffff:";
            str += v4part;
            return str;
          }
          if (parts[5] === 0) {
            str = "::";
            if (v4part === "0.0.0.0")
              v4part = "";
            if (v4part === "0.0.0.1")
              v4part = "1";
            str += v4part;
            return str;
          }
        }
        for (word = 0; word < 8; word++) {
          if (parts[word] === 0) {
            if (word - lastzero > 1) {
              len = 0;
            }
            lastzero = word;
            len++;
          }
          if (len > longest) {
            longest = len;
            zstart = word - longest + 1;
          }
        }
        for (word = 0; word < 8; word++) {
          if (longest > 1) {
            if (parts[word] === 0 && word >= zstart && word < zstart + longest) {
              if (word === zstart) {
                str += ":";
                if (zstart === 0)
                  str += ":";
              }
              continue;
            }
          }
          str += Number(_ntohs(parts[word] & 65535)).toString(16);
          str += word < 7 ? ":" : "";
        }
        return str;
      }
      function readSockaddr(sa, salen) {
        var family = HEAP16[sa >>> 1];
        var port = _ntohs(HEAPU16[sa + 2 >>> 1]);
        var addr;
        switch (family) {
          case 2:
            if (salen !== 16) {
              return {
                errno: 28
              };
            }
            addr = HEAP32[sa + 4 >>> 2];
            addr = inetNtop4(addr);
            break;
          case 10:
            if (salen !== 28) {
              return {
                errno: 28
              };
            }
            addr = [HEAP32[sa + 8 >>> 2], HEAP32[sa + 12 >>> 2], HEAP32[sa + 16 >>> 2], HEAP32[sa + 20 >>> 2]];
            addr = inetNtop6(addr);
            break;
          default:
            return {
              errno: 5
            };
        }
        return {
          family,
          addr,
          port
        };
      }
      function inetPton4(str) {
        var b = str.split(".");
        for (var i = 0; i < 4; i++) {
          var tmp2 = Number(b[i]);
          if (isNaN(tmp2))
            return null;
          b[i] = tmp2;
        }
        return (b[0] | b[1] << 8 | b[2] << 16 | b[3] << 24) >>> 0;
      }
      function jstoi_q(str) {
        return parseInt(str);
      }
      function inetPton6(str) {
        var words;
        var w, offset, z, i;
        var valid6regx = /^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;
        var parts = [];
        if (!valid6regx.test(str)) {
          return null;
        }
        if (str === "::") {
          return [0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (str.startsWith("::")) {
          str = str.replace("::", "Z:");
        } else {
          str = str.replace("::", ":Z:");
        }
        if (str.indexOf(".") > 0) {
          str = str.replace(new RegExp("[.]", "g"), ":");
          words = str.split(":");
          words[words.length - 4] = jstoi_q(words[words.length - 4]) + jstoi_q(words[words.length - 3]) * 256;
          words[words.length - 3] = jstoi_q(words[words.length - 2]) + jstoi_q(words[words.length - 1]) * 256;
          words = words.slice(0, words.length - 2);
        } else {
          words = str.split(":");
        }
        offset = 0;
        z = 0;
        for (w = 0; w < words.length; w++) {
          if (typeof words[w] == "string") {
            if (words[w] === "Z") {
              for (z = 0; z < 8 - words.length + 1; z++) {
                parts[w + z] = 0;
              }
              offset = z - 1;
            } else {
              parts[w + offset] = _htons(parseInt(words[w], 16));
            }
          } else {
            parts[w + offset] = words[w];
          }
        }
        return [parts[1] << 16 | parts[0], parts[3] << 16 | parts[2], parts[5] << 16 | parts[4], parts[7] << 16 | parts[6]];
      }
      var DNS = {
        address_map: {
          id: 1,
          addrs: {},
          names: {}
        },
        lookup_name: function(name) {
          var res = inetPton4(name);
          if (res !== null) {
            return name;
          }
          res = inetPton6(name);
          if (res !== null) {
            return name;
          }
          var addr;
          if (DNS.address_map.addrs[name]) {
            addr = DNS.address_map.addrs[name];
          } else {
            var id = DNS.address_map.id++;
            assert(id < 65535, "exceeded max address mappings of 65535");
            addr = "172.29." + (id & 255) + "." + (id & 65280);
            DNS.address_map.names[addr] = name;
            DNS.address_map.addrs[name] = addr;
          }
          return addr;
        },
        lookup_addr: function(addr) {
          if (DNS.address_map.names[addr]) {
            return DNS.address_map.names[addr];
          }
          return null;
        }
      };
      function getSocketAddress(addrp, addrlen, allowNull) {
        if (allowNull && addrp === 0)
          return null;
        var info = readSockaddr(addrp, addrlen);
        if (info.errno)
          throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      }
      function ___syscall_bind(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.bind(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_connect(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        var info = getSocketAddress(addr, addrlen);
        sock.sock_ops.connect(sock, info.addr, info.port);
        return 0;
      }
      function ___syscall_faccessat(dirfd, path, amode, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_fcntl64(fd, cmd, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_fstat64(fd, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function convertI32PairToI53Checked(lo, hi) {
        assert(lo == lo >>> 0 || lo == (lo | 0));
        assert(hi === (hi | 0));
        return hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
      }
      function ___syscall_ftruncate64(fd, length_low, length_high) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
        outIdx >>>= 0;
        assert(typeof str === "string");
        if (!(maxBytesToWrite > 0))
          return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx)
              break;
            heap[outIdx++ >>> 0] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 192 | u >> 6;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx)
              break;
            heap[outIdx++ >>> 0] = 224 | u >> 12;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx)
              break;
            if (u > 1114111)
              warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
            heap[outIdx++ >>> 0] = 240 | u >> 18;
            heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
            heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
            heap[outIdx++ >>> 0] = 128 | u & 63;
          }
        }
        heap[outIdx >>> 0] = 0;
        return outIdx - startIdx;
      }
      function stringToUTF8(str, outPtr, maxBytesToWrite) {
        assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
        return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      }
      function ___syscall_getdents64(fd, dirp, count) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function zeroMemory(address, size) {
        HEAPU8.fill(0, address, address + size);
        return address;
      }
      function writeSockaddr(sa, family, addr, port, addrlen) {
        switch (family) {
          case 2:
            addr = inetPton4(addr);
            zeroMemory(sa, 16);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 16;
            }
            HEAP16[sa >>> 1] = family;
            HEAP32[sa + 4 >>> 2] = addr;
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          case 10:
            addr = inetPton6(addr);
            zeroMemory(sa, 28);
            if (addrlen) {
              HEAP32[addrlen >>> 2] = 28;
            }
            HEAP32[sa >>> 2] = family;
            HEAP32[sa + 8 >>> 2] = addr[0];
            HEAP32[sa + 12 >>> 2] = addr[1];
            HEAP32[sa + 16 >>> 2] = addr[2];
            HEAP32[sa + 20 >>> 2] = addr[3];
            HEAP16[sa + 2 >>> 1] = _htons(port);
            break;
          default:
            return 5;
        }
        return 0;
      }
      function ___syscall_getpeername(fd, addr, addrlen, d1, d2, d3) {
        var sock = getSocketFromFD(fd);
        if (!sock.daddr) {
          return -53;
        }
        var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(sock.daddr), sock.dport, addrlen);
        assert(!errno);
        return 0;
      }
      function ___syscall_getsockopt(fd, level, optname, optval, optlen, d1) {
        var sock = getSocketFromFD(fd);
        if (level === 1) {
          if (optname === 4) {
            HEAP32[optval >>> 2] = sock.error;
            HEAP32[optlen >>> 2] = 4;
            sock.error = null;
            return 0;
          }
        }
        return -50;
      }
      function ___syscall_ioctl(fd, op, varargs) {
        SYSCALLS.varargs = varargs;
        return 0;
      }
      function ___syscall_lstat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_mkdirat(dirfd, path, mode) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_newfstatat(dirfd, path, buf, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_openat(dirfd, path, flags, varargs) {
        SYSCALLS.varargs = varargs;
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_recvfrom(fd, buf, len, flags, addr, addrlen) {
        var sock = getSocketFromFD(fd);
        var msg = sock.sock_ops.recvmsg(sock, len);
        if (!msg)
          return 0;
        if (addr) {
          var errno = writeSockaddr(addr, sock.family, DNS.lookup_name(msg.addr), msg.port, addrlen);
          assert(!errno);
        }
        HEAPU8.set(msg.buffer, buf >>> 0);
        return msg.buffer.byteLength;
      }
      function ___syscall_renameat(olddirfd, oldpath, newdirfd, newpath) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_rmdir(path) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_sendto(fd, message, length, flags, addr, addr_len) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_socket(domain, type, protocol) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_stat64(path, buf) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___syscall_unlinkat(dirfd, path, flags) {
        abort("it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function ___throw_exception_with_stack_trace(ex) {
        var e = new WebAssembly.Exception(getCppExceptionTag(), [ex], {
          traceStack: true
        });
        e.message = getExceptionMessage(e);
        if (e.stack) {
          var arr = e.stack.split("\n");
          arr.splice(1, 1);
          e.stack = arr.join("\n");
        }
        throw e;
      }
      var nowIsMonotonic = true;
      function __emscripten_get_now_is_monotonic() {
        return nowIsMonotonic;
      }
      function readI53FromI64(ptr) {
        return HEAPU32[ptr >>> 2] + HEAP32[ptr + 4 >>> 2] * 4294967296;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      function ydayFromDate(date) {
        var leap = isLeapYear(date.getFullYear());
        var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
        var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
        return yday;
      }
      function __localtime_js(time, tmPtr) {
        var date = new Date(readI53FromI64(time) * 1e3);
        HEAP32[tmPtr >>> 2] = date.getSeconds();
        HEAP32[tmPtr + 4 >>> 2] = date.getMinutes();
        HEAP32[tmPtr + 8 >>> 2] = date.getHours();
        HEAP32[tmPtr + 12 >>> 2] = date.getDate();
        HEAP32[tmPtr + 16 >>> 2] = date.getMonth();
        HEAP32[tmPtr + 20 >>> 2] = date.getFullYear() - 1900;
        HEAP32[tmPtr + 24 >>> 2] = date.getDay();
        var yday = ydayFromDate(date) | 0;
        HEAP32[tmPtr + 28 >>> 2] = yday;
        HEAP32[tmPtr + 36 >>> 2] = -(date.getTimezoneOffset() * 60);
        var start = new Date(date.getFullYear(), 0, 1);
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var winterOffset = start.getTimezoneOffset();
        var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
        HEAP32[tmPtr + 32 >>> 2] = dst;
      }
      function lengthBytesUTF8(str) {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var c = str.charCodeAt(i);
          if (c <= 127) {
            len++;
          } else if (c <= 2047) {
            len += 2;
          } else if (c >= 55296 && c <= 57343) {
            len += 4;
            ++i;
          } else {
            len += 3;
          }
        }
        return len;
      }
      function stringToNewUTF8(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = _malloc(size);
        if (ret)
          stringToUTF8(str, ret, size);
        return ret;
      }
      function __tzset_js(timezone, daylight, tzname) {
        var currentYear = new Date().getFullYear();
        var winter = new Date(currentYear, 0, 1);
        var summer = new Date(currentYear, 6, 1);
        var winterOffset = winter.getTimezoneOffset();
        var summerOffset = summer.getTimezoneOffset();
        var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
        HEAPU32[timezone >>> 2] = stdTimezoneOffset * 60;
        HEAP32[daylight >>> 2] = Number(winterOffset != summerOffset);
        function extractZone(date) {
          var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
          return match ? match[1] : "GMT";
        }
        var winterName = extractZone(winter);
        var summerName = extractZone(summer);
        var winterNamePtr = stringToNewUTF8(winterName);
        var summerNamePtr = stringToNewUTF8(summerName);
        if (summerOffset < winterOffset) {
          HEAPU32[tzname >>> 2] = winterNamePtr;
          HEAPU32[tzname + 4 >>> 2] = summerNamePtr;
        } else {
          HEAPU32[tzname >>> 2] = summerNamePtr;
          HEAPU32[tzname + 4 >>> 2] = winterNamePtr;
        }
      }
      function _abort() {
        abort("native code called abort()");
      }
      function _dlopen(filename, flags) {
        abort(dlopenMissingError);
      }
      function _duckdb_web_fs_directory_create(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.createDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_list_files(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.listDirectoryEntries(Module, path, pathLen);
      }
      function _duckdb_web_fs_directory_remove(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.removeDirectory(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_close(fileId) {
        return globalThis.DUCKDB_RUNTIME.closeFile(Module, fileId);
      }
      function _duckdb_web_fs_file_exists(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.checkFile(Module, path, pathLen);
      }
      function _duckdb_web_fs_file_get_last_modified_time(fileId) {
        return globalThis.DUCKDB_RUNTIME.getLastFileModificationTime(Module, fileId);
      }
      function _duckdb_web_fs_file_move(from, fromLen, to, toLen) {
        return globalThis.DUCKDB_RUNTIME.moveFile(Module, from, fromLen, to, toLen);
      }
      function _duckdb_web_fs_file_open(fileId, flags) {
        return globalThis.DUCKDB_RUNTIME.openFile(Module, fileId, flags);
      }
      function _duckdb_web_fs_file_read(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.readFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_file_truncate(fileId, newSize) {
        return globalThis.DUCKDB_RUNTIME.truncateFile(Module, fileId, newSize);
      }
      function _duckdb_web_fs_file_write(fileId, buf, size, location) {
        return globalThis.DUCKDB_RUNTIME.writeFile(Module, fileId, buf, size, location);
      }
      function _duckdb_web_fs_get_default_data_protocol(Module2) {
        return globalThis.DUCKDB_RUNTIME.getDefaultDataProtocol(Module2);
      }
      function _duckdb_web_fs_glob(path, pathLen) {
        return globalThis.DUCKDB_RUNTIME.glob(Module, path, pathLen);
      }
      function _duckdb_web_test_platform_feature(feature) {
        return globalThis.DUCKDB_RUNTIME.testPlatformFeature(Module, feature);
      }
      function _duckdb_web_udf_scalar_call(funcId, descPtr, descSize, ptrsPtr, ptrsSize, response) {
        return globalThis.DUCKDB_RUNTIME.callScalarUDF(Module, funcId, descPtr, descSize, ptrsPtr, ptrsSize, response);
      }
      function _emscripten_console_error(str) {
        assert(typeof str == "number");
        console.error(UTF8ToString(str));
      }
      function _emscripten_date_now() {
        return Date.now();
      }
      function getHeapMax() {
        return 4294901760;
      }
      function _emscripten_get_heap_max() {
        return getHeapMax();
      }
      var _emscripten_get_now;
      if (ENVIRONMENT_IS_NODE) {
        global.performance = require2("perf_hooks").performance;
      }
      _emscripten_get_now = () => performance.now();
      function _emscripten_memcpy_big(dest, src, num) {
        HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
      }
      function emscripten_realloc_buffer(size) {
        var b = wasmMemory.buffer;
        var pages = size - b.byteLength + 65535 >>> 16;
        try {
          wasmMemory.grow(pages);
          updateMemoryViews();
          return 1;
        } catch (e) {
          err(`emscripten_realloc_buffer: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
        }
      }
      function _emscripten_resize_heap(requestedSize) {
        var oldSize = HEAPU8.length;
        requestedSize = requestedSize >>> 0;
        assert(requestedSize > oldSize);
        var maxHeapSize = getHeapMax();
        if (requestedSize > maxHeapSize) {
          err(`Cannot enlarge memory, asked to go up to ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
          return false;
        }
        var alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = emscripten_realloc_buffer(newSize);
          if (replacement) {
            return true;
          }
        }
        err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
        return false;
      }
      var ENV = {};
      function getExecutableName() {
        return thisProgram || "./this.program";
      }
      function getEnvStrings() {
        if (!getEnvStrings.strings) {
          var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
          var env = {
            "USER": "web_user",
            "LOGNAME": "web_user",
            "PATH": "/",
            "PWD": "/",
            "HOME": "/home/web_user",
            "LANG": lang,
            "_": getExecutableName()
          };
          for (var x in ENV) {
            if (ENV[x] === void 0)
              delete env[x];
            else
              env[x] = ENV[x];
          }
          var strings = [];
          for (var x in env) {
            strings.push(`${x}=${env[x]}`);
          }
          getEnvStrings.strings = strings;
        }
        return getEnvStrings.strings;
      }
      function stringToAscii(str, buffer) {
        for (var i = 0; i < str.length; ++i) {
          assert(str.charCodeAt(i) === (str.charCodeAt(i) & 255));
          HEAP8[buffer++ >>> 0] = str.charCodeAt(i);
        }
        HEAP8[buffer >>> 0] = 0;
      }
      function _environ_get(__environ, environ_buf) {
        var bufSize = 0;
        getEnvStrings().forEach(function(string, i) {
          var ptr = environ_buf + bufSize;
          HEAPU32[__environ + i * 4 >>> 2] = ptr;
          stringToAscii(string, ptr);
          bufSize += string.length + 1;
        });
        return 0;
      }
      function _environ_sizes_get(penviron_count, penviron_buf_size) {
        var strings = getEnvStrings();
        HEAPU32[penviron_count >>> 2] = strings.length;
        var bufSize = 0;
        strings.forEach(function(string) {
          bufSize += string.length + 1;
        });
        HEAPU32[penviron_buf_size >>> 2] = bufSize;
        return 0;
      }
      function _fd_close(fd) {
        abort("fd_close called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_fdstat_get(fd, pbuf) {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          assert(fd == 0 || fd == 1 || fd == 2);
          var type = 2;
          if (fd == 0) {
            rightsBase = 2;
          } else if (fd == 1 || fd == 2) {
            rightsBase = 64;
          }
          flags = 1;
        }
        HEAP8[pbuf >>> 0] = type;
        HEAP16[pbuf + 2 >>> 1] = flags;
        tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >>> 2] = tempI64[0], HEAP32[pbuf + 12 >>> 2] = tempI64[1];
        tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >>> 2] = tempI64[0], HEAP32[pbuf + 20 >>> 2] = tempI64[1];
        return 0;
      }
      function _fd_pread(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pread called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_pwrite(fd, iov, iovcnt, offset_low, offset_high, pnum) {
        abort("fd_pwrite called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_read(fd, iov, iovcnt, pnum) {
        abort("fd_read called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        return 70;
      }
      function _fd_sync(fd) {
        abort("fd_sync called without SYSCALLS_REQUIRE_FILESYSTEM");
      }
      var printCharBuffers = [null, [], []];
      function printChar(stream, curr) {
        var buffer = printCharBuffers[stream];
        assert(buffer);
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      }
      function flush_NO_FILESYSTEM() {
        _fflush(0);
        if (printCharBuffers[1].length)
          printChar(1, 10);
        if (printCharBuffers[2].length)
          printChar(2, 10);
      }
      function _fd_write(fd, iov, iovcnt, pnum) {
        var num = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAPU32[iov >>> 2];
          var len = HEAPU32[iov + 4 >>> 2];
          iov += 8;
          for (var j = 0; j < len; j++) {
            printChar(fd, HEAPU8[ptr + j >>> 0]);
          }
          num += len;
        }
        HEAPU32[pnum >>> 2] = num;
        return 0;
      }
      function _getaddrinfo(node, service, hint, out2) {
        var addrs = [];
        var canon = null;
        var addr = 0;
        var port = 0;
        var flags = 0;
        var family = 0;
        var type = 0;
        var proto = 0;
        var ai, last;
        function allocaddrinfo(family2, type2, proto2, canon2, addr2, port2) {
          var sa, salen, ai2;
          var errno;
          salen = family2 === 10 ? 28 : 16;
          addr2 = family2 === 10 ? inetNtop6(addr2) : inetNtop4(addr2);
          sa = _malloc(salen);
          errno = writeSockaddr(sa, family2, addr2, port2);
          assert(!errno);
          ai2 = _malloc(32);
          HEAP32[ai2 + 4 >>> 2] = family2;
          HEAP32[ai2 + 8 >>> 2] = type2;
          HEAP32[ai2 + 12 >>> 2] = proto2;
          HEAPU32[ai2 + 24 >>> 2] = canon2;
          HEAPU32[ai2 + 20 >>> 2] = sa;
          if (family2 === 10) {
            HEAP32[ai2 + 16 >>> 2] = 28;
          } else {
            HEAP32[ai2 + 16 >>> 2] = 16;
          }
          HEAP32[ai2 + 28 >>> 2] = 0;
          return ai2;
        }
        if (hint) {
          flags = HEAP32[hint >>> 2];
          family = HEAP32[hint + 4 >>> 2];
          type = HEAP32[hint + 8 >>> 2];
          proto = HEAP32[hint + 12 >>> 2];
        }
        if (type && !proto) {
          proto = type === 2 ? 17 : 6;
        }
        if (!type && proto) {
          type = proto === 17 ? 2 : 1;
        }
        if (proto === 0) {
          proto = 6;
        }
        if (type === 0) {
          type = 1;
        }
        if (!node && !service) {
          return -2;
        }
        if (flags & ~(1 | 2 | 4 | 1024 | 8 | 16 | 32)) {
          return -1;
        }
        if (hint !== 0 && HEAP32[hint >>> 2] & 2 && !node) {
          return -1;
        }
        if (flags & 32) {
          return -2;
        }
        if (type !== 0 && type !== 1 && type !== 2) {
          return -7;
        }
        if (family !== 0 && family !== 2 && family !== 10) {
          return -6;
        }
        if (service) {
          service = UTF8ToString(service);
          port = parseInt(service, 10);
          if (isNaN(port)) {
            if (flags & 1024) {
              return -2;
            }
            return -8;
          }
        }
        if (!node) {
          if (family === 0) {
            family = 2;
          }
          if ((flags & 1) === 0) {
            if (family === 2) {
              addr = _htonl(2130706433);
            } else {
              addr = [0, 0, 0, 1];
            }
          }
          ai = allocaddrinfo(family, type, proto, null, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        node = UTF8ToString(node);
        addr = inetPton4(node);
        if (addr !== null) {
          if (family === 0 || family === 2) {
            family = 2;
          } else if (family === 10 && flags & 8) {
            addr = [0, 0, _htonl(65535), addr];
            family = 10;
          } else {
            return -2;
          }
        } else {
          addr = inetPton6(node);
          if (addr !== null) {
            if (family === 0 || family === 10) {
              family = 10;
            } else {
              return -2;
            }
          }
        }
        if (addr != null) {
          ai = allocaddrinfo(family, type, proto, node, addr, port);
          HEAPU32[out2 >>> 2] = ai;
          return 0;
        }
        if (flags & 4) {
          return -2;
        }
        node = DNS.lookup_name(node);
        addr = inetPton4(node);
        if (family === 0) {
          family = 2;
        } else if (family === 10) {
          addr = [0, 0, _htonl(65535), addr];
        }
        ai = allocaddrinfo(family, type, proto, null, addr, port);
        HEAPU32[out2 >>> 2] = ai;
        return 0;
      }
      function initRandomFill() {
        if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
          return (view) => crypto.getRandomValues(view);
        } else if (ENVIRONMENT_IS_NODE) {
          try {
            var crypto_module = require2("crypto");
            var randomFillSync = crypto_module["randomFillSync"];
            if (randomFillSync) {
              return (view) => crypto_module["randomFillSync"](view);
            }
            var randomBytes = crypto_module["randomBytes"];
            return (view) => (view.set(randomBytes(view.byteLength)), view);
          } catch (e) {
          }
        }
        abort("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };");
      }
      function randomFill(view) {
        return (randomFill = initRandomFill())(view);
      }
      function _getentropy(buffer, size) {
        randomFill(HEAPU8.subarray(buffer >>> 0, buffer + size >>> 0));
        return 0;
      }
      function _getnameinfo(sa, salen, node, nodelen, serv, servlen, flags) {
        var info = readSockaddr(sa, salen);
        if (info.errno) {
          return -6;
        }
        var port = info.port;
        var addr = info.addr;
        var overflowed = false;
        if (node && nodelen) {
          var lookup;
          if (flags & 1 || !(lookup = DNS.lookup_addr(addr))) {
            if (flags & 8) {
              return -2;
            }
          } else {
            addr = lookup;
          }
          var numBytesWrittenExclNull = stringToUTF8(addr, node, nodelen);
          if (numBytesWrittenExclNull + 1 >= nodelen) {
            overflowed = true;
          }
        }
        if (serv && servlen) {
          port = "" + port;
          var numBytesWrittenExclNull = stringToUTF8(port, serv, servlen);
          if (numBytesWrittenExclNull + 1 >= servlen) {
            overflowed = true;
          }
        }
        if (overflowed) {
          return -12;
        }
        return 0;
      }
      function arraySum(array, index) {
        var sum2 = 0;
        for (var i = 0; i <= index; sum2 += array[i++]) {
        }
        return sum2;
      }
      var MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function addDays(date, days) {
        var newDate = new Date(date.getTime());
        while (days > 0) {
          var leap = isLeapYear(newDate.getFullYear());
          var currentMonth = newDate.getMonth();
          var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];
          if (days > daysInCurrentMonth - newDate.getDate()) {
            days -= daysInCurrentMonth - newDate.getDate() + 1;
            newDate.setDate(1);
            if (currentMonth < 11) {
              newDate.setMonth(currentMonth + 1);
            } else {
              newDate.setMonth(0);
              newDate.setFullYear(newDate.getFullYear() + 1);
            }
          } else {
            newDate.setDate(newDate.getDate() + days);
            return newDate;
          }
        }
        return newDate;
      }
      function intArrayFromString(stringy, dontAddNull, length) {
        var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull)
          u8array.length = numBytesWritten;
        return u8array;
      }
      function writeArrayToMemory(array, buffer) {
        assert(array.length >= 0, "writeArrayToMemory array must have a length (should be an array or typed array)");
        HEAP8.set(array, buffer >>> 0);
      }
      function _strftime(s, maxsize, format, tm) {
        var tm_zone = HEAP32[tm + 40 >>> 2];
        var date = {
          tm_sec: HEAP32[tm >>> 2],
          tm_min: HEAP32[tm + 4 >>> 2],
          tm_hour: HEAP32[tm + 8 >>> 2],
          tm_mday: HEAP32[tm + 12 >>> 2],
          tm_mon: HEAP32[tm + 16 >>> 2],
          tm_year: HEAP32[tm + 20 >>> 2],
          tm_wday: HEAP32[tm + 24 >>> 2],
          tm_yday: HEAP32[tm + 28 >>> 2],
          tm_isdst: HEAP32[tm + 32 >>> 2],
          tm_gmtoff: HEAP32[tm + 36 >>> 2],
          tm_zone: tm_zone ? UTF8ToString(tm_zone) : ""
        };
        var pattern = UTF8ToString(format);
        var EXPANSION_RULES_1 = {
          "%c": "%a %b %d %H:%M:%S %Y",
          "%D": "%m/%d/%y",
          "%F": "%Y-%m-%d",
          "%h": "%b",
          "%r": "%I:%M:%S %p",
          "%R": "%H:%M",
          "%T": "%H:%M:%S",
          "%x": "%m/%d/%y",
          "%X": "%H:%M:%S",
          "%Ec": "%c",
          "%EC": "%C",
          "%Ex": "%m/%d/%y",
          "%EX": "%H:%M:%S",
          "%Ey": "%y",
          "%EY": "%Y",
          "%Od": "%d",
          "%Oe": "%e",
          "%OH": "%H",
          "%OI": "%I",
          "%Om": "%m",
          "%OM": "%M",
          "%OS": "%S",
          "%Ou": "%u",
          "%OU": "%U",
          "%OV": "%V",
          "%Ow": "%w",
          "%OW": "%W",
          "%Oy": "%y"
        };
        for (var rule in EXPANSION_RULES_1) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
        }
        var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        function leadingSomething(value, digits, character) {
          var str = typeof value == "number" ? value.toString() : value || "";
          while (str.length < digits) {
            str = character[0] + str;
          }
          return str;
        }
        function leadingNulls(value, digits) {
          return leadingSomething(value, digits, "0");
        }
        function compareByDay(date1, date2) {
          function sgn(value) {
            return value < 0 ? -1 : value > 0 ? 1 : 0;
          }
          var compare;
          if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
            if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
              compare = sgn(date1.getDate() - date2.getDate());
            }
          }
          return compare;
        }
        function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0:
              return new Date(janFourth.getFullYear() - 1, 11, 29);
            case 1:
              return janFourth;
            case 2:
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3:
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4:
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5:
              return new Date(janFourth.getFullYear() - 1, 11, 31);
            case 6:
              return new Date(janFourth.getFullYear() - 1, 11, 30);
          }
        }
        function getWeekBasedYear(date2) {
          var thisDate = addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear() + 1;
            }
            return thisDate.getFullYear();
          }
          return thisDate.getFullYear() - 1;
        }
        var EXPANSION_RULES_2 = {
          "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          },
          "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          },
          "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          },
          "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          },
          "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          },
          "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          },
          "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          },
          "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          },
          "%G": function(date2) {
            return getWeekBasedYear(date2);
          },
          "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          },
          "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          },
          "%j": function(date2) {
            return leadingNulls(date2.tm_mday + arraySum(isLeapYear(date2.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          },
          "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          },
          "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          },
          "%n": function() {
            return "\n";
          },
          "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            }
            return "PM";
          },
          "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          },
          "%t": function() {
            return "	";
          },
          "%u": function(date2) {
            return date2.tm_wday || 7;
          },
          "%U": function(date2) {
            var days = date2.tm_yday + 7 - date2.tm_wday;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%V": function(date2) {
            var val = Math.floor((date2.tm_yday + 7 - (date2.tm_wday + 6) % 7) / 7);
            if ((date2.tm_wday + 371 - date2.tm_yday - 2) % 7 <= 2) {
              val++;
            }
            if (!val) {
              val = 52;
              var dec31 = (date2.tm_wday + 7 - date2.tm_yday - 1) % 7;
              if (dec31 == 4 || dec31 == 5 && isLeapYear(date2.tm_year % 400 - 1)) {
                val++;
              }
            } else if (val == 53) {
              var jan1 = (date2.tm_wday + 371 - date2.tm_yday) % 7;
              if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date2.tm_year)))
                val = 1;
            }
            return leadingNulls(val, 2);
          },
          "%w": function(date2) {
            return date2.tm_wday;
          },
          "%W": function(date2) {
            var days = date2.tm_yday + 7 - (date2.tm_wday + 6) % 7;
            return leadingNulls(Math.floor(days / 7), 2);
          },
          "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          },
          "%Y": function(date2) {
            return date2.tm_year + 1900;
          },
          "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          },
          "%Z": function(date2) {
            return date2.tm_zone;
          },
          "%%": function() {
            return "%";
          }
        };
        pattern = pattern.replace(/%%/g, "\0\0");
        for (var rule in EXPANSION_RULES_2) {
          if (pattern.includes(rule)) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
          }
        }
        pattern = pattern.replace(/\0\0/g, "%");
        var bytes = intArrayFromString(pattern, false);
        if (bytes.length > maxsize) {
          return 0;
        }
        writeArrayToMemory(bytes, s);
        return bytes.length - 1;
      }
      function _strftime_l(s, maxsize, format, tm, loc) {
        return _strftime(s, maxsize, format, tm);
      }
      function _ucnv_close_64() {
        err("missing function: ucnv_close_64");
        abort(-1);
      }
      function _ucnv_convertEx_64() {
        err("missing function: ucnv_convertEx_64");
        abort(-1);
      }
      function _ucnv_open_64() {
        err("missing function: ucnv_open_64");
        abort(-1);
      }
      function _ucnv_toAlgorithmic_64() {
        err("missing function: ucnv_toAlgorithmic_64");
        abort(-1);
      }
      function _ucsdet_close_64() {
        err("missing function: ucsdet_close_64");
        abort(-1);
      }
      function _ucsdet_detect_64() {
        err("missing function: ucsdet_detect_64");
        abort(-1);
      }
      function _ucsdet_getConfidence_64() {
        err("missing function: ucsdet_getConfidence_64");
        abort(-1);
      }
      function _ucsdet_getName_64() {
        err("missing function: ucsdet_getName_64");
        abort(-1);
      }
      function _ucsdet_open_64() {
        err("missing function: ucsdet_open_64");
        abort(-1);
      }
      function _ucsdet_setText_64() {
        err("missing function: ucsdet_setText_64");
        abort(-1);
      }
      function _unzClose() {
        err("missing function: unzClose");
        abort(-1);
      }
      function _unzCloseCurrentFile() {
        err("missing function: unzCloseCurrentFile");
        abort(-1);
      }
      function _unzGetCurrentFileInfo() {
        err("missing function: unzGetCurrentFileInfo");
        abort(-1);
      }
      function _unzGetCurrentFileInfo64() {
        err("missing function: unzGetCurrentFileInfo64");
        abort(-1);
      }
      function _unzGetGlobalInfo() {
        err("missing function: unzGetGlobalInfo");
        abort(-1);
      }
      function _unzGoToFirstFile() {
        err("missing function: unzGoToFirstFile");
        abort(-1);
      }
      function _unzGoToNextFile() {
        err("missing function: unzGoToNextFile");
        abort(-1);
      }
      function _unzLocateFile() {
        err("missing function: unzLocateFile");
        abort(-1);
      }
      function _unzOpen() {
        err("missing function: unzOpen");
        abort(-1);
      }
      function _unzOpen2() {
        err("missing function: unzOpen2");
        abort(-1);
      }
      function _unzOpenCurrentFile() {
        err("missing function: unzOpenCurrentFile");
        abort(-1);
      }
      function _unzReadCurrentFile() {
        err("missing function: unzReadCurrentFile");
        abort(-1);
      }
      function _proc_exit(code) {
        EXITSTATUS = code;
        if (!keepRuntimeAlive()) {
          if (Module["onExit"])
            Module["onExit"](code);
          ABORT = true;
        }
        quit_(code, new ExitStatus(code));
      }
      function exitJS(status, implicit) {
        EXITSTATUS = status;
        checkUnflushedContent();
        if (keepRuntimeAlive() && !implicit) {
          var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;
          readyPromiseReject(msg);
          err(msg);
        }
        _proc_exit(status);
      }
      function handleException(e) {
        if (e instanceof ExitStatus || e == "unwind") {
          return EXITSTATUS;
        }
        checkStackCookie();
        if (e instanceof WebAssembly.RuntimeError) {
          if (_emscripten_stack_get_current() <= 0) {
            err("Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)");
          }
        }
        quit_(1, e);
      }
      function getCFunc(ident) {
        var func = Module["_" + ident];
        assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
        return func;
      }
      function stringToUTF8OnStack(str) {
        var size = lengthBytesUTF8(str) + 1;
        var ret = stackAlloc(size);
        stringToUTF8(str, ret, size);
        return ret;
      }
      function ccall(ident, returnType, argTypes, args, opts) {
        var toC = {
          "string": (str) => {
            var ret2 = 0;
            if (str !== null && str !== void 0 && str !== 0) {
              ret2 = stringToUTF8OnStack(str);
            }
            return ret2;
          },
          "array": (arr) => {
            var ret2 = stackAlloc(arr.length);
            writeArrayToMemory(arr, ret2);
            return ret2;
          }
        };
        function convertReturnValue(ret2) {
          if (returnType === "string") {
            return UTF8ToString(ret2);
          }
          if (returnType === "boolean")
            return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        assert(returnType !== "array", 'Return type should not be "array".');
        if (args) {
          for (var i = 0; i < args.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0)
                stack = stackSave();
              cArgs[i] = converter(args[i]);
            } else {
              cArgs[i] = args[i];
            }
          }
        }
        var ret = func.apply(null, cArgs);
        function onDone(ret2) {
          if (stack !== 0)
            stackRestore(stack);
          return convertReturnValue(ret2);
        }
        ret = onDone(ret);
        return ret;
      }
      function checkIncomingModuleAPI() {
        ignoredModuleProp("fetchSettings");
      }
      var wasmImports = {
        "XML_GetBuffer": _XML_GetBuffer,
        "XML_GetErrorCode": _XML_GetErrorCode,
        "XML_Parse": _XML_Parse,
        "XML_ParseBuffer": _XML_ParseBuffer,
        "XML_ParserCreate": _XML_ParserCreate,
        "XML_ParserFree": _XML_ParserFree,
        "XML_ResumeParser": _XML_ResumeParser,
        "XML_SetCharacterDataHandler": _XML_SetCharacterDataHandler,
        "XML_SetElementHandler": _XML_SetElementHandler,
        "XML_SetUserData": _XML_SetUserData,
        "XML_StopParser": _XML_StopParser,
        "__assert_fail": ___assert_fail,
        "__dlsym": ___dlsym,
        "__syscall__newselect": ___syscall__newselect,
        "__syscall_bind": ___syscall_bind,
        "__syscall_connect": ___syscall_connect,
        "__syscall_faccessat": ___syscall_faccessat,
        "__syscall_fcntl64": ___syscall_fcntl64,
        "__syscall_fstat64": ___syscall_fstat64,
        "__syscall_ftruncate64": ___syscall_ftruncate64,
        "__syscall_getdents64": ___syscall_getdents64,
        "__syscall_getpeername": ___syscall_getpeername,
        "__syscall_getsockopt": ___syscall_getsockopt,
        "__syscall_ioctl": ___syscall_ioctl,
        "__syscall_lstat64": ___syscall_lstat64,
        "__syscall_mkdirat": ___syscall_mkdirat,
        "__syscall_newfstatat": ___syscall_newfstatat,
        "__syscall_openat": ___syscall_openat,
        "__syscall_recvfrom": ___syscall_recvfrom,
        "__syscall_renameat": ___syscall_renameat,
        "__syscall_rmdir": ___syscall_rmdir,
        "__syscall_sendto": ___syscall_sendto,
        "__syscall_socket": ___syscall_socket,
        "__syscall_stat64": ___syscall_stat64,
        "__syscall_unlinkat": ___syscall_unlinkat,
        "__throw_exception_with_stack_trace": ___throw_exception_with_stack_trace,
        "_emscripten_get_now_is_monotonic": __emscripten_get_now_is_monotonic,
        "_localtime_js": __localtime_js,
        "_tzset_js": __tzset_js,
        "abort": _abort,
        "dlopen": _dlopen,
        "duckdb_web_fs_directory_create": _duckdb_web_fs_directory_create,
        "duckdb_web_fs_directory_exists": _duckdb_web_fs_directory_exists,
        "duckdb_web_fs_directory_list_files": _duckdb_web_fs_directory_list_files,
        "duckdb_web_fs_directory_remove": _duckdb_web_fs_directory_remove,
        "duckdb_web_fs_file_close": _duckdb_web_fs_file_close,
        "duckdb_web_fs_file_exists": _duckdb_web_fs_file_exists,
        "duckdb_web_fs_file_get_last_modified_time": _duckdb_web_fs_file_get_last_modified_time,
        "duckdb_web_fs_file_move": _duckdb_web_fs_file_move,
        "duckdb_web_fs_file_open": _duckdb_web_fs_file_open,
        "duckdb_web_fs_file_read": _duckdb_web_fs_file_read,
        "duckdb_web_fs_file_truncate": _duckdb_web_fs_file_truncate,
        "duckdb_web_fs_file_write": _duckdb_web_fs_file_write,
        "duckdb_web_fs_get_default_data_protocol": _duckdb_web_fs_get_default_data_protocol,
        "duckdb_web_fs_glob": _duckdb_web_fs_glob,
        "duckdb_web_test_platform_feature": _duckdb_web_test_platform_feature,
        "duckdb_web_udf_scalar_call": _duckdb_web_udf_scalar_call,
        "emscripten_console_error": _emscripten_console_error,
        "emscripten_date_now": _emscripten_date_now,
        "emscripten_get_heap_max": _emscripten_get_heap_max,
        "emscripten_get_now": _emscripten_get_now,
        "emscripten_memcpy_big": _emscripten_memcpy_big,
        "emscripten_resize_heap": _emscripten_resize_heap,
        "environ_get": _environ_get,
        "environ_sizes_get": _environ_sizes_get,
        "fd_close": _fd_close,
        "fd_fdstat_get": _fd_fdstat_get,
        "fd_pread": _fd_pread,
        "fd_pwrite": _fd_pwrite,
        "fd_read": _fd_read,
        "fd_seek": _fd_seek,
        "fd_sync": _fd_sync,
        "fd_write": _fd_write,
        "getaddrinfo": _getaddrinfo,
        "getentropy": _getentropy,
        "getnameinfo": _getnameinfo,
        "strftime_l": _strftime_l,
        "ucnv_close_64": _ucnv_close_64,
        "ucnv_convertEx_64": _ucnv_convertEx_64,
        "ucnv_open_64": _ucnv_open_64,
        "ucnv_toAlgorithmic_64": _ucnv_toAlgorithmic_64,
        "ucsdet_close_64": _ucsdet_close_64,
        "ucsdet_detect_64": _ucsdet_detect_64,
        "ucsdet_getConfidence_64": _ucsdet_getConfidence_64,
        "ucsdet_getName_64": _ucsdet_getName_64,
        "ucsdet_open_64": _ucsdet_open_64,
        "ucsdet_setText_64": _ucsdet_setText_64,
        "unzClose": _unzClose,
        "unzCloseCurrentFile": _unzCloseCurrentFile,
        "unzGetCurrentFileInfo": _unzGetCurrentFileInfo,
        "unzGetCurrentFileInfo64": _unzGetCurrentFileInfo64,
        "unzGetGlobalInfo": _unzGetGlobalInfo,
        "unzGoToFirstFile": _unzGoToFirstFile,
        "unzGoToNextFile": _unzGoToNextFile,
        "unzLocateFile": _unzLocateFile,
        "unzOpen": _unzOpen,
        "unzOpen2": _unzOpen2,
        "unzOpenCurrentFile": _unzOpenCurrentFile,
        "unzReadCurrentFile": _unzReadCurrentFile
      };
      var asm = createWasm();
      var ___wasm_call_ctors = createExportWrapper("__wasm_call_ctors");
      var _main = Module["_main"] = createExportWrapper("main");
      var _duckdb_web_fs_glob_add_path = Module["_duckdb_web_fs_glob_add_path"] = createExportWrapper("duckdb_web_fs_glob_add_path");
      var _duckdb_web_clear_response = Module["_duckdb_web_clear_response"] = createExportWrapper("duckdb_web_clear_response");
      var _duckdb_web_fail_with = Module["_duckdb_web_fail_with"] = createExportWrapper("duckdb_web_fail_with");
      var _duckdb_web_reset = Module["_duckdb_web_reset"] = createExportWrapper("duckdb_web_reset");
      var _duckdb_web_connect = Module["_duckdb_web_connect"] = createExportWrapper("duckdb_web_connect");
      var _duckdb_web_disconnect = Module["_duckdb_web_disconnect"] = createExportWrapper("duckdb_web_disconnect");
      var _duckdb_web_flush_files = Module["_duckdb_web_flush_files"] = createExportWrapper("duckdb_web_flush_files");
      var _duckdb_web_flush_file = Module["_duckdb_web_flush_file"] = createExportWrapper("duckdb_web_flush_file");
      var _duckdb_web_open = Module["_duckdb_web_open"] = createExportWrapper("duckdb_web_open");
      var _duckdb_web_get_global_file_info = Module["_duckdb_web_get_global_file_info"] = createExportWrapper("duckdb_web_get_global_file_info");
      var _duckdb_web_collect_file_stats = Module["_duckdb_web_collect_file_stats"] = createExportWrapper("duckdb_web_collect_file_stats");
      var _duckdb_web_export_file_stats = Module["_duckdb_web_export_file_stats"] = createExportWrapper("duckdb_web_export_file_stats");
      var _duckdb_web_fs_drop_file = Module["_duckdb_web_fs_drop_file"] = createExportWrapper("duckdb_web_fs_drop_file");
      var _duckdb_web_fs_drop_files = Module["_duckdb_web_fs_drop_files"] = createExportWrapper("duckdb_web_fs_drop_files");
      var _duckdb_web_fs_glob_file_infos = Module["_duckdb_web_fs_glob_file_infos"] = createExportWrapper("duckdb_web_fs_glob_file_infos");
      var _duckdb_web_fs_get_file_info_by_id = Module["_duckdb_web_fs_get_file_info_by_id"] = createExportWrapper("duckdb_web_fs_get_file_info_by_id");
      var _duckdb_web_fs_get_file_info_by_name = Module["_duckdb_web_fs_get_file_info_by_name"] = createExportWrapper("duckdb_web_fs_get_file_info_by_name");
      var _duckdb_web_fs_register_file_url = Module["_duckdb_web_fs_register_file_url"] = createExportWrapper("duckdb_web_fs_register_file_url");
      var _duckdb_web_fs_register_file_buffer = Module["_duckdb_web_fs_register_file_buffer"] = createExportWrapper("duckdb_web_fs_register_file_buffer");
      var _duckdb_web_copy_file_to_buffer = Module["_duckdb_web_copy_file_to_buffer"] = createExportWrapper("duckdb_web_copy_file_to_buffer");
      var _duckdb_web_copy_file_to_path = Module["_duckdb_web_copy_file_to_path"] = createExportWrapper("duckdb_web_copy_file_to_path");
      var _duckdb_web_get_version = Module["_duckdb_web_get_version"] = createExportWrapper("duckdb_web_get_version");
      var _duckdb_web_get_feature_flags = Module["_duckdb_web_get_feature_flags"] = createExportWrapper("duckdb_web_get_feature_flags");
      var _duckdb_web_tokenize = Module["_duckdb_web_tokenize"] = createExportWrapper("duckdb_web_tokenize");
      var _duckdb_web_udf_scalar_create = Module["_duckdb_web_udf_scalar_create"] = createExportWrapper("duckdb_web_udf_scalar_create");
      var _duckdb_web_prepared_create = Module["_duckdb_web_prepared_create"] = createExportWrapper("duckdb_web_prepared_create");
      var _duckdb_web_prepared_close = Module["_duckdb_web_prepared_close"] = createExportWrapper("duckdb_web_prepared_close");
      var _duckdb_web_prepared_run = Module["_duckdb_web_prepared_run"] = createExportWrapper("duckdb_web_prepared_run");
      var _duckdb_web_prepared_send = Module["_duckdb_web_prepared_send"] = createExportWrapper("duckdb_web_prepared_send");
      var _duckdb_web_query_run = Module["_duckdb_web_query_run"] = createExportWrapper("duckdb_web_query_run");
      var _duckdb_web_pending_query_start = Module["_duckdb_web_pending_query_start"] = createExportWrapper("duckdb_web_pending_query_start");
      var _duckdb_web_pending_query_poll = Module["_duckdb_web_pending_query_poll"] = createExportWrapper("duckdb_web_pending_query_poll");
      var _duckdb_web_pending_query_cancel = Module["_duckdb_web_pending_query_cancel"] = createExportWrapper("duckdb_web_pending_query_cancel");
      var _duckdb_web_query_fetch_results = Module["_duckdb_web_query_fetch_results"] = createExportWrapper("duckdb_web_query_fetch_results");
      var _duckdb_web_get_tablenames = Module["_duckdb_web_get_tablenames"] = createExportWrapper("duckdb_web_get_tablenames");
      var _duckdb_web_insert_arrow_from_ipc_stream = Module["_duckdb_web_insert_arrow_from_ipc_stream"] = createExportWrapper("duckdb_web_insert_arrow_from_ipc_stream");
      var _duckdb_web_insert_csv_from_path = Module["_duckdb_web_insert_csv_from_path"] = createExportWrapper("duckdb_web_insert_csv_from_path");
      var _duckdb_web_insert_json_from_path = Module["_duckdb_web_insert_json_from_path"] = createExportWrapper("duckdb_web_insert_json_from_path");
      var ___errno_location = createExportWrapper("__errno_location");
      var _fflush = Module["_fflush"] = createExportWrapper("fflush");
      var _htonl = createExportWrapper("htonl");
      var _htons = createExportWrapper("htons");
      var _ntohs = createExportWrapper("ntohs");
      var _malloc = Module["_malloc"] = createExportWrapper("malloc");
      var _free = Module["_free"] = createExportWrapper("free");
      var ___trap = function() {
        return (___trap = Module["asm"]["__trap"]).apply(null, arguments);
      };
      var _emscripten_stack_init = function() {
        return (_emscripten_stack_init = Module["asm"]["emscripten_stack_init"]).apply(null, arguments);
      };
      var _emscripten_stack_get_free = function() {
        return (_emscripten_stack_get_free = Module["asm"]["emscripten_stack_get_free"]).apply(null, arguments);
      };
      var _emscripten_stack_get_base = function() {
        return (_emscripten_stack_get_base = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
      };
      var _emscripten_stack_get_end = function() {
        return (_emscripten_stack_get_end = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
      };
      var stackSave = createExportWrapper("stackSave");
      var stackRestore = createExportWrapper("stackRestore");
      var stackAlloc = createExportWrapper("stackAlloc");
      var _emscripten_stack_get_current = function() {
        return (_emscripten_stack_get_current = Module["asm"]["emscripten_stack_get_current"]).apply(null, arguments);
      };
      var ___cxa_decrement_exception_refcount = Module["___cxa_decrement_exception_refcount"] = createExportWrapper("__cxa_decrement_exception_refcount");
      var ___cxa_increment_exception_refcount = Module["___cxa_increment_exception_refcount"] = createExportWrapper("__cxa_increment_exception_refcount");
      var ___thrown_object_from_unwind_exception = Module["___thrown_object_from_unwind_exception"] = createExportWrapper("__thrown_object_from_unwind_exception");
      var ___get_exception_message = Module["___get_exception_message"] = createExportWrapper("__get_exception_message");
      var dynCall_jiji = Module["dynCall_jiji"] = createExportWrapper("dynCall_jiji");
      var dynCall_iiiiij = Module["dynCall_iiiiij"] = createExportWrapper("dynCall_iiiiij");
      var dynCall_iiiiijj = Module["dynCall_iiiiijj"] = createExportWrapper("dynCall_iiiiijj");
      var dynCall_iiiiiijj = Module["dynCall_iiiiiijj"] = createExportWrapper("dynCall_iiiiiijj");
      var dynCall_viijii = Module["dynCall_viijii"] = createExportWrapper("dynCall_viijii");
      var dynCall_viijji = Module["dynCall_viijji"] = createExportWrapper("dynCall_viijji");
      var dynCall_iiiji = Module["dynCall_iiiji"] = createExportWrapper("dynCall_iiiji");
      var dynCall_ji = Module["dynCall_ji"] = createExportWrapper("dynCall_ji");
      var dynCall_viij = Module["dynCall_viij"] = createExportWrapper("dynCall_viij");
      var dynCall_vij = Module["dynCall_vij"] = createExportWrapper("dynCall_vij");
      var dynCall_vjjijij = Module["dynCall_vjjijij"] = createExportWrapper("dynCall_vjjijij");
      var dynCall_vijjji = Module["dynCall_vijjji"] = createExportWrapper("dynCall_vijjji");
      var dynCall_vjjii = Module["dynCall_vjjii"] = createExportWrapper("dynCall_vjjii");
      var dynCall_viiiiiji = Module["dynCall_viiiiiji"] = createExportWrapper("dynCall_viiiiiji");
      var dynCall_jiiiji = Module["dynCall_jiiiji"] = createExportWrapper("dynCall_jiiiji");
      var dynCall_jiiij = Module["dynCall_jiiij"] = createExportWrapper("dynCall_jiiij");
      var dynCall_jijjij = Module["dynCall_jijjij"] = createExportWrapper("dynCall_jijjij");
      var dynCall_iiij = Module["dynCall_iiij"] = createExportWrapper("dynCall_iiij");
      var dynCall_vijjj = Module["dynCall_vijjj"] = createExportWrapper("dynCall_vijjj");
      var dynCall_vijj = Module["dynCall_vijj"] = createExportWrapper("dynCall_vijj");
      var dynCall_viijj = Module["dynCall_viijj"] = createExportWrapper("dynCall_viijj");
      var dynCall_jiijii = Module["dynCall_jiijii"] = createExportWrapper("dynCall_jiijii");
      var dynCall_jijiii = Module["dynCall_jijiii"] = createExportWrapper("dynCall_jijiii");
      var dynCall_viijiiiii = Module["dynCall_viijiiiii"] = createExportWrapper("dynCall_viijiiiii");
      var dynCall_viijiiij = Module["dynCall_viijiiij"] = createExportWrapper("dynCall_viijiiij");
      var dynCall_vijiiiji = Module["dynCall_vijiiiji"] = createExportWrapper("dynCall_vijiiiji");
      var dynCall_viiiij = Module["dynCall_viiiij"] = createExportWrapper("dynCall_viiiij");
      var dynCall_jiiji = Module["dynCall_jiiji"] = createExportWrapper("dynCall_jiiji");
      var dynCall_viiijij = Module["dynCall_viiijij"] = createExportWrapper("dynCall_viiijij");
      var dynCall_viijiij = Module["dynCall_viijiij"] = createExportWrapper("dynCall_viijiij");
      var dynCall_viiiiijj = Module["dynCall_viiiiijj"] = createExportWrapper("dynCall_viiiiijj");
      var dynCall_viiijji = Module["dynCall_viiijji"] = createExportWrapper("dynCall_viiijji");
      var dynCall_vijii = Module["dynCall_vijii"] = createExportWrapper("dynCall_vijii");
      var dynCall_iiiiiji = Module["dynCall_iiiiiji"] = createExportWrapper("dynCall_iiiiiji");
      var dynCall_iij = Module["dynCall_iij"] = createExportWrapper("dynCall_iij");
      var dynCall_iiijj = Module["dynCall_iiijj"] = createExportWrapper("dynCall_iiijj");
      var dynCall_iijii = Module["dynCall_iijii"] = createExportWrapper("dynCall_iijii");
      var dynCall_viji = Module["dynCall_viji"] = createExportWrapper("dynCall_viji");
      var dynCall_iiji = Module["dynCall_iiji"] = createExportWrapper("dynCall_iiji");
      var dynCall_viijjj = Module["dynCall_viijjj"] = createExportWrapper("dynCall_viijjj");
      var dynCall_viiijj = Module["dynCall_viiijj"] = createExportWrapper("dynCall_viiijj");
      var dynCall_jijj = Module["dynCall_jijj"] = createExportWrapper("dynCall_jijj");
      var dynCall_jiiiii = Module["dynCall_jiiiii"] = createExportWrapper("dynCall_jiiiii");
      var dynCall_jiiii = Module["dynCall_jiiii"] = createExportWrapper("dynCall_jiiii");
      var dynCall_jii = Module["dynCall_jii"] = createExportWrapper("dynCall_jii");
      var dynCall_viijij = Module["dynCall_viijij"] = createExportWrapper("dynCall_viijij");
      var dynCall_viiij = Module["dynCall_viiij"] = createExportWrapper("dynCall_viiij");
      var dynCall_j = Module["dynCall_j"] = createExportWrapper("dynCall_j");
      var dynCall_viiijiiiijj = Module["dynCall_viiijiiiijj"] = createExportWrapper("dynCall_viiijiiiijj");
      var dynCall_jiiiij = Module["dynCall_jiiiij"] = createExportWrapper("dynCall_jiiiij");
      var dynCall_jj = Module["dynCall_jj"] = createExportWrapper("dynCall_jj");
      var dynCall_ij = Module["dynCall_ij"] = createExportWrapper("dynCall_ij");
      var dynCall_ijjj = Module["dynCall_ijjj"] = createExportWrapper("dynCall_ijjj");
      var dynCall_jjjd = Module["dynCall_jjjd"] = createExportWrapper("dynCall_jjjd");
      var dynCall_jjjjjjd = Module["dynCall_jjjjjjd"] = createExportWrapper("dynCall_jjjjjjd");
      var dynCall_jij = Module["dynCall_jij"] = createExportWrapper("dynCall_jij");
      var dynCall_viiijiiijii = Module["dynCall_viiijiiijii"] = createExportWrapper("dynCall_viiijiiijii");
      var dynCall_viijijiiii = Module["dynCall_viijijiiii"] = createExportWrapper("dynCall_viijijiiii");
      var dynCall_viiji = Module["dynCall_viiji"] = createExportWrapper("dynCall_viiji");
      var dynCall_jiiiijj = Module["dynCall_jiiiijj"] = createExportWrapper("dynCall_jiiiijj");
      var dynCall_viiiji = Module["dynCall_viiiji"] = createExportWrapper("dynCall_viiiji");
      var dynCall_viiiiji = Module["dynCall_viiiiji"] = createExportWrapper("dynCall_viiiiji");
      var dynCall_jijiiii = Module["dynCall_jijiiii"] = createExportWrapper("dynCall_jijiiii");
      var dynCall_viiijiji = Module["dynCall_viiijiji"] = createExportWrapper("dynCall_viiijiji");
      var dynCall_viijiji = Module["dynCall_viijiji"] = createExportWrapper("dynCall_viijiji");
      var dynCall_jiii = Module["dynCall_jiii"] = createExportWrapper("dynCall_jiii");
      Module["stackAlloc"] = stackAlloc;
      Module["stackSave"] = stackSave;
      Module["stackRestore"] = stackRestore;
      Module["ccall"] = ccall;
      var missingLibrarySymbols = ["getHostByName", "traverseStack", "getCallstack", "emscriptenLog", "convertPCtoSourceLocation", "readEmAsmArgs", "jstoi_s", "listenOnce", "autoResumeAudioContext", "dynCallLegacy", "getDynCaller", "dynCall", "runtimeKeepalivePush", "runtimeKeepalivePop", "callUserCallback", "maybeExit", "safeSetTimeout", "asmjsMangle", "asyncLoad", "alignMemory", "mmapAlloc", "HandleAllocator", "getNativeTypeSize", "STACK_SIZE", "STACK_ALIGN", "POINTER_SIZE", "ASSERTIONS", "writeI53ToI64", "writeI53ToI64Clamped", "writeI53ToI64Signaling", "writeI53ToU64Clamped", "writeI53ToU64Signaling", "readI53FromU64", "convertI32PairToI53", "convertU32PairToI53", "cwrap", "uleb128Encode", "sigToWasmTypes", "generateFuncType", "convertJsFunctionToWasm", "getEmptyTableSlot", "updateTableMap", "getFunctionAddress", "addFunction", "removeFunction", "reallyNegative", "unSign", "strLen", "reSign", "formatString", "intArrayToString", "AsciiToString", "UTF16ToString", "stringToUTF16", "lengthBytesUTF16", "UTF32ToString", "stringToUTF32", "lengthBytesUTF32", "registerKeyEventCallback", "maybeCStringToJsString", "findEventTarget", "findCanvasEventTarget", "getBoundingClientRect", "fillMouseEventData", "registerMouseEventCallback", "registerWheelEventCallback", "registerUiEventCallback", "registerFocusEventCallback", "fillDeviceOrientationEventData", "registerDeviceOrientationEventCallback", "fillDeviceMotionEventData", "registerDeviceMotionEventCallback", "screenOrientation", "fillOrientationChangeEventData", "registerOrientationChangeEventCallback", "fillFullscreenChangeEventData", "registerFullscreenChangeEventCallback", "JSEvents_requestFullscreen", "JSEvents_resizeCanvasForFullscreen", "registerRestoreOldStyle", "hideEverythingExceptGivenElement", "restoreHiddenElements", "setLetterbox", "softFullscreenResizeWebGLRenderTarget", "doRequestFullscreen", "fillPointerlockChangeEventData", "registerPointerlockChangeEventCallback", "registerPointerlockErrorEventCallback", "requestPointerLock", "fillVisibilityChangeEventData", "registerVisibilityChangeEventCallback", "registerTouchEventCallback", "fillGamepadEventData", "registerGamepadEventCallback", "registerBeforeUnloadEventCallback", "fillBatteryEventData", "battery", "registerBatteryEventCallback", "setCanvasElementSize", "getCanvasElementSize", "demangle", "demangleAll", "jsStackTrace", "stackTrace", "checkWasiClock", "wasiRightsToMuslOFlags", "wasiOFlagsToMuslOFlags", "createDyncallWrapper", "setImmediateWrapped", "clearImmediateWrapped", "polyfillSetImmediate", "getPromise", "makePromise", "idsToPromises", "makePromiseCallback", "setMainLoop", "heapObjectForWebGLType", "heapAccessShiftForWebGLHeap", "webgl_enable_ANGLE_instanced_arrays", "webgl_enable_OES_vertex_array_object", "webgl_enable_WEBGL_draw_buffers", "webgl_enable_WEBGL_multi_draw", "emscriptenWebGLGet", "computeUnpackAlignedImageSize", "colorChannelsInGlTextureFormat", "emscriptenWebGLGetTexPixelData", "__glGenObject", "emscriptenWebGLGetUniform", "webglGetUniformLocation", "webglPrepareUniformLocationsBeforeFirstUse", "webglGetLeftBracePos", "emscriptenWebGLGetVertexAttrib", "__glGetActiveAttribOrUniform", "writeGLArray", "registerWebGlEventCallback", "runAndAbortIfError", "SDL_unicode", "SDL_ttfContext", "SDL_audio", "GLFW_Window", "ALLOC_NORMAL", "ALLOC_STACK", "allocate", "writeStringToMemory", "writeAsciiToMemory"];
      missingLibrarySymbols.forEach(missingLibrarySymbol);
      var unexportedSymbols = ["run", "addOnPreRun", "addOnInit", "addOnPreMain", "addOnExit", "addOnPostRun", "addRunDependency", "removeRunDependency", "FS_createFolder", "FS_createPath", "FS_createDataFile", "FS_createLazyFile", "FS_createLink", "FS_createDevice", "FS_unlink", "out", "err", "callMain", "abort", "keepRuntimeAlive", "wasmMemory", "getTempRet0", "setTempRet0", "writeStackCookie", "checkStackCookie", "ptrToString", "zeroMemory", "exitJS", "getHeapMax", "emscripten_realloc_buffer", "ENV", "MONTH_DAYS_REGULAR", "MONTH_DAYS_LEAP", "MONTH_DAYS_REGULAR_CUMULATIVE", "MONTH_DAYS_LEAP_CUMULATIVE", "isLeapYear", "ydayFromDate", "arraySum", "addDays", "ERRNO_CODES", "ERRNO_MESSAGES", "setErrNo", "inetPton4", "inetNtop4", "inetPton6", "inetNtop6", "readSockaddr", "writeSockaddr", "DNS", "Protocols", "Sockets", "initRandomFill", "randomFill", "timers", "warnOnce", "UNWIND_CACHE", "readEmAsmArgsArray", "jstoi_q", "getExecutableName", "handleException", "readI53FromI64", "convertI32PairToI53Checked", "getCFunc", "freeTableIndexes", "functionsInTableMap", "setValue", "getValue", "PATH", "PATH_FS", "UTF8Decoder", "UTF8ArrayToString", "UTF8ToString", "stringToUTF8Array", "stringToUTF8", "lengthBytesUTF8", "intArrayFromString", "stringToAscii", "UTF16Decoder", "stringToNewUTF8", "stringToUTF8OnStack", "writeArrayToMemory", "JSEvents", "specialHTMLTargets", "currentFullscreenStrategy", "restoreOldWindowedStyle", "ExitStatus", "getEnvStrings", "flush_NO_FILESYSTEM", "dlopenMissingError", "promiseMap", "getExceptionMessageCommon", "getCppExceptionTag", "getCppExceptionThrownObjectFromWebAssemblyException", "incrementExceptionRefcount", "decrementExceptionRefcount", "getExceptionMessage", "Browser", "wget", "SYSCALLS", "getSocketFromFD", "getSocketAddress", "tempFixedLengthArray", "miniTempWebGLFloatBuffers", "miniTempWebGLIntBuffers", "GL", "emscripten_webgl_power_preferences", "AL", "GLUT", "EGL", "GLEW", "IDBStore", "SDL", "SDL_gfx", "GLFW", "allocateUTF8", "allocateUTF8OnStack", "SOCKFS", "FS"];
      unexportedSymbols.forEach(unexportedRuntimeSymbol);
      var calledRun;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun)
          run();
        if (!calledRun)
          dependenciesFulfilled = runCaller;
      };
      function callMain() {
        assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module["onRuntimeInitialized"])');
        assert(__ATPRERUN__.length == 0, "cannot call main when preRun functions remain to be called");
        var entryFunction = _main;
        var argc = 0;
        var argv = 0;
        try {
          var ret = entryFunction(argc, argv);
          exitJS(ret, true);
          return ret;
        } catch (e) {
          return handleException(e);
        }
      }
      function stackCheckInit() {
        _emscripten_stack_init();
        writeStackCookie();
      }
      function run() {
        if (runDependencies > 0) {
          return;
        }
        stackCheckInit();
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          if (calledRun)
            return;
          calledRun = true;
          Module["calledRun"] = true;
          if (ABORT)
            return;
          initRuntime();
          preMain();
          readyPromiseResolve(Module);
          if (Module["onRuntimeInitialized"])
            Module["onRuntimeInitialized"]();
          if (shouldRunNow)
            callMain();
          postRun();
        }
        if (Module["setStatus"]) {
          Module["setStatus"]("Running...");
          setTimeout(function() {
            setTimeout(function() {
              Module["setStatus"]("");
            }, 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
        checkStackCookie();
      }
      function checkUnflushedContent() {
        var oldOut = out;
        var oldErr = err;
        var has = false;
        out = err = (x) => {
          has = true;
        };
        try {
          flush_NO_FILESYSTEM();
        } catch (e) {
        }
        out = oldOut;
        err = oldErr;
        if (has) {
          warnOnce("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.");
          warnOnce("(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)");
        }
      }
      if (Module["preInit"]) {
        if (typeof Module["preInit"] == "function")
          Module["preInit"] = [Module["preInit"]];
        while (Module["preInit"].length > 0) {
          Module["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module["noInitialRun"])
        shouldRunNow = false;
      run();
      return DuckDB5.ready;
    };
  })();
  var duckdb_eh_default = DuckDB3;

  // src/bindings/bindings_browser_eh.ts
  var DuckDB4 = class extends DuckDBBrowserBindings {
    constructor(logger, runtime, mainModuleURL, pthreadWorkerURL = null) {
      super(logger, runtime, mainModuleURL, pthreadWorkerURL);
    }
    instantiateImpl(moduleOverrides) {
      return duckdb_eh_default({
        ...moduleOverrides,
        instantiateWasm: this.instantiateWasm.bind(this),
        locateFile: this.locateFile.bind(this)
      });
    }
  };

  // src/targets/duckdb-browser-blocking.ts
  async function createDuckDB(bundles, logger, runtime) {
    const platform = await getPlatformFeatures();
    if (platform.wasmExceptions) {
      if (bundles.eh) {
        return new DuckDB4(logger, runtime, bundles.eh.mainModule);
      }
    }
    return new DuckDB2(logger, runtime, bundles.mvp.mainModule);
  }

  // src/parallel/async_connection.ts
  var AsyncDuckDBConnection = class {
    constructor(bindings, conn) {
      this._bindings = bindings;
      this._conn = conn;
    }
    get bindings() {
      return this._bindings;
    }
    async close() {
      return this._bindings.disconnect(this._conn);
    }
    useUnsafe(callback) {
      return callback(this._bindings, this._conn);
    }
    async query(text) {
      this._bindings.logger.log({
        timestamp: new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      const buffer = await this._bindings.runQuery(this._conn, text);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync(), "Reader is not sync");
      console.assert(reader.isFile(), "Reader is not file");
      return new Table(reader);
    }
    async send(text) {
      this._bindings.logger.log({
        timestamp: new Date(),
        level: 2 /* INFO */,
        origin: 4 /* ASYNC_DUCKDB */,
        topic: 4 /* QUERY */,
        event: 4 /* RUN */,
        value: text
      });
      let header = await this._bindings.startPendingQuery(this._conn, text);
      while (header == null) {
        header = await this._bindings.pollPendingQuery(this._conn);
      }
      const iter = new AsyncResultStreamIterator(this._bindings, this._conn, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
    async cancelSent() {
      return await this._bindings.cancelPendingQuery(this._conn);
    }
    async getTableNames(query) {
      return await this._bindings.getTableNames(this._conn, query);
    }
    async prepare(text) {
      const stmt = await this._bindings.createPrepared(this._conn, text);
      return new AsyncPreparedStatement(this._bindings, this._conn, stmt);
    }
    async insertArrowTable(table, options) {
      const buffer = tableToIPC(table, "stream");
      await this.insertArrowFromIPCStream(buffer, options);
    }
    async insertArrowFromIPCStream(buffer, options) {
      await this._bindings.insertArrowFromIPCStream(this._conn, buffer, options);
    }
    async insertCSVFromPath(text, options) {
      await this._bindings.insertCSVFromPath(this._conn, text, options);
    }
    async insertJSONFromPath(text, options) {
      await this._bindings.insertJSONFromPath(this._conn, text, options);
    }
  };
  var AsyncResultStreamIterator = class {
    constructor(db2, conn, header) {
      this.db = db2;
      this.conn = conn;
      this.header = header;
      this._first = true;
      this._depleted = false;
      this._inFlight = null;
    }
    async next() {
      if (this._first) {
        this._first = false;
        return { done: false, value: this.header };
      }
      if (this._depleted) {
        return { done: true, value: null };
      }
      let buffer;
      if (this._inFlight != null) {
        buffer = await this._inFlight;
        this._inFlight = null;
      } else {
        buffer = await this.db.fetchQueryResults(this.conn);
      }
      this._depleted = buffer.length == 0;
      if (!this._depleted) {
        this._inFlight = this.db.fetchQueryResults(this.conn);
      }
      return {
        done: this._depleted,
        value: buffer
      };
    }
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  var AsyncPreparedStatement = class {
    constructor(bindings, connectionId, statementId) {
      this.bindings = bindings;
      this.connectionId = connectionId;
      this.statementId = statementId;
    }
    async close() {
      await this.bindings.closePrepared(this.connectionId, this.statementId);
    }
    async query(...params) {
      const buffer = await this.bindings.runPrepared(this.connectionId, this.statementId, params);
      const reader = RecordBatchReader.from(buffer);
      console.assert(reader.isSync());
      console.assert(reader.isFile());
      return new Table(reader);
    }
    async send(...params) {
      const header = await this.bindings.sendPrepared(this.connectionId, this.statementId, params);
      const iter = new AsyncResultStreamIterator(this.bindings, this.connectionId, header);
      const reader = await RecordBatchReader.from(iter);
      console.assert(reader.isAsync());
      console.assert(reader.isStream());
      return reader;
    }
  };

  // src/parallel/worker_request.ts
  var WorkerTask = class {
    constructor(type, data) {
      this.promiseResolver = () => {
      };
      this.promiseRejecter = () => {
      };
      this.type = type;
      this.data = data;
      this.promise = new Promise(
        (resolve, reject) => {
          this.promiseResolver = resolve;
          this.promiseRejecter = reject;
        }
      );
    }
  };

  // src/parallel/async_bindings.ts
  var TEXT_ENCODER3 = new TextEncoder();
  var AsyncDuckDB = class {
    constructor(logger, worker2 = null) {
      this._onInstantiationProgress = [];
      this._worker = null;
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
      this._nextMessageId = 0;
      this._pendingRequests = /* @__PURE__ */ new Map();
      this._logger = logger;
      this._onMessageHandler = this.onMessage.bind(this);
      this._onErrorHandler = this.onError.bind(this);
      this._onCloseHandler = this.onClose.bind(this);
      if (worker2 != null)
        this.attach(worker2);
    }
    get logger() {
      return this._logger;
    }
    attach(worker2) {
      this._worker = worker2;
      this._worker.addEventListener("message", this._onMessageHandler);
      this._worker.addEventListener("error", this._onErrorHandler);
      this._worker.addEventListener("close", this._onCloseHandler);
      this._workerShutdownPromise = new Promise(
        (resolve, _reject) => {
          this._workerShutdownResolver = resolve;
        }
      );
    }
    detach() {
      if (!this._worker)
        return;
      this._worker.removeEventListener("message", this._onMessageHandler);
      this._worker.removeEventListener("error", this._onErrorHandler);
      this._worker.removeEventListener("close", this._onCloseHandler);
      this._worker = null;
      this._workerShutdownResolver(null);
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    async terminate() {
      if (!this._worker)
        return;
      this._worker.terminate();
      this._worker = null;
      this._workerShutdownPromise = null;
      this._workerShutdownResolver = () => {
      };
    }
    async postTask(task, transfer = []) {
      if (!this._worker) {
        console.error("cannot send a message since the worker is not set!");
        return void 0;
      }
      const mid = this._nextMessageId++;
      this._pendingRequests.set(mid, task);
      this._worker.postMessage(
        {
          messageId: mid,
          type: task.type,
          data: task.data
        },
        transfer
      );
      return await task.promise;
    }
    onMessage(event) {
      const response = event.data;
      switch (response.type) {
        case "LOG" /* LOG */: {
          this._logger.log(response.data);
          return;
        }
        case "INSTANTIATE_PROGRESS" /* INSTANTIATE_PROGRESS */: {
          for (const p of this._onInstantiationProgress) {
            p(response.data);
          }
          return;
        }
      }
      const task = this._pendingRequests.get(response.requestId);
      if (!task) {
        console.warn(`unassociated response: [${response.requestId}, ${response.type.toString()}]`);
        return;
      }
      this._pendingRequests.delete(response.requestId);
      if (response.type == "ERROR" /* ERROR */) {
        const e = new Error(response.data.message);
        e.name = response.data.name;
        e.stack = response.data.stack;
        task.promiseRejecter(e);
        return;
      }
      switch (task.type) {
        case "CLOSE_PREPARED" /* CLOSE_PREPARED */:
        case "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */:
        case "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */:
        case "DISCONNECT" /* DISCONNECT */:
        case "DROP_FILE" /* DROP_FILE */:
        case "DROP_FILES" /* DROP_FILES */:
        case "FLUSH_FILES" /* FLUSH_FILES */:
        case "INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */:
        case "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */:
        case "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */:
        case "OPEN" /* OPEN */:
        case "PING" /* PING */:
        case "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */:
        case "REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */:
        case "REGISTER_FILE_URL" /* REGISTER_FILE_URL */:
        case "RESET" /* RESET */:
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "INSTANTIATE" /* INSTANTIATE */:
          this._onInstantiationProgress = [];
          if (response.type == "OK" /* OK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */:
          if (response.type == "FILE_INFOS" /* FILE_INFOS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_VERSION" /* GET_VERSION */:
          if (response.type == "VERSION_STRING" /* VERSION_STRING */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */:
          if (response.type == "FEATURE_FLAGS" /* FEATURE_FLAGS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "GET_TABLE_NAMES" /* GET_TABLE_NAMES */:
          if (response.type == "TABLE_NAMES" /* TABLE_NAMES */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "TOKENIZE" /* TOKENIZE */:
          if (response.type == "SCRIPT_TOKENS" /* SCRIPT_TOKENS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */:
          if (response.type == "FILE_BUFFER" /* FILE_BUFFER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */:
          if (response.type == "FILE_STATISTICS" /* FILE_STATISTICS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CONNECT" /* CONNECT */:
          if (response.type == "CONNECTION_INFO" /* CONNECTION_INFO */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "RUN_PREPARED" /* RUN_PREPARED */:
        case "RUN_QUERY" /* RUN_QUERY */:
          if (response.type == "QUERY_RESULT" /* QUERY_RESULT */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "SEND_PREPARED" /* SEND_PREPARED */:
          if (response.type == "QUERY_RESULT_HEADER" /* QUERY_RESULT_HEADER */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "START_PENDING_QUERY" /* START_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */:
          if (response.type == "QUERY_RESULT_HEADER_OR_NULL" /* QUERY_RESULT_HEADER_OR_NULL */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */:
          this._onInstantiationProgress = [];
          if (response.type == "SUCCESS" /* SUCCESS */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */:
          if (response.type == "QUERY_RESULT_CHUNK" /* QUERY_RESULT_CHUNK */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
        case "CREATE_PREPARED" /* CREATE_PREPARED */:
          if (response.type == "PREPARED_STATEMENT_ID" /* PREPARED_STATEMENT_ID */) {
            task.promiseResolver(response.data);
            return;
          }
          break;
      }
      task.promiseRejecter(new Error(`unexpected response type: ${response.type.toString()}`));
    }
    onError(event) {
      console.error(event);
      console.error(`error in duckdb worker: ${event.message}`);
      this._pendingRequests.clear();
    }
    onClose() {
      this._workerShutdownResolver(null);
      if (this._pendingRequests.size != 0) {
        console.warn(`worker terminated with ${this._pendingRequests.size} pending requests`);
        return;
      }
      this._pendingRequests.clear();
    }
    async reset() {
      const task = new WorkerTask("RESET" /* RESET */, null);
      return await this.postTask(task);
    }
    async ping() {
      const task = new WorkerTask("PING" /* PING */, null);
      await this.postTask(task);
    }
    async dropFile(name) {
      const task = new WorkerTask("DROP_FILE" /* DROP_FILE */, name);
      return await this.postTask(task);
    }
    async dropFiles() {
      const task = new WorkerTask("DROP_FILES" /* DROP_FILES */, null);
      return await this.postTask(task);
    }
    async flushFiles() {
      const task = new WorkerTask("FLUSH_FILES" /* FLUSH_FILES */, null);
      return await this.postTask(task);
    }
    async instantiate(mainModuleURL, pthreadWorkerURL = null, progress = (_p2) => {
    }) {
      this._onInstantiationProgress.push(progress);
      const task = new WorkerTask(
        "INSTANTIATE" /* INSTANTIATE */,
        [mainModuleURL, pthreadWorkerURL]
      );
      return await this.postTask(task);
    }
    async getVersion() {
      const task = new WorkerTask("GET_VERSION" /* GET_VERSION */, null);
      const version = await this.postTask(task);
      return version;
    }
    async getFeatureFlags() {
      const task = new WorkerTask(
        "GET_FEATURE_FLAGS" /* GET_FEATURE_FLAGS */,
        null
      );
      const feature = await this.postTask(task);
      return feature;
    }
    async open(config) {
      const task = new WorkerTask("OPEN" /* OPEN */, config);
      await this.postTask(task);
    }
    async tokenize(text) {
      const task = new WorkerTask("TOKENIZE" /* TOKENIZE */, text);
      const tokens = await this.postTask(task);
      return tokens;
    }
    async connectInternal() {
      const task = new WorkerTask("CONNECT" /* CONNECT */, null);
      return await this.postTask(task);
    }
    async connect() {
      const cid = await this.connectInternal();
      return new AsyncDuckDBConnection(this, cid);
    }
    async disconnect(conn) {
      const task = new WorkerTask(
        "DISCONNECT" /* DISCONNECT */,
        conn
      );
      await this.postTask(task);
    }
    async runQuery(conn, text) {
      const task = new WorkerTask(
        "RUN_QUERY" /* RUN_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async startPendingQuery(conn, text) {
      const task = new WorkerTask(
        "START_PENDING_QUERY" /* START_PENDING_QUERY */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async pollPendingQuery(conn) {
      const task = new WorkerTask(
        "POLL_PENDING_QUERY" /* POLL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    async cancelPendingQuery(conn) {
      const task = new WorkerTask(
        "CANCEL_PENDING_QUERY" /* CANCEL_PENDING_QUERY */,
        conn
      );
      return await this.postTask(task);
    }
    async fetchQueryResults(conn) {
      const task = new WorkerTask(
        "FETCH_QUERY_RESULTS" /* FETCH_QUERY_RESULTS */,
        conn
      );
      return await this.postTask(task);
    }
    async getTableNames(conn, text) {
      const task = new WorkerTask(
        "GET_TABLE_NAMES" /* GET_TABLE_NAMES */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async createPrepared(conn, text) {
      const task = new WorkerTask(
        "CREATE_PREPARED" /* CREATE_PREPARED */,
        [conn, text]
      );
      return await this.postTask(task);
    }
    async closePrepared(conn, statement) {
      const task = new WorkerTask(
        "CLOSE_PREPARED" /* CLOSE_PREPARED */,
        [conn, statement]
      );
      await this.postTask(task);
    }
    async runPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "RUN_PREPARED" /* RUN_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    async sendPrepared(conn, statement, params) {
      const task = new WorkerTask(
        "SEND_PREPARED" /* SEND_PREPARED */,
        [conn, statement, params]
      );
      return await this.postTask(task);
    }
    async globFiles(path) {
      const task = new WorkerTask(
        "GLOB_FILE_INFOS" /* GLOB_FILE_INFOS */,
        path
      );
      return await this.postTask(task);
    }
    async registerFileText(name, text) {
      const buffer = TEXT_ENCODER3.encode(text);
      await this.registerFileBuffer(name, buffer);
    }
    async registerFileURL(name, url, proto, directIO) {
      if (url === void 0) {
        url = name;
      }
      const task = new WorkerTask("REGISTER_FILE_URL" /* REGISTER_FILE_URL */, [name, url, proto, directIO]);
      await this.postTask(task);
    }
    async registerEmptyFileBuffer(name) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name, new Uint8Array()]
      );
      await this.postTask(task);
    }
    async registerFileBuffer(name, buffer) {
      const task = new WorkerTask(
        "REGISTER_FILE_BUFFER" /* REGISTER_FILE_BUFFER */,
        [name, buffer]
      );
      await this.postTask(task, [buffer.buffer]);
    }
    async registerFileHandle(name, handle, protocol, directIO) {
      const task = new WorkerTask("REGISTER_FILE_HANDLE" /* REGISTER_FILE_HANDLE */, [name, handle, protocol, directIO]);
      await this.postTask(task, []);
    }
    async collectFileStatistics(name, enable) {
      const task = new WorkerTask(
        "COLLECT_FILE_STATISTICS" /* COLLECT_FILE_STATISTICS */,
        [name, enable]
      );
      await this.postTask(task, []);
    }
    async exportFileStatistics(name) {
      const task = new WorkerTask(
        "EXPORT_FILE_STATISTICS" /* EXPORT_FILE_STATISTICS */,
        name
      );
      return await this.postTask(task, []);
    }
    async copyFileToBuffer(name) {
      const task = new WorkerTask(
        "COPY_FILE_TO_BUFFER" /* COPY_FILE_TO_BUFFER */,
        name
      );
      return await this.postTask(task);
    }
    async copyFileToPath(name, path) {
      const task = new WorkerTask(
        "COPY_FILE_TO_PATH" /* COPY_FILE_TO_PATH */,
        [name, path]
      );
      await this.postTask(task);
    }
    async insertArrowFromIPCStream(conn, buffer, options) {
      if (buffer.length == 0)
        return;
      const task = new WorkerTask("INSERT_ARROW_FROM_IPC_STREAM" /* INSERT_ARROW_FROM_IPC_STREAM */, [conn, buffer, options]);
      await this.postTask(task, [buffer.buffer]);
    }
    async insertCSVFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_CSV_FROM_PATH" /* INSERT_CSV_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
    async insertJSONFromPath(conn, path, options) {
      if (options.columns !== void 0) {
        const out = [];
        for (const k in options.columns) {
          const type = options.columns[k];
          out.push(arrowToSQLField(k, type));
        }
        options.columnsFlat = out;
        delete options.columns;
      }
      const task = new WorkerTask(
        "IMPORT_JSON_FROM_PATH" /* INSERT_JSON_FROM_PATH */,
        [conn, path, options]
      );
      await this.postTask(task);
    }
  };

  // src/worker.ts
  var import_web_worker = __toESM(require_browser());
  async function createWorker(url) {
    const request = new Request(url);
    const workerScript = await fetch(request);
    const workerURL = URL.createObjectURL(await workerScript.blob());
    return new import_web_worker.default(workerURL);
  }

  // test/all_types.test.ts
  var MINIMUM_DATE_STR = "-271821-04-20";
  var MINIMUM_DATE = new Date(Date.UTC(-271821, 3, 20));
  var MAXIMUM_DATE_STR = "275760-09-13";
  var MAXIMUM_DATE = new Date(Date.UTC(275760, 8, 13));
  var NOT_IMPLEMENTED_TYPES = [
    "timestamp_s",
    "timestamp_ms",
    "timestamp_ns",
    "timestamp_tz",
    "hugeint",
    "dec_18_6",
    "dec38_10",
    "uuid",
    "map",
    "json",
    "date_array",
    "timestamp_array",
    "timestamptz_array"
  ];
  var PARTIALLY_IMPLEMENTED_TYPES = ["date", "timestamp"];
  var PARTIALLY_IMPLEMENTED_ANSWER_MAP = {
    date: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null],
    timestamp: [MINIMUM_DATE.valueOf(), MAXIMUM_DATE.valueOf(), null]
  };
  var PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS = [
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Date,'${MAXIMUM_DATE_STR}'::Date,null],i + 1)) as date`,
    `(SELECT array_extract(['${MINIMUM_DATE_STR}'::Timestamp,'${MAXIMUM_DATE_STR}'::Timestamp,null],i + 1)) as timestamp`
  ];
  var TYPES_REQUIRING_CUSTOM_CONFIG = ["dec_4_1", "dec_9_4"];
  var FULLY_IMPLEMENTED_ANSWER_MAP = {
    bool: [false, true, null],
    tinyint: [-128, 127, null],
    smallint: [-32768, 32767, null],
    int: [-2147483648, 2147483647, null],
    utinyint: [0, 255, null],
    usmallint: [0, 65535, null],
    uint: [0, 4294967295, null],
    ubigint: [BigInt(0), BigInt("18446744073709551615"), null],
    bigint: [BigInt("-9223372036854775808"), BigInt("9223372036854775807"), null],
    time: [BigInt(0), BigInt(new Date("1970-01-01T23:59:59.999+00:00").valueOf()) * BigInt(1e3) + BigInt(999), null],
    time_tz: [
      BigInt(0),
      BigInt(new Date("1970-01-01T23:59:59.999+00:00").valueOf()) * BigInt(1e3) + BigInt(999),
      null
    ],
    interval: [new Int32Array([0, 0]), new Int32Array([0, 0]), null],
    float: [-34028234663852886e22, 34028234663852886e22, null],
    double: [-17976931348623157e292, 17976931348623157e292, null],
    varchar: ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goo\0se", null],
    small_enum: ["DUCK_DUCK_ENUM", "GOOSE", null],
    medium_enum: ["enum_0", "enum_299", null],
    large_enum: ["enum_0", "enum_69999", null],
    int_array: [[], [42, 999, null, null, -42], null],
    double_array: [[], [42, NaN, Infinity, -Infinity, null, -42], null],
    varchar_array: [[], ["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}", "goose", null, ""], null],
    nested_int_array: [[], [[], [42, 999, null, null, -42], null, [], [42, 999, null, null, -42]], null],
    struct: ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null],
    struct_of_arrays: [
      '{"a":null,"b":null}',
      '{"a":[42,999,null,null,-42],"b":["\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}","goose",null,""]}',
      null
    ],
    array_of_structs: [[], ['{"a":null,"b":null}', '{"a":42,"b":"\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}\u{1F986}"}', null], null],
    blob: [
      Uint8Array.from([
        116,
        104,
        105,
        115,
        105,
        115,
        97,
        108,
        111,
        110,
        103,
        98,
        108,
        111,
        98,
        0,
        119,
        105,
        116,
        104,
        110,
        117,
        108,
        108,
        98,
        121,
        116,
        101,
        115
      ]),
      Uint8Array.from([0, 0, 0, 97]),
      null
    ]
  };
  var REPLACE_COLUMNS = PARTIALLY_IMPLEMENTED_TYPES.concat(NOT_IMPLEMENTED_TYPES).concat(TYPES_REQUIRING_CUSTOM_CONFIG);
  function unpack(v) {
    if (v === null)
      return null;
    if (v instanceof Vector) {
      const ret = Array.from(v.toArray());
      for (let i = 0; i < ret.length; i++) {
        if (!v.isValid(i)) {
          ret[i] = null;
        }
      }
      return unpack(ret);
    } else if (v instanceof Array) {
      const ret = [];
      for (let i = 0; i < v.length; i++) {
        ret[i] = unpack(v[i]);
      }
      return ret;
    } else if (v instanceof Uint8Array) {
      return v;
    } else if (v.toJSON instanceof Function) {
      return JSON.stringify(v.toJSON());
    }
    return v;
  }
  function getValue(x) {
    if (typeof x?.valueOf === "function") {
      return x.valueOf();
    } else {
      return x;
    }
  }
  var ALL_TYPES_TEST = [
    {
      name: "fully supported types",
      query: `SELECT * REPLACE('not_implemented' as map) FROM test_all_types()`,
      skip: REPLACE_COLUMNS,
      answerMap: FULLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: REPLACE_COLUMNS.length + Object.keys(FULLY_IMPLEMENTED_ANSWER_MAP).length,
      queryConfig: null
    },
    {
      name: "partially supported types",
      query: `SELECT ${PARTIALLY_IMPLEMENTED_TYPES_SUBSTITUTIONS.join(", ")}
                FROM range(0, 3) tbl(i)`,
      skip: [],
      answerMap: PARTIALLY_IMPLEMENTED_ANSWER_MAP,
      answerCount: PARTIALLY_IMPLEMENTED_TYPES.length,
      queryConfig: null
    },
    {
      name: "types with custom config",
      query: `SELECT ${TYPES_REQUIRING_CUSTOM_CONFIG.join(",")} FROM test_all_types()`,
      skip: [],
      answerMap: {
        dec_4_1: [-999.9000000000001, 999.9000000000001, null],
        dec_9_4: [-99999.99990000001, 99999.99990000001, null]
      },
      answerCount: TYPES_REQUIRING_CUSTOM_CONFIG.length,
      queryConfig: {
        castDecimalToDouble: true
      }
    }
  ];
  function testAllTypes(db2) {
    let conn;
    beforeEach(() => {
      db2().flushFiles();
    });
    afterEach(() => {
      if (conn) {
        conn.close();
        conn = null;
      }
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Test All Types", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = db2().connect();
          const results = conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s of test.skip) {
            skip.set(s, true);
          }
          for (let i = 0; i < results.numCols; i++) {
            const name = results.schema.fields[i].name;
            if (name == "bit")
              continue;
            const col = results.getChildAt(i);
            if (skip.get(name))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(unpack(getValue(col.get(0)))).withContext(name).toEqual(test.answerMap[name][0]);
            expect(unpack(getValue(col.get(1)))).withContext(name).toEqual(test.answerMap[name][1]);
            expect(col.get(2)).withContext(name).toEqual(test.answerMap[name][2]);
          }
        });
      }
    });
  }
  function testAllTypesAsync(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Test All Types Async", () => {
      for (const test of ALL_TYPES_TEST) {
        it(test.name, async () => {
          if (test.queryConfig)
            db2().open({ query: test.queryConfig });
          conn = await db2().connect();
          const results = await conn.query(test.query);
          expect(results.numCols).toEqual(test.answerCount);
          const skip = /* @__PURE__ */ new Map();
          for (const s of test.skip) {
            skip.set(s, true);
          }
          for (let i = 0; i < results.numCols; i++) {
            const name = results.schema.fields[i].name;
            if (name == "bit")
              continue;
            const col = results.getChildAt(i);
            if (skip.get(name))
              continue;
            expect(col).not.toBeNull();
            expect(col?.length).not.toEqual(0);
            expect(Object.keys(test.answerMap)).toContain(name);
            expect(unpack(getValue(col.get(0)))).withContext(name + "|" + col?.toString() + "|[0]").toEqual(test.answerMap[name][0]);
            expect(unpack(getValue(col.get(1)))).withContext(name + "|" + col?.toString() + "|[1]").toEqual(test.answerMap[name][1]);
            expect(col.get(2)).withContext(name + "|" + col?.toString() + "|[2]").toEqual(test.answerMap[name][2]);
          }
        });
      }
    });
  }

  // test/httpfs_test.ts
  var BUCKET_NAME = "test-bucket";
  var ACCESS_KEY_ID = "S3RVER";
  var ACCESS_KEY_SECRET = "S3RVER";
  var S3_ENDPOINT = "http://localhost:4923";
  var S3_REGION = "eu-west-1";
  var setAwsConfig = async function(conn, type = 1 /* VALID */) {
    switch (type) {
      case 0 /* EMPTY */:
        await conn.query("SET s3_region='';");
        await conn.query("SET s3_access_key_id='';");
        await conn.query("SET s3_secret_access_key='';");
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 1 /* VALID */:
        await conn.query(`SET s3_region='${S3_REGION}';`);
        await conn.query(`SET s3_access_key_id='${ACCESS_KEY_ID}';`);
        await conn.query(`SET s3_secret_access_key='${ACCESS_KEY_SECRET}';`);
        await conn.query("SET s3_session_token='';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
      case 2 /* INVALID */:
        await conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        await conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        await conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        await conn.query("SET s3_session_token='INVALIDSESSIONTOKEN';");
        await conn.query(`SET s3_endpoint='${S3_ENDPOINT}';`);
        break;
    }
  };
  function testHTTPFS(sdb) {
    let conn;
    const getModule = function() {
      let module2 = null;
      conn.useUnsafe((bindings, con_number) => {
        module2 = bindings.mod;
      });
      expect(module2).toBeDefined();
      return module2;
    };
    const reset = async () => {
      sdb().reset();
      conn = sdb().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS", () => {
      it("s3 config is set correctly", async () => {
        const module2 = getModule();
        const globalFileInfo = runtime_browser_default.getGlobalFileInfo(module2);
        const cacheEpoch = globalFileInfo.cacheEpoch;
        expect(globalFileInfo?.s3Config).toBeDefined();
        expect(globalFileInfo?.s3Config?.region).toEqual("");
        expect(globalFileInfo?.s3Config?.accessKeyId).toEqual("");
        expect(globalFileInfo?.s3Config?.secretAccessKey).toEqual("");
        expect(globalFileInfo?.s3Config?.sessionToken).toEqual("");
        expect(globalFileInfo?.s3Config?.endpoint).toEqual("");
        conn.query("SET s3_region='a-very-remote-and-non-existent-s3-region';");
        conn.query("SET s3_access_key_id='THISACCESSKEYIDISNOTVALID';");
        conn.query("SET s3_secret_access_key='THISSECRETACCESSKEYISNOTVALID';");
        conn.query("SET s3_session_token='ANICESESSIONTOKEN';");
        conn.query("SET s3_endpoint='s3.some.sort.of.cloud';");
        const globalFileInfoUpdated = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoUpdated?.s3Config).toBeDefined();
        expect(globalFileInfoUpdated?.cacheEpoch).toEqual(cacheEpoch + 5);
        const params = getS3Params(globalFileInfoUpdated?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(params.url).toEqual("/testfile.txt");
        expect(params.query).toEqual("");
        expect(params.host).toEqual("test-bucket.s3.some.sort.of.cloud");
        expect(params.region).toEqual("a-very-remote-and-non-existent-s3-region");
        expect(params.service).toEqual("s3");
        expect(params.method).toEqual("GET");
        expect(params.accessKeyId).toEqual("THISACCESSKEYIDISNOTVALID");
        expect(params.secretAccessKey).toEqual("THISSECRETACCESSKEYISNOTVALID");
        expect(params.sessionToken).toEqual("ANICESESSIONTOKEN");
        conn.query("SET s3_endpoint='http://localhost:1337';");
        const globalFileInfoFullHttpEndpoint = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsFullHttpEndpoint = getS3Params(
          globalFileInfoFullHttpEndpoint?.s3Config,
          "s3://test-bucket/testfile.txt",
          "GET"
        );
        expect(paramsFullHttpEndpoint.host).toEqual("localhost:1337");
        await reset();
        const globalFileInfoCleared = runtime_browser_default.getGlobalFileInfo(module2);
        const paramsCleared = getS3Params(globalFileInfoCleared?.s3Config, "s3://test-bucket/testfile.txt", "GET");
        expect(paramsCleared.url).toEqual("/testfile.txt");
        expect(paramsCleared.query).toEqual("");
        expect(paramsCleared.host).toEqual("test-bucket.s3.amazonaws.com");
        expect(paramsCleared.region).toEqual("");
        expect(paramsCleared.service).toEqual("s3");
        expect(paramsCleared.method).toEqual("GET");
        expect(paramsCleared.accessKeyId).toEqual("");
        expect(paramsCleared.secretAccessKey).toEqual("");
        expect(paramsCleared.sessionToken).toEqual("");
      });
      it("url parsing is correct", () => {
        const module2 = getModule();
        conn.query("SET s3_endpoint='';");
        const globalFileInfoDefault = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDefault?.s3Config).toBeDefined();
        const defaultUrl = getHTTPUrl(globalFileInfoDefault?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(defaultUrl).toEqual(`https://${BUCKET_NAME}.s3.amazonaws.com/test-file.csv`);
        conn.query("SET s3_endpoint='https://duckdblabs.com';");
        const globalFileInfoFullUrl = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoFullUrl?.s3Config).toBeDefined();
        const fullUrl = getHTTPUrl(globalFileInfoFullUrl?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(fullUrl).toEqual(`https://duckdblabs.com/${BUCKET_NAME}/test-file.csv`);
        conn.query("SET s3_endpoint='duckdblabs.com';");
        const globalFileInfoDomain = runtime_browser_default.getGlobalFileInfo(module2);
        expect(globalFileInfoDomain?.s3Config).toBeDefined();
        const domainOnlyUrl = getHTTPUrl(globalFileInfoDomain?.s3Config, `s3://${BUCKET_NAME}/test-file.csv`);
        expect(domainOnlyUrl).toEqual(`https://${BUCKET_NAME}.duckdblabs.com/test-file.csv`);
      });
      it("s3 helper passes validation", () => {
        const testParams1 = {
          url: "/",
          query: "",
          host: "my-precious-bucket.s3.amazonaws.com",
          region: "us-east-1",
          service: "s3",
          method: "GET",
          accessKeyId: "AKIAIOSFODNN7EXAMPLE",
          secretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
          sessionToken: "",
          dateNow: "20150915",
          datetimeNow: "20150915T124500Z"
        };
        const result = createS3Headers(testParams1).get("Authorization");
        expect(result).toEqual(
          "AWS4-HMAC-SHA256 Credential=AKIAIOSFODNN7EXAMPLE/20150915/us-east-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=182072eb53d85c36b2d791a1fa46a12d23454ec1e921b02075c23aee40166d5a"
        );
        const canonical_query_string = "delimiter=%2F&encoding-type=url&list-type=2&prefix=";
        const testParams2 = {
          url: "/",
          query: canonical_query_string,
          host: "my-precious-bucket.s3.eu-west-1.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "GET",
          accessKeyId: "ASIAYSPIOYDTHTBIITVC",
          secretAccessKey: "vs1BZPxSL2qVARBSg5vCMKJsavCoEPlo/HSHRaVe",
          sessionToken: "IQoJb3JpZ2luX2VjENX//////////wEaCWV1LXdlc3QtMSJHMEUCIQDfjzs9BYHrEXDMU/NR+PHV1uSTr7CSVSQdjKSfiPRLdgIgCCztF0VMbi9+uHHAfBVKhV4t9MlUrQg3VAOIsLxrWyoqlAIIHRAAGgw1ODk0MzQ4OTY2MTQiDOGl2DsYxENcKCbh+irxARe91faI+hwUhT60sMGRFg0GWefKnPclH4uRFzczrDOcJlAAaQRJ7KOsT8BrJlrY1jSgjkO7PkVjPp92vi6lJX77bg99MkUTJActiOKmd84XvAE5bFc/jFbqechtBjXzopAPkKsGuaqAhCenXnFt6cwq+LZikv/NJGVw7TRphLV+Aq9PSL9XwdzIgsW2qXwe1c3rxDNj53yStRZHVggdxJ0OgHx5v040c98gFphzSULHyg0OY6wmCMTYcswpb4kO2IIi6AiD9cY25TlwPKRKPi5CdBsTPnyTeW62u7PvwK0fTSy4ZuJUuGKQnH2cKmCXquEwoOHEiQY6nQH9fzY/EDGHMRxWWhxu0HiqIfsuFqC7GS0p0ToKQE+pzNsvVwMjZc+KILIDDQpdCWRIwu53I5PZy2Cvk+3y4XLvdZKQCsAKqeOc4c94UAS4NmUT7mCDOuRV0cLBVM8F0JYBGrUxyI+YoIvHhQWmnRLuKgTb5PkF7ZWrXBHFWG5/tZDOvBbbaCWTlRCL9b0Vpg5+BM/81xd8jChP4w83",
          dateNow: "20210904",
          datetimeNow: "20210904T121746Z"
        };
        const result2 = createS3Headers(testParams2).get("Authorization");
        expect(result2).toEqual(
          "AWS4-HMAC-SHA256 Credential=ASIAYSPIOYDTHTBIITVC/20210904/eu-west-1/s3/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date;x-amz-security-token, Signature=4d9d6b59d7836b6485f6ad822de97be40287da30347d83042ea7fbed530dc4c0"
        );
        const testParams3 = {
          url: "/correct_auth_test.csv",
          query: "",
          host: "test-bucket-ceiveran.s3.amazonaws.com",
          region: "eu-west-1",
          service: "s3",
          method: "PUT",
          accessKeyId: "S3RVER",
          secretAccessKey: "S3RVER",
          sessionToken: "",
          dateNow: "20220121",
          datetimeNow: "20220121T141452Z"
        };
        const test3PayloadParams = {
          contentHash: "28a0cf6ac5c4cb73793091fe6ecc6a68bf90855ac9186158748158f50241bb0c",
          contentType: "text/data;charset=utf-8"
        };
        const result3 = createS3Headers(testParams3, test3PayloadParams).get("Authorization");
        expect(result3).toEqual(
          "AWS4-HMAC-SHA256 Credential=S3RVER/20220121/eu-west-1/s3/aws4_request, SignedHeaders=content-type;host;x-amz-content-sha256;x-amz-date, Signature=5d9a6cbfaa78a6d0f2ab7df0445e2f1cc9c80cd3655ac7de9e7219c036f23f02"
        );
        expect(uriEncode("/category=Books/")).toEqual("/category%3DBooks/");
        expect(uriEncode("/?category=Books&title=Ducks Retreat/")).toEqual(
          "/%3Fcategory%3DBooks%26title%3DDucks%20Retreat/"
        );
        expect(uriEncode("/?category=Books&title=Ducks Retreat/", true)).toEqual(
          "%2F%3Fcategory%3DBooks%26title%3DDucks%20Retreat%2F"
        );
      });
    });
  }
  function testHTTPFSAsync(adb2, resolveData2, baseDir) {
    let conn;
    const putTestFileToS3 = async function(fileName, format, test_data) {
      await adb2().registerFileBuffer("test_file.parquet", test_data);
      if (!conn) {
        conn = await adb2().connect();
      }
      await setAwsConfig(conn, 1 /* VALID */);
      await conn.query(`CREATE TABLE test_table AS (SELECT * FROM parquet_scan('test_file.parquet'));`);
      await conn.query(`COPY test_table TO 's3://${BUCKET_NAME}/${fileName}.${format}' (FORMAT '${format}');`);
      await adb2().flushFiles();
      await adb2().dropFiles();
    };
    const assertTestFileResultCorrect = async function(result, test_data) {
      await adb2().registerFileBuffer("test_file_baseline.parquet", test_data);
      await conn.query(`SELECT * FROM parquet_scan('test_file_baseline.parquet');`);
    };
    const reset = async () => {
      await adb2().reset();
      conn = await adb2().connect();
    };
    beforeEach(async () => await reset());
    afterEach(async () => await reset());
    describe("HTTPFS Async", () => {
      it("can fetch https file", async () => {
        const results = await conn.query(
          `select * from "https://raw.githubusercontent.com/duckdb/duckdb-wasm/master/data/test.csv";`
        );
        expect(BigInt(results.getChildAt(2)?.get(2))).toEqual(BigInt(9n));
      });
      it("can read and write csv file from S3 with correct auth credentials", async () => {
        let data = await resolveData2("/uni/studenten.parquet");
        await setAwsConfig(conn);
        await putTestFileToS3("correct_auth_test", "csv", data);
        const results_with_auth = await conn.query(`select * from "s3://${BUCKET_NAME}/correct_auth_test.csv";`);
        data = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data);
      });
      it("can read and write parquet file from S3 with correct auth credentials", async () => {
        let data = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("correct_auth_test", "parquet", data);
        await setAwsConfig(conn);
        const results_with_auth = await conn.query(
          `select * from "s3://${BUCKET_NAME}/correct_auth_test.parquet";`
        );
        data = await resolveData2("/uni/studenten.parquet");
        assertTestFileResultCorrect(results_with_auth, data);
      });
      it("can not read a file with incorrect credentials", async () => {
        const data = await resolveData2("/uni/studenten.parquet");
        await putTestFileToS3("incorrect_auth_test", "parquet", data);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select * from "s3://${BUCKET_NAME}/incorrect_auth_test.csv";`)
        ).toBeRejected();
      });
      it("properly invalidates file caches on settings update.", async () => {
        const data = await resolveData2("/tpch/0_01/parquet/lineitem.parquet");
        await putTestFileToS3("file_cache_invalidation_test", "parquet", data);
        await setAwsConfig(conn);
        const results_correct = await conn.query(
          `select l_partkey from "s3://${BUCKET_NAME}/file_cache_invalidation_test.parquet" limit 1;`
        );
        expect(results_correct.getChildAt(0)?.get(0)).toEqual(1552);
        await setAwsConfig(conn, 2 /* INVALID */);
        await expectAsync(
          conn.query(`select avg(l_partkey) from "s3://${BUCKET_NAME}/lineitem.parquet";`)
        ).toBeRejected();
      });
      it("write after read throws incorrect flag error without dropping files", async () => {
        await setAwsConfig(conn);
        await conn.query(
          `COPY (SELECT * FROM range(1000,1010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
        );
        const result = await conn.query(`SELECT * FROM "s3://${BUCKET_NAME}/test_written.csv";`);
        expect(Number(result.getChildAt(0)?.get(6))).toEqual(Number(1006));
        await expectAsync(
          conn.query(
            `COPY (SELECT * FROM range(2000,2010) tbl(i)) TO 's3://${BUCKET_NAME}/test_written.csv' (FORMAT 'csv');`
          )
        ).toBeRejectedWithError("Invalid Error: File is not opened in write mode");
      });
    });
  }

  // test/bindings.test.ts
  function testBindings(db2, baseURL2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("DuckDBBindings", () => {
      describe("error handling", () => {
        it("INVALID SQL", async () => {
          let error = null;
          try {
            await conn.send("INVALID");
          } catch (e) {
            error = e;
          }
          expect(error).not.toBe(null);
        });
      });
      describe("Check version", () => {
        it("Version check", async () => {
          await db2().reset();
          conn = db2().connect();
          const version = conn.query(
            "select * from (select version()) where version() != 'v0.0.1-dev0';"
          );
          const rows = version.toArray();
          expect(rows.length).toEqual(1);
          await db2().reset();
        });
      });
      describe("Reset", () => {
        it("table must disappear", async () => {
          await db2().reset();
          conn = db2().connect();
          conn.query("CREATE TABLE foo (a int)");
          let table = conn.query("PRAGMA show_tables;");
          let rows = table.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0]?.name).toEqual("foo");
          await db2().reset();
          conn = db2().connect();
          table = conn.query("PRAGMA show_tables;");
          rows = table.toArray();
          expect(rows.length).toEqual(0);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const result = stmt.query(234);
          expect(result.numRows).toBe(10001);
          stmt.close();
        });
        it("Streaming", async () => {
          const stmt = conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = stmt.send(234);
          let size = 0;
          for (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          conn.close();
        });
        it("Typecheck", async () => {
          conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          expect(
            () => stmt.query(true, 100, 1e4, 1e6, 5e9, 0.5, Math.PI, "hello world", "hi")
          ).not.toThrow();
          expect(
            () => stmt.query(
              "test",
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              1e4,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e6,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          expect(
            () => stmt.query(
              true,
              100,
              1e4,
              5e9,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            )
          ).toThrow();
          conn.close();
        });
      });
    });
  }
  function testAsyncBindings(adb2, baseURL2, baseDirProto) {
    beforeEach(async () => {
    });
    afterEach(async () => {
      await adb2().flushFiles();
      await adb2().dropFiles();
      await adb2().open({
        path: ":memory:"
      });
    });
    describe("Bindings", () => {
      describe("Open", () => {
        it("Remote TPCH 0_01", async () => {
          await adb2().registerFileURL("tpch_0_01.db", `${baseURL2}/tpch/0_01/duckdb/db`, baseDirProto, false);
          await adb2().open({
            path: "tpch_0_01.db"
          });
          const conn = await adb2().connect();
          const table = await conn.query("select count(*)::INTEGER as a from lineitem");
          const rows = table.toArray();
          expect(rows.length).toEqual(1);
          expect(rows[0]?.a).toEqual(60175);
        });
      });
      describe("Patching", () => {
        it("Count(*) Default", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: false
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Int);
        });
        it("Count(*) No BigInt", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              castBigIntToDouble: true
            }
          });
          const conn = await adb2().connect();
          const table = await conn.query("select 1::BIGINT");
          expect(table.schema.fields.length).toEqual(1);
          expect(table.schema.fields[0].typeId).toEqual(Type.Float);
        });
      });
      describe("Prepared Statement", () => {
        it("Materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v + ? FROM generate_series(0, 10000) as t(v);");
          const result = await stmt.query(234);
          expect(result.numRows).toBe(10001);
          await stmt.close();
        });
        it("Streaming", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare("SELECT v::INTEGER + ? AS v FROM generate_series(0, 10000) as t(v);");
          const stream = await stmt.send(234);
          let size = 0;
          for await (const batch of stream) {
            size += batch.numRows;
          }
          expect(size).toBe(10001);
          await conn.close();
        });
        it("Typecheck", async () => {
          const conn = await adb2().connect();
          await conn.query(`CREATE TABLE typecheck (
                    a BOOLEAN DEFAULT NULL,
                    b TINYINT DEFAULT NULL,
                    c SMALLINT DEFAULT NULL,
                    d INTEGER DEFAULT NULL,
                    e BIGINT DEFAULT NULL,
                    f FLOAT DEFAULT NULL,
                    g DOUBLE DEFAULT NULL,
                    h CHAR(11) DEFAULT NULL,
                    i VARCHAR(11) DEFAULT NULL
                )`);
          const stmt = await conn.prepare("INSERT INTO typecheck VALUES(?,?,?,?,?,?,?,?,?)");
          const expectToThrow = async (fn) => {
            let throwed = false;
            try {
              await fn();
            } catch (e) {
              throwed = true;
            }
            expect(throwed).toBe(true);
          };
          expectToThrow(async () => {
            await stmt.query(
              "test",
              100,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              1e4,
              1e4,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e6,
              1e6,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          expectToThrow(async () => {
            await stmt.query(
              true,
              100,
              1e4,
              5e9,
              5e9,
              0.5,
              Math.PI,
              "hello world",
              "hi"
            );
          });
          await conn.close();
        });
      });
      describe("AccessMode", () => {
        it("READ_ONLY", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 2 /* READ_ONLY */
            })
          ).toBeRejectedWithError(/Cannot launch in-memory database in read-only mode/);
        });
        it("READ_WRITE", async () => {
          await expectAsync(
            adb2().open({
              accessMode: 3 /* READ_WRITE */
            })
          ).toBeResolved();
        });
      });
      describe("Cancellation", () => {
        it("hello cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeTrue();
          let polledHeader = null;
          let polledError = null;
          try {
            polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).toBeNull();
          expect(polledError).not.toBeNull();
          expect(polledError.toString()).toEqual("Error: query was canceled");
          const canceledAgain = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(canceledAgain).toBeFalse();
          const table = await conn.query("select 42::integer;");
          expect(table.schema.fields.length).toEqual(1);
        });
        it("noop cancel", async () => {
          await adb2().open({
            path: ":memory:",
            query: {
              queryPollingInterval: 0
            }
          });
          const conn = await adb2().connect();
          const result = await conn.useUnsafe(
            (db2, id) => db2.startPendingQuery(id, "SELECT SUM(i) FROM range(1000000) tbl(i);")
          );
          expect(result).toBeNull();
          let polledHeader = null;
          let polledError = null;
          try {
            while (polledHeader == null) {
              polledHeader = await conn.useUnsafe((db2, id) => db2.pollPendingQuery(id));
            }
          } catch (e) {
            polledError = e;
          }
          expect(polledHeader).not.toBeNull();
          expect(polledError).toBeNull();
          const cancelOK = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(cancelOK).toBeFalse();
          const anotherOne = await conn.useUnsafe((db2, id) => db2.cancelPendingQuery(id));
          expect(anotherOne).toBeFalse();
        });
      });
    });
  }

  // test/batch_stream.test.ts
  var testRows = 1e4;
  function testBatchStream(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++);
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i++));
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", () => {
          const table = conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows + 1);
        });
        it("SMALLINT", () => {
          const table = conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows + 1);
        });
        it("INTEGER", () => {
          const table = conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++);
          }
          expect(i).toBe(testRows + 1);
        });
        it("BIGINT", () => {
          const table = conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows + 1);
        });
        it("STRING", () => {
          const table = conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i++));
          }
          expect(i).toBe(testRows + 1);
        });
      });
    });
  }

  // test/batch_stream_async.test.ts
  var testRows2 = 1e4;
  function testAsyncBatchStream(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("AsyncDuckDB", () => {
      it("ping", async () => {
        await db2().ping();
      });
    });
    describe("Arrow Record-Batches Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const row of batch) {
              expect(row.v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
      describe("scripts", () => {
        it("test1", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS x, (sin(v) * 100 + 100)::INTEGER AS y FROM generate_series(0, ${testRows2}) as t(v)
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(2);
            for (const row of batch) {
              expect(row.x).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Record-Batches Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 127);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const result = await conn.send(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++ & 32767);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const result = await conn.send(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(i++);
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const result = await conn.send(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(BigInt(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const result = await conn.send(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for await (const batch of result) {
            expect(batch.numCols).toBe(1);
            for (const v of batch.getChildAt(0)) {
              expect(v).toBe(String(i++));
            }
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Row-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(i++);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const row of table) {
            expect(row?.v.valueOf()).toBe(String(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
    describe("Arrow Table Column-Major", () => {
      describe("single column", () => {
        it("TINYINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 127)::TINYINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 127);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("SMALLINT", async () => {
          const table = await conn.query(`
                    SELECT (v & 32767)::SMALLINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++ & 32767);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("INTEGER", async () => {
          const table = await conn.query(`
                    SELECT v::INTEGER AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(i++);
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("BIGINT", async () => {
          const table = await conn.query(`
                    SELECT v::BIGINT AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(BigInt(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
        it("STRING", async () => {
          const table = await conn.query(`
                    SELECT v::VARCHAR AS v FROM generate_series(0, ${testRows2}) as t(v);
                `);
          let i = 0;
          for (const v of table.getChildAt(0)) {
            expect(v).toBe(String(i++));
          }
          expect(i).toBe(testRows2 + 1);
        });
      });
    });
  }

  // test/filesystem.test.ts
  var decoder2 = new TextDecoder();
  function testFilesystem(db2, resolveData2, baseDir, baseDirProto) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("File buffer registration", () => {
      const test = async () => {
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      };
      it("File buffer used once", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
      });
      it("File buffer registered twice", async () => {
        const students0 = await resolveData2("/uni/studenten.parquet");
        const students1 = await resolveData2("/uni/studenten.parquet");
        expect(students0).not.toBeNull();
        expect(students1).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students0);
        await test();
        await db2().registerFileBuffer("studenten.parquet", students1);
        await test();
      });
      it("File buffer used twice", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await test();
        await test();
      });
    });
    describe("Parquet Scans", () => {
      it("single table from buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("simple join", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        const hoeren = await resolveData2("/uni/hoeren.parquet");
        const vorlesungen = await resolveData2("/uni/vorlesungen.parquet");
        expect(students).not.toBeNull();
        expect(hoeren).not.toBeNull();
        expect(vorlesungen).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerFileBuffer("hoeren.parquet", hoeren);
        await db2().registerFileBuffer("vorlesungen.parquet", vorlesungen);
        const result = await conn.send(`
                    SELECT students.matrnr, vorlesungen.titel
                    FROM parquet_scan('studenten.parquet') students
                    INNER JOIN parquet_scan('hoeren.parquet') hoeren ON (students.matrnr = hoeren.matrnr)
                    INNER JOIN parquet_scan('vorlesungen.parquet') vorlesungen ON (vorlesungen.vorlnr = hoeren.vorlnr);
                `);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.numCols).toBe(2);
        const flat = [];
        for (const row of table) {
          flat.push({
            matrnr: row?.matrnr,
            titel: row?.titel?.toString()
          });
        }
        expect(flat).toEqual([
          { matrnr: 26120, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Grundz\xFCge" },
          { matrnr: 27550, titel: "Logik" },
          { matrnr: 28106, titel: "Ethik" },
          { matrnr: 28106, titel: "Wissenschaftstheorie" },
          { matrnr: 28106, titel: "Bioethik" },
          { matrnr: 28106, titel: "Der Wiener Kreis" },
          { matrnr: 29120, titel: "Grundz\xFCge" },
          { matrnr: 29120, titel: "Ethik" },
          { matrnr: 29120, titel: "M\xE4eutik" },
          { matrnr: 29555, titel: "Glaube und Wissen" },
          { matrnr: 25403, titel: "Glaube und Wissen" }
        ]);
      });
    });
    describe("Writing", () => {
      it("Copy To CSV Buffer", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students.csv");
        await conn.query(`CREATE TABLE students AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students TO 'students.csv' WITH (HEADER 1, DELIMITER ';', FORMAT CSV);`);
        await conn.query(`DROP TABLE IF EXISTS students`);
        const outBuffer = await db2().copyFileToBuffer("students.csv");
        expect(outBuffer).not.toBeNull();
        const text = decoder2.decode(outBuffer);
        expect(text).toBe(`matrnr;name;semester
24002;Xenokrates;18
25403;Jonas;12
26120;Fichte;10
26830;Aristoxenos;8
27550;Schopenhauer;6
28106;Carnap;3
29120;Theophrastos;2
29555;Feuerbach;2
`);
      });
      it("Copy To Parquet", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students2.parquet");
        await conn.query(`CREATE TABLE students2 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students2 TO 'students2.parquet' (FORMAT PARQUET);`);
        const url = await db2().copyFileToBuffer("students2.parquet");
        expect(url).not.toBeNull();
      });
      it("Copy To Parquet And Load Again", async () => {
        const students = await resolveData2("/uni/studenten.parquet");
        expect(students).not.toBeNull();
        await db2().registerFileBuffer("studenten.parquet", students);
        await db2().registerEmptyFileBuffer("students3.parquet");
        await conn.query(`CREATE TABLE students3 AS SELECT * FROM parquet_scan('studenten.parquet');`);
        await conn.query(`COPY students3 TO 'students3.parquet' (FORMAT PARQUET);`);
        const url = await db2().copyFileToBuffer("students3.parquet");
        expect(url).not.toBeNull();
        await conn.query(`CREATE TABLE students4 AS SELECT * FROM parquet_scan('students3.parquet');`);
        const result = await conn.send(`SELECT matrnr FROM students4;`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
    });
    describe("File access", () => {
      it("Small Parquet file", async () => {
        await db2().registerFileURL("studenten.parquet", `${baseDir}/uni/studenten.parquet`, baseDirProto, true);
        const result = await conn.send(`SELECT matrnr FROM parquet_scan('studenten.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.toArray()).toEqual(
          new Int32Array([24002, 25403, 26120, 26830, 27550, 28106, 29120, 29555])
        );
      });
      it("Large Parquet file", async () => {
        await db2().registerFileURL(
          "lineitem.parquet",
          `${baseDir}/tpch/0_01/parquet/lineitem.parquet`,
          baseDirProto,
          true
        );
        const result = await conn.send(`SELECT count(*)::INTEGER as cnt FROM parquet_scan('lineitem.parquet');`);
        const batches = [];
        for await (const batch of result) {
          batches.push(batch);
        }
        const table = await new Table(batches);
        expect(table.getChildAt(0)?.get(0)).toBeGreaterThan(6e4);
      });
    });
    describe("Export", () => {
      it("Generate Series as CSV", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportcsv'`);
        const results = await db2().globFiles("/tmp/duckdbexportcsv/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportcsv/foo.csv",
          "/tmp/duckdbexportcsv/load.sql",
          "/tmp/duckdbexportcsv/schema.sql"
        ]);
        const csv_buffer_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/foo.csv");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportcsv/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(csv_buffer_utf8.length).not.toEqual(0);
        const load_script = decoder2.decode(load_script_utf8);
        const schema_script = decoder2.decode(schema_script_utf8);
        const csv_buffer = decoder2.decode(csv_buffer_utf8);
        expect(load_script.trim()).toEqual(
          `COPY foo FROM '/tmp/duckdbexportcsv/foo.csv' (FORMAT 'csv', quote '"', delimiter ',', header 0);`
        );
        expect(schema_script.trim()).toEqual(`CREATE TABLE foo(v BIGINT);`);
        expect(csv_buffer.trim()).toEqual(`1
2
3
4
5`);
      });
      it("Generate Series as Parquet", async () => {
        await conn.query("CREATE TABLE foo AS SELECT * FROM generate_series(1, 5) t(v)");
        await conn.query(`EXPORT DATABASE '/tmp/duckdbexportparquet' (FORMAT PARQUET)`);
        const results = await db2().globFiles("/tmp/duckdbexportparquet/*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(3);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual([
          "/tmp/duckdbexportparquet/foo.parquet",
          "/tmp/duckdbexportparquet/load.sql",
          "/tmp/duckdbexportparquet/schema.sql"
        ]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/foo.parquet");
        const load_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/load.sql");
        const schema_script_utf8 = await db2().copyFileToBuffer("/tmp/duckdbexportparquet/schema.sql");
        expect(load_script_utf8.length).not.toEqual(0);
        expect(schema_script_utf8.length).not.toEqual(0);
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(
          `SELECT v::integer FROM parquet_scan('/tmp/duckdbexportparquet/foo.parquet')`
        );
        expect(content.nullCount).toEqual(0);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
    describe("Copy", () => {
      it("Generate Series as Parquet", async () => {
        await conn.query(
          `COPY (SELECT * FROM generate_series(1, 5) t(v)) TO '/tmp/duckdbcopytest.parquet' (FORMAT 'parquet')`
        );
        const results = await db2().globFiles("/tmp/duckdbcopytest*");
        expect(results).not.toEqual([]);
        expect(results.length).toEqual(1);
        const filenames = results.map((file) => file.fileName).sort();
        expect(filenames).toEqual(["/tmp/duckdbcopytest.parquet"]);
        const parquet_buffer = await db2().copyFileToBuffer("/tmp/duckdbcopytest.parquet");
        expect(parquet_buffer.length).not.toEqual(0);
        const content = await conn.query(`SELECT v::integer FROM parquet_scan('/tmp/duckdbcopytest.parquet')`);
        expect(content.numRows).toEqual(5);
        expect(content.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 3, 4, 5]));
      });
    });
  }

  // test/table_test.ts
  function compareTable(table, expected) {
    const colCount = expected.length;
    expect(table.numCols).toEqual(colCount);
    if (colCount == 0)
      return;
    const rowCount = expected[0].values.length;
    for (let i = 0; i < colCount; ++i) {
      expect(expected[i].values.length).toEqual(rowCount);
      expect(table.getChildAt(i)?.length).toEqual(rowCount);
      expect(table.schema.fields[i]?.name).toEqual(expected[i].name);
    }
    for (let i = 0; i < colCount; ++i) {
      const col = table.getChildAt(i);
      const have = [];
      for (let j = 0; j < rowCount; ++j) {
        have.push(col.get(j));
      }
      expect(Number(have)).toEqual(Number(expected[i].values));
    }
  }

  // test/insert_arrow.test.ts
  var buildUtf8Array = (values) => {
    const builder = new Utf8Builder({
      type: new Utf8()
    });
    for (const v of values) {
      builder.append(v);
    }
    builder.finish();
    return builder.flush();
  };
  var ARROW_INSERT_TESTS = [
    {
      name: "integers_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int32()),
        new Field2("c", new Int32())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int32(), data: new Int32Array([2, 5, 8]) }),
            makeData({ type: new Int32(), data: new Int32Array([3, 6, 9]) })
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "combined_1",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "combined_2",
      schema: new Schema2([
        new Field2("a", new Int32()),
        new Field2("b", new Int16()),
        new Field2("c", new Utf8())
      ]),
      batches: [
        {
          numRows: 3,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([1, 4, 7]) }),
            makeData({ type: new Int16(), data: new Int16Array([2, 5, 8]) }),
            buildUtf8Array(["3", "6", "9"])
          ]
        },
        {
          numRows: 2,
          columns: [
            makeData({ type: new Int32(), data: new Int32Array([10, 13]) }),
            makeData({ type: new Int16(), data: new Int16Array([11, 14]) }),
            buildUtf8Array(["12", "15"])
          ]
        }
      ],
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7, 10, 13] },
        { name: "b", values: [2, 5, 8, 11, 14] },
        { name: "c", values: ["3", "6", "9", "12", "15"] }
      ]
    }
  ];
  function testArrowInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data);
          });
          const table = new Table(test.schema, batches);
          conn.insertArrowTable(table, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testArrowInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("Arrow async insert from iterable", () => {
      for (const test of ARROW_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const batches = test.batches.map((b) => {
            const data = makeData({
              type: new Struct(test.schema.fields),
              children: b.columns
            });
            return new RecordBatch(test.schema, data);
          });
          const table = new Table(test.schema, batches);
          await conn.insertArrowTable(table, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describe("Arrow async insert from table", () => {
      it("simple integers", async () => {
        await conn.query(`DROP TABLE IF EXISTS insert_from_table`);
        const table = new Table({
          a: makeVector(new Int32Array([1, 4, 7])),
          b: makeVector(new Int32Array([2, 5, 8])),
          c: vectorFromArray(["3", "6", "9"])
        });
        await conn.insertArrowTable(table, {
          name: "insert_from_vectors"
        });
        const results = await conn.query("select * from insert_from_vectors");
        compareTable(results, [
          { name: "a", values: [1, 4, 7] },
          { name: "b", values: [2, 5, 8] },
          { name: "c", values: ["3", "6", "9"] }
        ]);
      });
    });
  }

  // test/insert_json.test.ts
  function describeBrowser(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder2 = new TextEncoder();
  var JSON_INSERT_TESTS = [
    {
      name: "rows_integers",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "cols_integers",
      input: `{
            "a": [1, 4, 7],
            "b": [2, 5, 8],
            "c": [3, 6, 9]
        }`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "options_1",
      input: `[
            {"a":1, "b":2, "c":3},
            {"a":4, "b":5, "c":6},
            {"a":7, "b":8, "c":9},
        ]`,
      options: {
        schema: "main",
        name: "foo",
        shape: "row-array" /* ROW_ARRAY */,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    }
  ];
  var TEST_FILE = "TEST";
  function testJSONInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Sync", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          db2().registerFileBuffer(TEST_FILE, buffer);
          conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testJSONInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("JSON Insert Buffer Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE, buffer);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser("JSON Insert Blob Async", () => {
      for (const test of JSON_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder2.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertJSONFromPath(TEST_FILE, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/insert_csv.test.ts
  function describeBrowser2(description, specDefinitions) {
    if (typeof window !== "undefined") {
      describe(description, specDefinitions);
    }
  }
  var encoder3 = new TextEncoder();
  var CSV_INSERT_TESTS = [
    {
      name: "integers_auto_1",
      input: `"a","b","c"
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a,b,c
1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: [3, 6, 9] }
      ]
    },
    {
      name: "integers_auto_3",
      input: `a,b,c`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "column0", values: ["a"] },
        { name: "column1", values: ["b"] },
        { name: "column2", values: ["c"] }
      ]
    },
    {
      name: "integers_auto_2",
      input: `a
1
4
7
`,
      options: {
        schema: "main",
        name: "foo"
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [{ name: "a", values: [1, 4, 7] }]
    },
    {
      name: "options_1",
      input: `1,2,3
4,5,6
7,8,9
`,
      options: {
        schema: "main",
        name: "foo2",
        header: false,
        detect: false,
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new Utf8()
        }
      },
      query: "SELECT * FROM main.foo2",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        { name: "c", values: ["3", "6", "9"] }
      ]
    },
    {
      name: "options_2",
      input: `1|2|01/02/2020
4|5|01/03/2020
7|8|01/04/2020
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        dateFormat: "%m/%d/%Y",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new DateDay()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(2020, 0, 2)),
            new Date(Date.UTC(2020, 0, 3)),
            new Date(Date.UTC(2020, 0, 4))
          ]
        }
      ]
    },
    {
      name: "options_3",
      input: `1|2|20:32:45 1992-03-02
4|5|20:32:50 1992-03-02
7|8|20:32:55 1992-03-02
`,
      options: {
        schema: "main",
        name: "foo",
        detect: false,
        header: false,
        delimiter: "|",
        quote: "'",
        timestampFormat: "%H:%M:%S %Y-%m-%d",
        columns: {
          a: new Int16(),
          b: new Int32(),
          c: new TimestampSecond()
        }
      },
      query: "SELECT * FROM main.foo",
      expectedColumns: [
        { name: "a", values: [1, 4, 7] },
        { name: "b", values: [2, 5, 8] },
        {
          name: "c",
          values: [
            new Date(Date.UTC(1992, 2, 2, 20, 32, 45)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 50)).getTime(),
            new Date(Date.UTC(1992, 2, 2, 20, 32, 55)).getTime()
          ]
        }
      ]
    }
  ];
  var TEST_FILE2 = "TEST";
  function testCSVInsert(db2) {
    let conn;
    beforeEach(async () => {
      db2().flushFiles();
      conn = db2().connect();
    });
    afterEach(async () => {
      conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Sync", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, () => {
          conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          db2().registerFileBuffer(TEST_FILE2, buffer);
          conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }
  function testCSVInsertAsync(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("CSV Insert Buffer Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          await db2().registerFileBuffer(TEST_FILE2, buffer);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
    describeBrowser2("CSV Insert Blob Async", () => {
      for (const test of CSV_INSERT_TESTS) {
        it(test.name, async () => {
          await conn.query(`DROP TABLE IF EXISTS ${test.options.schema || "main"}.${test.options.name}`);
          const buffer = encoder3.encode(test.input);
          const blob = new Blob([buffer]);
          await db2().registerFileHandle(TEST_FILE2, blob, 2 /* BROWSER_FILEREADER */, false);
          await conn.insertCSVFromPath(TEST_FILE2, test.options);
          const results = await conn.query(test.query);
          compareTable(results, test.expectedColumns);
        });
      }
    });
  }

  // test/tokenizer.test.ts
  function testTokenization(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }
  function testTokenizationAsync(db2) {
    describe("Tokenizer", () => {
      it("SELECT 1", async () => {
        expect(await db2().tokenize("SELECT 1")).toEqual({
          offsets: [0, 7],
          types: [4, 1]
        });
      });
      it("SELECT * FROM region", async () => {
        expect(await db2().tokenize("SELECT * FROM region")).toEqual({
          offsets: [0, 7, 9, 14],
          types: [4, 3, 4, 0]
        });
      });
    });
  }

  // test/tablenames.test.ts
  var TABLENAME_TESTS = [
    {
      name: "standard",
      input: "SELECT * FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "fetch_specific",
      input: "SELECT col_a FROM my_table",
      tables: ["my_table"]
    },
    {
      name: "multiple_tables",
      input: "SELECT * FROM my_table1, my_table2, my_table3",
      tables: ["my_table1", "my_table2", "my_table3"]
    },
    {
      name: "same_table_multiple_times",
      input: "SELECT col_a FROM my_table, my_table m2, my_table m3",
      tables: ["my_table"]
    },
    {
      name: "subqueries",
      input: "SELECT * FROM (SELECT * FROM (SELECT * FROM my_table) bla) bla3",
      tables: ["my_table"]
    },
    {
      name: "join",
      input: "SELECT col_a FROM my_table JOIN my_table2 ON (my_table.col_b=my_table2.col_d)",
      tables: ["my_table", "my_table2"]
    },
    {
      name: "scalar_subquery",
      input: "SELECT (SELECT COUNT(*) FROM my_table)",
      tables: ["my_table"]
    },
    {
      name: "set_operations",
      input: "SELECT * FROM my_table UNION ALL SELECT * FROM my_table2 INTERSECT SELECT * FROM my_table3",
      tables: ["my_table", "my_table2", "my_table3"]
    },
    {
      name: "window_functions",
      input: "SELECT row_number() OVER (ORDER BY (SELECT i+j FROM my_table2)) FROM my_table",
      tables: ["my_table", "my_table2"]
    }
  ];
  function testTableNames(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
    });
    describe("TableNames", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, () => {
          const tables = conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }
  function testTableNamesAsync(db2) {
    let conn;
    beforeEach(async () => {
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
    });
    describe("TableNames Async", () => {
      for (const test of TABLENAME_TESTS) {
        it(test.name, async () => {
          const tables = await conn.getTableNames(test.input);
          expect(tables).toEqual(test.tables);
        });
      }
    });
  }

  // test/regression/github_332.test.ts
  function test332(db2) {
    let conn;
    beforeEach(async () => {
      await db2().flushFiles();
      conn = await db2().connect();
    });
    afterEach(async () => {
      await conn.close();
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("332", async () => {
        await db2().registerFileText(
          "Products.csv",
          `ProductGroup,Product,Year,Quarter,Revenue,Units,Count,Product Key,Reseller,Product Info,QuarterAsNumber
Electronics,Phone,2018,Q1,103,7,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q1,102,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2019,Q1,98,12,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2018,Q1,104,3,1,2018-Q1,Samsung,Format=XML; <Properties>\u2026,1
Electronics,Computer,2019,Q1,83,7,1,2019-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2018,Q1,17,4,1,2018-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2019,Q1,20,7,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2018,Q1,25,12,1,2018-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Movies,2019,Q1,26,13,1,2019-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2018,Q2,99,4,1,2018-Q2,LG,Format=XML; <Properties>\u2026,2
Electronics,Computer,2019,Q2,84,20,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2018,Q2,17,4,1,2018-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Media,Theater,2019,Q2,22,5,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2018,Q2,25,12,1,2018-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2019,Q2,26,14,1,2019-Q2,Google,Format=XML; <Properties>\u2026,2
Electronics,Phone,2000,Q1,103,7,1,2000-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2001,Q1,102,4,1,2001-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2002,Q1,98,12,1,2002-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Computer,2003,Q1,104,3,1,2003-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Computer,2004,Q1,83,7,1,2004-Q1,Samsung,Format=XML; <Properties>\u2026,1
Media,Theater,2005,Q1,17,4,1,2005-Q1,Google,Format=XML; <Properties>\u2026,1
Media,Theater,2006,Q1,20,7,1,2006-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2007,Q1,25,12,1,2007-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Movies,2008,Q1,26,13,1,2008-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Electronics,Phone,2009,Q2,105,5,1,2009-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2010,Q2,82,15,1,2010-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2011,Q2,99,4,1,2011-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2012,Q2,84,20,1,2012-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2013,Q2,17,4,1,2013-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Theater,2014,Q2,22,5,1,2014-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2015,Q2,25,12,1,2015-Q2,Sony,Format=XML; <Properties>\u2026,2
Media,Movies,2016,Q2,26,14,1,2016-Q2,Samsung,Format=XML; <Properties>\u2026,2
Media,Movies,2017,Q1,26,13,1,2017-Q1,Google,Format=XML; <Properties>\u2026,1
Electronics,Phone,2018,Q2,105,5,1,2018-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Phone,2019,Q2,82,15,1,2019-Q2,Sony,Format=XML; <Properties>\u2026,2
Electronics,Computer,2020,Q2,99,4,1,2020-Q2,Microsoft,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q1,103,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Electronics,Phone,2020,Q2,102,4,1,2020-Q2,Samsung,Format=XML; <Properties>\u2026,2
Electronics,Phone,2020,Q3,98,12,1,2020-Q3,LG,Format=XML; <Properties>\u2026,3
Electronics,Computer,2020,Q4,104,3,1,2020-Q4,LG,Format=XML; <Properties>\u2026,4
Electronics,Computer,2020,Q1,83,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,17,4,1,2020-Q1,Microsoft,Format=XML; <Properties>\u2026,1
Media,Theater,2020,Q1,20,7,1,2020-Q1,Sony,Format=XML; <Properties>\u2026,1
`
        );
        await conn.query("CREATE TABLE products AS SELECT * FROM 'Products.csv'");
        const all = await conn.query("SELECT * FROM products");
        expect(all.schema.fields.length).toBe(11);
        expect(all.schema.fields[0].name).toBe("ProductGroup");
        const insensitive = await conn.query("SELECT productgroup FROM products GROUP BY productgroup");
        expect(insensitive.schema.fields.length).toBe(1);
        expect(insensitive.schema.fields[0].name).toBe("ProductGroup");
        expect(insensitive.toArray().length).toEqual(2);
        await conn.query("DROP TABLE products");
      });
    });
  }

  // test/regression/github_334.test.ts
  function test334(adb2) {
    describe("GitHub issues", () => {
      describe("334", () => {
        it("CSV insert", async () => {
          await adb2().registerFileText(`data.csv`, "1|foo\n2|bar\n");
          const conn = await adb2().connect();
          await conn.insertCSVFromPath("data.csv", {
            schema: "main",
            name: "foo",
            detect: false,
            header: false,
            delimiter: "|",
            columns: {
              col1: new Int32(),
              col2: new Utf8()
            }
          });
          await conn.query("DROP TABLE IF EXISTS foo");
          await conn.close();
          await adb2().dropFile("data.csv");
        });
        it("JSON row insert", async () => {
          await adb2().registerFileText(
            "rows.json",
            `[
                    { "col1": 1, "col2": "foo" },
                    { "col1": 2, "col2": "bar" },
                ]`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("rows.json", { name: "rows" });
          await conn.query("DROP TABLE IF EXISTS rows");
          await conn.close();
          await adb2().dropFile("rows.json");
        });
        it("JSON column insert", async () => {
          await adb2().registerFileText(
            "columns.json",
            `{
                    "col1": [1, 2],
                    "col2": ["foo", "bar"]
                }`
          );
          const conn = await adb2().connect();
          await conn.insertJSONFromPath("columns.json", { name: "columns" });
          await conn.query("DROP TABLE IF EXISTS columns");
          await conn.close();
          await adb2().dropFile("columns.json");
        });
        it("Query result materialized", async () => {
          const conn = await adb2().connect();
          await conn.query(`
                SELECT * FROM generate_series(1, 100) t(v)
            `);
          await conn.close();
        });
        it("Query result streamed", async () => {
          const conn = await adb2().connect();
          for await (const batch of await conn.send(`
                SELECT * FROM generate_series(1, 100) t(v)
            `)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await conn.close();
        });
        it("Prepared statement materialized", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          await stmt.query(234);
          await stmt.close();
          await conn.close();
        });
        it("Prepared statement streamed", async () => {
          const conn = await adb2().connect();
          const stmt = await conn.prepare(`SELECT v + ? FROM generate_series(0, 10000) as t(v);`);
          for await (const batch of await stmt.send(234)) {
            expect(batch.numRows).toBeGreaterThan(0);
          }
          await stmt.close();
          await conn.close();
        });
      });
    });
  }

  // test/regression/github_393.test.ts
  function test393(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("393", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: false
          }
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithoutCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)).getTime());
        await db2().open({
          path: ":memory:",
          query: {
            castTimestampToDate: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT TIMESTAMP '1992-03-22 01:02:03' as ts`);
        expect(resultWithCast.toArray()[0]?.ts).toEqual(new Date(Date.UTC(1992, 2, 22, 1, 2, 3)));
      });
    });
  }

  // test/regression/github_448.test.ts
  function test448(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("448", async () => {
        conn = await db2().connect();
        await conn.query(`create temp table test448(i integer)`);
        await conn.query(`insert into test448 values (1),(2),(1)`);
        let result = await conn.query(`select * from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(3);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1, 2, 1]));
        result = await conn.query(`select histogram(i) from test448`);
        expect(result.numCols).toBe(1);
        expect(result.numRows).toBe(1);
        const array = result.getChildAt(0).toArray();
        expect(array.length).toEqual(1);
        expect(array[0].toString()).toEqual("{1: 2, 2: 1}");
      });
    });
  }

  // test/regression/github_470.test.ts
  function test470(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("470", async () => {
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: false
          }
        });
        conn = await db2().connect();
        const result1 = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(result1.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {
            castDurationToTime64: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithCast.toArray()[0]?.interval?.toString()).toEqual("0,3");
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithDefault = await conn.query(`SELECT INTERVAL '3' MONTH AS interval`);
        expect(resultWithDefault.toArray()[0]?.interval?.toString()).toEqual("0,3");
      });
    });
  }

  // test/regression/github_477.test.ts
  function test477(db2) {
    let conn = null;
    beforeEach(async () => {
      await db2().flushFiles();
    });
    afterEach(async () => {
      if (conn) {
        await conn.close();
        conn = null;
      }
      await db2().flushFiles();
      await db2().dropFiles();
    });
    describe("GitHub issues", () => {
      it("477", async () => {
        await db2().open({
          path: ":memory:",
          query: {}
        });
        conn = await db2().connect();
        const resultWithoutCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithoutCast.schema.fields[0].type.scale).toEqual(1);
        expect(resultWithoutCast.schema.fields[0].type.precision).toEqual(2);
        expect(resultWithoutCast.toArray()[0]?.decimal == -19).toBe(false);
        await db2().open({
          path: ":memory:",
          query: {
            castDecimalToDouble: true
          }
        });
        conn = await db2().connect();
        const resultWithCast = await conn.query(`SELECT (-1.9)::DECIMAL(2,1) as decimal`);
        expect(resultWithCast.toArray()[0]?.decimal).toEqual(-1.9000000000000001);
      });
    });
  }

  // test/regression/index.ts
  function testRegressionAsync(adb2) {
    test332(adb2);
    test334(adb2);
    test393(adb2);
    test448(adb2);
    test470(adb2);
    test477(adb2);
  }

  // test/udf.test.ts
  function testUDF(db2) {
    let conn;
    beforeEach(() => {
      conn = db2().connect();
    });
    afterEach(() => {
      conn.close();
      db2().flushFiles();
      db2().dropFiles();
    });
    describe("UDF", () => {
      it("simple", async () => {
        conn.createScalarFunction("jsudf", new Int32(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([1e4]));
      });
      it("double", async () => {
        conn.createScalarFunction("jsudf2", new Float64(), (a) => a);
        const result = conn.query(
          "SELECT max(jsudf2(v::DOUBLE))::DOUBLE as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Float64Array([1e4]));
      });
      it("2 args", async () => {
        conn.createScalarFunction("jsudf3", new Int32(), (a, b) => a + b);
        const result = conn.query(
          "SELECT max(jsudf3(v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([2e4]));
      });
      it("3 args", async () => {
        conn.createScalarFunction("jsudf3args", new Int32(), (a, b, c) => a + b + c);
        const result = conn.query(
          "SELECT max(jsudf3args(v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([3e4]));
      });
      it("4 args", async () => {
        conn.createScalarFunction("jsudf4args", new Int32(), (a, b, c, d) => a + b + c + d);
        const result = conn.query(
          "SELECT max(jsudf4args(v::INTEGER, v::INTEGER, v::INTEGER, v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([4e4]));
      });
      it("noargs", async () => {
        conn.createScalarFunction("jsudf4", new Int32(), () => 42);
        const result = conn.query("SELECT max(jsudf4())::INTEGER as foo FROM generate_series(1, 10000) as t(v)");
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("withnulls", async () => {
        conn.createScalarFunction("jsudf5", new Int32(), (a) => a == null ? -100 : a);
        const result = conn.query(
          "SELECT min(jsudf5((case when v % 2 = 0 then v else null end)::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("stringparam", async () => {
        function jsudf6(s) {
          return s.length;
        }
        conn.createScalarFunction("jsudf6", new Int32(), jsudf6);
        const result = conn.query(
          "SELECT max(jsudf6('str_' || v))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("stringparamnulls", async () => {
        function jsudf7(s) {
          if (s == void 0) {
            return 0;
          } else {
            return s.length;
          }
        }
        conn.createScalarFunction("jsudf7", new Int32(), jsudf7);
        const result = conn.query(
          "SELECT max(jsudf7((case when v % 2 = 0 then 'str_' || v else null end)::VARCHAR))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([9]));
      });
      it("nullintreturn", async () => {
        conn.createScalarFunction("jsudf8", new Int32(), (a) => void 0);
        const result = conn.query(
          "SELECT max(COALESCE(jsudf8(v::INTEGER), 42))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([42]));
      });
      it("stringreturn", async () => {
        conn.createScalarFunction("jsudf9", new Utf8(), (a) => "Hello " + a);
        const result = conn.query(
          "SELECT max(LENGTH(jsudf9(v::INTEGER)))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([11]));
      });
      it("nullstringreturn", async () => {
        conn.createScalarFunction("jsudf10", new Utf8(), (a) => a % 2 == 0 ? "Hello" : void 0);
        const result = conn.query(
          "SELECT COUNT(jsudf10(v::INTEGER))::INTEGER as foo FROM generate_series(1, 10000) as t(v)"
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([5e3]));
      });
      it("struct", async () => {
        conn.createScalarFunction("jsudf11", new Int32(), (a) => a.x == null ? -100 : a.x);
        const result = conn.query(
          `SELECT min(jsudf11({'x': (case when v % 2 = 0 then v else null end)::INTEGER, 'y': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnested", async () => {
        conn.createScalarFunction("jsudf12", new Int32(), (a) => a.x.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf12({'x': {'y': (case when v % 2 = 0 then v else null end)::INTEGER }, 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
      it("structnestednull", async () => {
        conn.createScalarFunction("jsudf13", new Int32(), (a) => a.x?.y == null ? -100 : a.x.y);
        const result = conn.query(
          `SELECT min(jsudf13({'x': (case when v % 2 = 0 then {'y': v::INTEGER } else null end), 'z': 42}))::INTEGER as foo FROM generate_series(1, 10000) as t(v)`
        );
        expect(result.numRows).toEqual(1);
        expect(result.numCols).toEqual(1);
        expect(result.getChildAt(0)?.length).toEqual(1);
        expect(result.getChildAt(0)?.toArray()).toEqual(new Int32Array([-100]));
      });
    });
  }

  // test/index_browser.ts
  var DUCKDB_BUNDLES = {
    mvp: {
      mainModule: new URL("/static/duckdb-mvp.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-mvp.worker.js", window.location.href).href
    },
    eh: {
      mainModule: new URL("/static/duckdb-eh.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-eh.worker.js", window.location.href).href
    },
    coi: {
      mainModule: new URL("/static/duckdb-coi.wasm", window.location.href).href,
      mainWorker: new URL("/static/duckdb-browser-coi.worker.js", window.location.href).href,
      pthreadWorker: new URL("/static/duckdb-browser-coi.pthread.worker.js", window.location.href).href
    }
  };
  var DUCKDB_BUNDLE = null;
  describe("wasm check", () => {
    it("worker and wasm urls", async () => {
      if ((await getPlatformFeatures()).crossOriginIsolated && await exceptions() && await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.coi.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.coi.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(DUCKDB_BUNDLES.coi.pthreadWorker);
      }
      if (await exceptions() && !await threads()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.eh.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.eh.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
      if (!await exceptions()) {
        expect(DUCKDB_BUNDLE.mainModule).toEqual(DUCKDB_BUNDLES.mvp.mainModule);
        expect(DUCKDB_BUNDLE.mainWorker).toEqual(DUCKDB_BUNDLES.mvp.mainWorker);
        expect(DUCKDB_BUNDLE.pthreadWorker).toEqual(null);
      }
    });
  });
  jasmine.DEFAULT_TIMEOUT_INTERVAL = 6e4;
  var resolveBuffer = async (url) => {
    const req = await fetch(`/data${url}`);
    if (!req.ok)
      return null;
    return new Uint8Array(await req.arrayBuffer());
  };
  var resolveData = async (url) => {
    switch (url) {
      case "/uni/all.zip":
        return await resolveBuffer("/uni/all.zip");
      case "/uni/assistenten.parquet":
        return await resolveBuffer("/uni/assistenten.parquet");
      case "/uni/studenten.parquet":
        return await resolveBuffer("/uni/studenten.parquet");
      case "/uni/hoeren.parquet":
        return await resolveBuffer("/uni/hoeren.parquet");
      case "/uni/vorlesungen.parquet":
        return await resolveBuffer("/uni/vorlesungen.parquet");
      case "/tpch/0_01/parquet/lineitem.parquet":
        return await resolveBuffer("/tpch/0_01/parquet/lineitem.parquet");
      default:
        return null;
    }
  };
  var db = null;
  var adb = null;
  var worker = null;
  beforeAll(async () => {
    const logger = new VoidLogger();
    db = await createDuckDB(DUCKDB_BUNDLES, logger, BROWSER_RUNTIME);
    await db.instantiate((_) => {
    });
    DUCKDB_BUNDLE = await selectBundle(DUCKDB_BUNDLES);
    worker = await createWorker(DUCKDB_BUNDLE.mainWorker);
    adb = new AsyncDuckDB(logger, worker);
    await adb.instantiate(DUCKDB_BUNDLE.mainModule, DUCKDB_BUNDLE.pthreadWorker);
  });
  afterAll(async () => {
    if (worker)
      worker.terminate();
  });
  var baseURL = window.location.origin;
  var dataURL = `${baseURL}/data`;
  testHTTPFS(() => db);
  testHTTPFSAsync(() => adb, resolveData, dataURL);
  testUDF(() => db);
  testTableNames(() => db);
  testTableNamesAsync(() => adb);
  testRegressionAsync(() => adb);
  testAllTypes(() => db);
  testAllTypesAsync(() => adb);
  testBindings(() => db, dataURL);
  testAsyncBindings(() => adb, dataURL, 4 /* HTTP */);
  testBatchStream(() => db);
  testAsyncBatchStream(() => adb);
  testFilesystem(() => adb, resolveData, dataURL, 4 /* HTTP */);
  testArrowInsert(() => db);
  testArrowInsertAsync(() => adb);
  testJSONInsert(() => db);
  testJSONInsertAsync(() => adb);
  testCSVInsert(() => db);
  testCSVInsertAsync(() => adb);
  testTokenization(() => db);
  testTokenizationAsync(() => adb);
})();
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9qcy1zaGEyNTYvc3JjL3NoYTI1Ni5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvd2ViLXdvcmtlci9janMvYnJvd3Nlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvdHNsaWIvbW9kdWxlcy9pbmRleC5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9idWZmZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvdXRmOC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9jb21wYXQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby9pby9hZGFwdGVycy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2VudW0udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvdmVjdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL3ByZXR0eS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9ibi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3R5cGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL21hdGgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3Ivc2V0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvcm93L3Jvdy9zdHJ1Y3QudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvZ2V0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvcm93L3Jvdy9tYXAudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy91dGlsL3V0aWwvYml0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZGF0YS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9jaHVuay50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci9pbmRleG9mLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2l0ZXJhdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2J5dGVsZW5ndGgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92ZWN0b3IudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdmFsaWQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvYnVmZmVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2Jsb2NrLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvdXRpbHMuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9sb25nLmpzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mbGF0YnVmZmVycy9tanMvZW5jb2RpbmcuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2ZsYXRidWZmZXJzL21qcy9ieXRlLWJ1ZmZlci5qcyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvZmxhdGJ1ZmZlcnMvbWpzL2J1aWxkZXIuanMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9rZXktdmFsdWUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9tZXRhZGF0YS12ZXJzaW9uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZW5kaWFubmVzcy50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RpY3Rpb25hcnkta2luZC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ludC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RpY3Rpb25hcnktZW5jb2RpbmcudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9iaW5hcnkudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9ib29sLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZGF0ZS11bml0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZGF0ZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2RlY2ltYWwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi90aW1lLXVuaXQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9maXhlZC1zaXplLWJpbmFyeS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ZpeGVkLXNpemUtbGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3ByZWNpc2lvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2Zsb2F0aW5nLXBvaW50LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvaW50ZXJ2YWwtdW5pdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2ludGVydmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvbGlzdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL21hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL251bGwudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9zdHJ1Y3RfLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvdGltZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3RpbWVzdGFtcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3VuaW9uLW1vZGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi91bmlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL3V0ZjgudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi90eXBlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZmllbGQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9zY2hlbWEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9mb290ZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9zY2hlbWEudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pcGMvbWV0YWRhdGEvaXBjL21ldGFkYXRhL2ZpbGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby9pby9pbnRlcmZhY2VzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vaW8vc3RyZWFtLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vaW8vZmlsZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3V0aWwvdXRpbC9pbnQudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvdmVjdG9ybG9hZGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2JpbmFyeS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9ib29sLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2RhdGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvZGVjaW1hbC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9kaWN0aW9uYXJ5LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2ZpeGVkc2l6ZWJpbmFyeS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9maXhlZHNpemVsaXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2Zsb2F0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2ludGVydmFsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL2ludC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9saXN0LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL21hcC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci9udWxsLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvYnVpbGRlci9idWlsZGVyL3N0cnVjdC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci90aW1lc3RhbXAudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9idWlsZGVyL2J1aWxkZXIvdGltZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci91bmlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2J1aWxkZXIvYnVpbGRlci91dGY4LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL2J1aWxkZXJjdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdmlzaXRvci92aXNpdG9yL3R5cGVjb21wYXJhdG9yLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmFjdG9yaWVzLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdXRpbC91dGlsL3JlY29yZGJhdGNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvdGFibGUudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9yZWNvcmRiYXRjaC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2JvZHktY29tcHJlc3Npb24tbWV0aG9kLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvY29tcHJlc3Npb24tdHlwZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL2JvZHktY29tcHJlc3Npb24udHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9idWZmZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9mYi9mYi9maWVsZC1ub2RlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvcmVjb3JkLWJhdGNoLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvZGljdGlvbmFyeS1iYXRjaC50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2ZiL2ZiL21lc3NhZ2UtaGVhZGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvZmIvZmIvbWVzc2FnZS50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L3Zpc2l0b3IvdmlzaXRvci90eXBlYXNzZW1ibGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL21ldGFkYXRhL2lwYy9tZXRhZGF0YS9qc29uLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL21ldGFkYXRhL2lwYy9tZXRhZGF0YS9tZXNzYWdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL2lwYy9tZXNzYWdlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL2lwYy9yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy92aXNpdG9yL3Zpc2l0b3IvdmVjdG9yYXNzZW1ibGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaXBjL2lwYy93cml0ZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby93aGF0d2cvaW8vd2hhdHdnL2l0ZXJhYmxlLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vd2hhdHdnL2lvL3doYXR3Zy9idWlsZGVyLnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvaW8vd2hhdHdnL2lvL3doYXR3Zy9yZWFkZXIudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2FwYWNoZS1hcnJvdy9pby93aGF0d2cvaW8vd2hhdHdnL3dyaXRlci50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L2lwYy9pcGMvc2VyaWFsaXphdGlvbi50cyIsICIuLi8uLi8uLi9ub2RlX21vZHVsZXMvYXBhY2hlLWFycm93L0Fycm93LnRzIiwgIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9hcGFjaGUtYXJyb3cvQXJyb3cuZG9tLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9jb25uZWN0aW9uLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy91ZGZfcnVudGltZS50cyIsICIuLi9zcmMvYmluZGluZ3MvcnVudGltZS50cyIsICIuLi9zcmMvYmluZGluZ3MvZmlsZV9zdGF0cy50cyIsICIuLi9zcmMvanNvbl90eXBlZGVmLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19iYXNlLnRzIiwgIi4uL3NyYy9sb2cudHMiLCAiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3dhc20tZmVhdHVyZS1kZXRlY3QvZGlzdC9lc20vaW5kZXguanMiLCAiLi4vc3JjL3BsYXRmb3JtLnRzIiwgIi4uL3NyYy91dGlscy9zM19oZWxwZXIudHMiLCAiLi4vc3JjL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlci50cyIsICIuLi9zcmMvYmluZGluZ3MvZHVja2RiLW12cC5qcyIsICIuLi9zcmMvYmluZGluZ3MvYmluZGluZ3NfYnJvd3Nlcl9iYXNlLnRzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX212cC50cyIsICIuLi9zcmMvYmluZGluZ3MvZHVja2RiLWVoLmpzIiwgIi4uL3NyYy9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX2VoLnRzIiwgIi4uL3NyYy90YXJnZXRzL2R1Y2tkYi1icm93c2VyLWJsb2NraW5nLnRzIiwgIi4uL3NyYy9wYXJhbGxlbC9hc3luY19jb25uZWN0aW9uLnRzIiwgIi4uL3NyYy9wYXJhbGxlbC93b3JrZXJfcmVxdWVzdC50cyIsICIuLi9zcmMvcGFyYWxsZWwvYXN5bmNfYmluZGluZ3MudHMiLCAiLi4vc3JjL3dvcmtlci50cyIsICIuLi90ZXN0L2FsbF90eXBlcy50ZXN0LnRzIiwgIi4uL3Rlc3QvaHR0cGZzX3Rlc3QudHMiLCAiLi4vdGVzdC9iaW5kaW5ncy50ZXN0LnRzIiwgIi4uL3Rlc3QvYmF0Y2hfc3RyZWFtLnRlc3QudHMiLCAiLi4vdGVzdC9iYXRjaF9zdHJlYW1fYXN5bmMudGVzdC50cyIsICIuLi90ZXN0L2ZpbGVzeXN0ZW0udGVzdC50cyIsICIuLi90ZXN0L3RhYmxlX3Rlc3QudHMiLCAiLi4vdGVzdC9pbnNlcnRfYXJyb3cudGVzdC50cyIsICIuLi90ZXN0L2luc2VydF9qc29uLnRlc3QudHMiLCAiLi4vdGVzdC9pbnNlcnRfY3N2LnRlc3QudHMiLCAiLi4vdGVzdC90b2tlbml6ZXIudGVzdC50cyIsICIuLi90ZXN0L3RhYmxlbmFtZXMudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vZ2l0aHViXzMzMi50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9naXRodWJfMzM0LnRlc3QudHMiLCAiLi4vdGVzdC9yZWdyZXNzaW9uL2dpdGh1Yl8zOTMudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vZ2l0aHViXzQ0OC50ZXN0LnRzIiwgIi4uL3Rlc3QvcmVncmVzc2lvbi9naXRodWJfNDcwLnRlc3QudHMiLCAiLi4vdGVzdC9yZWdyZXNzaW9uL2dpdGh1Yl80NzcudGVzdC50cyIsICIuLi90ZXN0L3JlZ3Jlc3Npb24vaW5kZXgudHMiLCAiLi4vdGVzdC91ZGYudGVzdC50cyIsICIuLi90ZXN0L2luZGV4X2Jyb3dzZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5c3RlbSwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG52YXIgX19leHRlbmRzO1xyXG52YXIgX19hc3NpZ247XHJcbnZhciBfX3Jlc3Q7XHJcbnZhciBfX2RlY29yYXRlO1xyXG52YXIgX19wYXJhbTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fc3ByZWFkQXJyYXk7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG4gICAgX19leHRlbmRzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2RlY29yYXRlID0gZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICAgICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICAgICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxuICAgIH07XHJcblxyXG4gICAgX19wYXJhbSA9IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXdhaXRlciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgICAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2dlbmVyYXRvciA9IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XHJcbiAgICAgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgICAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uKG0sIG8pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxuICAgIH0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0RGVmYXVsdCA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICAgICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgICAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4gPSBmdW5jdGlvbiAoc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG59KTtcclxuIiwgIi8qKlxuICogW2pzLXNoYTI1Nl17QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEyNTZ9XG4gKlxuICogQHZlcnNpb24gMC45LjBcbiAqIEBhdXRob3IgQ2hlbiwgWWktQ3l1YW4gW2VtbjE3OEBnbWFpbC5jb21dXG4gKiBAY29weXJpZ2h0IENoZW4sIFlpLUN5dWFuIDIwMTQtMjAxN1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qanNsaW50IGJpdHdpc2U6IHRydWUgKi9cbihmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRVJST1IgPSAnaW5wdXQgaXMgaW52YWxpZCB0eXBlJztcbiAgdmFyIFdJTkRPVyA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnO1xuICB2YXIgcm9vdCA9IFdJTkRPVyA/IHdpbmRvdyA6IHt9O1xuICBpZiAocm9vdC5KU19TSEEyNTZfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEyNTZfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTI1Nl9OT19DT01NT05fSlMgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHM7XG4gIHZhciBBTUQgPSB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQ7XG4gIHZhciBBUlJBWV9CVUZGRVIgPSAhcm9vdC5KU19TSEEyNTZfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgRVhUUkEgPSBbLTIxNDc0ODM2NDgsIDgzODg2MDgsIDMyNzY4LCAxMjhdO1xuICB2YXIgU0hJRlQgPSBbMjQsIDE2LCA4LCAwXTtcbiAgdmFyIEsgPSBbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG4gIF07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdhcnJheScsICdkaWdlc3QnLCAnYXJyYXlCdWZmZXInXTtcblxuICB2YXIgYmxvY2tzID0gW107XG5cbiAgaWYgKHJvb3QuSlNfU0hBMjU2X05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTI1Nl9OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKG91dHB1dFR5cGUsIGlzMjI0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IFNoYTI1NihpczIyNCwgdHJ1ZSkudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGlzMjI0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZCgnaGV4JywgaXMyMjQpO1xuICAgIGlmIChOT0RFX0pTKSB7XG4gICAgICBtZXRob2QgPSBub2RlV3JhcChtZXRob2QsIGlzMjI0KTtcbiAgICB9XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhMjU2KGlzMjI0KTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVPdXRwdXRNZXRob2QodHlwZSwgaXMyMjQpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBub2RlV3JhcCA9IGZ1bmN0aW9uIChtZXRob2QsIGlzMjI0KSB7XG4gICAgdmFyIGNyeXB0byA9IGV2YWwoXCJyZXF1aXJlKCdjcnlwdG8nKVwiKTtcbiAgICB2YXIgQnVmZmVyID0gZXZhbChcInJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclwiKTtcbiAgICB2YXIgYWxnb3JpdGhtID0gaXMyMjQgPyAnc2hhMjI0JyA6ICdzaGEyNTYnO1xuICAgIHZhciBub2RlTWV0aG9kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKG1lc3NhZ2UsICd1dGY4JykuZGlnZXN0KCdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1lc3NhZ2UpIHx8IEFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSB8fFxuICAgICAgICBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobSkudXBkYXRlKG5ldyBCdWZmZXIobWVzc2FnZSkpLmRpZ2VzdCgnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWV0aG9kKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG5vZGVNZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhtYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAob3V0cHV0VHlwZSwgaXMyMjQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG5ldyBIbWFjU2hhMjU2KGtleSwgaXMyMjQsIHRydWUpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUhtYWNNZXRob2QgPSBmdW5jdGlvbiAoaXMyMjQpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlSG1hY091dHB1dE1ldGhvZCgnaGV4JywgaXMyMjQpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gbmV3IEhtYWNTaGEyNTYoa2V5LCBpczIyNCk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5KS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVIbWFjT3V0cHV0TWV0aG9kKHR5cGUsIGlzMjI0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGEyNTYoaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIGlmIChzaGFyZWRNZW1vcnkpIHtcbiAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgICAgdGhpcy5ibG9ja3MgPSBibG9ja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYmxvY2tzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIH1cblxuICAgIGlmIChpczIyNCkge1xuICAgICAgdGhpcy5oMCA9IDB4YzEwNTllZDg7XG4gICAgICB0aGlzLmgxID0gMHgzNjdjZDUwNztcbiAgICAgIHRoaXMuaDIgPSAweDMwNzBkZDE3O1xuICAgICAgdGhpcy5oMyA9IDB4ZjcwZTU5Mzk7XG4gICAgICB0aGlzLmg0ID0gMHhmZmMwMGIzMTtcbiAgICAgIHRoaXMuaDUgPSAweDY4NTgxNTExO1xuICAgICAgdGhpcy5oNiA9IDB4NjRmOThmYTc7XG4gICAgICB0aGlzLmg3ID0gMHhiZWZhNGZhNDtcbiAgICB9IGVsc2UgeyAvLyAyNTZcbiAgICAgIHRoaXMuaDAgPSAweDZhMDllNjY3O1xuICAgICAgdGhpcy5oMSA9IDB4YmI2N2FlODU7XG4gICAgICB0aGlzLmgyID0gMHgzYzZlZjM3MjtcbiAgICAgIHRoaXMuaDMgPSAweGE1NGZmNTNhO1xuICAgICAgdGhpcy5oNCA9IDB4NTEwZTUyN2Y7XG4gICAgICB0aGlzLmg1ID0gMHg5YjA1Njg4YztcbiAgICAgIHRoaXMuaDYgPSAweDFmODNkOWFiO1xuICAgICAgdGhpcy5oNyA9IDB4NWJlMGNkMTk7XG4gICAgfVxuXG4gICAgdGhpcy5ibG9jayA9IHRoaXMuc3RhcnQgPSB0aGlzLmJ5dGVzID0gdGhpcy5oQnl0ZXMgPSAwO1xuICAgIHRoaXMuZmluYWxpemVkID0gdGhpcy5oYXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmlzMjI0ID0gaXMyMjQ7XG4gIH1cblxuICBTaGEyNTYucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgY29kZSwgaW5kZXggPSAwLCBpLCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCwgYmxvY2tzID0gdGhpcy5ibG9ja3M7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmhhc2hlZCkge1xuICAgICAgICB0aGlzLmhhc2hlZCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBibG9ja3NbMTZdID0gYmxvY2tzWzFdID0gYmxvY2tzWzJdID0gYmxvY2tzWzNdID1cbiAgICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICAgIGJsb2Nrc1s4XSA9IGJsb2Nrc1s5XSA9IGJsb2Nrc1sxMF0gPSBibG9ja3NbMTFdID1cbiAgICAgICAgICBibG9ja3NbMTJdID0gYmxvY2tzWzEzXSA9IGJsb2Nrc1sxNF0gPSBibG9ja3NbMTVdID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgNjQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IDY0OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcbiAgICAgIHRoaXMuYnl0ZXMgKz0gaSAtIHRoaXMuc3RhcnQ7XG4gICAgICBpZiAoaSA+PSA2NCkge1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzWzE2XTtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSA2NDtcbiAgICAgICAgdGhpcy5oYXNoKCk7XG4gICAgICAgIHRoaXMuaGFzaGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlcyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgIHRoaXMuaEJ5dGVzICs9IHRoaXMuYnl0ZXMgLyA0Mjk0OTY3Mjk2IDw8IDA7XG4gICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcyAlIDQyOTQ5NjcyOTY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXg7XG4gICAgYmxvY2tzWzE2XSA9IHRoaXMuYmxvY2s7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gRVhUUkFbaSAmIDNdO1xuICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbMTZdO1xuICAgIGlmIChpID49IDU2KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzaGVkKSB7XG4gICAgICAgIHRoaXMuaGFzaCgpO1xuICAgICAgfVxuICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgIGJsb2Nrc1sxNl0gPSBibG9ja3NbMV0gPSBibG9ja3NbMl0gPSBibG9ja3NbM10gPVxuICAgICAgICBibG9ja3NbNF0gPSBibG9ja3NbNV0gPSBibG9ja3NbNl0gPSBibG9ja3NbN10gPVxuICAgICAgICBibG9ja3NbOF0gPSBibG9ja3NbOV0gPSBibG9ja3NbMTBdID0gYmxvY2tzWzExXSA9XG4gICAgICAgIGJsb2Nrc1sxMl0gPSBibG9ja3NbMTNdID0gYmxvY2tzWzE0XSA9IGJsb2Nrc1sxNV0gPSAwO1xuICAgIH1cbiAgICBibG9ja3NbMTRdID0gdGhpcy5oQnl0ZXMgPDwgMyB8IHRoaXMuYnl0ZXMgPj4+IDI5O1xuICAgIGJsb2Nrc1sxNV0gPSB0aGlzLmJ5dGVzIDw8IDM7XG4gICAgdGhpcy5oYXNoKCk7XG4gIH07XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhID0gdGhpcy5oMCwgYiA9IHRoaXMuaDEsIGMgPSB0aGlzLmgyLCBkID0gdGhpcy5oMywgZSA9IHRoaXMuaDQsIGYgPSB0aGlzLmg1LCBnID0gdGhpcy5oNixcbiAgICAgIGggPSB0aGlzLmg3LCBibG9ja3MgPSB0aGlzLmJsb2NrcywgaiwgczAsIHMxLCBtYWosIHQxLCB0MiwgY2gsIGFiLCBkYSwgY2QsIGJjO1xuXG4gICAgZm9yIChqID0gMTY7IGogPCA2NDsgKytqKSB7XG4gICAgICAvLyByaWdodHJvdGF0ZVxuICAgICAgdDEgPSBibG9ja3NbaiAtIDE1XTtcbiAgICAgIHMwID0gKCh0MSA+Pj4gNykgfCAodDEgPDwgMjUpKSBeICgodDEgPj4+IDE4KSB8ICh0MSA8PCAxNCkpIF4gKHQxID4+PiAzKTtcbiAgICAgIHQxID0gYmxvY2tzW2ogLSAyXTtcbiAgICAgIHMxID0gKCh0MSA+Pj4gMTcpIHwgKHQxIDw8IDE1KSkgXiAoKHQxID4+PiAxOSkgfCAodDEgPDwgMTMpKSBeICh0MSA+Pj4gMTApO1xuICAgICAgYmxvY2tzW2pdID0gYmxvY2tzW2ogLSAxNl0gKyBzMCArIGJsb2Nrc1tqIC0gN10gKyBzMSA8PCAwO1xuICAgIH1cblxuICAgIGJjID0gYiAmIGM7XG4gICAgZm9yIChqID0gMDsgaiA8IDY0OyBqICs9IDQpIHtcbiAgICAgIGlmICh0aGlzLmZpcnN0KSB7XG4gICAgICAgIGlmICh0aGlzLmlzMjI0KSB7XG4gICAgICAgICAgYWIgPSAzMDAwMzI7XG4gICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAxNDEzMjU3ODE5O1xuICAgICAgICAgIGggPSB0MSAtIDE1MDA1NDU5OSA8PCAwO1xuICAgICAgICAgIGQgPSB0MSArIDI0MTc3MDc3IDw8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWIgPSA3MDQ3NTExMDk7XG4gICAgICAgICAgdDEgPSBibG9ja3NbMF0gLSAyMTAyNDQyNDg7XG4gICAgICAgICAgaCA9IHQxIC0gMTUyMTQ4NjUzNCA8PCAwO1xuICAgICAgICAgIGQgPSB0MSArIDE0MzY5NDU2NSA8PCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gKChhID4+PiAyKSB8IChhIDw8IDMwKSkgXiAoKGEgPj4+IDEzKSB8IChhIDw8IDE5KSkgXiAoKGEgPj4+IDIyKSB8IChhIDw8IDEwKSk7XG4gICAgICAgIHMxID0gKChlID4+PiA2KSB8IChlIDw8IDI2KSkgXiAoKGUgPj4+IDExKSB8IChlIDw8IDIxKSkgXiAoKGUgPj4+IDI1KSB8IChlIDw8IDcpKTtcbiAgICAgICAgYWIgPSBhICYgYjtcbiAgICAgICAgbWFqID0gYWIgXiAoYSAmIGMpIF4gYmM7XG4gICAgICAgIGNoID0gKGUgJiBmKSBeICh+ZSAmIGcpO1xuICAgICAgICB0MSA9IGggKyBzMSArIGNoICsgS1tqXSArIGJsb2Nrc1tqXTtcbiAgICAgICAgdDIgPSBzMCArIG1hajtcbiAgICAgICAgaCA9IGQgKyB0MSA8PCAwO1xuICAgICAgICBkID0gdDEgKyB0MiA8PCAwO1xuICAgICAgfVxuICAgICAgczAgPSAoKGQgPj4+IDIpIHwgKGQgPDwgMzApKSBeICgoZCA+Pj4gMTMpIHwgKGQgPDwgMTkpKSBeICgoZCA+Pj4gMjIpIHwgKGQgPDwgMTApKTtcbiAgICAgIHMxID0gKChoID4+PiA2KSB8IChoIDw8IDI2KSkgXiAoKGggPj4+IDExKSB8IChoIDw8IDIxKSkgXiAoKGggPj4+IDI1KSB8IChoIDw8IDcpKTtcbiAgICAgIGRhID0gZCAmIGE7XG4gICAgICBtYWogPSBkYSBeIChkICYgYikgXiBhYjtcbiAgICAgIGNoID0gKGggJiBlKSBeICh+aCAmIGYpO1xuICAgICAgdDEgPSBnICsgczEgKyBjaCArIEtbaiArIDFdICsgYmxvY2tzW2ogKyAxXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBnID0gYyArIHQxIDw8IDA7XG4gICAgICBjID0gdDEgKyB0MiA8PCAwO1xuICAgICAgczAgPSAoKGMgPj4+IDIpIHwgKGMgPDwgMzApKSBeICgoYyA+Pj4gMTMpIHwgKGMgPDwgMTkpKSBeICgoYyA+Pj4gMjIpIHwgKGMgPDwgMTApKTtcbiAgICAgIHMxID0gKChnID4+PiA2KSB8IChnIDw8IDI2KSkgXiAoKGcgPj4+IDExKSB8IChnIDw8IDIxKSkgXiAoKGcgPj4+IDI1KSB8IChnIDw8IDcpKTtcbiAgICAgIGNkID0gYyAmIGQ7XG4gICAgICBtYWogPSBjZCBeIChjICYgYSkgXiBkYTtcbiAgICAgIGNoID0gKGcgJiBoKSBeICh+ZyAmIGUpO1xuICAgICAgdDEgPSBmICsgczEgKyBjaCArIEtbaiArIDJdICsgYmxvY2tzW2ogKyAyXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBmID0gYiArIHQxIDw8IDA7XG4gICAgICBiID0gdDEgKyB0MiA8PCAwO1xuICAgICAgczAgPSAoKGIgPj4+IDIpIHwgKGIgPDwgMzApKSBeICgoYiA+Pj4gMTMpIHwgKGIgPDwgMTkpKSBeICgoYiA+Pj4gMjIpIHwgKGIgPDwgMTApKTtcbiAgICAgIHMxID0gKChmID4+PiA2KSB8IChmIDw8IDI2KSkgXiAoKGYgPj4+IDExKSB8IChmIDw8IDIxKSkgXiAoKGYgPj4+IDI1KSB8IChmIDw8IDcpKTtcbiAgICAgIGJjID0gYiAmIGM7XG4gICAgICBtYWogPSBiYyBeIChiICYgZCkgXiBjZDtcbiAgICAgIGNoID0gKGYgJiBnKSBeICh+ZiAmIGgpO1xuICAgICAgdDEgPSBlICsgczEgKyBjaCArIEtbaiArIDNdICsgYmxvY2tzW2ogKyAzXTtcbiAgICAgIHQyID0gczAgKyBtYWo7XG4gICAgICBlID0gYSArIHQxIDw8IDA7XG4gICAgICBhID0gdDEgKyB0MiA8PCAwO1xuICAgIH1cblxuICAgIHRoaXMuaDAgPSB0aGlzLmgwICsgYSA8PCAwO1xuICAgIHRoaXMuaDEgPSB0aGlzLmgxICsgYiA8PCAwO1xuICAgIHRoaXMuaDIgPSB0aGlzLmgyICsgYyA8PCAwO1xuICAgIHRoaXMuaDMgPSB0aGlzLmgzICsgZCA8PCAwO1xuICAgIHRoaXMuaDQgPSB0aGlzLmg0ICsgZSA8PCAwO1xuICAgIHRoaXMuaDUgPSB0aGlzLmg1ICsgZiA8PCAwO1xuICAgIHRoaXMuaDYgPSB0aGlzLmg2ICsgZyA8PCAwO1xuICAgIHRoaXMuaDcgPSB0aGlzLmg3ICsgaCA8PCAwO1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBoMCA9IHRoaXMuaDAsIGgxID0gdGhpcy5oMSwgaDIgPSB0aGlzLmgyLCBoMyA9IHRoaXMuaDMsIGg0ID0gdGhpcy5oNCwgaDUgPSB0aGlzLmg1LFxuICAgICAgaDYgPSB0aGlzLmg2LCBoNyA9IHRoaXMuaDc7XG5cbiAgICB2YXIgaGV4ID0gSEVYX0NIQVJTWyhoMCA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMCA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDAgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgwID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDAgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgxID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoMSA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDEgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toMSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDIgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGgyID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMiA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2gyICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoMyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDMgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGgzID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDMgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAyNCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiAxNikgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg0ID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNCA+PiA4KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDQgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNCAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDI0KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgIEhFWF9DSEFSU1soaDUgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg1ID4+IDgpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNSA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2g1ICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAyOCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gMjQpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgSEVYX0NIQVJTWyhoNiA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDYgPj4gOCkgJiAweDBGXSArXG4gICAgICBIRVhfQ0hBUlNbKGg2ID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbaDYgJiAweDBGXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGg3ID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhoNyA+PiAyNCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGg3ID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgSEVYX0NIQVJTWyhoNyA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soaDcgPj4gOCkgJiAweDBGXSArXG4gICAgICAgIEhFWF9DSEFSU1soaDcgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1toNyAmIDB4MEZdO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xuICB9O1xuXG4gIFNoYTI1Ni5wcm90b3R5cGUudG9TdHJpbmcgPSBTaGEyNTYucHJvdG90eXBlLmhleDtcblxuICBTaGEyNTYucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgaDAgPSB0aGlzLmgwLCBoMSA9IHRoaXMuaDEsIGgyID0gdGhpcy5oMiwgaDMgPSB0aGlzLmgzLCBoNCA9IHRoaXMuaDQsIGg1ID0gdGhpcy5oNSxcbiAgICAgIGg2ID0gdGhpcy5oNiwgaDcgPSB0aGlzLmg3O1xuXG4gICAgdmFyIGFyciA9IFtcbiAgICAgIChoMCA+PiAyNCkgJiAweEZGLCAoaDAgPj4gMTYpICYgMHhGRiwgKGgwID4+IDgpICYgMHhGRiwgaDAgJiAweEZGLFxuICAgICAgKGgxID4+IDI0KSAmIDB4RkYsIChoMSA+PiAxNikgJiAweEZGLCAoaDEgPj4gOCkgJiAweEZGLCBoMSAmIDB4RkYsXG4gICAgICAoaDIgPj4gMjQpICYgMHhGRiwgKGgyID4+IDE2KSAmIDB4RkYsIChoMiA+PiA4KSAmIDB4RkYsIGgyICYgMHhGRixcbiAgICAgIChoMyA+PiAyNCkgJiAweEZGLCAoaDMgPj4gMTYpICYgMHhGRiwgKGgzID4+IDgpICYgMHhGRiwgaDMgJiAweEZGLFxuICAgICAgKGg0ID4+IDI0KSAmIDB4RkYsIChoNCA+PiAxNikgJiAweEZGLCAoaDQgPj4gOCkgJiAweEZGLCBoNCAmIDB4RkYsXG4gICAgICAoaDUgPj4gMjQpICYgMHhGRiwgKGg1ID4+IDE2KSAmIDB4RkYsIChoNSA+PiA4KSAmIDB4RkYsIGg1ICYgMHhGRixcbiAgICAgIChoNiA+PiAyNCkgJiAweEZGLCAoaDYgPj4gMTYpICYgMHhGRiwgKGg2ID4+IDgpICYgMHhGRiwgaDYgJiAweEZGXG4gICAgXTtcbiAgICBpZiAoIXRoaXMuaXMyMjQpIHtcbiAgICAgIGFyci5wdXNoKChoNyA+PiAyNCkgJiAweEZGLCAoaDcgPj4gMTYpICYgMHhGRiwgKGg3ID4+IDgpICYgMHhGRiwgaDcgJiAweEZGKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcblxuICBTaGEyNTYucHJvdG90eXBlLmFycmF5ID0gU2hhMjU2LnByb3RvdHlwZS5kaWdlc3Q7XG5cbiAgU2hhMjU2LnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuaXMyMjQgPyAyOCA6IDMyKTtcbiAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMCwgdGhpcy5oMCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDQsIHRoaXMuaDEpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMig4LCB0aGlzLmgyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMTIsIHRoaXMuaDMpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMigxNiwgdGhpcy5oNCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKDIwLCB0aGlzLmg1KTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoMjQsIHRoaXMuaDYpO1xuICAgIGlmICghdGhpcy5pczIyNCkge1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKDI4LCB0aGlzLmg3KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBmdW5jdGlvbiBIbWFjU2hhMjU2KGtleSwgaXMyMjQsIHNoYXJlZE1lbW9yeSkge1xuICAgIHZhciBpLCB0eXBlID0gdHlwZW9mIGtleTtcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBieXRlcyA9IFtdLCBsZW5ndGggPSBrZXkubGVuZ3RoLCBpbmRleCA9IDAsIGNvZGU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29kZSA9IGtleS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhjMCB8IChjb2RlID4+IDYpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ZTAgfCAoY29kZSA+PiAxMikpO1xuICAgICAgICAgIGJ5dGVzW2luZGV4KytdID0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8IChjb2RlICYgMHgzZikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHhmMCB8IChjb2RlID4+IDE4KSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSk7XG4gICAgICAgICAgYnl0ZXNbaW5kZXgrK10gPSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKTtcbiAgICAgICAgICBieXRlc1tpbmRleCsrXSA9ICgweDgwIHwgKGNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtleSA9IGJ5dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIGtleS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICBrZXkgPSBuZXcgVWludDhBcnJheShrZXkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICBpZiAoIUFSUkFZX0JVRkZFUiB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkubGVuZ3RoID4gNjQpIHtcbiAgICAgIGtleSA9IChuZXcgU2hhMjU2KGlzMjI0LCB0cnVlKSkudXBkYXRlKGtleSkuYXJyYXkoKTtcbiAgICB9XG5cbiAgICB2YXIgb0tleVBhZCA9IFtdLCBpS2V5UGFkID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgIHZhciBiID0ga2V5W2ldIHx8IDA7XG4gICAgICBvS2V5UGFkW2ldID0gMHg1YyBeIGI7XG4gICAgICBpS2V5UGFkW2ldID0gMHgzNiBeIGI7XG4gICAgfVxuXG4gICAgU2hhMjU2LmNhbGwodGhpcywgaXMyMjQsIHNoYXJlZE1lbW9yeSk7XG5cbiAgICB0aGlzLnVwZGF0ZShpS2V5UGFkKTtcbiAgICB0aGlzLm9LZXlQYWQgPSBvS2V5UGFkO1xuICAgIHRoaXMuaW5uZXIgPSB0cnVlO1xuICAgIHRoaXMuc2hhcmVkTWVtb3J5ID0gc2hhcmVkTWVtb3J5O1xuICB9XG4gIEhtYWNTaGEyNTYucHJvdG90eXBlID0gbmV3IFNoYTI1NigpO1xuXG4gIEhtYWNTaGEyNTYucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIFNoYTI1Ni5wcm90b3R5cGUuZmluYWxpemUuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgdGhpcy5pbm5lciA9IGZhbHNlO1xuICAgICAgdmFyIGlubmVySGFzaCA9IHRoaXMuYXJyYXkoKTtcbiAgICAgIFNoYTI1Ni5jYWxsKHRoaXMsIHRoaXMuaXMyMjQsIHRoaXMuc2hhcmVkTWVtb3J5KTtcbiAgICAgIHRoaXMudXBkYXRlKHRoaXMub0tleVBhZCk7XG4gICAgICB0aGlzLnVwZGF0ZShpbm5lckhhc2gpO1xuICAgICAgU2hhMjU2LnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZXhwb3J0cyA9IGNyZWF0ZU1ldGhvZCgpO1xuICBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHM7XG4gIGV4cG9ydHMuc2hhMjI0ID0gY3JlYXRlTWV0aG9kKHRydWUpO1xuICBleHBvcnRzLnNoYTI1Ni5obWFjID0gY3JlYXRlSG1hY01ldGhvZCgpO1xuICBleHBvcnRzLnNoYTIyNC5obWFjID0gY3JlYXRlSG1hY01ldGhvZCh0cnVlKTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc2hhMjU2ID0gZXhwb3J0cy5zaGEyNTY7XG4gICAgcm9vdC5zaGEyMjQgPSBleHBvcnRzLnNoYTIyNDtcbiAgICBpZiAoQU1EKSB7XG4gICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSkoKTtcbiIsICIvKipcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gV29ya2VyOyIsICJpbXBvcnQgdHNsaWIgZnJvbSAnLi4vdHNsaWIuanMnO1xyXG5jb25zdCB7XHJcbiAgICBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbixcclxuICAgIF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcixcclxuICAgIF9fZ2VuZXJhdG9yLFxyXG4gICAgX19leHBvcnRTdGFyLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nLFxyXG4gICAgX192YWx1ZXMsXHJcbiAgICBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZCxcclxuICAgIF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG59ID0gdHNsaWI7XHJcbmV4cG9ydCB7XHJcbiAgICBfX2V4dGVuZHMsXHJcbiAgICBfX2Fzc2lnbixcclxuICAgIF9fcmVzdCxcclxuICAgIF9fZGVjb3JhdGUsXHJcbiAgICBfX3BhcmFtLFxyXG4gICAgX19tZXRhZGF0YSxcclxuICAgIF9fYXdhaXRlcixcclxuICAgIF9fZ2VuZXJhdG9yLFxyXG4gICAgX19leHBvcnRTdGFyLFxyXG4gICAgX19jcmVhdGVCaW5kaW5nLFxyXG4gICAgX192YWx1ZXMsXHJcbiAgICBfX3JlYWQsXHJcbiAgICBfX3NwcmVhZCxcclxuICAgIF9fc3ByZWFkQXJyYXlzLFxyXG4gICAgX19zcHJlYWRBcnJheSxcclxuICAgIF9fYXdhaXQsXHJcbiAgICBfX2FzeW5jR2VuZXJhdG9yLFxyXG4gICAgX19hc3luY0RlbGVnYXRvcixcclxuICAgIF9fYXN5bmNWYWx1ZXMsXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcclxuICAgIF9faW1wb3J0U3RhcixcclxuICAgIF9faW1wb3J0RGVmYXVsdCxcclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXHJcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0LFxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxyXG59O1xyXG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiZXhwb3J0IGNvbnN0IFNJWkVPRl9TSE9SVCA9IDI7XHJcbmV4cG9ydCBjb25zdCBTSVpFT0ZfSU5UID0gNDtcclxuZXhwb3J0IGNvbnN0IEZJTEVfSURFTlRJRklFUl9MRU5HVEggPSA0O1xyXG5leHBvcnQgY29uc3QgU0laRV9QUkVGSVhfTEVOR1RIID0gNDtcclxuIiwgImV4cG9ydCBjb25zdCBpbnQzMiA9IG5ldyBJbnQzMkFycmF5KDIpO1xyXG5leHBvcnQgY29uc3QgZmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoaW50MzIuYnVmZmVyKTtcclxuZXhwb3J0IGNvbnN0IGZsb2F0NjQgPSBuZXcgRmxvYXQ2NEFycmF5KGludDMyLmJ1ZmZlcik7XHJcbmV4cG9ydCBjb25zdCBpc0xpdHRsZUVuZGlhbiA9IG5ldyBVaW50MTZBcnJheShuZXcgVWludDhBcnJheShbMSwgMF0pLmJ1ZmZlcilbMF0gPT09IDE7XHJcbiIsICJleHBvcnQgZnVuY3Rpb24gY3JlYXRlTG9uZyhsb3csIGhpZ2gpIHtcclxuICAgIHJldHVybiBMb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBMb25nIHtcclxuICAgIGNvbnN0cnVjdG9yKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuICAgICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGUobG93LCBoaWdoKSB7XHJcbiAgICAgICAgLy8gU3BlY2lhbC1jYXNlIHplcm8gdG8gYXZvaWQgR0Mgb3ZlcmhlYWQgZm9yIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgICAgcmV0dXJuIGxvdyA9PSAwICYmIGhpZ2ggPT0gMCA/IExvbmcuWkVSTyA6IG5ldyBMb25nKGxvdywgaGlnaCk7XHJcbiAgICB9XHJcbiAgICB0b0Zsb2F0NjQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyA+Pj4gMCkgKyB0aGlzLmhpZ2ggKiAweDEwMDAwMDAwMDtcclxuICAgIH1cclxuICAgIGVxdWFscyhvdGhlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvdyA9PSBvdGhlci5sb3cgJiYgdGhpcy5oaWdoID09IG90aGVyLmhpZ2g7XHJcbiAgICB9XHJcbn1cclxuTG9uZy5aRVJPID0gbmV3IExvbmcoMCwgMCk7XHJcbiIsICJleHBvcnQgdmFyIEVuY29kaW5nO1xyXG4oZnVuY3Rpb24gKEVuY29kaW5nKSB7XHJcbiAgICBFbmNvZGluZ1tFbmNvZGluZ1tcIlVURjhfQllURVNcIl0gPSAxXSA9IFwiVVRGOF9CWVRFU1wiO1xyXG4gICAgRW5jb2RpbmdbRW5jb2RpbmdbXCJVVEYxNl9TVFJJTkdcIl0gPSAyXSA9IFwiVVRGMTZfU1RSSU5HXCI7XHJcbn0pKEVuY29kaW5nIHx8IChFbmNvZGluZyA9IHt9KSk7XHJcbiIsICJpbXBvcnQgeyBGSUxFX0lERU5USUZJRVJfTEVOR1RILCBTSVpFT0ZfSU5UIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IExvbmcgfSBmcm9tIFwiLi9sb25nXCI7XHJcbmltcG9ydCB7IGludDMyLCBpc0xpdHRsZUVuZGlhbiwgZmxvYXQzMiwgZmxvYXQ2NCB9IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IEVuY29kaW5nIH0gZnJvbSBcIi4vZW5jb2RpbmdcIjtcclxuZXhwb3J0IGNsYXNzIEJ5dGVCdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgQnl0ZUJ1ZmZlciB3aXRoIGEgZ2l2ZW4gYXJyYXkgb2YgYnl0ZXMgKGBVaW50OEFycmF5YClcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYnl0ZXNfKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc18gPSBieXRlc187XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW5kIGFsbG9jYXRlIGEgbmV3IEJ5dGVCdWZmZXIgd2l0aCBhIGdpdmVuIHNpemUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhbGxvY2F0ZShieXRlX3NpemUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZV9zaXplKSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uXyA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdW5kZXJseWluZyBgVWludDhBcnJheWAuXHJcbiAgICAgKi9cclxuICAgIGJ5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBidWZmZXIncyBwb3NpdGlvbi5cclxuICAgICAqL1xyXG4gICAgcG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25fO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGJ1ZmZlcidzIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBzZXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMucG9zaXRpb25fID0gcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYnVmZmVyJ3MgY2FwYWNpdHkuXHJcbiAgICAgKi9cclxuICAgIGNhcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzXy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZWFkSW50OChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDgob2Zmc2V0KSA8PCAyNCA+PiAyNDtcclxuICAgIH1cclxuICAgIHJlYWRVaW50OChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XTtcclxuICAgIH1cclxuICAgIHJlYWRJbnQxNihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVWludDE2KG9mZnNldCkgPDwgMTYgPj4gMTY7XHJcbiAgICB9XHJcbiAgICByZWFkVWludDE2KG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzX1tvZmZzZXRdIHwgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPDwgODtcclxuICAgIH1cclxuICAgIHJlYWRJbnQzMihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc19bb2Zmc2V0XSB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDFdIDw8IDggfCB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA8PCAxNiB8IHRoaXMuYnl0ZXNfW29mZnNldCArIDNdIDw8IDI0O1xyXG4gICAgfVxyXG4gICAgcmVhZFVpbnQzMihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0KSA+Pj4gMDtcclxuICAgIH1cclxuICAgIHJlYWRJbnQ2NChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcodGhpcy5yZWFkSW50MzIob2Zmc2V0KSwgdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgNCkpO1xyXG4gICAgfVxyXG4gICAgcmVhZFVpbnQ2NChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExvbmcodGhpcy5yZWFkVWludDMyKG9mZnNldCksIHRoaXMucmVhZFVpbnQzMihvZmZzZXQgKyA0KSk7XHJcbiAgICB9XHJcbiAgICByZWFkRmxvYXQzMihvZmZzZXQpIHtcclxuICAgICAgICBpbnQzMlswXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIGZsb2F0MzJbMF07XHJcbiAgICB9XHJcbiAgICByZWFkRmxvYXQ2NChvZmZzZXQpIHtcclxuICAgICAgICBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDAgOiAxXSA9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICAgICAgaW50MzJbaXNMaXR0bGVFbmRpYW4gPyAxIDogMF0gPSB0aGlzLnJlYWRJbnQzMihvZmZzZXQgKyA0KTtcclxuICAgICAgICByZXR1cm4gZmxvYXQ2NFswXTtcclxuICAgIH1cclxuICAgIHdyaXRlSW50OChvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVVaW50OChvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQxNihvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcclxuICAgIH1cclxuICAgIHdyaXRlVWludDE2KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXRdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0ICsgMV0gPSB2YWx1ZSA+PiA4O1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQzMihvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcclxuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDE2O1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XHJcbiAgICB9XHJcbiAgICB3cml0ZVVpbnQzMihvZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ieXRlc19bb2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDFdID0gdmFsdWUgPj4gODtcclxuICAgICAgICB0aGlzLmJ5dGVzX1tvZmZzZXQgKyAyXSA9IHZhbHVlID4+IDE2O1xyXG4gICAgICAgIHRoaXMuYnl0ZXNfW29mZnNldCArIDNdID0gdmFsdWUgPj4gMjQ7XHJcbiAgICB9XHJcbiAgICB3cml0ZUludDY0KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLndyaXRlSW50MzIob2Zmc2V0LCB2YWx1ZS5sb3cpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCB2YWx1ZS5oaWdoKTtcclxuICAgIH1cclxuICAgIHdyaXRlVWludDY0KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCwgdmFsdWUubG93KTtcclxuICAgICAgICB0aGlzLndyaXRlVWludDMyKG9mZnNldCArIDQsIHZhbHVlLmhpZ2gpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVGbG9hdDMyKG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICBmbG9hdDMyWzBdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgaW50MzJbMF0pO1xyXG4gICAgfVxyXG4gICAgd3JpdGVGbG9hdDY0KG9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICBmbG9hdDY0WzBdID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDMyKG9mZnNldCwgaW50MzJbaXNMaXR0bGVFbmRpYW4gPyAwIDogMV0pO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMihvZmZzZXQgKyA0LCBpbnQzMltpc0xpdHRsZUVuZGlhbiA/IDEgOiAwXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZmlsZSBpZGVudGlmaWVyLiAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBmb3IgRmxhdEJ1ZmZlcnMgd2hvc2VcclxuICAgICAqIHNjaGVtYSBkb2VzIG5vdCBpbmNsdWRlIGEgZmlsZV9pZGVudGlmaWVyIChsaWtlbHkgcG9pbnRzIGF0IHBhZGRpbmcgb3IgdGhlXHJcbiAgICAgKiBzdGFydCBvZiBhIHRoZSByb290IHZ0YWJsZSkuXHJcbiAgICAgKi9cclxuICAgIGdldEJ1ZmZlcklkZW50aWZpZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYnl0ZXNfLmxlbmd0aCA8IHRoaXMucG9zaXRpb25fICsgU0laRU9GX0lOVCArXHJcbiAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGbGF0QnVmZmVyczogQnl0ZUJ1ZmZlciBpcyB0b28gc2hvcnQgdG8gY29udGFpbiBhbiBpZGVudGlmaWVyLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb25fICsgU0laRU9GX0lOVCArIGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9vayB1cCBhIGZpZWxkIGluIHRoZSB2dGFibGUsIHJldHVybiBhbiBvZmZzZXQgaW50byB0aGUgb2JqZWN0LCBvciAwIGlmIHRoZVxyXG4gICAgICogZmllbGQgaXMgbm90IHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIF9fb2Zmc2V0KGJiX3BvcywgdnRhYmxlX29mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IHZ0YWJsZSA9IGJiX3BvcyAtIHRoaXMucmVhZEludDMyKGJiX3Bvcyk7XHJcbiAgICAgICAgcmV0dXJuIHZ0YWJsZV9vZmZzZXQgPCB0aGlzLnJlYWRJbnQxNih2dGFibGUpID8gdGhpcy5yZWFkSW50MTYodnRhYmxlICsgdnRhYmxlX29mZnNldCkgOiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGFueSBUYWJsZS1kZXJpdmVkIHR5cGUgdG8gcG9pbnQgdG8gdGhlIHVuaW9uIGF0IHRoZSBnaXZlbiBvZmZzZXQuXHJcbiAgICAgKi9cclxuICAgIF9fdW5pb24odCwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdC5iYl9wb3MgPSBvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpO1xyXG4gICAgICAgIHQuYmIgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBKYXZhU2NyaXB0IHN0cmluZyBmcm9tIFVURi04IGRhdGEgc3RvcmVkIGluc2lkZSB0aGUgRmxhdEJ1ZmZlci5cclxuICAgICAqIFRoaXMgYWxsb2NhdGVzIGEgbmV3IHN0cmluZyBhbmQgY29udmVydHMgdG8gd2lkZSBjaGFycyB1cG9uIGVhY2ggYWNjZXNzLlxyXG4gICAgICpcclxuICAgICAqIFRvIGF2b2lkIHRoZSBjb252ZXJzaW9uIHRvIFVURi0xNiwgcGFzcyBFbmNvZGluZy5VVEY4X0JZVEVTIGFzXHJcbiAgICAgKiB0aGUgXCJvcHRpb25hbEVuY29kaW5nXCIgYXJndW1lbnQuIFRoaXMgaXMgdXNlZnVsIGZvciBhdm9pZGluZyBjb252ZXJzaW9uIHRvXHJcbiAgICAgKiBhbmQgZnJvbSBVVEYtMTYgd2hlbiB0aGUgZGF0YSB3aWxsIGp1c3QgYmUgcGFja2FnZWQgYmFjayB1cCBpbiBhbm90aGVyXHJcbiAgICAgKiBGbGF0QnVmZmVyIGxhdGVyIG9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvZmZzZXRcclxuICAgICAqIEBwYXJhbSBvcHRfZW5jb2RpbmcgRGVmYXVsdHMgdG8gVVRGMTZfU1RSSU5HXHJcbiAgICAgKi9cclxuICAgIF9fc3RyaW5nKG9mZnNldCwgb3B0X2VuY29kaW5nKSB7XHJcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWFkSW50MzIob2Zmc2V0KTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIG9mZnNldCArPSBTSVpFT0ZfSU5UO1xyXG4gICAgICAgIGlmIChvcHRfZW5jb2RpbmcgPT09IEVuY29kaW5nLlVURjhfQllURVMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNfLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IGNvZGVQb2ludDtcclxuICAgICAgICAgICAgLy8gRGVjb2RlIFVURi04XHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLnJlYWRVaW50OChvZmZzZXQgKyBpKyspO1xyXG4gICAgICAgICAgICBpZiAoYSA8IDB4QzApIHtcclxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcclxuICAgICAgICAgICAgICAgIGlmIChhIDwgMHhFMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICgoYSAmIDB4MUYpIDw8IDYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiICYgMHgzRik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IDB4RjApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYSAmIDB4MEYpIDw8IDEyKSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiICYgMHgzRikgPDwgNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjICYgMHgzRik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gdGhpcy5yZWFkVWludDgob2Zmc2V0ICsgaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYSAmIDB4MDcpIDw8IDE4KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChiICYgMHgzRikgPDwgMTIpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGMgJiAweDNGKSA8PCA2KSB8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGQgJiAweDNGKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRW5jb2RlIFVURi0xNlxyXG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGNvZGVQb2ludCA+PiAxMCkgKyAweEQ4MDAsIChjb2RlUG9pbnQgJiAoKDEgPDwgMTApIC0gMSkpICsgMHhEQzAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdW5pb25zIHRoYXQgY2FuIGNvbnRhaW4gc3RyaW5nIGFzIGl0cyBtZW1iZXIsIGlmIGEgVGFibGUtZGVyaXZlZCB0eXBlIHRoZW4gaW5pdGlhbGl6ZSBpdCxcclxuICAgICAqIGlmIGEgc3RyaW5nIHRoZW4gcmV0dXJuIGEgbmV3IG9uZVxyXG4gICAgICpcclxuICAgICAqIFdBUk5JTkc6IHN0cmluZ3MgYXJlIGltbXV0YWJsZSBpbiBKUyBzbyB3ZSBjYW4ndCBjaGFuZ2UgdGhlIHN0cmluZyB0aGF0IHRoZSB1c2VyIGdhdmUgdXMsIHRoaXNcclxuICAgICAqIG1ha2VzIHRoZSBiZWhhdmlvdXIgb2YgX191bmlvbl93aXRoX3N0cmluZyBkaWZmZXJlbnQgY29tcGFyZWQgdG8gX191bmlvblxyXG4gICAgICovXHJcbiAgICBfX3VuaW9uX3dpdGhfc3RyaW5nKG8sIG9mZnNldCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19zdHJpbmcob2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX191bmlvbihvLCBvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSB0aGUgcmVsYXRpdmUgb2Zmc2V0IHN0b3JlZCBhdCBcIm9mZnNldFwiXHJcbiAgICAgKi9cclxuICAgIF9faW5kaXJlY3Qob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIHRoaXMucmVhZEludDMyKG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc3RhcnQgb2YgZGF0YSBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIF9fdmVjdG9yKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBvZmZzZXQgKyB0aGlzLnJlYWRJbnQzMihvZmZzZXQpICsgU0laRU9GX0lOVDsgLy8gZGF0YSBzdGFydHMgYWZ0ZXIgdGhlIGxlbmd0aFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciB3aG9zZSBvZmZzZXQgaXMgc3RvcmVkIGF0IFwib2Zmc2V0XCIgaW4gdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIF9fdmVjdG9yX2xlbihvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkSW50MzIob2Zmc2V0ICsgdGhpcy5yZWFkSW50MzIob2Zmc2V0KSk7XHJcbiAgICB9XHJcbiAgICBfX2hhc19pZGVudGlmaWVyKGlkZW50KSB7XHJcbiAgICAgICAgaWYgKGlkZW50Lmxlbmd0aCAhPSBGSUxFX0lERU5USUZJRVJfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcclxuICAgICAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZJTEVfSURFTlRJRklFUl9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaWRlbnQuY2hhckNvZGVBdChpKSAhPSB0aGlzLnJlYWRJbnQ4KHRoaXMucG9zaXRpb24oKSArIFNJWkVPRl9JTlQgKyBpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBnZW5lcmF0ZWQgY29kZSBkZXBlbmRpbmcgb24gdGhpcyBmaWxlIGRpcmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVMb25nKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHJldHVybiBMb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBsaXN0IGZvciBvYmogYXBpXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNjYWxhckxpc3QobGlzdEFjY2Vzc29yLCBsaXN0TGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RBY2Nlc3NvcihpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2gobGlzdEFjY2Vzc29yKGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2VuZXJhdGluZyBsaXN0IGZvciBvYmogYXBpXHJcbiAgICAgKiBAcGFyYW0gbGlzdEFjY2Vzc29yIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBpbmRleCBhbmQgcmV0dXJuIGRhdGEgYXQgdGhhdCBpbmRleFxyXG4gICAgICogQHBhcmFtIGxpc3RMZW5ndGggbGlzdExlbmd0aFxyXG4gICAgICogQHBhcmFtIHJlcyByZXN1bHQgbGlzdFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVPYmpMaXN0KGxpc3RBY2Nlc3NvciwgbGlzdExlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdExlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IGxpc3RBY2Nlc3NvcihpKTtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2godmFsLnVucGFjaygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBCeXRlQnVmZmVyIH0gZnJvbSBcIi4vYnl0ZS1idWZmZXJcIjtcclxuaW1wb3J0IHsgU0laRU9GX1NIT1JULCBTSVpFX1BSRUZJWF9MRU5HVEgsIFNJWkVPRl9JTlQsIEZJTEVfSURFTlRJRklFUl9MRU5HVEggfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgTG9uZyB9IGZyb20gXCIuL2xvbmdcIjtcclxuZXhwb3J0IGNsYXNzIEJ1aWxkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBGbGF0QnVmZmVyQnVpbGRlci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0X2luaXRpYWxfc2l6ZSkge1xyXG4gICAgICAgIC8qKiBNaW5pbXVtIGFsaWdubWVudCBlbmNvdW50ZXJlZCBzbyBmYXIuICovXHJcbiAgICAgICAgdGhpcy5taW5hbGlnbiA9IDE7XHJcbiAgICAgICAgLyoqIFRoZSB2dGFibGUgZm9yIHRoZSBjdXJyZW50IHRhYmxlLiAqL1xyXG4gICAgICAgIHRoaXMudnRhYmxlID0gbnVsbDtcclxuICAgICAgICAvKiogVGhlIGFtb3VudCBvZiBmaWVsZHMgd2UncmUgYWN0dWFsbHkgdXNpbmcuICovXHJcbiAgICAgICAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcclxuICAgICAgICAvKiogV2hldGhlciB3ZSBhcmUgY3VycmVudGx5IHNlcmlhbGl6aW5nIGEgdGFibGUuICovXHJcbiAgICAgICAgdGhpcy5pc05lc3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKiBTdGFydGluZyBvZmZzZXQgb2YgdGhlIGN1cnJlbnQgc3RydWN0L3RhYmxlLiAqL1xyXG4gICAgICAgIHRoaXMub2JqZWN0X3N0YXJ0ID0gMDtcclxuICAgICAgICAvKiogTGlzdCBvZiBvZmZzZXRzIG9mIGFsbCB2dGFibGVzLiAqL1xyXG4gICAgICAgIHRoaXMudnRhYmxlcyA9IFtdO1xyXG4gICAgICAgIC8qKiBGb3IgdGhlIGN1cnJlbnQgdmVjdG9yIGJlaW5nIGJ1aWx0LiAqL1xyXG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XHJcbiAgICAgICAgLyoqIEZhbHNlIG9taXRzIGRlZmF1bHQgdmFsdWVzIGZyb20gdGhlIHNlcmlhbGl6ZWQgZGF0YSAqL1xyXG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0cmluZ19tYXBzID0gbnVsbDtcclxuICAgICAgICBsZXQgaW5pdGlhbF9zaXplO1xyXG4gICAgICAgIGlmICghb3B0X2luaXRpYWxfc2l6ZSkge1xyXG4gICAgICAgICAgICBpbml0aWFsX3NpemUgPSAxMDI0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5pdGlhbF9zaXplID0gb3B0X2luaXRpYWxfc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge0J5dGVCdWZmZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJiID0gQnl0ZUJ1ZmZlci5hbGxvY2F0ZShpbml0aWFsX3NpemUpO1xyXG4gICAgICAgIHRoaXMuc3BhY2UgPSBpbml0aWFsX3NpemU7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmJiLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5zcGFjZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcclxuICAgICAgICB0aGlzLm1pbmFsaWduID0gMTtcclxuICAgICAgICB0aGlzLnZ0YWJsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52dGFibGVfaW5fdXNlID0gMDtcclxuICAgICAgICB0aGlzLmlzTmVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vYmplY3Rfc3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMudnRhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmVjdG9yX251bV9lbGVtcyA9IDA7XHJcbiAgICAgICAgdGhpcy5mb3JjZV9kZWZhdWx0cyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RyaW5nX21hcHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbiBvcmRlciB0byBzYXZlIHNwYWNlLCBmaWVsZHMgdGhhdCBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcclxuICAgICAqIGRvbid0IGdldCBzZXJpYWxpemVkIGludG8gdGhlIGJ1ZmZlci4gRm9yY2luZyBkZWZhdWx0cyBwcm92aWRlcyBhXHJcbiAgICAgKiB3YXkgdG8gbWFudWFsbHkgZGlzYWJsZSB0aGlzIG9wdGltaXphdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9yY2VEZWZhdWx0cyB0cnVlIGFsd2F5cyBzZXJpYWxpemVzIGRlZmF1bHQgdmFsdWVzXHJcbiAgICAgKi9cclxuICAgIGZvcmNlRGVmYXVsdHMoZm9yY2VEZWZhdWx0cykge1xyXG4gICAgICAgIHRoaXMuZm9yY2VfZGVmYXVsdHMgPSBmb3JjZURlZmF1bHRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIEJ5dGVCdWZmZXIgcmVwcmVzZW50aW5nIHRoZSBGbGF0QnVmZmVyLiBPbmx5IGNhbGwgdGhpcyBhZnRlciB5b3UndmVcclxuICAgICAqIGNhbGxlZCBmaW5pc2goKS4gVGhlIGFjdHVhbCBkYXRhIHN0YXJ0cyBhdCB0aGUgQnl0ZUJ1ZmZlcidzIGN1cnJlbnQgcG9zaXRpb24sXHJcbiAgICAgKiBub3QgbmVjZXNzYXJpbHkgYXQgMC5cclxuICAgICAqL1xyXG4gICAgZGF0YUJ1ZmZlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBieXRlcyByZXByZXNlbnRpbmcgdGhlIEZsYXRCdWZmZXIuIE9ubHkgY2FsbCB0aGlzIGFmdGVyIHlvdSd2ZVxyXG4gICAgICogY2FsbGVkIGZpbmlzaCgpLlxyXG4gICAgICovXHJcbiAgICBhc1VpbnQ4QXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmIuYnl0ZXMoKS5zdWJhcnJheSh0aGlzLmJiLnBvc2l0aW9uKCksIHRoaXMuYmIucG9zaXRpb24oKSArIHRoaXMub2Zmc2V0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlIHRvIHdyaXRlIGFuIGVsZW1lbnQgb2YgYHNpemVgIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYCBoYXZlIGJlZW5cclxuICAgICAqIHdyaXR0ZW4sIGUuZy4gaWYgeW91IHdyaXRlIGEgc3RyaW5nLCB5b3UgbmVlZCB0byBhbGlnbiBzdWNoIHRoZSBpbnQgbGVuZ3RoXHJcbiAgICAgKiBmaWVsZCBpcyBhbGlnbmVkIHRvIDQgYnl0ZXMsIGFuZCB0aGUgc3RyaW5nIGRhdGEgZm9sbG93cyBpdCBkaXJlY3RseS4gSWYgYWxsXHJcbiAgICAgKiB5b3UgbmVlZCB0byBkbyBpcyBhbGlnbm1lbnQsIGBhZGRpdGlvbmFsX2J5dGVzYCB3aWxsIGJlIDAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNpemUgVGhpcyBpcyB0aGUgb2YgdGhlIG5ldyBlbGVtZW50IHRvIHdyaXRlXHJcbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbF9ieXRlcyBUaGUgcGFkZGluZyBzaXplXHJcbiAgICAgKi9cclxuICAgIHByZXAoc2l6ZSwgYWRkaXRpb25hbF9ieXRlcykge1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBiaWdnZXN0IHRoaW5nIHdlJ3ZlIGV2ZXIgYWxpZ25lZCB0by5cclxuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMubWluYWxpZ24pIHtcclxuICAgICAgICAgICAgdGhpcy5taW5hbGlnbiA9IHNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZpbmQgdGhlIGFtb3VudCBvZiBhbGlnbm1lbnQgbmVlZGVkIHN1Y2ggdGhhdCBgc2l6ZWAgaXMgcHJvcGVybHlcclxuICAgICAgICAvLyBhbGlnbmVkIGFmdGVyIGBhZGRpdGlvbmFsX2J5dGVzYFxyXG4gICAgICAgIGNvbnN0IGFsaWduX3NpemUgPSAoKH4odGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSArIGFkZGl0aW9uYWxfYnl0ZXMpKSArIDEpICYgKHNpemUgLSAxKTtcclxuICAgICAgICAvLyBSZWFsbG9jYXRlIHRoZSBidWZmZXIgaWYgbmVlZGVkLlxyXG4gICAgICAgIHdoaWxlICh0aGlzLnNwYWNlIDwgYWxpZ25fc2l6ZSArIHNpemUgKyBhZGRpdGlvbmFsX2J5dGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZF9idWZfc2l6ZSA9IHRoaXMuYmIuY2FwYWNpdHkoKTtcclxuICAgICAgICAgICAgdGhpcy5iYiA9IEJ1aWxkZXIuZ3Jvd0J5dGVCdWZmZXIodGhpcy5iYik7XHJcbiAgICAgICAgICAgIHRoaXMuc3BhY2UgKz0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gb2xkX2J1Zl9zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBhZChhbGlnbl9zaXplKTtcclxuICAgIH1cclxuICAgIHBhZChieXRlX3NpemUpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVfc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQ4KC0tdGhpcy5zcGFjZSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQ4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDgodGhpcy5zcGFjZSAtPSAxLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZUludDE2KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5iYi53cml0ZUludDE2KHRoaXMuc3BhY2UgLT0gMiwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgd3JpdGVJbnQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlSW50NjQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJiLndyaXRlSW50NjQodGhpcy5zcGFjZSAtPSA4LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZUZsb2F0MzIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJiLndyaXRlRmxvYXQzMih0aGlzLnNwYWNlIC09IDQsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIHdyaXRlRmxvYXQ2NCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmIud3JpdGVGbG9hdDY0KHRoaXMuc3BhY2UgLT0gOCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYGludDhgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50OGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRJbnQ4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDEsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQ4KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGBpbnQxNmAgdG8gdGhlIGJ1ZmZlciwgcHJvcGVybHkgYWxpZ25lZCwgYW5kIGdyb3dzIHRoZSBidWZmZXIgKGlmIG5lY2Vzc2FyeSkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGBpbnQxNmAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRJbnQxNih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucHJlcCgyLCAwKTtcclxuICAgICAgICB0aGlzLndyaXRlSW50MTYodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYGludDMyYCB0byB0aGUgYnVmZmVyLCBwcm9wZXJseSBhbGlnbmVkLCBhbmQgZ3Jvd3MgdGhlIGJ1ZmZlciAoaWYgbmVjZXNzYXJ5KS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgYGludDMyYCB0byBhZGQgdGhlIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGFkZEludDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDQsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBgaW50NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgaW50NjRgIHRvIGFkZCB0aGUgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgYWRkSW50NjQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnByZXAoOCwgMCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDY0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgYGZsb2F0MzJgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgZmxvYXQzMmAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRGbG9hdDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDQsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDMyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgYGZsb2F0NjRgIHRvIHRoZSBidWZmZXIsIHByb3Blcmx5IGFsaWduZWQsIGFuZCBncm93cyB0aGUgYnVmZmVyIChpZiBuZWNlc3NhcnkpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBgZmxvYXQ2NGAgdG8gYWRkIHRoZSB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRGbG9hdDY0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5wcmVwKDgsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVGbG9hdDY0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGFkZEZpZWxkSW50OCh2b2Zmc2V0LCB2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VfZGVmYXVsdHMgfHwgdmFsdWUgIT0gZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW50OCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEludDE2KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQxNih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEludDMyKHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQzMih2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEludDY0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCAhdmFsdWUuZXF1YWxzKGRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQ2NCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2xvdCh2b2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRGaWVsZEZsb2F0MzIodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmZvcmNlX2RlZmF1bHRzIHx8IHZhbHVlICE9IGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEZsb2F0MzIodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkRmllbGRGbG9hdDY0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRGbG9hdDY0KHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5zbG90KHZvZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZEZpZWxkT2Zmc2V0KHZvZmZzZXQsIHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5mb3JjZV9kZWZhdWx0cyB8fCB2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRPZmZzZXQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJ1Y3RzIGFyZSBzdG9yZWQgaW5saW5lLCBzbyBub3RoaW5nIGFkZGl0aW9uYWwgaXMgYmVpbmcgYWRkZWQuIGBkYCBpcyBhbHdheXMgMC5cclxuICAgICAqL1xyXG4gICAgYWRkRmllbGRTdHJ1Y3Qodm9mZnNldCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBkZWZhdWx0VmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXN0ZWQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnNsb3Qodm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdHJ1Y3R1cmVzIGFyZSBhbHdheXMgc3RvcmVkIGlubGluZSwgdGhleSBuZWVkIHRvIGJlIGNyZWF0ZWQgcmlnaHRcclxuICAgICAqIHdoZXJlIHRoZXkncmUgdXNlZC4gIFlvdSdsbCBnZXQgdGhpcyBhc3NlcnRpb24gZmFpbHVyZSBpZiB5b3VcclxuICAgICAqIGNyZWF0ZWQgaXQgZWxzZXdoZXJlLlxyXG4gICAgICovXHJcbiAgICBuZXN0ZWQob2JqKSB7XHJcbiAgICAgICAgaWYgKG9iaiAhPSB0aGlzLm9mZnNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IHN0cnVjdCBtdXN0IGJlIHNlcmlhbGl6ZWQgaW5saW5lLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIG5vdCBiZSBjcmVhdGluZyBhbnkgb3RoZXIgb2JqZWN0LCBzdHJpbmcgb3IgdmVjdG9yXHJcbiAgICAgKiB3aGlsZSBhbiBvYmplY3QgaXMgYmVpbmcgY29uc3RydWN0ZWRcclxuICAgICAqL1xyXG4gICAgbm90TmVzdGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVzdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IG9iamVjdCBzZXJpYWxpemF0aW9uIG11c3Qgbm90IGJlIG5lc3RlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY3VycmVudCB2dGFibGUgYXQgYHZvZmZzZXRgIHRvIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHNsb3Qodm9mZnNldCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy52dGFibGVbdm9mZnNldF0gPSB0aGlzLm9mZnNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBvZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRoaXMuc3BhY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERvdWJsZXMgdGhlIHNpemUgb2YgdGhlIGJhY2tpbmcgQnl0ZUJ1ZmZlciBhbmQgY29waWVzIHRoZSBvbGQgZGF0YSB0b3dhcmRzXHJcbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBuZXcgYnVmZmVyIChzaW5jZSB3ZSBidWlsZCB0aGUgYnVmZmVyIGJhY2t3YXJkcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJiIFRoZSBjdXJyZW50IGJ1ZmZlciB3aXRoIHRoZSBleGlzdGluZyBkYXRhXHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBieXRlIGJ1ZmZlciB3aXRoIHRoZSBvbGQgZGF0YSBjb3BpZWRcclxuICAgICAqIHRvIGl0LiBUaGUgZGF0YSBpcyBsb2NhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiB1aW50OEFycmF5LnNldCgpIGZvcm1hbGx5IHRha2VzIHtBcnJheTxudW1iZXI+fEFycmF5QnVmZmVyVmlld30sIHNvIHRvIHBhc3NcclxuICAgICAqIGl0IGEgdWludDhBcnJheSB3ZSBuZWVkIHRvIHN1cHByZXNzIHRoZSB0eXBlIGNoZWNrOlxyXG4gICAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ3Jvd0J5dGVCdWZmZXIoYmIpIHtcclxuICAgICAgICBjb25zdCBvbGRfYnVmX3NpemUgPSBiYi5jYXBhY2l0eSgpO1xyXG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkb24ndCBncm93IGJleW9uZCB3aGF0IGZpdHMgaW4gYW4gaW50LlxyXG4gICAgICAgIGlmIChvbGRfYnVmX3NpemUgJiAweEMwMDAwMDAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGNhbm5vdCBncm93IGJ1ZmZlciBiZXlvbmQgMiBnaWdhYnl0ZXMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld19idWZfc2l6ZSA9IG9sZF9idWZfc2l6ZSA8PCAxO1xyXG4gICAgICAgIGNvbnN0IG5iYiA9IEJ5dGVCdWZmZXIuYWxsb2NhdGUobmV3X2J1Zl9zaXplKTtcclxuICAgICAgICBuYmIuc2V0UG9zaXRpb24obmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcclxuICAgICAgICBuYmIuYnl0ZXMoKS5zZXQoYmIuYnl0ZXMoKSwgbmV3X2J1Zl9zaXplIC0gb2xkX2J1Zl9zaXplKTtcclxuICAgICAgICByZXR1cm4gbmJiO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uIG9mZnNldCwgcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2lsbCBiZSB3cml0dGVuLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGFkZE9mZnNldChvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLnByZXAoU0laRU9GX0lOVCwgMCk7IC8vIEVuc3VyZSBhbGlnbm1lbnQgaXMgYWxyZWFkeSBkb25lLlxyXG4gICAgICAgIHRoaXMud3JpdGVJbnQzMih0aGlzLm9mZnNldCgpIC0gb2Zmc2V0ICsgU0laRU9GX0lOVCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGVuY29kaW5nIGEgbmV3IG9iamVjdCBpbiB0aGUgYnVmZmVyLiAgVXNlcnMgd2lsbCBub3QgdXN1YWxseSBuZWVkIHRvXHJcbiAgICAgKiBjYWxsIHRoaXMgZGlyZWN0bHkuIFRoZSBGbGF0QnVmZmVycyBjb21waWxlciB3aWxsIGdlbmVyYXRlIGhlbHBlciBtZXRob2RzXHJcbiAgICAgKiB0aGF0IGNhbGwgdGhpcyBtZXRob2QgaW50ZXJuYWxseS5cclxuICAgICAqL1xyXG4gICAgc3RhcnRPYmplY3QobnVtZmllbGRzKSB7XHJcbiAgICAgICAgdGhpcy5ub3ROZXN0ZWQoKTtcclxuICAgICAgICBpZiAodGhpcy52dGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnZ0YWJsZSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZ0YWJsZV9pbl91c2UgPSBudW1maWVsZHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1maWVsZHM7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnZ0YWJsZVtpXSA9IDA7IC8vIFRoaXMgd2lsbCBwdXNoIGFkZGl0aW9uYWwgZWxlbWVudHMgYXMgbmVlZGVkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMub2JqZWN0X3N0YXJ0ID0gdGhpcy5vZmZzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIG9mZiB3cml0aW5nIHRoZSBvYmplY3QgdGhhdCBpcyB1bmRlciBjb25zdHJ1Y3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCB0byB0aGUgb2JqZWN0IGluc2lkZSBgZGF0YUJ1ZmZlcmBcclxuICAgICAqL1xyXG4gICAgZW5kT2JqZWN0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZ0YWJsZSA9PSBudWxsIHx8ICF0aGlzLmlzTmVzdGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGVuZE9iamVjdCBjYWxsZWQgd2l0aG91dCBzdGFydE9iamVjdCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZEludDMyKDApO1xyXG4gICAgICAgIGNvbnN0IHZ0YWJsZWxvYyA9IHRoaXMub2Zmc2V0KCk7XHJcbiAgICAgICAgLy8gVHJpbSB0cmFpbGluZyB6ZXJvZXMuXHJcbiAgICAgICAgbGV0IGkgPSB0aGlzLnZ0YWJsZV9pbl91c2UgLSAxO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxyXG4gICAgICAgIGZvciAoOyBpID49IDAgJiYgdGhpcy52dGFibGVbaV0gPT0gMDsgaS0tKSB7IH1cclxuICAgICAgICBjb25zdCB0cmltbWVkX3NpemUgPSBpICsgMTtcclxuICAgICAgICAvLyBXcml0ZSBvdXQgdGhlIGN1cnJlbnQgdnRhYmxlLlxyXG4gICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAvLyBPZmZzZXQgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZS5cclxuICAgICAgICAgICAgdGhpcy5hZGRJbnQxNih0aGlzLnZ0YWJsZVtpXSAhPSAwID8gdnRhYmxlbG9jIC0gdGhpcy52dGFibGVbaV0gOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRfZmllbGRzID0gMjsgLy8gVGhlIGZpZWxkcyBiZWxvdzpcclxuICAgICAgICB0aGlzLmFkZEludDE2KHZ0YWJsZWxvYyAtIHRoaXMub2JqZWN0X3N0YXJ0KTtcclxuICAgICAgICBjb25zdCBsZW4gPSAodHJpbW1lZF9zaXplICsgc3RhbmRhcmRfZmllbGRzKSAqIFNJWkVPRl9TSE9SVDtcclxuICAgICAgICB0aGlzLmFkZEludDE2KGxlbik7XHJcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhbiBleGlzdGluZyB2dGFibGUgdGhhdCBtYXRjaGVzIHRoZSBjdXJyZW50IG9uZS5cclxuICAgICAgICBsZXQgZXhpc3RpbmdfdnRhYmxlID0gMDtcclxuICAgICAgICBjb25zdCB2dDEgPSB0aGlzLnNwYWNlO1xyXG4gICAgICAgIG91dGVyX2xvb3A6IGZvciAoaSA9IDA7IGkgPCB0aGlzLnZ0YWJsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdnQyID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy52dGFibGVzW2ldO1xyXG4gICAgICAgICAgICBpZiAobGVuID09IHRoaXMuYmIucmVhZEludDE2KHZ0MikpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBTSVpFT0ZfU0hPUlQ7IGogPCBsZW47IGogKz0gU0laRU9GX1NIT1JUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYmIucmVhZEludDE2KHZ0MSArIGopICE9IHRoaXMuYmIucmVhZEludDE2KHZ0MiArIGopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyX2xvb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdfdnRhYmxlID0gdGhpcy52dGFibGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4aXN0aW5nX3Z0YWJsZSkge1xyXG4gICAgICAgICAgICAvLyBGb3VuZCBhIG1hdGNoOlxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnQgdnRhYmxlLlxyXG4gICAgICAgICAgICB0aGlzLnNwYWNlID0gdGhpcy5iYi5jYXBhY2l0eSgpIC0gdnRhYmxlbG9jO1xyXG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBleGlzdGluZyB2dGFibGUuXHJcbiAgICAgICAgICAgIHRoaXMuYmIud3JpdGVJbnQzMih0aGlzLnNwYWNlLCBleGlzdGluZ192dGFibGUgLSB2dGFibGVsb2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTm8gbWF0Y2g6XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbG9jYXRpb24gb2YgdGhlIGN1cnJlbnQgdnRhYmxlIHRvIHRoZSBsaXN0IG9mIHZ0YWJsZXMuXHJcbiAgICAgICAgICAgIHRoaXMudnRhYmxlcy5wdXNoKHRoaXMub2Zmc2V0KCkpO1xyXG4gICAgICAgICAgICAvLyBQb2ludCB0YWJsZSB0byBjdXJyZW50IHZ0YWJsZS5cclxuICAgICAgICAgICAgdGhpcy5iYi53cml0ZUludDMyKHRoaXMuYmIuY2FwYWNpdHkoKSAtIHZ0YWJsZWxvYywgdGhpcy5vZmZzZXQoKSAtIHZ0YWJsZWxvYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNOZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdnRhYmxlbG9jO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5hbGl6ZSBhIGJ1ZmZlciwgcG9pdGluZyB0byB0aGUgZ2l2ZW4gYHJvb3RfdGFibGVgLlxyXG4gICAgICovXHJcbiAgICBmaW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgb3B0X3NpemVfcHJlZml4KSB7XHJcbiAgICAgICAgY29uc3Qgc2l6ZV9wcmVmaXggPSBvcHRfc2l6ZV9wcmVmaXggPyBTSVpFX1BSRUZJWF9MRU5HVEggOiAwO1xyXG4gICAgICAgIGlmIChvcHRfZmlsZV9pZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVfaWRlbnRpZmllciA9IG9wdF9maWxlX2lkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIHRoaXMucHJlcCh0aGlzLm1pbmFsaWduLCBTSVpFT0ZfSU5UICtcclxuICAgICAgICAgICAgICAgIEZJTEVfSURFTlRJRklFUl9MRU5HVEggKyBzaXplX3ByZWZpeCk7XHJcbiAgICAgICAgICAgIGlmIChmaWxlX2lkZW50aWZpZXIubGVuZ3RoICE9IEZJTEVfSURFTlRJRklFUl9MRU5HVEgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmxhdEJ1ZmZlcnM6IGZpbGUgaWRlbnRpZmllciBtdXN0IGJlIGxlbmd0aCAnICtcclxuICAgICAgICAgICAgICAgICAgICBGSUxFX0lERU5USUZJRVJfTEVOR1RIKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gRklMRV9JREVOVElGSUVSX0xFTkdUSCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW50OChmaWxlX2lkZW50aWZpZXIuY2hhckNvZGVBdChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcmVwKHRoaXMubWluYWxpZ24sIFNJWkVPRl9JTlQgKyBzaXplX3ByZWZpeCk7XHJcbiAgICAgICAgdGhpcy5hZGRPZmZzZXQocm9vdF90YWJsZSk7XHJcbiAgICAgICAgaWYgKHNpemVfcHJlZml4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkSW50MzIodGhpcy5iYi5jYXBhY2l0eSgpIC0gdGhpcy5zcGFjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmIuc2V0UG9zaXRpb24odGhpcy5zcGFjZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmFsaXplIGEgc2l6ZSBwcmVmaXhlZCBidWZmZXIsIHBvaW50aW5nIHRvIHRoZSBnaXZlbiBgcm9vdF90YWJsZWAuXHJcbiAgICAgKi9cclxuICAgIGZpbmlzaFNpemVQcmVmaXhlZChyb290X3RhYmxlLCBvcHRfZmlsZV9pZGVudGlmaWVyKSB7XHJcbiAgICAgICAgdGhpcy5maW5pc2gocm9vdF90YWJsZSwgb3B0X2ZpbGVfaWRlbnRpZmllciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY2hlY2tzIGEgcmVxdWlyZWQgZmllbGQgaGFzIGJlZW4gc2V0IGluIGEgZ2l2ZW4gdGFibGUgdGhhdCBoYXNcclxuICAgICAqIGp1c3QgYmVlbiBjb25zdHJ1Y3RlZC5cclxuICAgICAqL1xyXG4gICAgcmVxdWlyZWRGaWVsZCh0YWJsZSwgZmllbGQpIHtcclxuICAgICAgICBjb25zdCB0YWJsZV9zdGFydCA9IHRoaXMuYmIuY2FwYWNpdHkoKSAtIHRhYmxlO1xyXG4gICAgICAgIGNvbnN0IHZ0YWJsZV9zdGFydCA9IHRhYmxlX3N0YXJ0IC0gdGhpcy5iYi5yZWFkSW50MzIodGFibGVfc3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IG9rID0gdGhpcy5iYi5yZWFkSW50MTYodnRhYmxlX3N0YXJ0ICsgZmllbGQpICE9IDA7XHJcbiAgICAgICAgLy8gSWYgdGhpcyBmYWlscywgdGhlIGNhbGxlciB3aWxsIHNob3cgd2hhdCBmaWVsZCBuZWVkcyB0byBiZSBzZXQuXHJcbiAgICAgICAgaWYgKCFvaykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBmaWVsZCAnICsgZmllbGQgKyAnIG11c3QgYmUgc2V0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhIG5ldyBhcnJheS92ZWN0b3Igb2Ygb2JqZWN0cy4gIFVzZXJzIHVzdWFsbHkgd2lsbCBub3QgY2FsbFxyXG4gICAgICogdGhpcyBkaXJlY3RseS4gVGhlIEZsYXRCdWZmZXJzIGNvbXBpbGVyIHdpbGwgY3JlYXRlIGEgc3RhcnQvZW5kXHJcbiAgICAgKiBtZXRob2QgZm9yIHZlY3RvciB0eXBlcyBpbiBnZW5lcmF0ZWQgY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZWxlbV9zaXplIFRoZSBzaXplIG9mIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXlcclxuICAgICAqIEBwYXJhbSBudW1fZWxlbXMgVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXlcclxuICAgICAqIEBwYXJhbSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudCBvZiB0aGUgYXJyYXlcclxuICAgICAqL1xyXG4gICAgc3RhcnRWZWN0b3IoZWxlbV9zaXplLCBudW1fZWxlbXMsIGFsaWdubWVudCkge1xyXG4gICAgICAgIHRoaXMubm90TmVzdGVkKCk7XHJcbiAgICAgICAgdGhpcy52ZWN0b3JfbnVtX2VsZW1zID0gbnVtX2VsZW1zO1xyXG4gICAgICAgIHRoaXMucHJlcChTSVpFT0ZfSU5ULCBlbGVtX3NpemUgKiBudW1fZWxlbXMpO1xyXG4gICAgICAgIHRoaXMucHJlcChhbGlnbm1lbnQsIGVsZW1fc2l6ZSAqIG51bV9lbGVtcyk7IC8vIEp1c3QgaW4gY2FzZSBhbGlnbm1lbnQgPiBpbnQuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmlzaCBvZmYgdGhlIGNyZWF0aW9uIG9mIGFuIGFycmF5IGFuZCBhbGwgaXRzIGVsZW1lbnRzLiBUaGUgYXJyYXkgbXVzdCBiZVxyXG4gICAgICogY3JlYXRlZCB3aXRoIGBzdGFydFZlY3RvcmAuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG9mZnNldCBhdCB3aGljaCB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheVxyXG4gICAgICogc3RhcnRzLlxyXG4gICAgICovXHJcbiAgICBlbmRWZWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZUludDMyKHRoaXMudmVjdG9yX251bV9lbGVtcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZSB0aGUgc3RyaW5nIGBzYCBpbiB0aGUgYnVmZmVyIHVzaW5nIFVURi04LiBJZiB0aGUgc3RyaW5nIHBhc3NlZCBoYXNcclxuICAgICAqIGFscmVhZHkgYmVlbiBzZWVuLCB3ZSByZXR1cm4gdGhlIG9mZnNldCBvZiB0aGUgYWxyZWFkeSB3cml0dGVuIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzIFRoZSBzdHJpbmcgdG8gZW5jb2RlXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB3aGVyZSB0aGUgZW5jb2RlZCBzdHJpbmcgc3RhcnRzXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVNoYXJlZFN0cmluZyhzKSB7XHJcbiAgICAgICAgaWYgKCFzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuc3RyaW5nX21hcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5zdHJpbmdfbWFwcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nX21hcHMuaGFzKHMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ19tYXBzLmdldChzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jcmVhdGVTdHJpbmcocyk7XHJcbiAgICAgICAgdGhpcy5zdHJpbmdfbWFwcy5zZXQocywgb2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGUgdGhlIHN0cmluZyBgc2AgaW4gdGhlIGJ1ZmZlciB1c2luZyBVVEYtOC4gSWYgYSBVaW50OEFycmF5IGlzIHBhc3NlZFxyXG4gICAgICogaW5zdGVhZCBvZiBhIHN0cmluZywgaXQgaXMgYXNzdW1lZCB0byBjb250YWluIHZhbGlkIFVURi04IGVuY29kZWQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcyBUaGUgc3RyaW5nIHRvIGVuY29kZVxyXG4gICAgICogQHJldHVybiBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGVuY29kZWQgc3RyaW5nIHN0YXJ0c1xyXG4gICAgICovXHJcbiAgICBjcmVhdGVTdHJpbmcocykge1xyXG4gICAgICAgIGlmICghcykge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHV0Zjg7XHJcbiAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XHJcbiAgICAgICAgICAgIHV0ZjggPSBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXRmOCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjb2RlUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgVVRGLTE2XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gcy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYSA8IDB4RDgwMCB8fCBhID49IDB4REMwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVQb2ludCA9IGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gcy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZVBvaW50ID0gKGEgPDwgMTApICsgYiArICgweDEwMDAwIC0gKDB4RDgwMCA8PCAxMCkgLSAweERDMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRW5jb2RlIFVURi04XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaChjb2RlUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmOC5wdXNoKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4LnB1c2goKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwLCAoKGNvZGVQb2ludCA+PiAxMikgJiAweDNGKSB8IDB4ODApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaCgoKGNvZGVQb2ludCA+PiA2KSAmIDB4M0YpIHwgMHg4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHV0ZjgucHVzaCgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZEludDgoMCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFZlY3RvcigxLCB1dGY4Lmxlbmd0aCwgMSk7XHJcbiAgICAgICAgdGhpcy5iYi5zZXRQb3NpdGlvbih0aGlzLnNwYWNlIC09IHV0ZjgubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gdGhpcy5zcGFjZSwgYnl0ZXMgPSB0aGlzLmJiLmJ5dGVzKCk7IGkgPCB1dGY4Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJ5dGVzW29mZnNldCsrXSA9IHV0ZjhbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBnZW5lcmF0ZWQgY29kZSBkZXBlbmRpbmcgb24gdGhpcyBmaWxlIGRpcmVjdGx5LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVMb25nKGxvdywgaGlnaCkge1xyXG4gICAgICAgIHJldHVybiBMb25nLmNyZWF0ZShsb3csIGhpZ2gpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0byBwYWNrIGFuIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIG9mZnNldCBvZiBvYmpcclxuICAgICAqL1xyXG4gICAgY3JlYXRlT2JqZWN0T2Zmc2V0KG9iaikge1xyXG4gICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmcob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoucGFjayh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIHBhY2sgYSBsaXN0IG9mIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGxpc3Qgb2Ygb2Zmc2V0cyBvZiBlYWNoIG5vbiBudWxsIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVPYmplY3RPZmZzZXRMaXN0KGxpc3QpIHtcclxuICAgICAgICBjb25zdCByZXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0LnB1c2godGhpcy5jcmVhdGVPYmplY3RPZmZzZXQodmFsKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZsYXRCdWZmZXJzOiBBcmd1bWVudCBmb3IgY3JlYXRlT2JqZWN0T2Zmc2V0TGlzdCBjYW5ub3QgY29udGFpbiBudWxsLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVTdHJ1Y3RPZmZzZXRMaXN0KGxpc3QsIHN0YXJ0RnVuYykge1xyXG4gICAgICAgIHN0YXJ0RnVuYyh0aGlzLCBsaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVPYmplY3RPZmZzZXRMaXN0KGxpc3QpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFZlY3RvcigpO1xyXG4gICAgfVxyXG59XHJcbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgeyBEdWNrREJCaW5kaW5ncyB9IGZyb20gJy4vYmluZGluZ3NfaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMsIEFycm93SW5zZXJ0T3B0aW9ucyB9IGZyb20gJy4vaW5zZXJ0X29wdGlvbnMnO1xyXG5cclxuLyoqIEEgdGhpbiBoZWxwZXIgdG8gYmluZCB0aGUgY29ubmVjdGlvbiBpZCBhbmQgdGFsayByZWNvcmQgYmF0Y2hlcyAqL1xyXG5leHBvcnQgY2xhc3MgRHVja0RCQ29ubmVjdGlvbiB7XHJcbiAgICAvKiogVGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgX2JpbmRpbmdzOiBEdWNrREJCaW5kaW5ncztcclxuICAgIC8qKiBUaGUgY29ubmVjdGlvbiBoYW5kbGUgKi9cclxuICAgIHByb3RlY3RlZCBfY29ubjogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25uOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl9iaW5kaW5ncyA9IGJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuX2Nvbm4gPSBjb25uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDbG9zZSBhIGNvbm5lY3Rpb24gKi9cclxuICAgIHB1YmxpYyBjbG9zZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9iaW5kaW5ncy5kaXNjb25uZWN0KHRoaXMuX2Nvbm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBCcmF2ZSBzb3VscyBtYXkgdXNlIHRoaXMgZnVuY3Rpb24gdG8gY29uc3VtZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uIGlkICovXHJcbiAgICBwdWJsaWMgdXNlVW5zYWZlPFI+KGNhbGxiYWNrOiAoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25uOiBudW1iZXIpID0+IFIpIHtcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSdW4gYSBxdWVyeSAqL1xyXG4gICAgcHVibGljIHF1ZXJ5PFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFycm93LkRhdGFUeXBlIH0gPSBhbnk+KHRleHQ6IHN0cmluZyk6IGFycm93LlRhYmxlPFQ+IHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9iaW5kaW5ncy5ydW5RdWVyeSh0aGlzLl9jb25uLCB0ZXh0KTtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3luYygpKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNGaWxlKCkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgYXJyb3cuVGFibGUocmVhZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2VuZCBhIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc2VuZDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PihcclxuICAgICAgICB0ZXh0OiBzdHJpbmcsXHJcbiAgICApOiBQcm9taXNlPGFycm93LlJlY29yZEJhdGNoU3RyZWFtUmVhZGVyPFQ+PiB7XHJcbiAgICAgICAgbGV0IGhlYWRlciA9IHRoaXMuX2JpbmRpbmdzLnN0YXJ0UGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4sIHRleHQpO1xyXG4gICAgICAgIHdoaWxlIChoZWFkZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBoZWFkZXIgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5fYmluZGluZ3MucG9sbFBlbmRpbmdRdWVyeSh0aGlzLl9jb25uKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpdGVyID0gbmV3IFJlc3VsdFN0cmVhbUl0ZXJhdG9yKHRoaXMuX2JpbmRpbmdzLCB0aGlzLl9jb25uLCBoZWFkZXIpO1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGFycm93LlJlY29yZEJhdGNoUmVhZGVyLmZyb208VD4oaXRlcik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzU3luYygpKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTdHJlYW0oKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2FuY2VsIGEgcXVlcnkgdGhhdCB3YXMgc2VudCBlYXJsaWVyICovXHJcbiAgICBwdWJsaWMgY2FuY2VsU2VudCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmluZGluZ3MuY2FuY2VsUGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGFibGUgbmFtZXMgKi9cclxuICAgIHB1YmxpYyBnZXRUYWJsZU5hbWVzKHF1ZXJ5OiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmdldFRhYmxlTmFtZXModGhpcy5fY29ubiwgcXVlcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBwcmVwYXJlPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFycm93LkRhdGFUeXBlIH0gPSBhbnk+KHRleHQ6IHN0cmluZyk6IFByZXBhcmVkU3RhdGVtZW50IHtcclxuICAgICAgICBjb25zdCBzdG10ID0gdGhpcy5fYmluZGluZ3MuY3JlYXRlUHJlcGFyZWQodGhpcy5fY29ubiwgdGV4dCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwYXJlZFN0YXRlbWVudDxUPih0aGlzLl9iaW5kaW5ncywgdGhpcy5fY29ubiwgc3RtdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0ZSBhIHNjYWxhciBmdW5jdGlvbiAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVNjYWxhckZ1bmN0aW9uKG5hbWU6IHN0cmluZywgcmV0dXJuczogYXJyb3cuRGF0YVR5cGUsIGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKHRoaXMuX2Nvbm4sIG5hbWUsIHJldHVybnMsIGZ1bmMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnNlcnQgYW4gYXJyb3cgdGFibGUgKi9cclxuICAgIHB1YmxpYyBpbnNlcnRBcnJvd1RhYmxlKHRhYmxlOiBhcnJvdy5UYWJsZSwgb3B0aW9uczogQXJyb3dJbnNlcnRPcHRpb25zKTogdm9pZCB7XHJcblx0Y29uc3QgYnVmZmVyID0gYXJyb3cudGFibGVUb0lQQyh0YWJsZSwgJ3N0cmVhbScpO1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKGJ1ZmZlciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGFuIGFycm93IHRhYmxlIGZyb20gYW4gaXBjIHN0cmVhbSAqL1xyXG4gICAgcHVibGljIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShidWZmZXI6IFVpbnQ4QXJyYXksIG9wdGlvbnM6IEFycm93SW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmluc2VydEFycm93RnJvbUlQQ1N0cmVhbSh0aGlzLl9jb25uLCBidWZmZXIsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbmVzcnQgY3N2IGZpbGUgZnJvbSBwYXRoICovXHJcbiAgICBwdWJsaWMgaW5zZXJ0Q1NWRnJvbVBhdGgocGF0aDogc3RyaW5nLCBvcHRpb25zOiBDU1ZJbnNlcnRPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MuaW5zZXJ0Q1NWRnJvbVBhdGgodGhpcy5fY29ubiwgcGF0aCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGpzb24gZmlsZSBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBpbnNlcnRKU09ORnJvbVBhdGgocGF0aDogc3RyaW5nLCBvcHRpb25zOiBKU09OSW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmluc2VydEpTT05Gcm9tUGF0aCh0aGlzLl9jb25uLCBwYXRoLCBvcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqIEEgcmVzdWx0IHN0cmVhbSBpdGVyYXRvciAqL1xyXG5leHBvcnQgY2xhc3MgUmVzdWx0U3RyZWFtSXRlcmF0b3IgaW1wbGVtZW50cyBJdGVyYWJsZTxVaW50OEFycmF5PiB7XHJcbiAgICAvKiogRmlyc3QgY2h1bms/ICovXHJcbiAgICBfZmlyc3Q6IGJvb2xlYW47XHJcbiAgICAvKiogUmVhY2hlZCBlbmQgb2Ygc3RyZWFtPyAqL1xyXG4gICAgX2RlcGxldGVkOiBib29sZWFuO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIHByb3RlY3RlZCBjb25uOiBudW1iZXIsIHByb3RlY3RlZCBoZWFkZXI6IFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICB0aGlzLl9maXJzdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZGVwbGV0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBuZXh0KCk6IEl0ZXJhdG9yUmVzdWx0PFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLmhlYWRlciB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVwbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVmZmVySTggPSB0aGlzLmJpbmRpbmdzLmZldGNoUXVlcnlSZXN1bHRzKHRoaXMuY29ubik7XHJcbiAgICAgICAgdGhpcy5fZGVwbGV0ZWQgPSBidWZmZXJJOC5sZW5ndGggPT0gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkb25lOiB0aGlzLl9kZXBsZXRlZCxcclxuICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlckk4LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBBIHRoaW4gaGVscGVyIHRvIGJpbmQgdGhlIHByZXBhcmVkIHN0YXRlbWVudCBpZCovXHJcbmV4cG9ydCBjbGFzcyBQcmVwYXJlZFN0YXRlbWVudDxUIGV4dGVuZHMgeyBba2V5OiBzdHJpbmddOiBhcnJvdy5EYXRhVHlwZSB9ID0gYW55PiB7XHJcbiAgICAvKiogVGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzO1xyXG4gICAgLyoqIFRoZSBjb25uZWN0aW9uIGlkICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgY29ubmVjdGlvbklkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHN0YXRlbWVudCBpZCAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0YXRlbWVudElkOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIENvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihiaW5kaW5nczogRHVja0RCQmluZGluZ3MsIGNvbm5lY3Rpb25JZDogbnVtYmVyLCBzdGF0ZW1lbnRJZDogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IGJpbmRpbmdzO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xyXG4gICAgICAgIHRoaXMuc3RhdGVtZW50SWQgPSBzdGF0ZW1lbnRJZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLmJpbmRpbmdzLmNsb3NlUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSdW4gYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBxdWVyeSguLi5wYXJhbXM6IGFueVtdKTogYXJyb3cuVGFibGU8VD4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYmluZGluZ3MucnVuUHJlcGFyZWQodGhpcy5jb25uZWN0aW9uSWQsIHRoaXMuc3RhdGVtZW50SWQsIHBhcmFtcyk7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihidWZmZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzRmlsZSgpKTtcclxuICAgICAgICByZXR1cm4gbmV3IGFycm93LlRhYmxlKHJlYWRlciBhcyBhcnJvdy5SZWNvcmRCYXRjaEZpbGVSZWFkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTZW5kIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXHJcbiAgICBwdWJsaWMgc2VuZCguLi5wYXJhbXM6IGFueVtdKTogYXJyb3cuUmVjb3JkQmF0Y2hTdHJlYW1SZWFkZXI8VD4ge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IHRoaXMuYmluZGluZ3Muc2VuZFByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUmVzdWx0U3RyZWFtSXRlcmF0b3IodGhpcy5iaW5kaW5ncywgdGhpcy5jb25uZWN0aW9uSWQsIGhlYWRlcik7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihpdGVyKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTeW5jKCkpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N0cmVhbSgpKTtcclxuICAgICAgICByZXR1cm4gcmVhZGVyIGFzIGFycm93LlJlY29yZEJhdGNoU3RyZWFtUmVhZGVyO1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgeyBEdWNrREJSdW50aW1lIH0gZnJvbSAnLi9ydW50aW1lJztcclxuaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuXHJcbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG5jb25zdCBURVhUX0RFQ09ERVIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XHJcblxyXG5mdW5jdGlvbiBzdG9yZUVycm9yKG1vZDogRHVja0RCTW9kdWxlLCByZXNwb25zZTogbnVtYmVyLCBtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IG1zZ0J1ZmZlciA9IFRFWFRfRU5DT0RFUi5lbmNvZGUobWVzc2FnZSk7XHJcbiAgICBjb25zdCBoZWFwQWRkciA9IG1vZC5fbWFsbG9jKG1zZ0J1ZmZlci5ieXRlTGVuZ3RoKTtcclxuICAgIGNvbnN0IGhlYXBBcnJheSA9IG1vZC5IRUFQVTguc3ViYXJyYXkoaGVhcEFkZHIsIGhlYXBBZGRyICsgbXNnQnVmZmVyLmJ5dGVMZW5ndGgpO1xyXG4gICAgaGVhcEFycmF5LnNldChtc2dCdWZmZXIpO1xyXG4gICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF0gPSAxO1xyXG4gICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMV0gPSBoZWFwQWRkcjtcclxuICAgIG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDJdID0gaGVhcEFycmF5LmJ5dGVMZW5ndGg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFR5cGVTaXplKHB0eXBlOiBzdHJpbmcpIHtcclxuICAgIHN3aXRjaCAocHR5cGUpIHtcclxuICAgICAgICBjYXNlICdVSU5UOCc6XHJcbiAgICAgICAgY2FzZSAnSU5UOCc6XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgJ0lOVDMyJzpcclxuICAgICAgICBjYXNlICdGTE9BVCc6XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgICAgIGNhc2UgJ0lOVDY0JzpcclxuICAgICAgICBjYXNlICdVSU5UNjQnOlxyXG4gICAgICAgIGNhc2UgJ0RPVUJMRSc6XHJcbiAgICAgICAgY2FzZSAnVkFSQ0hBUic6XHJcbiAgICAgICAgICAgIHJldHVybiA4O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwdHJUb0FycmF5KG1vZDogRHVja0RCTW9kdWxlLCBwdHI6IG51bWJlciwgcHR5cGU6IHN0cmluZywgbjogbnVtYmVyKSB7XHJcbiAgICBjb25zdCBoZWFwID0gbW9kLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIG4gKiBnZXRUeXBlU2l6ZShwdHlwZSkpO1xyXG4gICAgc3dpdGNoIChwdHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ1VJTlQ4JzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhlYXAuYnVmZmVyLCBoZWFwLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgICAgIGNhc2UgJ0lOVDgnOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcclxuICAgICAgICBjYXNlICdJTlQzMic6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcclxuICAgICAgICBjYXNlICdGTE9BVCc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGhlYXAuYnVmZmVyLCBoZWFwLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgICAgIGNhc2UgJ0RPVUJMRSc6XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGhlYXAuYnVmZmVyLCBoZWFwLmJ5dGVPZmZzZXQsIG4pO1xyXG4gICAgICAgIGNhc2UgJ1ZBUkNIQVInOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShoZWFwLmJ1ZmZlciwgaGVhcC5ieXRlT2Zmc2V0LCBuKTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw+KDApOyAvLyBjb3VnaFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBwdHJUb1VpbnQ4QXJyYXkobW9kOiBEdWNrREJNb2R1bGUsIHB0cjogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGhlYXAgPSBtb2QuSEVBUFU4LnN1YmFycmF5KHB0ciwgcHRyICsgbik7XHJcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XHJcbn1cclxuZnVuY3Rpb24gcHRyVG9GbG9hdDY0QXJyYXkobW9kOiBEdWNrREJNb2R1bGUsIHB0cjogbnVtYmVyLCBuOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IGhlYXAgPSBtb2QuSEVBUFU4LnN1YmFycmF5KHB0ciwgcHRyICsgbiAqIDgpO1xyXG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoaGVhcC5idWZmZXIsIGhlYXAuYnl0ZU9mZnNldCwgbik7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbiB7XHJcbiAgICBuYW1lPzogc3RyaW5nO1xyXG4gICAgc3FsVHlwZTogc3RyaW5nO1xyXG4gICAgcGh5c2ljYWxUeXBlOiBzdHJpbmc7XHJcbiAgICB2YWxpZGl0eUJ1ZmZlcj86IG51bWJlcjtcclxuICAgIGRhdGFCdWZmZXI/OiBudW1iZXI7XHJcbiAgICBsZW5ndGhCdWZmZXI/OiBudW1iZXI7XHJcbiAgICBjaGlsZHJlbj86IEFyZ3VtZW50VHlwZURlc2NyaXB0aW9uW107XHJcbn1cclxuXHJcbmludGVyZmFjZSBSZXR1cm5UeXBlRGVzY3JpcHRpb24ge1xyXG4gICAgc3FsVHlwZTogc3RyaW5nO1xyXG4gICAgcGh5c2ljYWxUeXBlOiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBTY2hlbWFEZXNjcmlwdGlvbiB7XHJcbiAgICByb3dzOiBudW1iZXI7XHJcbiAgICBhcmdzOiBBcmd1bWVudFR5cGVEZXNjcmlwdGlvbltdO1xyXG4gICAgcmV0OiBSZXR1cm5UeXBlRGVzY3JpcHRpb247XHJcbn1cclxuXHJcbnR5cGUgQXJndW1lbnRSZXNvbHZlciA9IChyb3c6IG51bWJlcikgPT4gYW55IHwgbnVsbDtcclxuXHJcbi8vIHRoaXMgaXMgY2FsbGVkIGZyb20gd2ViZGIuY2MvQ2FsbFNjYWxhclVERkZ1bmN0aW9uLCBjaGFuZ2VzIGhlcmUgbmVlZCB0byBiZSBtYXRjaGVkIHRoZXJlXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxsU2NhbGFyVURGKFxyXG4gICAgcnVudGltZTogRHVja0RCUnVudGltZSxcclxuICAgIG1vZDogRHVja0RCTW9kdWxlLFxyXG4gICAgcmVzcG9uc2U6IG51bWJlcixcclxuICAgIGZ1bmNJZDogbnVtYmVyLFxyXG4gICAgZGVzY1B0cjogbnVtYmVyLFxyXG4gICAgZGVzY1NpemU6IG51bWJlcixcclxuICAgIHB0cnNQdHI6IG51bWJlcixcclxuICAgIHB0cnNTaXplOiBudW1iZXIsXHJcbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCB1ZGYgPSBydW50aW1lLl91ZGZGdW5jdGlvbnMuZ2V0KGZ1bmNJZCk7XHJcbiAgICAgICAgaWYgKCF1ZGYpIHtcclxuICAgICAgICAgICAgc3RvcmVFcnJvcihtb2QsIHJlc3BvbnNlLCAnVW5rbm93biBVREYgd2l0aCBpZDogJyArIGZ1bmNJZCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmF3RGVzYyA9IFRFWFRfREVDT0RFUi5kZWNvZGUobW9kLkhFQVBVOC5zdWJhcnJheShkZXNjUHRyLCBkZXNjUHRyICsgZGVzY1NpemUpKTtcclxuICAgICAgICBjb25zdCBkZXNjID0gSlNPTi5wYXJzZShyYXdEZXNjKSBhcyBTY2hlbWFEZXNjcmlwdGlvbjtcclxuICAgICAgICBjb25zdCBwdHJzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCBwdHJzUHRyLCBwdHJzU2l6ZSAvIDgpO1xyXG5cclxuICAgICAgICBjb25zdCBidWlsZFJlc29sdmVyID0gKGFyZzogQXJndW1lbnRUeXBlRGVzY3JpcHRpb24pOiBBcmd1bWVudFJlc29sdmVyID0+IHtcclxuICAgICAgICAgICAgbGV0IHZhbGlkaXR5OiBVaW50OEFycmF5IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChhcmcudmFsaWRpdHlCdWZmZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRpdHkgPSBwdHJUb1VpbnQ4QXJyYXkobW9kLCBwdHJzW2FyZy52YWxpZGl0eUJ1ZmZlcl0gYXMgbnVtYmVyLCBkZXNjLnJvd3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYXJnLnBoeXNpY2FsVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnVkFSQ0hBUic6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmRhdGFCdWZmZXIgPT09IG51bGwgfHwgYXJnLmRhdGFCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBkYXRhIHZpZXcsIGV4cGVjdGVkIGRhdGEgYnVmZmVyIGZvciBWQVJDSEFSIGFyZ3VtZW50Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoQnVmZmVyID09PSBudWxsIHx8IGFyZy5sZW5ndGhCdWZmZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hbGZvcm1lZCBkYXRhIHZpZXcsIGV4cGVjdGVkIGRhdGEgbGVuZ3RoIGJ1ZmZlciBmb3IgVkFSQ0hBUiBhcmd1bWVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBwdHJUb0FycmF5KG1vZCwgcHRyc1thcmcuZGF0YUJ1ZmZlcl0gYXMgbnVtYmVyLCBhcmcucGh5c2ljYWxUeXBlLCBkZXNjLnJvd3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ3M6IChzdHJpbmcgfCBudWxsKVtdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nTGVuZ3RocyA9IHB0clRvRmxvYXQ2NEFycmF5KG1vZCwgcHRyc1thcmcubGVuZ3RoQnVmZmVyXSBhcyBudW1iZXIsIGRlc2Mucm93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjLnJvd3M7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRpdHkgIT0gbnVsbCAmJiAhdmFsaWRpdHlbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YmFycmF5ID0gbW9kLkhFQVBVOC5zdWJhcnJheShcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhd1tqXSBhcyBudW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmF3W2pdIGFzIG51bWJlcikgKyAoc3RyaW5nTGVuZ3Roc1tqXSBhcyBudW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBURVhUX0RFQ09ERVIuZGVjb2RlKHN1YmFycmF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHN0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IHN0cmluZ3Nbcm93XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ1NUUlVDVCc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXA6IGFueSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuOiBBcmd1bWVudFJlc29sdmVyW10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IChhcmcuY2hpbGRyZW4/Lmxlbmd0aCB8fCAwKTsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhcmcuY2hpbGRyZW4hW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGJ1aWxkUmVzb2x2ZXIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goKHJvdzogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbYXR0ci5uYW1lIV0gPSBjaGlsZChyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZGl0eSFbcm93XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZXNvbHZlciBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKHJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzb2x2ZXIgb2YgY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlcihyb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5kYXRhQnVmZmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hbGZvcm1lZCBkYXRhIHZpZXcsIGV4cGVjdGVkIGRhdGEgYnVmZmVyIGZvciBhcmd1bWVudCBvZiB0eXBlOiAnICsgYXJnLnBoeXNpY2FsVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHB0clRvQXJyYXkobW9kLCBwdHJzW2FyZy5kYXRhQnVmZmVyXSBhcyBudW1iZXIsIGFyZy5waHlzaWNhbFR5cGUsIGRlc2Mucm93cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyb3c6IG51bWJlcikgPT4gKCF2YWxpZGl0eSFbcm93XSA/IG51bGwgOiBkYXRhW3Jvd10pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocm93OiBudW1iZXIpID0+IGRhdGFbcm93XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBUcmFuc2xhdGUgYXJndW1lbnQgZGF0YVxyXG4gICAgICAgIGNvbnN0IGFyZ1Jlc29sdmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzYy5hcmdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGFyZ1Jlc29sdmVycy5wdXNoKGJ1aWxkUmVzb2x2ZXIoZGVzYy5hcmdzW2ldKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQcmVwYXJlIHJlc3VsdCBidWZmZXJzXHJcbiAgICAgICAgLy8gVE9ETzogd2UgcHJvYmFibHkgZG8gbm90IHdhbnQgdG8gcmVjcmVhdGUgdGhvc2UgZXZlcnkgdGltZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdERhdGFMZW4gPSBkZXNjLnJvd3MgKiBnZXRUeXBlU2l6ZShkZXNjLnJldC5waHlzaWNhbFR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdERhdGFQdHIgPSBtb2QuX21hbGxvYyhyZXN1bHREYXRhTGVuKTtcclxuICAgICAgICBjb25zdCByZXN1bHREYXRhID0gcHRyVG9BcnJheShtb2QsIHJlc3VsdERhdGFQdHIsIGRlc2MucmV0LnBoeXNpY2FsVHlwZSwgZGVzYy5yb3dzKTtcclxuICAgICAgICBjb25zdCByZXN1bHRWYWxpZGl0eVB0ciA9IG1vZC5fbWFsbG9jKGRlc2Mucm93cyk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0VmFsaWRpdHkgPSBwdHJUb1VpbnQ4QXJyYXkobW9kLCByZXN1bHRWYWxpZGl0eVB0ciwgZGVzYy5yb3dzKTtcclxuICAgICAgICBpZiAocmVzdWx0RGF0YS5sZW5ndGggPT0gMCB8fCByZXN1bHRWYWxpZGl0eS5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICBzdG9yZUVycm9yKG1vZCwgcmVzcG9uc2UsIFwiQ2FuJ3QgY3JlYXRlIHBoeXNpY2FsIGFycmF5cyBmb3IgcmVzdWx0XCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByYXdSZXN1bHREYXRhID0gcmVzdWx0RGF0YTtcclxuICAgICAgICBpZiAoZGVzYy5yZXQucGh5c2ljYWxUeXBlID09ICdWQVJDSEFSJykge1xyXG4gICAgICAgICAgICByYXdSZXN1bHREYXRhID0gbmV3IEFycmF5PHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw+KGRlc2Mucm93cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxsIHRoZSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlc2MuYXJncy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzYy5yb3dzOyArK2kpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkZXNjLmFyZ3MubGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGFyZ3Nbal0gPSBhcmdSZXNvbHZlcnNbal0oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzID0gdWRmLmZ1bmMoLi4uYXJncyk7XHJcbiAgICAgICAgICAgIHJhd1Jlc3VsdERhdGFbaV0gPSByZXM7XHJcbiAgICAgICAgICAgIHJlc3VsdFZhbGlkaXR5W2ldID0gcmVzID09PSB1bmRlZmluZWQgfHwgcmVzID09PSBudWxsID8gMCA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFbmNvZGUgcmV0dXJuIHZhbHVlc1xyXG4gICAgICAgIGxldCByZXN1bHRMZW5ndGhzUHRyID0gMDtcclxuICAgICAgICBzd2l0Y2ggKGRlc2MucmV0LnBoeXNpY2FsVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdWQVJDSEFSJzoge1xyXG4gICAgICAgICAgICAgICAgLy8gQWxsb2NhdGUgcmVzdWx0IGJ1ZmZlcnNcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdERhdGFVVEY4ID0gbmV3IEFycmF5PFVpbnQ4QXJyYXk+KDApOyAvLyBjb3VnaFxyXG4gICAgICAgICAgICAgICAgcmVzdWx0TGVuZ3Roc1B0ciA9IG1vZC5fbWFsbG9jKGRlc2Mucm93cyAqIGdldFR5cGVTaXplKCdET1VCTEUnKSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRMZW5ndGhzID0gcHRyVG9GbG9hdDY0QXJyYXkobW9kLCByZXN1bHRMZW5ndGhzUHRyLCBkZXNjLnJvd3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdHdvIGxvb3BzIHRvIGZpZ3VyZSBvdXQgdGhlIHRvdGFsIGxlbmd0aCBidXQgbWF5YmUgd2UgY2FuIGF2b2lkIHRoZSBkb3VibGUgYWxsb2NhdGlvblxyXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGRlc2Mucm93czsgKytyb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1dGY4ID0gVEVYVF9FTkNPREVSLmVuY29kZSgocmF3UmVzdWx0RGF0YSBhcyAoc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZClbXSlbcm93XSB8fCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0RGF0YVVURjgucHVzaCh1dGY4KTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRMZW5ndGhzW3Jvd10gPSB1dGY4Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSB1dGY4Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSBtYWxsb2MgYSBidWZmZXIgZm9yIHRoZSBzdHJpbmdzIHRvIGxpdmUgaW4gZm9yIG5vd1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyaW5nUHRyID0gbW9kLl9tYWxsb2ModG90YWxMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0U3RyaW5nQnVmID0gbW9kLkhFQVBVOC5zdWJhcnJheShyZXN1bHRTdHJpbmdQdHIsIHJlc3VsdFN0cmluZ1B0ciArIHRvdGFsTGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3cgY29weSBhbGwgdGhlIHN0cmluZ3MgdG8gdGhlIG5ldyBidWZmZXIgYmFjayB0byBiYWNrXHJcbiAgICAgICAgICAgICAgICBsZXQgd3JpdGVyT2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IGRlc2Mucm93czsgKytyb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHREYXRhW3Jvd10gPSB3cml0ZXJPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0VVRGOCA9IHJlc3VsdERhdGFVVEY4W3Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gcmVzdWx0U3RyaW5nQnVmLnN1YmFycmF5KHdyaXRlck9mZnNldCwgd3JpdGVyT2Zmc2V0ICsgcmVzdWx0VVRGOC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5zZXQocmVzdWx0VVRGOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyT2Zmc2V0ICs9IHJlc3VsdFVURjgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOZWVkIHRvIHN0b3JlIHRocmVlIHBvaW50ZXJzLCBkYXRhLCB2YWxpZGl0eSBhbmQgbGVuZ3RoXHJcbiAgICAgICAgY29uc3QgcmV0TGVuID0gMyAqIDg7XHJcbiAgICAgICAgY29uc3QgcmV0UHRyID0gbW9kLl9tYWxsb2MocmV0TGVuKTtcclxuICAgICAgICBjb25zdCByZXRCdWZmZXIgPSBwdHJUb0Zsb2F0NjRBcnJheShtb2QsIHJldFB0ciwgMyk7XHJcbiAgICAgICAgcmV0QnVmZmVyWzBdID0gcmVzdWx0RGF0YVB0cjtcclxuICAgICAgICByZXRCdWZmZXJbMV0gPSByZXN1bHRWYWxpZGl0eVB0cjtcclxuICAgICAgICByZXRCdWZmZXJbMl0gPSByZXN1bHRMZW5ndGhzUHRyO1xyXG5cclxuICAgICAgICAvLyBQYWNrIHJlc3BvbnNlXHJcbiAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF0gPSAwO1xyXG4gICAgICAgIG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDFdID0gcmV0UHRyO1xyXG4gICAgICAgIG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDJdID0gMDtcclxuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgIHN0b3JlRXJyb3IobW9kLCByZXNwb25zZSwgZS50b1N0cmluZygpKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuaW1wb3J0IHsgVURGRnVuY3Rpb24gfSBmcm9tICcuL3VkZl9mdW5jdGlvbic7XHJcbmltcG9ydCAqIGFzIHVkZl9ydCBmcm9tICcuL3VkZl9ydW50aW1lJztcclxuXHJcbi8qKiBXcmFwcGVyIGZvciBUZXh0RGVjb2RlciB0byBzdXBwb3J0IHNoYXJlZCBhcnJheSBidWZmZXJzICovXHJcbmZ1bmN0aW9uIFRleHREZWNvZGVyV3JhcHBlcigpOiAoaW5wdXQ/OiBCdWZmZXJTb3VyY2UpID0+IHN0cmluZyB7XHJcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XHJcbiAgICByZXR1cm4gKGRhdGE6IGFueSkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGRhdGEuYnVmZmVyIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpIHtcclxuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoZGF0YSk7XHJcbiAgICB9O1xyXG59XHJcbi8qKiBIZWxwZXIgdG8gZGVjb2RlIHRleHQgKi9cclxuZXhwb3J0IGNvbnN0IGRlY29kZVRleHQgPSBUZXh0RGVjb2RlcldyYXBwZXIoKTtcclxuXHJcbi8qKiBDb3B5IGEgYnVmZmVyICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmYWlsV2l0aChtb2Q6IER1Y2tEQk1vZHVsZSwgbXNnOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoYEZBSUwgV0lUSDogJHttc2d9YCk7XHJcbiAgICBtb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfZmFpbF93aXRoJywgbnVsbCwgWydzdHJpbmcnXSwgW21zZ10pO1xyXG59XHJcblxyXG4vKiogQ29weSBhIGJ1ZmZlciAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weUJ1ZmZlcihtb2Q6IER1Y2tEQk1vZHVsZSwgYmVnaW46IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBVaW50OEFycmF5IHtcclxuICAgIGNvbnN0IGJ1ZmZlciA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYmVnaW4sIGJlZ2luICsgbGVuZ3RoKTtcclxuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShuZXcgQXJyYXlCdWZmZXIoYnVmZmVyLmJ5dGVMZW5ndGgpKTtcclxuICAgIGNvcHkuc2V0KGJ1ZmZlcik7XHJcbiAgICByZXR1cm4gY29weTtcclxufVxyXG5cclxuLyoqIERlY29kZSBhIHN0cmluZyAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVhZFN0cmluZyhtb2Q6IER1Y2tEQk1vZHVsZSwgYmVnaW46IG51bWJlciwgbGVuZ3RoOiBudW1iZXIpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGRlY29kZVRleHQobW9kLkhFQVBVOC5zdWJhcnJheShiZWdpbiwgYmVnaW4gKyBsZW5ndGgpKTtcclxufVxyXG5cclxuLyoqIFRoZSBkYXRhIHByb3RvY29sICovXHJcbmV4cG9ydCBlbnVtIER1Y2tEQkRhdGFQcm90b2NvbCB7XHJcbiAgICBCVUZGRVIgPSAwLFxyXG4gICAgTk9ERV9GUyA9IDEsXHJcbiAgICBCUk9XU0VSX0ZJTEVSRUFERVIgPSAyLFxyXG4gICAgQlJPV1NFUl9GU0FDQ0VTUyA9IDMsXHJcbiAgICBIVFRQID0gNCxcclxuICAgIFMzID0gNSxcclxufVxyXG5cclxuLyoqIEZpbGUgZmxhZ3MgZm9yIG9wZW5pbmcgZmlsZXMqL1xyXG5leHBvcnQgZW51bSBGaWxlRmxhZ3Mge1xyXG4gICAgLy8hIE9wZW4gZmlsZSB3aXRoIHJlYWQgYWNjZXNzXHJcbiAgICBGSUxFX0ZMQUdTX1JFQUQgPSAxIDw8IDAsXHJcbiAgICAvLyEgT3BlbiBmaWxlIHdpdGggd3JpdGUgYWNjZXNzXHJcbiAgICBGSUxFX0ZMQUdTX1dSSVRFID0gMSA8PCAxLFxyXG4gICAgLy8hIFVzZSBkaXJlY3QgSU8gd2hlbiByZWFkaW5nL3dyaXRpbmcgdG8gdGhlIGZpbGVcclxuICAgIEZJTEVfRkxBR1NfRElSRUNUX0lPID0gMSA8PCAyLFxyXG4gICAgLy8hIENyZWF0ZSBmaWxlIGlmIG5vdCBleGlzdHMsIGNhbiBvbmx5IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBXUklURVxyXG4gICAgRklMRV9GTEFHU19GSUxFX0NSRUFURSA9IDEgPDwgMyxcclxuICAgIC8vISBBbHdheXMgY3JlYXRlIGEgbmV3IGZpbGUuIElmIGEgZmlsZSBleGlzdHMsIHRoZSBmaWxlIGlzIHRydW5jYXRlZC4gQ2Fubm90IGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBDUkVBVEUuXHJcbiAgICBGSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFX05FVyA9IDEgPDwgNCxcclxuICAgIC8vISBPcGVuIGZpbGUgaW4gYXBwZW5kIG1vZGVcclxuICAgIEZJTEVfRkxBR1NfQVBQRU5EID0gMSA8PCA1LFxyXG59XHJcblxyXG4vKiogQ29uZmlndXJhdGlvbiBmb3IgdGhlIEFXUyBTMyBGaWxlc3lzdGVtICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgUzNDb25maWcge1xyXG4gICAgcmVnaW9uPzogc3RyaW5nO1xyXG4gICAgZW5kcG9pbnQ/OiBzdHJpbmc7XHJcbiAgICBhY2Nlc3NLZXlJZD86IHN0cmluZztcclxuICAgIHNlY3JldEFjY2Vzc0tleT86IHN0cmluZztcclxuICAgIHNlc3Npb25Ub2tlbj86IHN0cmluZztcclxufVxyXG5cclxuLyoqIEFuIGluZm8gZm9yIGEgZmlsZSByZWdpc3RlcmVkIHdpdGggRHVja0RCICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCRmlsZUluZm8ge1xyXG4gICAgY2FjaGVFcG9jaDogbnVtYmVyO1xyXG4gICAgZmlsZUlkOiBudW1iZXI7XHJcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xyXG4gICAgZGF0YVByb3RvY29sOiBEdWNrREJEYXRhUHJvdG9jb2w7XHJcbiAgICBkYXRhVXJsOiBzdHJpbmcgfCBudWxsO1xyXG4gICAgYWxsb3dGdWxsSHR0cFJlYWRzPzogYm9vbGVhbjtcclxuICAgIHMzQ29uZmlnPzogUzNDb25maWc7XHJcbn1cclxuXHJcbi8qKiBHbG9iYWwgaW5mbyBmb3IgYWxsIGZpbGVzIHJlZ2lzdGVyZWQgd2l0aCBEdWNrREIgKi9cclxuZXhwb3J0IGludGVyZmFjZSBEdWNrREJHbG9iYWxGaWxlSW5mbyB7XHJcbiAgICBjYWNoZUVwb2NoOiBudW1iZXI7XHJcbiAgICBhbGxvd0Z1bGxIdHRwUmVhZHM/OiBib29sZWFuO1xyXG4gICAgczNDb25maWc/OiBTM0NvbmZpZztcclxufVxyXG5cclxuLyoqIENhbGwgYSBmdW5jdGlvbiB3aXRoIHBhY2tlZCByZXNwb25zZSBidWZmZXIgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxTUmV0KFxyXG4gICAgbW9kOiBEdWNrREJNb2R1bGUsXHJcbiAgICBmdW5jTmFtZTogc3RyaW5nLFxyXG4gICAgYXJnVHlwZXM6IEFycmF5PEVtc2NyaXB0ZW4uSlNUeXBlPixcclxuICAgIGFyZ3M6IEFycmF5PGFueT4sXHJcbik6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB7XHJcbiAgICBjb25zdCBzdGFja1BvaW50ZXIgPSBtb2Quc3RhY2tTYXZlKCk7XHJcblxyXG4gICAgLy8gQWxsb2NhdGUgdGhlIHBhY2tlZCByZXNwb25zZSBidWZmZXJcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gbW9kLnN0YWNrQWxsb2MoMyAqIDgpO1xyXG4gICAgYXJnVHlwZXMudW5zaGlmdCgnbnVtYmVyJyk7XHJcbiAgICBhcmdzLnVuc2hpZnQocmVzcG9uc2UpO1xyXG5cclxuICAgIC8vIERvIHRoZSBjYWxsXHJcbiAgICBtb2QuY2NhbGwoZnVuY05hbWUsIG51bGwsIGFyZ1R5cGVzLCBhcmdzKTtcclxuXHJcbiAgICAvLyBSZWFkIHRoZSByZXNwb25zZVxyXG4gICAgY29uc3Qgc3RhdHVzID0gbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMF07XHJcbiAgICBjb25zdCBkYXRhID0gbW9kLkhFQVBGNjRbKHJlc3BvbnNlID4+IDMpICsgMV07XHJcbiAgICBjb25zdCBkYXRhU2l6ZSA9IG1vZC5IRUFQRjY0WyhyZXNwb25zZSA+PiAzKSArIDJdO1xyXG5cclxuICAgIC8vIFJlc3RvcmUgdGhlIHN0YWNrXHJcbiAgICBtb2Quc3RhY2tSZXN0b3JlKHN0YWNrUG9pbnRlcik7XHJcbiAgICByZXR1cm4gW3N0YXR1cywgZGF0YSwgZGF0YVNpemVdO1xyXG59XHJcblxyXG4vKiogRHJvcCByZXNwb25zZSBidWZmZXJzICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkcm9wUmVzcG9uc2VCdWZmZXJzKG1vZDogRHVja0RCTW9kdWxlKTogdm9pZCB7XHJcbiAgICBtb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2UnLCBudWxsLCBbXSwgW10pO1xyXG59XHJcblxyXG4vKiogVGhlIGR1Y2tkYiBydW50aW1lICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCUnVudGltZSB7XHJcbiAgICBfZmlsZXM/OiBNYXA8c3RyaW5nLCBhbnk+O1xyXG4gICAgX3VkZkZ1bmN0aW9uczogTWFwPG51bWJlciwgVURGRnVuY3Rpb24+O1xyXG5cclxuICAgIC8vIFRlc3QgYSBwbGF0Zm9ybSBmZWF0dXJlXHJcbiAgICB0ZXN0UGxhdGZvcm1GZWF0dXJlKG1vZDogRHVja0RCTW9kdWxlLCBmZWF0dXJlOiBudW1iZXIpOiBib29sZWFuO1xyXG5cclxuICAgIC8vIEZpbGUgQVBJcyB3aXRoIGRlZGljYXRlZCBmaWxlIGlkZW50aWZpZXJcclxuICAgIGdldERlZmF1bHREYXRhUHJvdG9jb2wobW9kOiBEdWNrREJNb2R1bGUpOiBudW1iZXI7XHJcbiAgICBvcGVuRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGZsYWdzOiBGaWxlRmxhZ3MpOiB2b2lkO1xyXG4gICAgc3luY0ZpbGUobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKTogdm9pZDtcclxuICAgIGNsb3NlRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgZ2V0TGFzdEZpbGVNb2RpZmljYXRpb25UaW1lKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IG51bWJlcjtcclxuICAgIHRydW5jYXRlRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIG5ld1NpemU6IG51bWJlcik6IHZvaWQ7XHJcbiAgICByZWFkRmlsZShtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGJ1ZmZlcjogbnVtYmVyLCBieXRlczogbnVtYmVyLCBsb2NhdGlvbjogbnVtYmVyKTogbnVtYmVyO1xyXG4gICAgd3JpdGVGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgYnVmZmVyOiBudW1iZXIsIGJ5dGVzOiBudW1iZXIsIGxvY2F0aW9uOiBudW1iZXIpOiBudW1iZXI7XHJcblxyXG4gICAgLy8gRmlsZSBBUElzIHdpdGggcGF0aCBwYXJhbWV0ZXJcclxuICAgIHJlbW92ZURpcmVjdG9yeShtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgY2hlY2tEaXJlY3RvcnkobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcclxuICAgIGNyZWF0ZURpcmVjdG9yeShtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiB2b2lkO1xyXG4gICAgbGlzdERpcmVjdG9yeUVudHJpZXMobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcclxuICAgIGdsb2IobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogdm9pZDtcclxuICAgIG1vdmVGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmcm9tUHRyOiBudW1iZXIsIGZyb21MZW46IG51bWJlciwgdG9QdHI6IG51bWJlciwgdG9MZW46IG51bWJlcik6IHZvaWQ7XHJcbiAgICBjaGVja0ZpbGUobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogYm9vbGVhbjtcclxuICAgIHJlbW92ZUZpbGUobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICAvLyBDYWxsIGEgc2NhbGFyIFVERiBmdW5jdGlvblxyXG4gICAgY2FsbFNjYWxhclVERihcclxuICAgICAgICBtb2Q6IER1Y2tEQk1vZHVsZSxcclxuICAgICAgICByZXNwb25zZTogbnVtYmVyLFxyXG4gICAgICAgIGZ1bmNJZDogbnVtYmVyLFxyXG4gICAgICAgIGRlc2NQdHI6IG51bWJlcixcclxuICAgICAgICBkZXNjU2l6ZTogbnVtYmVyLFxyXG4gICAgICAgIHB0cnNQdHI6IG51bWJlcixcclxuICAgICAgICBwdHJzU2l6ZTogbnVtYmVyLFxyXG4gICAgKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUlVOVElNRTogRHVja0RCUnVudGltZSA9IHtcclxuICAgIF91ZGZGdW5jdGlvbnM6IG5ldyBNYXAoKSxcclxuXHJcbiAgICB0ZXN0UGxhdGZvcm1GZWF0dXJlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmVhdHVyZTogbnVtYmVyKTogYm9vbGVhbiA9PiBmYWxzZSxcclxuICAgIGdldERlZmF1bHREYXRhUHJvdG9jb2w6IChfbW9kOiBEdWNrREJNb2R1bGUpOiBudW1iZXIgPT4gRHVja0RCRGF0YVByb3RvY29sLkJVRkZFUixcclxuICAgIG9wZW5GaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmlsZUlkOiBudW1iZXIsIGZsYWdzOiBGaWxlRmxhZ3MpOiB2b2lkID0+IHt9LFxyXG4gICAgc3luY0ZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBjbG9zZUZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBnZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG4gICAgdHJ1bmNhdGVGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfZmlsZUlkOiBudW1iZXIsIF9uZXdTaXplOiBudW1iZXIpOiB2b2lkID0+IHt9LFxyXG4gICAgcmVhZEZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlciwgX2J1ZmZlcjogbnVtYmVyLCBfYnl0ZXM6IG51bWJlciwgX2xvY2F0aW9uOiBudW1iZXIpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuICAgIHdyaXRlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2ZpbGVJZDogbnVtYmVyLCBfYnVmZmVyOiBudW1iZXIsIF9ieXRlczogbnVtYmVyLCBfbG9jYXRpb246IG51bWJlcik6IG51bWJlciA9PiB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbW92ZURpcmVjdG9yeTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBjaGVja0RpcmVjdG9yeTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVEaXJlY3Rvcnk6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiB2b2lkID0+IHt9LFxyXG4gICAgbGlzdERpcmVjdG9yeUVudHJpZXM6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9wYXRoUHRyOiBudW1iZXIsIF9wYXRoTGVuOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgZ2xvYjogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IHZvaWQgPT4ge30sXHJcbiAgICBtb3ZlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX2Zyb21QdHI6IG51bWJlciwgX2Zyb21MZW46IG51bWJlciwgX3RvUHRyOiBudW1iZXIsIF90b0xlbjogbnVtYmVyKTogdm9pZCA9PiB7fSxcclxuICAgIGNoZWNrRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcik6IGJvb2xlYW4gPT4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVGaWxlOiAoX21vZDogRHVja0RCTW9kdWxlLCBfcGF0aFB0cjogbnVtYmVyLCBfcGF0aExlbjogbnVtYmVyKTogdm9pZCA9PiB7fSxcclxuICAgIGNhbGxTY2FsYXJVREY6IChcclxuICAgICAgICBtb2Q6IER1Y2tEQk1vZHVsZSxcclxuICAgICAgICByZXNwb25zZTogbnVtYmVyLFxyXG4gICAgICAgIGZ1bmNJZDogbnVtYmVyLFxyXG4gICAgICAgIGRlc2NQdHI6IG51bWJlcixcclxuICAgICAgICBkZXNjU2l6ZTogbnVtYmVyLFxyXG4gICAgICAgIHB0cnNQdHI6IG51bWJlcixcclxuICAgICAgICBwdHJzU2l6ZTogbnVtYmVyLFxyXG4gICAgKTogdm9pZCA9PiB7XHJcbiAgICAgICAgdWRmX3J0LmNhbGxTY2FsYXJVREYoREVGQVVMVF9SVU5USU1FLCBtb2QsIHJlc3BvbnNlLCBmdW5jSWQsIGRlc2NQdHIsIGRlc2NTaXplLCBwdHJzUHRyLCBwdHJzU2l6ZSk7XHJcbiAgICB9LFxyXG59O1xyXG4iLCAiZXhwb3J0IGludGVyZmFjZSBGaWxlQmxvY2tTdGF0aXN0aWNzIHtcclxuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBjb2xkICovXHJcbiAgICBmaWxlX3JlYWRzX2NvbGQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBhaGVhZHMgKi9cclxuICAgIGZpbGVfcmVhZHNfYWhlYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgZmlsZSByZWFkcyBjYWNoZWQgKi9cclxuICAgIGZpbGVfcmVhZHNfY2FjaGVkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGZpbGUgd3JpdGVzICovXHJcbiAgICBmaWxlX3dyaXRlczogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBwYWdlIGFjY2Vzc2VzICovXHJcbiAgICBwYWdlX2FjY2Vzc2VzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIHBhZ2UgbG9hZHMgKi9cclxuICAgIHBhZ2VfbG9hZHM6IG51bWJlcjtcclxufVxyXG5cclxuLyoqIFRoZSBmaWxlIGJsb2NrIHN0YXRpc3RpY3MgKi9cclxuZXhwb3J0IGNsYXNzIEZpbGVTdGF0aXN0aWNzIHtcclxuICAgIC8qKiBUaGUgY29sZCBmaWxlIHJlYWRzICovXHJcbiAgICBwdWJsaWMgdG90YWxGaWxlUmVhZHNDb2xkOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGZpbGUgcmVhZGFoZWFkcyAqL1xyXG4gICAgcHVibGljIHRvdGFsRmlsZVJlYWRzQWhlYWQ6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgY2FjaGVkIGZpbGUgcmVhZHMgKi9cclxuICAgIHB1YmxpYyB0b3RhbEZpbGVSZWFkc0NhY2hlZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBmaWxlIHdyaXRlcyAqL1xyXG4gICAgcHVibGljIHRvdGFsRmlsZVdyaXRlczogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBwYWdlIGFjY2Vzc2VzICovXHJcbiAgICBwdWJsaWMgdG90YWxQYWdlQWNjZXNzZXM6IG51bWJlcjtcclxuICAgIC8qKiBUaGUgcGFnZSBsb2FkcyAqL1xyXG4gICAgcHVibGljIHRvdGFsUGFnZUxvYWRzOiBudW1iZXI7XHJcbiAgICAvKiogVGhlIGJsb2NrcyAqL1xyXG4gICAgcHVibGljIGJsb2NrU2l6ZTogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBibG9ja3MgKi9cclxuICAgIHB1YmxpYyBibG9ja1N0YXRzOiBVaW50OEFycmF5O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHU4YXJyYXk6IFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICBjb25zdCBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KHU4YXJyYXkuYnVmZmVyLCB1OGFycmF5LmJ5dGVPZmZzZXQsIHU4YXJyYXkuYnl0ZUxlbmd0aCAvIDgpO1xyXG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcih1OGFycmF5LmJ5dGVMZW5ndGgpKTtcclxuICAgICAgICBibG9ja3Muc2V0KHU4YXJyYXkuc3ViYXJyYXkoNyAqIDgpKTtcclxuICAgICAgICB0aGlzLnRvdGFsRmlsZVJlYWRzQ29sZCA9IGY2NFswXTtcclxuICAgICAgICB0aGlzLnRvdGFsRmlsZVJlYWRzQWhlYWQgPSBmNjRbMV07XHJcbiAgICAgICAgdGhpcy50b3RhbEZpbGVSZWFkc0NhY2hlZCA9IGY2NFsyXTtcclxuICAgICAgICB0aGlzLnRvdGFsRmlsZVdyaXRlcyA9IGY2NFszXTtcclxuICAgICAgICB0aGlzLnRvdGFsUGFnZUFjY2Vzc2VzID0gZjY0WzRdO1xyXG4gICAgICAgIHRoaXMudG90YWxQYWdlTG9hZHMgPSBmNjRbNV07XHJcbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSBmNjRbNl07XHJcbiAgICAgICAgdGhpcy5ibG9ja1N0YXRzID0gYmxvY2tzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgYmxvY2sgc3RhdHMgKi9cclxuICAgIHB1YmxpYyBnZXRCbG9ja1N0YXRzKGluZGV4OiBudW1iZXIsIG91dD86IEZpbGVCbG9ja1N0YXRpc3RpY3MpOiBGaWxlQmxvY2tTdGF0aXN0aWNzIHtcclxuICAgICAgICBvdXQgPSBvdXQgfHwge1xyXG4gICAgICAgICAgICBmaWxlX3JlYWRzX2NvbGQ6IDAsXHJcbiAgICAgICAgICAgIGZpbGVfcmVhZHNfYWhlYWQ6IDAsXHJcbiAgICAgICAgICAgIGZpbGVfcmVhZHNfY2FjaGVkOiAwLFxyXG4gICAgICAgICAgICBmaWxlX3dyaXRlczogMCxcclxuICAgICAgICAgICAgcGFnZV9hY2Nlc3NlczogMCxcclxuICAgICAgICAgICAgcGFnZV9sb2FkczogMCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIG91dC5maWxlX3dyaXRlcyA9IHRoaXMuYmxvY2tTdGF0c1tpbmRleCAqIDMgKyAwXSAmIDBiMTExMTtcclxuICAgICAgICBvdXQuZmlsZV9yZWFkc19jb2xkID0gdGhpcy5ibG9ja1N0YXRzW2luZGV4ICogMyArIDBdID4+IDQ7XHJcbiAgICAgICAgb3V0LmZpbGVfcmVhZHNfYWhlYWQgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gJiAwYjExMTE7XHJcbiAgICAgICAgb3V0LmZpbGVfcmVhZHNfY2FjaGVkID0gdGhpcy5ibG9ja1N0YXRzW2luZGV4ICogMyArIDFdID4+IDQ7XHJcbiAgICAgICAgb3V0LnBhZ2VfYWNjZXNzZXMgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gJiAwYjExMTE7XHJcbiAgICAgICAgb3V0LnBhZ2VfbG9hZHMgPSB0aGlzLmJsb2NrU3RhdHNbaW5kZXggKiAzICsgMV0gPj4gNDtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTUUxUeXBlIHtcclxuICAgIC8vLyBUaGUgc3FsIHR5cGVcclxuICAgIHNxbFR5cGU6IHN0cmluZztcclxuICAgIC8vLyBJcyBudWxsYWJsZT9cclxuICAgIG51bGxhYmxlPzogYm9vbGVhbjtcclxuICAgIC8vLyBEZWNpbWFsIHByZWNpc2lvblxyXG4gICAgcHJlY2lzaW9uPzogbnVtYmVyO1xyXG4gICAgLy8vIERlY2ltYWwgc2NhbGluZ1xyXG4gICAgc2NhbGU/OiBudW1iZXI7XHJcbiAgICAvLy8gVGltZXpvbmVcclxuICAgIHRpbWV6b25lPzogc3RyaW5nO1xyXG4gICAgLy8vIEJ5dGUgd2lkdGggKEZpeGVkU2l6ZUJpbmFyeSlcclxuICAgIGJ5dGVXaWR0aD86IG51bWJlcjtcclxuICAgIC8vLyBLZXkgdHlwZVxyXG4gICAga2V5VHlwZT86IFNRTFR5cGU7XHJcbiAgICAvLy8gVmFsdWUgdHlwZVxyXG4gICAgdmFsdWVUeXBlPzogU1FMVHlwZTtcclxuICAgIC8vLyBGaWVsZHNcclxuICAgIGZpZWxkcz86IFNRTEZpZWxkW107XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJvd1RvU1FMVHlwZSh0eXBlOiBhcnJvdy5EYXRhVHlwZSk6IFNRTFR5cGUge1xyXG4gICAgc3dpdGNoICh0eXBlLnR5cGVJZCkge1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5CaW5hcnk6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdiaW5hcnknIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkJvb2w6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdib29sJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5EYXRlOlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZGF0ZScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGF0ZURheTpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2RhdGUzMltkXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGF0ZU1pbGxpc2Vjb25kOlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZGF0ZTY0W21zXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRGVjaW1hbDoge1xyXG4gICAgICAgICAgICBjb25zdCBkZWMgPSB0eXBlIGFzIGFycm93LkRlY2ltYWw7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdkZWNpbWFsJywgcHJlY2lzaW9uOiBkZWMucHJlY2lzaW9uLCBzY2FsZTogZGVjLnNjYWxlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5GbG9hdDE2OlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnZmxvYXQxNicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuRmxvYXQzMjpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2Zsb2F0MzInIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkZsb2F0NjQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdmbG9hdDY0JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQzMicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50MTY6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQxNicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50MzI6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQzMicgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50NjQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICdpbnQ2NCcgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVWludDE2OlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndWludDE2JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5VaW50MzI6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1aW50MzInIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlVpbnQ2NDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3VpbnQ2NCcgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVWludDg6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1aW50OCcgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuSW50ZXJ2YWxEYXlUaW1lOlxyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAnaW50ZXJ2YWxbZHRdJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5JbnRlcnZhbFllYXJNb250aDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2ludGVydmFsW21dJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5MaXN0OiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB0eXBlIGFzIGFycm93Lkxpc3Q7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzcWxUeXBlOiAnbGlzdCcsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IGFycm93VG9TUUxUeXBlKGxpc3QudmFsdWVUeXBlKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLkZpeGVkU2l6ZUJpbmFyeToge1xyXG4gICAgICAgICAgICBjb25zdCBiaW4gPSB0eXBlIGFzIGFycm93LkZpeGVkU2l6ZUJpbmFyeTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ2ZpeGVkc2l6ZWJpbmFyeScsIGJ5dGVXaWR0aDogYmluLmJ5dGVXaWR0aCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuTnVsbDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ251bGwnIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlV0Zjg6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd1dGY4JyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5TdHJ1Y3Q6IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RydWN0XyA9IHR5cGUgYXMgYXJyb3cuU3RydWN0O1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc3FsVHlwZTogJ3N0cnVjdCcsXHJcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHN0cnVjdF8uY2hpbGRyZW4ubWFwKGMgPT4gYXJyb3dUb1NRTEZpZWxkKGMubmFtZSwgYy50eXBlKSksXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5NYXA6IHtcclxuICAgICAgICAgICAgY29uc3QgbWFwXyA9IHR5cGUgYXMgYXJyb3cuTWFwXztcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHNxbFR5cGU6ICdtYXAnLFxyXG4gICAgICAgICAgICAgICAga2V5VHlwZTogYXJyb3dUb1NRTFR5cGUobWFwXy5rZXlUeXBlKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogYXJyb3dUb1NRTFR5cGUobWFwXy52YWx1ZVR5cGUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZTpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbc10nIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVNaWNyb3NlY29uZDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbdXNdJyB9O1xyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lTWlsbGlzZWNvbmQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lW21zXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZU5hbm9zZWNvbmQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lW25zXScgfTtcclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZVNlY29uZDpcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVbc10nIH07XHJcbiAgICAgICAgY2FzZSBhcnJvdy5UeXBlLlRpbWVzdGFtcDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wO1xyXG4gICAgICAgICAgICByZXR1cm4geyBzcWxUeXBlOiAndGltZXN0YW1wJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZXN0YW1wU2Vjb25kOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRzID0gdHlwZSBhcyBhcnJvdy5UaW1lc3RhbXBTZWNvbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbc10nLCB0aW1lem9uZTogdHMudGltZXpvbmUgfHwgdW5kZWZpbmVkIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lc3RhbXBNaWNyb3NlY29uZDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTWljcm9zZWNvbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbdXNdJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIGFycm93LlR5cGUuVGltZXN0YW1wTmFub3NlY29uZDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTmFub3NlY29uZDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgc3FsVHlwZTogJ3RpbWVzdGFtcFtuc10nLCB0aW1lem9uZTogdHMudGltZXpvbmUgfHwgdW5kZWZpbmVkIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgYXJyb3cuVHlwZS5UaW1lc3RhbXBNaWxsaXNlY29uZDoge1xyXG4gICAgICAgICAgICBjb25zdCB0cyA9IHR5cGUgYXMgYXJyb3cuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHNxbFR5cGU6ICd0aW1lc3RhbXBbbXNdJywgdGltZXpvbmU6IHRzLnRpbWV6b25lIHx8IHVuZGVmaW5lZCB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgYXJyb3cgdHlwZTogJHt0eXBlLnRvU3RyaW5nKCl9YCk7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFNRTEZpZWxkID0gU1FMVHlwZSAmIHsgbmFtZTogc3RyaW5nIH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYXJyb3dUb1NRTEZpZWxkKG5hbWU6IHN0cmluZywgdHlwZTogYXJyb3cuRGF0YVR5cGUpOiBTUUxGaWVsZCB7XHJcbiAgICBjb25zdCB0ID0gYXJyb3dUb1NRTFR5cGUodHlwZSkgYXMgU1FMRmllbGQ7XHJcbiAgICB0Lm5hbWUgPSBuYW1lO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuIiwgImltcG9ydCB7IER1Y2tEQk1vZHVsZSwgUFRocmVhZCB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XHJcbmltcG9ydCB7IER1Y2tEQkNvbmZpZyB9IGZyb20gJy4vY29uZmlnJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLi9wcm9ncmVzcyc7XHJcbmltcG9ydCB7IER1Y2tEQkJpbmRpbmdzIH0gZnJvbSAnLi9iaW5kaW5nc19pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBEdWNrREJDb25uZWN0aW9uIH0gZnJvbSAnLi9jb25uZWN0aW9uJztcclxuaW1wb3J0IHsgU3RhdHVzQ29kZSB9IGZyb20gJy4uL3N0YXR1cyc7XHJcbmltcG9ydCB7IGRyb3BSZXNwb25zZUJ1ZmZlcnMsIER1Y2tEQlJ1bnRpbWUsIHJlYWRTdHJpbmcsIGNhbGxTUmV0LCBjb3B5QnVmZmVyLCBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuL3J1bnRpbWUnO1xyXG5pbXBvcnQgeyBDU1ZJbnNlcnRPcHRpb25zLCBKU09OSW5zZXJ0T3B0aW9ucywgQXJyb3dJbnNlcnRPcHRpb25zIH0gZnJvbSAnLi9pbnNlcnRfb3B0aW9ucyc7XHJcbmltcG9ydCB7IFNjcmlwdFRva2VucyB9IGZyb20gJy4vdG9rZW5zJztcclxuaW1wb3J0IHsgRmlsZVN0YXRpc3RpY3MgfSBmcm9tICcuL2ZpbGVfc3RhdHMnO1xyXG5pbXBvcnQgeyBhcnJvd1RvU1FMRmllbGQsIGFycm93VG9TUUxUeXBlIH0gZnJvbSAnLi4vanNvbl90eXBlZGVmJztcclxuaW1wb3J0IHsgV2ViRmlsZSB9IGZyb20gJy4vd2ViX2ZpbGUnO1xyXG5pbXBvcnQgeyBVREZGdW5jdGlvbiwgVURGRnVuY3Rpb25EZWNsYXJhdGlvbiB9IGZyb20gJy4vdWRmX2Z1bmN0aW9uJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbmNvbnN0IFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xyXG5cclxuZGVjbGFyZSBnbG9iYWwge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhclxyXG4gICAgdmFyIERVQ0tEQl9SVU5USU1FOiBhbnk7XHJcbn1cclxuXHJcbi8qKiBBIER1Y2tEQiBGZWF0dXJlICovXHJcbmV4cG9ydCBlbnVtIER1Y2tEQkZlYXR1cmUge1xyXG4gICAgV0FTTV9FWENFUFRJT05TID0gMSA8PCAwLFxyXG4gICAgV0FTTV9USFJFQURTID0gMSA8PCAxLFxyXG4gICAgV0FTTV9TSU1EID0gMSA8PCAyLFxyXG4gICAgV0FTTV9CVUxLX01FTU9SWSA9IDEgPDwgMyxcclxuICAgIEVNSVRfQklHSU5UID0gMSA8PCA0LFxyXG59XHJcblxyXG4vKiogVGhlIHByb3h5IGZvciBlaXRoZXIgdGhlIGJyb3dzZXItIG9yZGVyIG5vZGUtYmFzZWQgRHVja0RCIEFQSSAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRHVja0RCQmluZGluZ3NCYXNlIGltcGxlbWVudHMgRHVja0RCQmluZGluZ3Mge1xyXG4gICAgLyoqIFRoZSBsb2dnZXIgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBfbG9nZ2VyOiBMb2dnZXI7XHJcbiAgICAvKiogQmFja2VuZC1kZXBlbmRlbnQgbmF0aXZlLWdsdWUgY29kZSBmb3IgRHVja0RCICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3J1bnRpbWU6IER1Y2tEQlJ1bnRpbWU7XHJcbiAgICAvKiogVGhlIGluc3RhbmNlICovXHJcbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBEdWNrREJNb2R1bGUgfCBudWxsID0gbnVsbDtcclxuICAgIC8qKiBUaGUgbG9hZGluZyBwcm9taXNlICovXHJcbiAgICBwcm90ZWN0ZWQgX2luaXRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbCA9IG51bGw7XHJcbiAgICAvKiogVGhlIHJlc29sdmVyIGZvciB0aGUgb3BlbiBwcm9taXNlIChjYWxsZWQgYnkgb25SdW50aW1lSW5pdGlhbGl6ZWQpICovXHJcbiAgICBwcm90ZWN0ZWQgX2luaXRQcm9taXNlUmVzb2x2ZXI6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcclxuICAgIC8qKiBUaGUgbmV4dCBVREYgaWQgKi9cclxuICAgIHByb3RlY3RlZCBfbmV4dFVERklkOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXIsIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBsb2dnZXI7XHJcbiAgICAgICAgdGhpcy5fcnVudGltZSA9IHJ1bnRpbWU7XHJcbiAgICAgICAgdGhpcy5fbmV4dFVERklkID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBsb2dnZXIgKi9cclxuICAgIHB1YmxpYyBnZXQgbG9nZ2VyKCk6IExvZ2dlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ2dlcjtcclxuICAgIH1cclxuICAgIC8qKiBHZXQgdGhlIGluc3RhbmNlICovXHJcbiAgICBwdWJsaWMgZ2V0IG1vZCgpOiBEdWNrREJNb2R1bGUge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZSE7XHJcbiAgICB9XHJcbiAgICAvKiogR2V0IHRoZSBpbnN0YW5jZSAqL1xyXG4gICAgcHVibGljIGdldCBwdGhyZWFkKCk6IFBUaHJlYWQgfCBudWxsIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QuUFRocmVhZCB8fCBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgbW9kdWxlICovXHJcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+O1xyXG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSBtb2R1bGUgKi9cclxuICAgIHByb3RlY3RlZCBvbkluc3RhbnRpYXRpb25Qcm9ncmVzczogKChwOiBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MpID0+IHZvaWQpW10gPSBbXTtcclxuICAgIC8qKiBJbnN0YW50aWF0ZSB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnN0YW50aWF0ZShvblByb2dyZXNzOiAocHJvZ3Jlc3M6IEluc3RhbnRpYXRpb25Qcm9ncmVzcykgPT4gdm9pZCA9IF8gPT4ge30pOiBQcm9taXNlPHRoaXM+IHtcclxuICAgICAgICAvLyBBbHJlYWR5IG9wZW5lZD9cclxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3BlbiBpbiBwcm9ncmVzcz9cclxuICAgICAgICBpZiAodGhpcy5faW5pdFByb21pc2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uSW5zdGFudGlhdGlvblByb2dyZXNzLnB1c2gob25Qcm9ncmVzcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2UgY2FuIGF3YWl0XHJcbiAgICAgICAgdGhpcy5faW5pdFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgcHJvZ3Jlc3MgaGFuZGxlclxyXG4gICAgICAgIHRoaXMub25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSBbb25Qcm9ncmVzc107XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBkdWNrZGJcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGF3YWl0IHRoaXMuaW5zdGFudGlhdGVJbXBsKHtcclxuICAgICAgICAgICAgcHJpbnQ6IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksXHJcbiAgICAgICAgICAgIHByaW50RXJyOiBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFxyXG4gICAgICAgICAgICBvblJ1bnRpbWVJbml0aWFsaXplZDogdGhpcy5faW5pdFByb21pc2VSZXNvbHZlcixcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBXYWl0IGZvciBvblJ1bnRpbWVJbml0aWFsaXplZFxyXG4gICAgICAgIGF3YWl0IHRoaXMuX2luaXRQcm9taXNlO1xyXG4gICAgICAgIHRoaXMuX2luaXRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICAvLyBSZW1vdmUgb3duIHByb2dyZXNzIGNhbGxiYWNrXHJcbiAgICAgICAgdGhpcy5vbkluc3RhbnRpYXRpb25Qcm9ncmVzcyA9IHRoaXMub25JbnN0YW50aWF0aW9uUHJvZ3Jlc3MuZmlsdGVyKHggPT4geCAhPSBvblByb2dyZXNzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKiBPcGVuIGEgZGF0YWJhc2Ugd2l0aCBhIGNvbmZpZyAqL1xyXG4gICAgcHVibGljIG9wZW4oY29uZmlnOiBEdWNrREJDb25maWcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfb3BlbicsIFsnc3RyaW5nJ10sIFtKU09OLnN0cmluZ2lmeShjb25maWcpXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzZXQgdGhlIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX3Jlc2V0JywgW10sIFtdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIHZlcnNpb24gKi9cclxuICAgIHB1YmxpYyBnZXRWZXJzaW9uKCk6IHN0cmluZyB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2dldF92ZXJzaW9uJywgW10sIFtdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH1cclxuICAgIC8qKiBHZXQgdGhlIGZlYXR1cmUgZmxhZ3MgKi9cclxuICAgIHB1YmxpYyBnZXRGZWF0dXJlRmxhZ3MoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2QuY2NhbGwoJ2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3MnLCAnbnVtYmVyJywgW10sIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVG9rZW5pemUgYSBzY3JpcHQgKi9cclxuICAgIHB1YmxpYyB0b2tlbml6ZSh0ZXh0OiBzdHJpbmcpOiBTY3JpcHRUb2tlbnMge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl90b2tlbml6ZScsIFsnc3RyaW5nJ10sIFt0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXMpIGFzIFNjcmlwdFRva2VucztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29ubmVjdCB0byBkYXRhYmFzZSAqL1xyXG4gICAgcHVibGljIGNvbm5lY3QoKTogRHVja0RCQ29ubmVjdGlvbiB7XHJcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2Nvbm5lY3QnLCAnbnVtYmVyJywgW10sIFtdKTtcclxuICAgICAgICByZXR1cm4gbmV3IER1Y2tEQkNvbm5lY3Rpb24odGhpcywgY29ubik7XHJcbiAgICB9XHJcbiAgICAvKiogRGlzY29ubmVjdCBmcm9tIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgZGlzY29ubmVjdChjb25uOiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLm1vZC5jY2FsbCgnZHVja2RiX3dlYl9kaXNjb25uZWN0JywgbnVsbCwgWydudW1iZXInXSwgW2Nvbm5dKTtcclxuICAgICAgICBpZiAodGhpcy5wdGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIFsuLi50aGlzLnB0aHJlYWQucnVubmluZ1dvcmtlcnMsIC4uLnRoaXMucHRocmVhZC51bnVzZWRXb3JrZXJzXSkge1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdkcm9wVURGRnVuY3Rpb25zJyxcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogU2VuZCBhIHF1ZXJ5IGFuZCByZXR1cm4gdGhlIGZ1bGwgcmVzdWx0ICovXHJcbiAgICBwdWJsaWMgcnVuUXVlcnkoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcXVlcnlfcnVuJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgU3RhcnQgYSBwZW5kaW5nIHF1ZXJ5IGFzeW5jaHJvbm91c2x5LlxyXG4gICAgICogIFRoaXMgbWV0aG9kIHJldHVybnMgZWl0aGVyIHRoZSBhcnJvdyBpcGMgc2NoZW1hIG9yIG51bGwuXHJcbiAgICAgKiAgT24gbnVsbCwgdGhlIHF1ZXJ5IGhhcyB0byBiZSBleGVjdXRlZCB1c2luZyBgcG9sbFBlbmRpbmdRdWVyeWAgdW50aWwgdGhhdCByZXR1cm5zICE9IG51bGwuXHJcbiAgICAgKiAgUmVzdWx0cyBjYW4gdGhlbiBiZSBmZXRjaGVkIHVzaW5nIGBmZXRjaFF1ZXJ5UmVzdWx0c2BcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXJ0UGVuZGluZ1F1ZXJ5KGNvbm46IG51bWJlciwgdGV4dDogc3RyaW5nKTogVWludDhBcnJheSB8IG51bGwge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0JywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIFBvbGwgYSBwZW5kaW5nIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgcG9sbFBlbmRpbmdRdWVyeShjb25uOiBudW1iZXIpOiBVaW50OEFycmF5IHwgbnVsbCB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbCcsIFsnbnVtYmVyJ10sIFtjb25uXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIENhbmNlbCBhIHBlbmRpbmcgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBjYW5jZWxQZW5kaW5nUXVlcnkoY29ubjogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsJywgJ2Jvb2xlYW4nLCBbJ251bWJlciddLCBbY29ubl0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEZldGNoIHF1ZXJ5IHJlc3VsdHMgKi9cclxuICAgIHB1YmxpYyBmZXRjaFF1ZXJ5UmVzdWx0cyhjb25uOiBudW1iZXIpOiBVaW50OEFycmF5IHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0cycsIFsnbnVtYmVyJ10sIFtjb25uXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgLyoqIEdldCB0YWJsZSBuYW1lcyAqL1xyXG4gICAgcHVibGljIGdldFRhYmxlTmFtZXMoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZXMpIGFzIHN0cmluZ1tdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDcmVhdGUgYSBzY2FsYXIgZnVuY3Rpb24gKi9cclxuICAgIHB1YmxpYyBjcmVhdGVTY2FsYXJGdW5jdGlvbihcclxuICAgICAgICBjb25uOiBudW1iZXIsXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIHJldHVybnM6IGFycm93LkRhdGFUeXBlLFxyXG4gICAgICAgIGZ1bmM6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCxcclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGRlY2w6IFVERkZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHRoaXMuX25leHRVREZJZCxcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgcmV0dXJuVHlwZTogYXJyb3dUb1NRTFR5cGUocmV0dXJucyksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBkZWY6IFVERkZ1bmN0aW9uID0ge1xyXG4gICAgICAgICAgICBmdW5jdGlvbklkOiBkZWNsLmZ1bmN0aW9uSWQsXHJcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubixcclxuICAgICAgICAgICAgbmFtZTogbmFtZSxcclxuICAgICAgICAgICAgcmV0dXJuVHlwZTogcmV0dXJucyxcclxuICAgICAgICAgICAgZnVuYyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX25leHRVREZJZCArPSAxO1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxyXG4gICAgICAgICAgICB0aGlzLm1vZCxcclxuICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGUnLFxyXG4gICAgICAgICAgICBbJ251bWJlcicsICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW2Nvbm4sIEpTT04uc3RyaW5naWZ5KGRlY2wpXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICAgICAgZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5fdWRmRnVuY3Rpb25zID0gKGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuX3VkZkZ1bmN0aW9ucyB8fCBuZXcgTWFwKCkpLnNldChcclxuICAgICAgICAgICAgZGVmLmZ1bmN0aW9uSWQsXHJcbiAgICAgICAgICAgIGRlZixcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmICh0aGlzLnB0aHJlYWQpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB3b3JrZXIgb2YgWy4uLnRoaXMucHRocmVhZC5ydW5uaW5nV29ya2VycywgLi4udGhpcy5wdGhyZWFkLnVudXNlZFdvcmtlcnNdKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ3JlZ2lzdGVyVURGRnVuY3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIHVkZjogZGVmLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFByZXBhcmUgYSBzdGF0ZW1lbnQgYW5kIHJldHVybiBpdHMgaWRlbnRpZmllciAqL1xyXG4gICAgcHVibGljIGNyZWF0ZVByZXBhcmVkKGNvbm46IG51bWJlciwgdGV4dDogc3RyaW5nKTogbnVtYmVyIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlJywgWydudW1iZXInLCAnc3RyaW5nJ10sIFtjb25uLCB0ZXh0XSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gZDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBjbG9zZVByZXBhcmVkKGNvbm46IG51bWJlciwgc3RhdGVtZW50OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2UnLCBbJ251bWJlcicsICdudW1iZXInXSwgW2Nvbm4sIHN0YXRlbWVudF0pO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEV4ZWN1dGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgYW5kIHJldHVybiB0aGUgZnVsbCByZXN1bHQgKi9cclxuICAgIHB1YmxpYyBydW5QcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogVWludDhBcnJheSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9wcmVwYXJlZF9ydW4nLFxyXG4gICAgICAgICAgICBbJ251bWJlcicsICdudW1iZXInLCAnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnQsIEpTT04uc3RyaW5naWZ5KHBhcmFtcyldLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXMgPSBjb3B5QnVmZmVyKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFeGVjdXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50IGFuZCBzdHJlYW0gdGhlIHJlc3VsdCAqL1xyXG4gICAgcHVibGljIHNlbmRQcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogVWludDhBcnJheSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kJyxcclxuICAgICAgICAgICAgWydudW1iZXInLCAnbnVtYmVyJywgJ3N0cmluZyddLFxyXG4gICAgICAgICAgICBbY29ubiwgc3RhdGVtZW50LCBKU09OLnN0cmluZ2lmeShwYXJhbXMpXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzID0gY29weUJ1ZmZlcih0aGlzLm1vZCwgZCwgbik7XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IHJlY29yZCBiYXRjaGVzIGZyb20gYW4gYXJyb3cgaXBjIHN0cmVhbSAqL1xyXG4gICAgcHVibGljIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShjb25uOiBudW1iZXIsIGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9ucz86IEFycm93SW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IDApIHJldHVybjtcclxuICAgICAgICAvLyBTdG9yZSBidWZmZXJcclxuICAgICAgICBjb25zdCBidWZmZXJQdHIgPSB0aGlzLm1vZC5fbWFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlck9mcyA9IHRoaXMubW9kLkhFQVBVOC5zdWJhcnJheShidWZmZXJQdHIsIGJ1ZmZlclB0ciArIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGJ1ZmZlck9mcy5zZXQoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCBvcHRKU09OID0gb3B0aW9ucyA/IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpIDogJyc7XHJcblxyXG4gICAgICAgIC8vIENhbGwgd2FzbSBmdW5jdGlvblxyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KFxyXG4gICAgICAgICAgICB0aGlzLm1vZCxcclxuICAgICAgICAgICAgJ2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbScsXHJcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnc3RyaW5nJ10sXHJcbiAgICAgICAgICAgIFtjb25uLCBidWZmZXJQdHIsIGJ1ZmZlci5sZW5ndGgsIG9wdEpTT05dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IGNzdiBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBpbnNlcnRDU1ZGcm9tUGF0aChjb25uOiBudW1iZXIsIHBhdGg6IHN0cmluZywgb3B0aW9uczogQ1NWSW5zZXJ0T3B0aW9ucyk6IHZvaWQge1xyXG4gICAgICAgIC8vIFN0cmluZ2lmeSBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sdW1uc0ZsYXQgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrIGluIG9wdGlvbnMuY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdC5wdXNoKGFycm93VG9TUUxGaWVsZChrLCBvcHRpb25zLmNvbHVtbnNba10pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHQgPSB7IC4uLm9wdGlvbnMgfSBhcyBhbnk7XHJcbiAgICAgICAgb3B0LmNvbHVtbnMgPSBvcHQuY29sdW1uc0ZsYXQ7XHJcbiAgICAgICAgZGVsZXRlIG9wdC5jb2x1bW5zRmxhdDtcclxuICAgICAgICBjb25zdCBvcHRKU09OID0gSlNPTi5zdHJpbmdpZnkob3B0KTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCB3YXNtIGZ1bmN0aW9uXHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aCcsXHJcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ3N0cmluZycsICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdEpTT05dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnQganNvbiBmcm9tIHBhdGggKi9cclxuICAgIHB1YmxpYyBpbnNlcnRKU09ORnJvbVBhdGgoY29ubjogbnVtYmVyLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IEpTT05JbnNlcnRPcHRpb25zKTogdm9pZCB7XHJcbiAgICAgICAgLy8gU3RyaW5naWZ5IG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2x1bW5zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5jb2x1bW5zRmxhdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbHVtbnNGbGF0LnB1c2goYXJyb3dUb1NRTEZpZWxkKGssIG9wdGlvbnMuY29sdW1uc1trXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdCA9IHsgLi4ub3B0aW9ucyB9IGFzIGFueTtcclxuICAgICAgICBvcHQuY29sdW1ucyA9IG9wdC5jb2x1bW5zRmxhdDtcclxuICAgICAgICBkZWxldGUgb3B0LmNvbHVtbnNGbGF0O1xyXG4gICAgICAgIGNvbnN0IG9wdEpTT04gPSBKU09OLnN0cmluZ2lmeShvcHQpO1xyXG5cclxuICAgICAgICAvLyBDYWxsIHdhc20gZnVuY3Rpb25cclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcclxuICAgICAgICAgICAgdGhpcy5tb2QsXHJcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aCcsXHJcbiAgICAgICAgICAgIFsnbnVtYmVyJywgJ3N0cmluZycsICdzdHJpbmcnXSxcclxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdEpTT05dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBHbG9iIGZpbGUgaW5mb3MgKi9cclxuICAgIHB1YmxpYyBnbG9iRmlsZXMocGF0aDogc3RyaW5nKTogV2ViRmlsZVtdIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zJywgWydzdHJpbmcnXSwgW3BhdGhdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZm9TdHIgPSByZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShpbmZvU3RyKSBhcyBXZWJGaWxlW107XHJcbiAgICAgICAgaWYgKGluZm8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmZvO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlZ2lzdGVyIGEgZmlsZSBvYmplY3QgVVJMICovXHJcbiAgICBwdWJsaWMgcmVnaXN0ZXJGaWxlVVJMKG5hbWU6IHN0cmluZywgdXJsOiBzdHJpbmcsIHByb3RvOiBEdWNrREJEYXRhUHJvdG9jb2wsIGRpcmVjdElPID0gZmFsc2UpOiB2b2lkIHtcclxuICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdXJsID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybCcsXHJcbiAgICAgICAgICAgIFsnc3RyaW5nJywgJ3N0cmluZyddLFxyXG4gICAgICAgICAgICBbbmFtZSwgdXJsLCBwcm90bywgZGlyZWN0SU9dLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgIH1cclxuICAgIC8qKiBSZWdpc3RlciBmaWxlIHRleHQgKi9cclxuICAgIHB1YmxpYyByZWdpc3RlckZpbGVUZXh0KG5hbWU6IHN0cmluZywgdGV4dDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gVEVYVF9FTkNPREVSLmVuY29kZSh0ZXh0KTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmlsZUJ1ZmZlcihuYW1lLCBidWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqIFJlZ2lzdGVyIGEgZmlsZSBidWZmZXIgKi9cclxuICAgIHB1YmxpYyByZWdpc3RlckZpbGVCdWZmZXIobmFtZTogc3RyaW5nLCBidWZmZXI6IFVpbnQ4QXJyYXkpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBwdHIgPSB0aGlzLm1vZC5fbWFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGRzdCA9IHRoaXMubW9kLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIGRzdC5zZXQoYnVmZmVyKTtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcclxuICAgICAgICAgICAgdGhpcy5tb2QsXHJcbiAgICAgICAgICAgICdkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyJyxcclxuICAgICAgICAgICAgWydzdHJpbmcnLCAnbnVtYmVyJywgJ251bWJlciddLFxyXG4gICAgICAgICAgICBbbmFtZSwgcHRyLCBidWZmZXIubGVuZ3RoXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmVnaXN0ZXIgYSBmaWxlIG9iamVjdCBVUkwgKi9cclxuICAgIHB1YmxpYyByZWdpc3RlckZpbGVIYW5kbGU8SGFuZGxlVHlwZT4oXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIGhhbmRsZTogSGFuZGxlVHlwZSxcclxuICAgICAgICBwcm90b2NvbDogRHVja0RCRGF0YVByb3RvY29sLFxyXG4gICAgICAgIGRpcmVjdElPOiBib29sZWFuLFxyXG4gICAgKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgIHRoaXMubW9kLFxyXG4gICAgICAgICAgICAnZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybCcsXHJcbiAgICAgICAgICAgIFsnc3RyaW5nJywgJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddLFxyXG4gICAgICAgICAgICBbbmFtZSwgbmFtZSwgcHJvdG9jb2wsIGRpcmVjdElPXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICAgICAgZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5fZmlsZXMgPSAoZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5fZmlsZXMgfHwgbmV3IE1hcCgpKS5zZXQobmFtZSwgaGFuZGxlKTtcclxuICAgICAgICBpZiAodGhpcy5wdGhyZWFkKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIHRoaXMucHRocmVhZC5ydW5uaW5nV29ya2Vycykge1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBjbWQ6ICdyZWdpc3RlckZpbGVIYW5kbGUnLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVIYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIHRoaXMucHRocmVhZC51bnVzZWRXb3JrZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNtZDogJ2Ryb3BGaWxlSGFuZGxlJyxcclxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbmFtZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIERyb3AgZmlsZSAqL1xyXG4gICAgcHVibGljIGRyb3BGaWxlKG5hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9mc19kcm9wX2ZpbGUnLCBbJ3N0cmluZyddLCBbbmFtZV0pO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHJvcFJlc3BvbnNlQnVmZmVycyh0aGlzLm1vZCk7XHJcbiAgICB9XHJcbiAgICAvKiogRHJvcCBmaWxlcyAqL1xyXG4gICAgcHVibGljIGRyb3BGaWxlcygpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlcycsIFtdLCBbXSk7XHJcbiAgICAgICAgaWYgKHMgIT09IFN0YXR1c0NvZGUuU1VDQ0VTUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZyh0aGlzLm1vZCwgZCwgbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgIH1cclxuICAgIC8qKiBGbHVzaCBhbGwgZmlsZXMgKi9cclxuICAgIHB1YmxpYyBmbHVzaEZpbGVzKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubW9kLmNjYWxsKCdkdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzJywgbnVsbCwgW10sIFtdKTtcclxuICAgIH1cclxuICAgIC8qKiBXcml0ZSBhIGZpbGUgdG8gYSBwYXRoICovXHJcbiAgICBwdWJsaWMgY29weUZpbGVUb1BhdGgobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldCh0aGlzLm1vZCwgJ2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGgnLCBbJ3N0cmluZycsICdzdHJpbmcnXSwgW25hbWUsIHBhdGhdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnModGhpcy5tb2QpO1xyXG4gICAgfVxyXG4gICAgLyoqIFdyaXRlIGEgZmlsZSB0byBhIGJ1ZmZlciAqL1xyXG4gICAgcHVibGljIGNvcHlGaWxlVG9CdWZmZXIobmFtZTogc3RyaW5nKTogVWludDhBcnJheSB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXInLCBbJ3N0cmluZyddLCBbbmFtZV0pO1xyXG4gICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYWRTdHJpbmcodGhpcy5tb2QsIGQsIG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5tb2QuSEVBUFU4LnN1YmFycmF5KGQsIGQgKyBuKTtcclxuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLmxlbmd0aCk7XHJcbiAgICAgICAgY29weS5zZXQoYnVmZmVyKTtcclxuICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKHRoaXMubW9kKTtcclxuICAgICAgICByZXR1cm4gY29weTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRW5hYmxlIHRyYWNraW5nIG9mIGZpbGUgc3RhdGlzdGljcyAqL1xyXG4gICAgcHVibGljIGNvbGxlY3RGaWxlU3RhdGlzdGljcyhmaWxlOiBzdHJpbmcsIGVuYWJsZTogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IFtzLCBkLCBuXSA9IGNhbGxTUmV0KHRoaXMubW9kLCAnZHVja2RiX3dlYl9jb2xsZWN0X2ZpbGVfc3RhdHMnLCBbJ3N0cmluZycsICdib29sZWFuJ10sIFtmaWxlLCBlbmFibGVdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEV4cG9ydCBmaWxlIHN0YXRpc3RpY3MgKi9cclxuICAgIHB1YmxpYyBleHBvcnRGaWxlU3RhdGlzdGljcyhmaWxlOiBzdHJpbmcpOiBGaWxlU3RhdGlzdGljcyB7XHJcbiAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQodGhpcy5tb2QsICdkdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzJywgWydzdHJpbmcnXSwgW2ZpbGVdKTtcclxuICAgICAgICBpZiAocyAhPT0gU3RhdHVzQ29kZS5TVUNDRVNTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFkU3RyaW5nKHRoaXMubW9kLCBkLCBuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmlsZVN0YXRpc3RpY3ModGhpcy5tb2QuSEVBUFU4LnN1YmFycmF5KGQsIGQgKyBuKSk7XHJcbiAgICB9XHJcbn1cclxuIiwgImV4cG9ydCBlbnVtIExvZ0xldmVsIHtcclxuICAgIE5PTkUgPSAwLFxyXG4gICAgREVCVUcgPSAxLFxyXG4gICAgSU5GTyA9IDIsXHJcbiAgICBXQVJOSU5HID0gMyxcclxuICAgIEVSUk9SID0gNCxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gTG9nVG9waWMge1xyXG4gICAgTk9ORSA9IDAsXHJcbiAgICBDT05ORUNUID0gMSxcclxuICAgIERJU0NPTk5FQ1QgPSAyLFxyXG4gICAgT1BFTiA9IDMsXHJcbiAgICBRVUVSWSA9IDQsXHJcbiAgICBJTlNUQU5USUFURSA9IDUsXHJcbn1cclxuXHJcbmV4cG9ydCBlbnVtIExvZ0V2ZW50IHtcclxuICAgIE5PTkUgPSAwLFxyXG4gICAgT0sgPSAxLFxyXG4gICAgRVJST1IgPSAyLFxyXG4gICAgU1RBUlQgPSAzLFxyXG4gICAgUlVOID0gNCxcclxuICAgIENBUFRVUkUgPSA1LFxyXG59XHJcblxyXG5leHBvcnQgZW51bSBMb2dPcmlnaW4ge1xyXG4gICAgTk9ORSA9IDAsXHJcbiAgICBXRUJfV09SS0VSID0gMSxcclxuICAgIE5PREVfV09SS0VSID0gMixcclxuICAgIEJJTkRJTkdTID0gMyxcclxuICAgIEFTWU5DX0RVQ0tEQiA9IDQsXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIExvZ0VudHJ5PE8sIFQsIEUsIFY+ID0ge1xyXG4gICAgcmVhZG9ubHkgdGltZXN0YW1wOiBEYXRlO1xyXG4gICAgcmVhZG9ubHkgbGV2ZWw6IExvZ0xldmVsO1xyXG4gICAgcmVhZG9ubHkgb3JpZ2luOiBPO1xyXG4gICAgcmVhZG9ubHkgdG9waWM6IFQ7XHJcbiAgICByZWFkb25seSBldmVudDogRTtcclxuICAgIHJlYWRvbmx5IHZhbHVlOiBWO1xyXG59O1xyXG5cclxuZXhwb3J0IHR5cGUgTG9nRW50cnlWYXJpYW50ID1cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5JTlNUQU5USUFURSwgTG9nRXZlbnQuRVJST1IsIHN0cmluZz5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5RVUVSWSwgTG9nRXZlbnQuU1RBUlQsIHZvaWQ+XHJcbiAgICB8IExvZ0VudHJ5PExvZ09yaWdpbi5CSU5ESU5HUywgTG9nVG9waWMuUVVFUlksIExvZ0V2ZW50Lk9LLCB2b2lkPlxyXG4gICAgfCBMb2dFbnRyeTxMb2dPcmlnaW4uQklORElOR1MsIExvZ1RvcGljLlFVRVJZLCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5DT05ORUNULCBMb2dFdmVudC5PSywgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5DT05ORUNULCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5ESVNDT05ORUNULCBMb2dFdmVudC5PSywgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5ESVNDT05ORUNULCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5TVEFSVCwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5PSywgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkJJTkRJTkdTLCBMb2dUb3BpYy5PUEVOLCBMb2dFdmVudC5FUlJPUiwgdm9pZD5cclxuICAgIHwgTG9nRW50cnk8TG9nT3JpZ2luLkFTWU5DX0RVQ0tEQiwgTG9nVG9waWMuUVVFUlksIExvZ0V2ZW50LlJVTiwgc3RyaW5nPjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyIHtcclxuICAgIGxvZyhlbnRyeTogTG9nRW50cnlWYXJpYW50KTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFZvaWRMb2dnZXIgaW1wbGVtZW50cyBMb2dnZXIge1xyXG4gICAgcHVibGljIGxvZyhfZW50cnk6IExvZ0VudHJ5VmFyaWFudCk6IHZvaWQge31cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENvbnNvbGVMb2dnZXIgaW1wbGVtZW50cyBMb2dnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGxldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk8pIHt9XHJcbiAgICBwdWJsaWMgbG9nKGVudHJ5OiBMb2dFbnRyeVZhcmlhbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZW50cnkubGV2ZWwgPj0gdGhpcy5sZXZlbCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlbnRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9nTGV2ZWxMYWJlbChsZXZlbDogTG9nTGV2ZWwpOiBzdHJpbmcge1xyXG4gICAgc3dpdGNoIChsZXZlbCkge1xyXG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuTk9ORTpcclxuICAgICAgICAgICAgcmV0dXJuICdOT05FJztcclxuICAgICAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0RFQlVHJztcclxuICAgICAgICBjYXNlIExvZ0xldmVsLklORk86XHJcbiAgICAgICAgICAgIHJldHVybiAnSU5GTyc7XHJcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5XQVJOSU5HOlxyXG4gICAgICAgICAgICByZXR1cm4gJ1dBUk5JTkcnO1xyXG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XHJcbiAgICAgICAgICAgIHJldHVybiAnRVJST1InO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnPyc7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dFdmVudExhYmVsKGV2ZW50OiBMb2dFdmVudCk6IHN0cmluZyB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50KSB7XHJcbiAgICAgICAgY2FzZSBMb2dFdmVudC5OT05FOlxyXG4gICAgICAgICAgICByZXR1cm4gJ05PTkUnO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuT0s6XHJcbiAgICAgICAgICAgIHJldHVybiAnT0snO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuRVJST1I6XHJcbiAgICAgICAgICAgIHJldHVybiAnRVJST1InO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuU1RBUlQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnU1RBUlQnO1xyXG4gICAgICAgIGNhc2UgTG9nRXZlbnQuUlVOOlxyXG4gICAgICAgICAgICByZXR1cm4gJ1JVTic7XHJcbiAgICAgICAgY2FzZSBMb2dFdmVudC5DQVBUVVJFOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0NBUFRVUkUnO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnPyc7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dUb3BpY0xhYmVsKHRvcGljOiBMb2dUb3BpYyk6IHN0cmluZyB7XHJcbiAgICBzd2l0Y2ggKHRvcGljKSB7XHJcbiAgICAgICAgY2FzZSBMb2dUb3BpYy5DT05ORUNUOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0NPTk5FQ1QnO1xyXG4gICAgICAgIGNhc2UgTG9nVG9waWMuRElTQ09OTkVDVDpcclxuICAgICAgICAgICAgcmV0dXJuICdESVNDT05ORUNUJztcclxuICAgICAgICBjYXNlIExvZ1RvcGljLklOU1RBTlRJQVRFOlxyXG4gICAgICAgICAgICByZXR1cm4gJ0lOU1RBTlRJQVRFJztcclxuICAgICAgICBjYXNlIExvZ1RvcGljLk9QRU46XHJcbiAgICAgICAgICAgIHJldHVybiAnT1BFTic7XHJcbiAgICAgICAgY2FzZSBMb2dUb3BpYy5RVUVSWTpcclxuICAgICAgICAgICAgcmV0dXJuICdRVUVSWSc7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuICc/JztcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvZ09yaWdpbkxhYmVsKG9yaWdpbjogTG9nT3JpZ2luKTogc3RyaW5nIHtcclxuICAgIHN3aXRjaCAob3JpZ2luKSB7XHJcbiAgICAgICAgY2FzZSBMb2dPcmlnaW4uTk9ORTpcclxuICAgICAgICAgICAgcmV0dXJuICdOT05FJztcclxuICAgICAgICBjYXNlIExvZ09yaWdpbi5XRUJfV09SS0VSOlxyXG4gICAgICAgICAgICByZXR1cm4gJ1dFQiBXT1JLRVInO1xyXG4gICAgICAgIGNhc2UgTG9nT3JpZ2luLk5PREVfV09SS0VSOlxyXG4gICAgICAgICAgICByZXR1cm4gJ05PREUgV09SS0VSJztcclxuICAgICAgICBjYXNlIExvZ09yaWdpbi5CSU5ESU5HUzpcclxuICAgICAgICAgICAgcmV0dXJuICdEVUNLREIgQklORElOR1MnO1xyXG4gICAgICAgIGNhc2UgTG9nT3JpZ2luLkFTWU5DX0RVQ0tEQjpcclxuICAgICAgICAgICAgcmV0dXJuICdEVUNLREInO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAnPyc7XHJcbiAgICB9XHJcbn1cclxuIiwgImV4cG9ydCBjb25zdCBiaWdJbnQ9KCk9Pihhc3luYyBlPT57dHJ5e3JldHVybihhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShlKSkuaW5zdGFuY2UuZXhwb3J0cy5iKEJpZ0ludCgwKSk9PT1CaWdJbnQoMCl9Y2F0Y2goZSl7cmV0dXJuITF9fSkobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNiwxLDk2LDEsMTI2LDEsMTI2LDMsMiwxLDAsNyw1LDEsMSw5OCwwLDAsMTAsNiwxLDQsMCwzMiwwLDExXSkpLGJ1bGtNZW1vcnk9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsMywxLDAsMSwxMCwxNCwxLDEyLDAsNjUsMCw2NSwwLDY1LDAsMjUyLDEwLDAsMCwxMV0pKSxleGNlcHRpb25zPWFzeW5jKCk9PldlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCw4LDEsNiwwLDYsNjQsMjUsMTEsMTFdKSksZXh0ZW5kZWRDb25zdD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsNSwzLDEsMCwxLDExLDksMSwwLDY1LDEsNjUsMiwxMDYsMTEsMF0pKSxnYz1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSwxMCwyLDk1LDEsMTI1LDAsOTYsMCwxLDEwNywwLDMsMiwxLDEsMTAsMTIsMSwxMCwwLDY3LDAsMCwwLDAsMjUxLDcsMCwxMV0pKSxtZW1vcnk2ND1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsNSwzLDEsNCwxXSkpLG11bHRpVmFsdWU9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNiwxLDk2LDAsMiwxMjcsMTI3LDMsMiwxLDAsMTAsOCwxLDYsMCw2NSwwLDY1LDAsMTFdKSksbXV0YWJsZUdsb2JhbHM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDIsOCwxLDEsOTcsMSw5OCwzLDEyNywxLDYsNiwxLDEyNywxLDY1LDAsMTEsNyw1LDEsMSw5NywzLDFdKSkscmVmZXJlbmNlVHlwZXM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDcsMSw1LDAsMjA4LDExMiwyNiwxMV0pKSxyZWxheGVkU2ltZD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw1LDEsOTYsMCwxLDEyMywzLDIsMSwwLDEwLDE1LDEsMTMsMCw2NSwxLDI1MywxNSw2NSwyLDI1MywxNSwyNTMsMTI4LDIsMTFdKSksc2F0dXJhdGVkRmxvYXRUb0ludD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMTIsMSwxMCwwLDY3LDAsMCwwLDAsMjUyLDAsMjYsMTFdKSksc2lnbkV4dGVuc2lvbnM9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDgsMSw2LDAsNjUsMCwxOTIsMjYsMTFdKSksc2ltZD1hc3luYygpPT5XZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw1LDEsOTYsMCwxLDEyMywzLDIsMSwwLDEwLDEwLDEsOCwwLDY1LDAsMjUzLDE1LDI1Myw5OCwxMV0pKSxzdHJlYW1pbmdDb21waWxhdGlvbj0oKT0+KGFzeW5jKCk9PlwiY29tcGlsZVN0cmVhbWluZ1wiaW4gV2ViQXNzZW1ibHkpKCksdGFpbENhbGw9YXN5bmMoKT0+V2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDYsMSw0LDAsMTgsMCwxMV0pKSx0aHJlYWRzPSgpPT4oYXN5bmMgZT0+e3RyeXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgTWVzc2FnZUNoYW5uZWwmJihuZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUoZSl9Y2F0Y2goZSl7cmV0dXJuITF9fSkobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKTtcbiIsICJpbXBvcnQgKiBhcyBjaGVjayBmcm9tICd3YXNtLWZlYXR1cmUtZGV0ZWN0JztcclxuaW1wb3J0IHsgUEFDS0FHRV9OQU1FLCBQQUNLQUdFX1ZFUlNJT04gfSBmcm9tICcuL3ZlcnNpb24nO1xyXG5cclxuLy8gUGxhdGZvcm0gY2hlY2sgdGFrZW4gZnJvbSBoZXJlOlxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20veHRlcm1qcy94dGVybS5qcy9ibG9iL21hc3Rlci9zcmMvY29tbW9uL1BsYXRmb3JtLnRzI0wyMVxyXG5cclxuaW50ZXJmYWNlIElOYXZpZ2F0b3Ige1xyXG4gICAgdXNlckFnZW50OiBzdHJpbmc7XHJcbiAgICBsYW5ndWFnZTogc3RyaW5nO1xyXG4gICAgcGxhdGZvcm06IHN0cmluZztcclxufVxyXG5cclxuLy8gV2UncmUgZGVjbGFyaW5nIGEgbmF2aWdhdG9yIGdsb2JhbCBoZXJlIGFzIHdlIGV4cGVjdCBpdCBpbiBhbGwgcnVudGltZXMgKG5vZGUgYW5kIGJyb3dzZXIpLCBidXRcclxuLy8gd2Ugd2FudCB0aGlzIG1vZHVsZSB0byBsaXZlIGluIGNvbW1vbi5cclxuZGVjbGFyZSBjb25zdCBuYXZpZ2F0b3I6IElOYXZpZ2F0b3I7XHJcblxyXG5leHBvcnQgY29uc3QgaXNOb2RlID0gKCkgPT4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGZhbHNlKTtcclxuY29uc3QgdXNlckFnZW50ID0gKCkgPT4gKGlzTm9kZSgpID8gJ25vZGUnIDogbmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbmV4cG9ydCBjb25zdCBpc0ZpcmVmb3ggPSAoKSA9PiB1c2VyQWdlbnQoKS5pbmNsdWRlcygnRmlyZWZveCcpO1xyXG5leHBvcnQgY29uc3QgaXNTYWZhcmkgPSAoKSA9PiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCgpKTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRHVja0RCQnVuZGxlcyB7XHJcbiAgICBtdnA6IHtcclxuICAgICAgICBtYWluTW9kdWxlOiBzdHJpbmc7XHJcbiAgICAgICAgbWFpbldvcmtlcjogc3RyaW5nO1xyXG4gICAgfTtcclxuICAgIGVoPzoge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IHN0cmluZztcclxuICAgICAgICBtYWluV29ya2VyOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgY29pPzoge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IHN0cmluZztcclxuICAgICAgICBtYWluV29ya2VyOiBzdHJpbmc7XHJcbiAgICAgICAgcHRocmVhZFdvcmtlcjogc3RyaW5nO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEpzRGVsaXZyQnVuZGxlcygpOiBEdWNrREJCdW5kbGVzIHtcclxuICAgIGNvbnN0IGpzZGVsaXZyX2Rpc3RfdXJsID0gYGh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vJHtQQUNLQUdFX05BTUV9QCR7UEFDS0FHRV9WRVJTSU9OfS9kaXN0L2A7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG12cDoge1xyXG4gICAgICAgICAgICBtYWluTW9kdWxlOiBgJHtqc2RlbGl2cl9kaXN0X3VybH1kdWNrZGItbXZwLndhc21gLFxyXG4gICAgICAgICAgICBtYWluV29ya2VyOiBgJHtqc2RlbGl2cl9kaXN0X3VybH1kdWNrZGItYnJvd3Nlci1tdnAud29ya2VyLmpzYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVoOiB7XHJcbiAgICAgICAgICAgIG1haW5Nb2R1bGU6IGAke2pzZGVsaXZyX2Rpc3RfdXJsfWR1Y2tkYi1laC53YXNtYCxcclxuICAgICAgICAgICAgbWFpbldvcmtlcjogYCR7anNkZWxpdnJfZGlzdF91cmx9ZHVja2RiLWJyb3dzZXItZWgud29ya2VyLmpzYCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIENPSSBpcyBzdGlsbCBleHBlcmltZW50YWwsIGxldCB0aGUgdXNlciBvcHQgaW4gZXhwbGljaXRseVxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEdWNrREJCdW5kbGUge1xyXG4gICAgbWFpbk1vZHVsZTogc3RyaW5nO1xyXG4gICAgbWFpbldvcmtlcjogc3RyaW5nIHwgbnVsbDtcclxuICAgIHB0aHJlYWRXb3JrZXI6IHN0cmluZyB8IG51bGw7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGxhdGZvcm1GZWF0dXJlcyB7XHJcbiAgICBiaWdJbnQ2NEFycmF5OiBib29sZWFuO1xyXG4gICAgY3Jvc3NPcmlnaW5Jc29sYXRlZDogYm9vbGVhbjtcclxuICAgIHdhc21FeGNlcHRpb25zOiBib29sZWFuO1xyXG4gICAgd2FzbVNJTUQ6IGJvb2xlYW47XHJcbiAgICB3YXNtQnVsa01lbW9yeTogYm9vbGVhbjtcclxuICAgIHdhc21UaHJlYWRzOiBib29sZWFuO1xyXG59XHJcblxyXG5sZXQgYmlnSW50NjRBcnJheTogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xyXG5sZXQgd2FzbUV4Y2VwdGlvbnM6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxubGV0IHdhc21UaHJlYWRzOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XHJcbmxldCB3YXNtU0lNRDogYm9vbGVhbiB8IG51bGwgPSBudWxsO1xyXG5sZXQgd2FzbUJ1bGtNZW1vcnk6IGJvb2xlYW4gfCBudWxsID0gbnVsbDtcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbmFtZXNwYWNlXHJcbmRlY2xhcmUgbmFtZXNwYWNlIGdsb2JhbFRoaXMge1xyXG4gICAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWQ6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQbGF0Zm9ybUZlYXR1cmVzKCk6IFByb21pc2U8UGxhdGZvcm1GZWF0dXJlcz4ge1xyXG4gICAgaWYgKGJpZ0ludDY0QXJyYXkgPT0gbnVsbCkge1xyXG4gICAgICAgIGJpZ0ludDY0QXJyYXkgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPSAndW5kZWZpbmVkJztcclxuICAgIH1cclxuICAgIGlmICh3YXNtRXhjZXB0aW9ucyA9PSBudWxsKSB7XHJcbiAgICAgICAgd2FzbUV4Y2VwdGlvbnMgPSBhd2FpdCBjaGVjay5leGNlcHRpb25zKCk7XHJcbiAgICB9XHJcbiAgICBpZiAod2FzbVRocmVhZHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHdhc21UaHJlYWRzID0gYXdhaXQgY2hlY2sudGhyZWFkcygpO1xyXG4gICAgfVxyXG4gICAgaWYgKHdhc21TSU1EID09IG51bGwpIHtcclxuICAgICAgICB3YXNtU0lNRCA9IGF3YWl0IGNoZWNrLnNpbWQoKTtcclxuICAgIH1cclxuICAgIGlmICh3YXNtQnVsa01lbW9yeSA9PSBudWxsKSB7XHJcbiAgICAgICAgd2FzbUJ1bGtNZW1vcnkgPSBhd2FpdCBjaGVjay5idWxrTWVtb3J5KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJpZ0ludDY0QXJyYXk6IGJpZ0ludDY0QXJyYXkhLFxyXG4gICAgICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWQ6IGlzTm9kZSgpIHx8IGdsb2JhbFRoaXMuY3Jvc3NPcmlnaW5Jc29sYXRlZCB8fCBmYWxzZSxcclxuICAgICAgICB3YXNtRXhjZXB0aW9uczogd2FzbUV4Y2VwdGlvbnMhLFxyXG4gICAgICAgIHdhc21TSU1EOiB3YXNtU0lNRCEsXHJcbiAgICAgICAgd2FzbVRocmVhZHM6IHdhc21UaHJlYWRzISxcclxuICAgICAgICB3YXNtQnVsa01lbW9yeTogd2FzbUJ1bGtNZW1vcnkhLFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNlbGVjdEJ1bmRsZShidW5kbGVzOiBEdWNrREJCdW5kbGVzKTogUHJvbWlzZTxEdWNrREJCdW5kbGU+IHtcclxuICAgIGNvbnN0IHBsYXRmb3JtID0gYXdhaXQgZ2V0UGxhdGZvcm1GZWF0dXJlcygpO1xyXG4gICAgaWYgKHBsYXRmb3JtLndhc21FeGNlcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHBsYXRmb3JtLndhc21TSU1EICYmIHBsYXRmb3JtLndhc21UaHJlYWRzICYmIHBsYXRmb3JtLmNyb3NzT3JpZ2luSXNvbGF0ZWQgJiYgYnVuZGxlcy5jb2kpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1haW5Nb2R1bGU6IGJ1bmRsZXMuY29pLm1haW5Nb2R1bGUsXHJcbiAgICAgICAgICAgICAgICBtYWluV29ya2VyOiBidW5kbGVzLmNvaS5tYWluV29ya2VyLFxyXG4gICAgICAgICAgICAgICAgcHRocmVhZFdvcmtlcjogYnVuZGxlcy5jb2kucHRocmVhZFdvcmtlcixcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJ1bmRsZXMuZWgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1haW5Nb2R1bGU6IGJ1bmRsZXMuZWgubWFpbk1vZHVsZSxcclxuICAgICAgICAgICAgICAgIG1haW5Xb3JrZXI6IGJ1bmRsZXMuZWgubWFpbldvcmtlcixcclxuICAgICAgICAgICAgICAgIHB0aHJlYWRXb3JrZXI6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYWluTW9kdWxlOiBidW5kbGVzLm12cC5tYWluTW9kdWxlLFxyXG4gICAgICAgIG1haW5Xb3JrZXI6IGJ1bmRsZXMubXZwLm1haW5Xb3JrZXIsXHJcbiAgICAgICAgcHRocmVhZFdvcmtlcjogbnVsbCxcclxuICAgIH07XHJcbn1cclxuIiwgImltcG9ydCB7UzNDb25maWd9IGZyb20gXCIuLi9iaW5kaW5nc1wiO1xyXG5pbXBvcnQge3NoYTI1Nn0gZnJvbSBcImpzLXNoYTI1NlwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTM1BhcmFtcyB7XHJcbiAgICB1cmw6IHN0cmluZyxcclxuICAgIHF1ZXJ5OiBzdHJpbmcsXHJcbiAgICBob3N0OiBzdHJpbmcsXHJcbiAgICByZWdpb246IHN0cmluZyxcclxuICAgIHNlcnZpY2U6IHN0cmluZyxcclxuICAgIG1ldGhvZDogc3RyaW5nLFxyXG4gICAgYWNjZXNzS2V5SWQ6IHN0cmluZyxcclxuICAgIHNlY3JldEFjY2Vzc0tleTogc3RyaW5nLFxyXG4gICAgc2Vzc2lvblRva2VuOiBzdHJpbmcsXHJcbiAgICBkYXRlTm93OiBzdHJpbmcsXHJcbiAgICBkYXRldGltZU5vdzogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUzNQYXlsb2FkUGFyYW1zIHtcclxuICAgIGNvbnRlbnRIYXNoOiBzdHJpbmcgfCBudWxsLFxyXG4gICAgY29udGVudFR5cGU6IHN0cmluZyB8IG51bGxcclxufVxyXG5cclxuY29uc3QgZ2V0SFRUUEhvc3QgPSBmdW5jdGlvbiAoY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZywgYnVja2V0IDogc3RyaW5nKSA6IHN0cmluZyB7XHJcbiAgICBpZiAoY29uZmlnPy5lbmRwb2ludD8uc3RhcnRzV2l0aChcImh0dHBcIikpIHtcclxuICAgICAgICAvLyBFbmRwb2ludCBpcyBhIGZ1bGwgdXJsLCB3ZSBhcHBlbmQgdGhlIGJ1Y2tldFxyXG4gICAgICAgIGNvbnN0IGh0dHBIb3N0ID0gYCR7Y29uZmlnPy5lbmRwb2ludH1gO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGh0dHBIb3N0LmluZGV4T2YoXCI6Ly9cIikrMztcclxuICAgICAgICByZXR1cm4gaHR0cEhvc3Quc3Vic3RyaW5nKG9mZnNldCk7XHJcbiAgICB9IGVsc2UgaWYgKGNvbmZpZz8uZW5kcG9pbnQpIHtcclxuICAgICAgICAvLyBFbmRwb2ludCBpcyBub3QgYSBmdWxsIHVybCBhbmQgdGhlIGh0dHBzOi8ve2J1Y2tldH0ue2RvbWFpbn0gZm9ybWF0IHdpbGwgYmUgdXNlZFxyXG4gICAgICAgIHJldHVybiBgJHtidWNrZXR9LiR7Y29uZmlnPy5lbmRwb2ludH1gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBEZWZhdWx0IGF3cyBzMyB1cmxcclxuICAgICAgICByZXR1cm4gYCR7YnVja2V0fS5zMy5hbWF6b25hd3MuY29tYDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFMzUGFyYW1zIChjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCwgdXJsOiBzdHJpbmcsIG1ldGhvZCA6IHN0cmluZykgOiBTM1BhcmFtcyB7XHJcbiAgICBjb25zdCBwYXJzZWRTM1VybCA9IHBhcnNlUzNVcmwodXJsKTtcclxuXHJcbiAgICAvLyB3aGVuIHVzaW5nIFMzIHBhdGgtc3R5bGUgYWNjZXNzLCB0aGUgc2lnbmVkIFVSTCBzaG91bGQgYWxzbyBpbmNsdWRlIHRoZSBidWNrZXQgbmFtZSwgXHJcbiAgICAvLyAgYXMgaXQgaXMgcHJlc2VudCBpbiB0aGUgSFRUUCBVUkwgcGF0aC5cclxuICAgIC8vIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC91c2VyZ3VpZGUvYWNjZXNzLWJ1Y2tldC1pbnRyby5odG1sI3BhdGgtc3R5bGUtdXJsLWV4XHJcbiAgICBsZXQgcGF0aCA9ICBwYXJzZWRTM1VybC5wYXRoO1xyXG4gICAgaWYgKGlzUGF0aFN0eWxlQWNjZXNzKGNvbmZpZykpIHtcclxuICAgICAgICBwYXRoID0gYC8ke3BhcnNlZFMzVXJsLmJ1Y2tldH0ke3BhdGh9YDtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXJsOiBwYXRoLFxyXG4gICAgICAgIHF1ZXJ5OiBcIlwiLFxyXG4gICAgICAgIGhvc3Q6IGdldEhUVFBIb3N0KGNvbmZpZywgdXJsLCBwYXJzZWRTM1VybC5idWNrZXQpLFxyXG4gICAgICAgIHJlZ2lvbjogKGNvbmZpZz8ucmVnaW9uKSA/PyBcIlwiLFxyXG4gICAgICAgIHNlcnZpY2U6IFwiczNcIixcclxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcclxuICAgICAgICBhY2Nlc3NLZXlJZDogKGNvbmZpZz8uYWNjZXNzS2V5SWQpID8/IFwiXCIsXHJcbiAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAoY29uZmlnPy5zZWNyZXRBY2Nlc3NLZXkpID8/IFwiXCIsXHJcbiAgICAgICAgc2Vzc2lvblRva2VuOiAoY29uZmlnPy5zZXNzaW9uVG9rZW4pID8/IFwiXCIsXHJcbiAgICAgICAgZGF0ZU5vdzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoLy0vZywnJykuc3BsaXQoJ1QnKVswXSxcclxuICAgICAgICBkYXRldGltZU5vdzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoLy0vZywnJykucmVwbGFjZSgvOi9nLCcnKS5zcGxpdCgnLicpWzBdKyAnWicsXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXJpRW5jb2RlKGlucHV0IDogc3RyaW5nLCBlbmNvZGVfc2xhc2ggPSBmYWxzZSkge1xyXG4gICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FtYXpvblMzL2xhdGVzdC9BUEkvc2lndjQtcXVlcnktc3RyaW5nLWF1dGguaHRtbFxyXG5cclxuICAgIGNvbnN0IGhleERpZ2l0ID0gXCIwMTIzNDU2Nzg5QUJDREVGXCI7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgY2ggOiBzdHJpbmcgPSBpbnB1dFtpXTtcclxuXHJcbiAgICAgICAgaWYgKChjaCA+PSAnQScgJiYgY2ggPD0gJ1onKSB8fCAoY2ggPj0gJ2EnICYmIGNoIDw9ICd6JykgfHwgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHx8IGNoID09ICdfJyB8fFxyXG4gICAgICAgICAgICBjaCA9PSAnLScgfHwgY2ggPT0gJ34nIHx8IGNoID09ICcuJykge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PSAnLycpIHtcclxuICAgICAgICAgICAgaWYgKGVuY29kZV9zbGFzaCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJTJGXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIlXCI7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBoZXhEaWdpdFtjaC5jaGFyQ29kZUF0KDApID4+IDRdO1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gaGV4RGlnaXRbY2guY2hhckNvZGVBdCgwKSAmIDE1XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUzNIZWFkZXJzKHBhcmFtczogUzNQYXJhbXMsIHBheWxvYWRQYXJhbXMgOiBTM1BheWxvYWRQYXJhbXMgfCBudWxsID0gbnVsbCkgOiBNYXA8c3RyaW5nLCBzdHJpbmc+IHtcclxuICAgIC8vIHRoaXMgaXMgdGhlIHNoYTI1NiBvZiB0aGUgZW1wdHkgc3RyaW5nLCBpdHMgdXNlZnVsIHNpbmNlIHdlIGhhdmUgbm8gcGF5bG9hZCBmb3IgR0VUIHJlcXVlc3RzXHJcbiAgICBjb25zdCBwYXlsb2FkSGFzaCA9IChwYXlsb2FkUGFyYW1zPy5jb250ZW50SGFzaCkgPz8gXCJlM2IwYzQ0Mjk4ZmMxYzE0OWFmYmY0Yzg5OTZmYjkyNDI3YWU0MWU0NjQ5YjkzNGNhNDk1OTkxYjc4NTJiODU1XCI7XHJcblxyXG4gICAgY29uc3QgcmVzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcclxuICAgIC8vIHJlcy5zZXQoXCJob3N0XCIsIHBhcmFtcy5ob3N0KVxyXG4gICAgcmVzLnNldChcIngtYW16LWRhdGVcIiwgcGFyYW1zLmRhdGV0aW1lTm93KTtcclxuICAgIHJlcy5zZXQoXCJ4LWFtei1jb250ZW50LXNoYTI1NlwiLCBwYXlsb2FkSGFzaCk7XHJcblxyXG4gICAgaWYgKHBhcmFtcy5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICByZXMuc2V0KFwieC1hbXotc2VjdXJpdHktdG9rZW5cIiwgcGFyYW1zLnNlc3Npb25Ub2tlbik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gY29uc3RydWN0IHN0cmluZyB0byBzaWduXHJcbiAgICBsZXQgc2lnbmVkSGVhZGVycyA9IFwiXCI7XHJcbiAgICBpZiAocGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGUpIHtcclxuICAgICAgICBzaWduZWRIZWFkZXJzICs9IFwiY29udGVudC10eXBlO1wiO1xyXG4gICAgfVxyXG4gICAgc2lnbmVkSGVhZGVycyArPSBcImhvc3Q7eC1hbXotY29udGVudC1zaGEyNTY7eC1hbXotZGF0ZVwiO1xyXG4gICAgaWYgKHBhcmFtcy5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICBzaWduZWRIZWFkZXJzICs9IFwiO3gtYW16LXNlY3VyaXR5LXRva2VuXCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNhbm9uaWNhbFJlcXVlc3QgPSBwYXJhbXMubWV0aG9kICsgXCJcXG5cIiArIHVyaUVuY29kZShwYXJhbXMudXJsKSArIFwiXFxuXCIgKyBwYXJhbXMucXVlcnk7XHJcbiAgICBpZiAocGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGUpIHtcclxuICAgICAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxuY29udGVudC10eXBlOlwiICsgcGF5bG9hZFBhcmFtcz8uY29udGVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxuaG9zdDpcIiArIHBhcmFtcy5ob3N0ICtcclxuICAgICAgICBcIlxcbngtYW16LWNvbnRlbnQtc2hhMjU2OlwiICsgcGF5bG9hZEhhc2ggKyBcIlxcbngtYW16LWRhdGU6XCIgKyBwYXJhbXMuZGF0ZXRpbWVOb3c7XHJcbiAgICBpZiAocGFyYW1zLnNlc3Npb25Ub2tlbiAmJiBwYXJhbXMuc2Vzc2lvblRva2VuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjYW5vbmljYWxSZXF1ZXN0ICs9IFwiXFxueC1hbXotc2VjdXJpdHktdG9rZW46XCIgKyBwYXJhbXMuc2Vzc2lvblRva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIGNhbm9uaWNhbFJlcXVlc3QgKz0gXCJcXG5cXG5cIiArIHNpZ25lZEhlYWRlcnMgKyBcIlxcblwiICsgcGF5bG9hZEhhc2g7XHJcbiAgICBjb25zdCBjYW5vbmljYWxSZXF1ZXN0SGFzaFN0ciA9IHNoYTI1NihjYW5vbmljYWxSZXF1ZXN0KTtcclxuXHJcbiAgICBjb25zdCBzdHJpbmdUb1NpZ24gPSBcIkFXUzQtSE1BQy1TSEEyNTZcXG5cIiArIHBhcmFtcy5kYXRldGltZU5vdyArIFwiXFxuXCIgKyBwYXJhbXMuZGF0ZU5vdyArIFwiL1wiICsgcGFyYW1zLnJlZ2lvbiArIFwiL1wiICsgcGFyYW1zLnNlcnZpY2UgK1xyXG4gICAgICAgIFwiL2F3czRfcmVxdWVzdFxcblwiICsgY2Fub25pY2FsUmVxdWVzdEhhc2hTdHI7XHJcblxyXG4gICAgLy8gdHMtaWdub3JlJ3MgYmVjYXVzZSBsaWJyYXJ5IGNhbiBhY2NlcHQgYXJyYXkgYnVmZmVyIGFzIGtleSwgYnV0IFRTIGFyZyBpcyBpbmNvcnJlY3RcclxuICAgIGNvbnN0IHNpZ25LZXkgPSBcIkFXUzRcIiArIHBhcmFtcy5zZWNyZXRBY2Nlc3NLZXk7XHJcbiAgICBjb25zdCBrRGF0ZSA9IHNoYTI1Ni5obWFjLmFycmF5QnVmZmVyKHNpZ25LZXksIHBhcmFtcy5kYXRlTm93KTtcclxuXHJcbiAgICAvLyBOb3RlLCBqcy1zaGEyNTYgaGFzIGEgYnVnIGluIHRoZSBUUyBpbnRlcmZhY2UgdGhhdCBvbmx5IHN1cHBvcnRzIHN0cmluZ3MgYXMga2V5cywgd2hpbGUgd2UgbmVlZCBhIGJ5dGVhcnJheVxyXG4gICAgLy8gYXMga2V5LiBQUiBpcyBvcGVuIGJ1dCB1bm1lcmdlZDogaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEyNTYvcHVsbC8yNVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBjb25zdCBrUmVnaW9uID0gc2hhMjU2LmhtYWMuYXJyYXlCdWZmZXIoa0RhdGUsIHBhcmFtcy5yZWdpb24pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAvLyBAdHMtaWdub3JlXHJcbiAgICBjb25zdCBrU2VydmljZSA9IHNoYTI1Ni5obWFjLmFycmF5QnVmZmVyKGtSZWdpb24sIHBhcmFtcy5zZXJ2aWNlLCk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBzaGEyNTYuaG1hYy5hcnJheUJ1ZmZlcihrU2VydmljZSwgXCJhd3M0X3JlcXVlc3RcIik7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNoYTI1Ni5obWFjKHNpZ25pbmdLZXksIHN0cmluZ1RvU2lnbik7XHJcblxyXG4gICAgcmVzLnNldChcIkF1dGhvcml6YXRpb25cIiwgXCJBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9XCIgKyBwYXJhbXMuYWNjZXNzS2V5SWQgKyBcIi9cIiArIHBhcmFtcy5kYXRlTm93ICsgXCIvXCIgKyBwYXJhbXMucmVnaW9uICsgXCIvXCIgK1xyXG4gICAgICAgIHBhcmFtcy5zZXJ2aWNlICsgXCIvYXdzNF9yZXF1ZXN0LCBTaWduZWRIZWFkZXJzPVwiICsgc2lnbmVkSGVhZGVycyArXHJcbiAgICAgICAgXCIsIFNpZ25hdHVyZT1cIiArIHNpZ25hdHVyZSk7XHJcblxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5cclxuY29uc3QgY3JlYXRlUzNIZWFkZXJzRnJvbVMzQ29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZyA6IFMzQ29uZmlnIHwgdW5kZWZpbmVkLCB1cmwgOiBzdHJpbmcsIG1ldGhvZCA6IHN0cmluZywgY29udGVudFR5cGU6IHN0cmluZyB8IG51bGwgPSBudWxsLCBwYXlsb2FkIDogVWludDhBcnJheSB8IG51bGwgPSBudWxsKSA6IE1hcDxzdHJpbmcsIHN0cmluZz4ge1xyXG4gICAgY29uc3QgcGFyYW1zID0gZ2V0UzNQYXJhbXMoY29uZmlnLCB1cmwsIG1ldGhvZCk7XHJcbiAgICBjb25zdCBwYXlsb2FkUGFyYW1zID0ge1xyXG4gICAgICAgIGNvbnRlbnRUeXBlOiBjb250ZW50VHlwZSxcclxuICAgICAgICBjb250ZW50SGFzaDogcGF5bG9hZCA/IHNoYTI1Ni5oZXgocGF5bG9hZCEpIDogbnVsbFxyXG4gICAgfSBhcyBTM1BheWxvYWRQYXJhbXM7XHJcbiAgICByZXR1cm4gY3JlYXRlUzNIZWFkZXJzKHBhcmFtcywgcGF5bG9hZFBhcmFtcyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRTM0hlYWRlcnMoeGhyOiBYTUxIdHRwUmVxdWVzdCwgY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZywgbWV0aG9kOiBzdHJpbmcsIGNvbnRlbnRUeXBlOiBzdHJpbmcgfCBudWxsID0gbnVsbCwgcGF5bG9hZCA6IFVpbnQ4QXJyYXkgfCBudWxsID0gbnVsbCkge1xyXG4gICAgaWYgKGNvbmZpZz8uYWNjZXNzS2V5SWQgfHwgY29uZmlnPy5zZXNzaW9uVG9rZW4pIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gY3JlYXRlUzNIZWFkZXJzRnJvbVMzQ29uZmlnKGNvbmZpZywgdXJsLCBtZXRob2QsIGNvbnRlbnRUeXBlLCBwYXlsb2FkKTtcclxuICAgICAgICBoZWFkZXJzLmZvckVhY2goKHZhbHVlOiBzdHJpbmcsIGhlYWRlcjogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlciwgdmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcclxuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJjb250ZW50LXR5cGVcIiwgY29udGVudFR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUzNVcmwgKHVybDogc3RyaW5nKSA6IHtidWNrZXQgOiBzdHJpbmcsIHBhdGggOiBzdHJpbmd9IHtcclxuICAgIGlmICh1cmwuaW5kZXhPZihcInMzOi8vXCIpICE9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgbmVlZHMgdG8gc3RhcnQgd2l0aCBzMzovL1wiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNsYXNoUG9zID0gdXJsLmluZGV4T2YoJy8nLCA1KTtcclxuXHJcbiAgICBpZiAoc2xhc2hQb3MgPT0gLTEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgbmVlZHMgdG8gY29udGFpbiBhICcvJyBhZnRlciB0aGUgaG9zdFwiKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBidWNrZXQgPSB1cmwuc3Vic3RyaW5nKDUsIHNsYXNoUG9zKTtcclxuICAgIGlmICghYnVja2V0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVVJMIG5lZWRzIHRvIGNvbnRhaW4gYSBidWNrZXQgbmFtZVwiKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhdGggPSB1cmwuc3Vic3RyaW5nKHNsYXNoUG9zKTtcclxuICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBuZWVkcyB0byBjb250YWluIGtleVwiKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge2J1Y2tldDogYnVja2V0LCBwYXRoOiBwYXRofVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1BhdGhTdHlsZUFjY2Vzcyhjb25maWcgOiBTM0NvbmZpZyB8IHVuZGVmaW5lZCkgOiBib29sZWFuIHtcclxuICAgIGlmIChjb25maWc/LmVuZHBvaW50Py5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2VcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhUVFBVcmwoY29uZmlnIDogUzNDb25maWcgfCB1bmRlZmluZWQsIHVybCA6IHN0cmluZykgOiBzdHJpbmcge1xyXG4gICAgY29uc3QgcGFyc2VkVXJsID0gcGFyc2VTM1VybCh1cmwpO1xyXG4gICAgaWYgKGlzUGF0aFN0eWxlQWNjZXNzKGNvbmZpZykpIHtcclxuICAgICAgICAvLyBFbmRwb2ludCBpcyBhIGZ1bGwgdXJsLCB3ZSBhcHBlbmQgdGhlIGJ1Y2tldFxyXG4gICAgICAgIHJldHVybiBgJHtjb25maWc/LmVuZHBvaW50fS8ke3BhcnNlZFVybC5idWNrZXR9YCArIHBhcnNlZFVybC5wYXRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICdodHRwczovLycgKyBnZXRIVFRQSG9zdChjb25maWcsIHVybCwgcGFyc2VkVXJsLmJ1Y2tldCkgKyBwYXJzZWRVcmwucGF0aDtcclxufSIsICJpbXBvcnQgeyBTdGF0dXNDb2RlIH0gZnJvbSAnLi4vc3RhdHVzJztcclxuaW1wb3J0IHsgYWRkUzNIZWFkZXJzLCBnZXRIVFRQVXJsIH0gZnJvbSAnLi4vdXRpbHMnO1xyXG5cclxuaW1wb3J0IHtcclxuICAgIGNhbGxTUmV0LFxyXG4gICAgZHJvcFJlc3BvbnNlQnVmZmVycyxcclxuICAgIER1Y2tEQkRhdGFQcm90b2NvbCxcclxuICAgIER1Y2tEQkZpbGVJbmZvLFxyXG4gICAgRHVja0RCR2xvYmFsRmlsZUluZm8sXHJcbiAgICBEdWNrREJSdW50aW1lLFxyXG4gICAgZmFpbFdpdGgsXHJcbiAgICBGaWxlRmxhZ3MsXHJcbiAgICByZWFkU3RyaW5nLFxyXG59IGZyb20gJy4vcnVudGltZSc7XHJcbmltcG9ydCB7IER1Y2tEQk1vZHVsZSB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XHJcbmltcG9ydCAqIGFzIHVkZiBmcm9tICcuL3VkZl9ydW50aW1lJztcclxuXHJcbmV4cG9ydCBjb25zdCBCUk9XU0VSX1JVTlRJTUU6IER1Y2tEQlJ1bnRpbWUgJiB7XHJcbiAgICBfZmlsZUluZm9DYWNoZTogTWFwPG51bWJlciwgRHVja0RCRmlsZUluZm8+O1xyXG4gICAgX2dsb2JhbEZpbGVJbmZvOiBEdWNrREJHbG9iYWxGaWxlSW5mbyB8IG51bGw7XHJcblxyXG4gICAgZ2V0RmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyKTogRHVja0RCRmlsZUluZm8gfCBudWxsO1xyXG4gICAgZ2V0R2xvYmFsRmlsZUluZm8obW9kOiBEdWNrREJNb2R1bGUpOiBEdWNrREJHbG9iYWxGaWxlSW5mbyB8IG51bGw7XHJcbn0gPSB7XHJcbiAgICBfZmlsZXM6IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCksXHJcbiAgICBfZmlsZUluZm9DYWNoZTogbmV3IE1hcDxudW1iZXIsIER1Y2tEQkZpbGVJbmZvPigpLFxyXG4gICAgX3VkZkZ1bmN0aW9uczogbmV3IE1hcCgpLFxyXG4gICAgX2dsb2JhbEZpbGVJbmZvOiBudWxsLFxyXG5cclxuICAgIGdldEZpbGVJbmZvKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlcik6IER1Y2tEQkZpbGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGVkID0gQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmdldChmaWxlSWQpO1xyXG4gICAgICAgICAgICBjb25zdCBbcywgZCwgbl0gPSBjYWxsU1JldChcclxuICAgICAgICAgICAgICAgIG1vZCxcclxuICAgICAgICAgICAgICAgICdkdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWQnLFxyXG4gICAgICAgICAgICAgICAgWydudW1iZXInLCAnbnVtYmVyJ10sXHJcbiAgICAgICAgICAgICAgICBbZmlsZUlkLCBjYWNoZWQ/LmNhY2hlRXBvY2ggfHwgMF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEVwb2NoIGlzIHVwIHRvIGRhdGVcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWQhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGluZm9TdHIgPSByZWFkU3RyaW5nKG1vZCwgZCwgbik7XHJcbiAgICAgICAgICAgIGRyb3BSZXNwb25zZUJ1ZmZlcnMobW9kKTtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UoaW5mb1N0cik7XHJcbiAgICAgICAgICAgIGlmIChpbmZvID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB7IC4uLmluZm8sIGJsb2I6IG51bGwgfSBhcyBEdWNrREJGaWxlSW5mbztcclxuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLnNldChmaWxlSWQsIGZpbGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXRHbG9iYWxGaWxlSW5mbyhtb2Q6IER1Y2tEQk1vZHVsZSk6IER1Y2tEQkdsb2JhbEZpbGVJbmZvIHwgbnVsbCB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgW3MsIGQsIG5dID0gY2FsbFNSZXQoXHJcbiAgICAgICAgICAgICAgICBtb2QsXHJcbiAgICAgICAgICAgICAgICAnZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mbycsXHJcbiAgICAgICAgICAgICAgICBbJ251bWJlciddLFxyXG4gICAgICAgICAgICAgICAgW0JST1dTRVJfUlVOVElNRS5fZ2xvYmFsRmlsZUluZm8/LmNhY2hlRXBvY2ggfHwgMF0sXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChzICE9PSBTdGF0dXNDb2RlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEVwb2NoIGlzIHVwIHRvIGRhdGVcclxuICAgICAgICAgICAgICAgIHJldHVybiBCUk9XU0VSX1JVTlRJTUUuX2dsb2JhbEZpbGVJbmZvITtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpbmZvU3RyID0gcmVhZFN0cmluZyhtb2QsIGQsIG4pO1xyXG4gICAgICAgICAgICBkcm9wUmVzcG9uc2VCdWZmZXJzKG1vZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBKU09OLnBhcnNlKGluZm9TdHIpO1xyXG4gICAgICAgICAgICBpZiAoaW5mbyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBCUk9XU0VSX1JVTlRJTUUuX2dsb2JhbEZpbGVJbmZvID0geyAuLi5pbmZvLCBibG9iOiBudWxsIH0gYXMgRHVja0RCR2xvYmFsRmlsZUluZm87XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gQlJPV1NFUl9SVU5USU1FLl9nbG9iYWxGaWxlSW5mbztcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICB0ZXN0UGxhdGZvcm1GZWF0dXJlOiAoX21vZDogRHVja0RCTW9kdWxlLCBmZWF0dXJlOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBCaWdJbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGVzdCBmb3IgdW5rbm93biBmZWF0dXJlOiAke2ZlYXR1cmV9YCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBnZXREZWZhdWx0RGF0YVByb3RvY29sKG1vZDogRHVja0RCTW9kdWxlKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUjtcclxuICAgIH0sXHJcblxyXG4gICAgb3BlbkZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIsIGZsYWdzOiBGaWxlRmxhZ3MpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIEJST1dTRVJfUlVOVElNRS5fZmlsZUluZm9DYWNoZS5kZWxldGUoZmlsZUlkKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IEJST1dTRVJfUlVOVElNRS5nZXRGaWxlSW5mbyhtb2QsIGZpbGVJZCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZmlsZT8uZGF0YVByb3RvY29sKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuUzM6IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19SRUFEICYmIGZsYWdzICYgRmlsZUZsYWdzLkZJTEVfRkxBR1NfV1JJVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogY2Fubm90IG9wZW4gZmlsZSB3aXRoIGJvdGggcmVhZCBhbmQgd3JpdGUgZmxhZ3Mgc2V0YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICYgRmlsZUZsYWdzLkZJTEVfRkxBR1NfQVBQRU5EKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPcGVuaW5nIGZpbGUgJHtmaWxlLmZpbGVOYW1lfSBmYWlsZWQ6IGFwcGVuZGluZyB0byBIVFRQL1MzIGZpbGVzIGlzIG5vdCBzdXBwb3J0ZWRgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19XUklURSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzZW5kIGEgSEVBRCByZXF1ZXN0IHRvIHRyeSB0byBkZXRlcm1pbmUgaWYgd2UgY2FuIHdyaXRlIHRvIGRhdGFfdXJsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZS5kYXRhUHJvdG9jb2wgPT0gRHVja0RCRGF0YVByb3RvY29sLlMzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIGdldEhUVFBVcmwoZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIsIGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdIRUFEJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIGZpbGUuZGF0YVVybCEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGVjdCAyMDAgZm9yIGV4aXN0aW5nIGZpbGVzIHRoYXQgd2Ugd2lsbCBvdmVyd3JpdGUgb3IgNDA0IGZvciBub24tZXhpc3RlbnQgZmlsZXMgY2FuIGJlIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT0gMjAwICYmIHhoci5zdGF0dXMgIT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogVW5leHBlY3RlZCByZXR1cm4gc3RhdHVzIGZyb20gc2VydmVyICgke3hoci5zdGF0dXN9KWAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnN0YXR1cyA9PSA0MDQgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICEoZmxhZ3MgJiBGaWxlRmxhZ3MuRklMRV9GTEFHU19GSUxFX0NSRUFURSB8fCBmbGFncyAmIEZpbGVGbGFncy5GSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFX05FVylcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYE9wZW5pbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZDogQ2Fubm90IHdyaXRlIHRvIG5vbi1leGlzdGVudCBmaWxlIHdpdGhvdXQgRklMRV9GTEFHU19GSUxFX0NSRUFURSBvciBGSUxFX0ZMQUdTX0ZJTEVfQ1JFQVRFX05FVyBmbGFnLmAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBhbiBlbXB0eSBidWZmZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBidWZmZXIgdGhlIHdyaXRlcyB0byB0aGlzIHMzL2h0dHAgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbW9kLl9tYWxsb2MoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQVTguc2V0KHNyYywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDBdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZsYWdzICE9IEZpbGVGbGFncy5GSUxFX0ZMQUdTX1JFQUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVuaW5nIGZpbGUgJHtmaWxlLmZpbGVOYW1lfSBmYWlsZWQ6IHVuc3VwcG9ydGVkIGZpbGUgZmxhZ3M6ICR7ZmxhZ3N9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBTdXBwb3J0cyByYW5nZXM/XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvcjogYW55IHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBhIGR1bW15IEhFQUQgcmVxdWVzdCB3aXRoIHJhbmdlIHByb3RvY29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgIC0+IGdvb2QgSUZGIHN0YXR1cyBpcyAyMDYgYW5kIGNvbnRlbnRMZW5naHQgaXMgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZGF0YVByb3RvY29sID09IER1Y2tEQkRhdGFQcm90b2NvbC5TMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBnZXRIVFRQVXJsKGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBmaWxlLnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhLCAnSEVBRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBmaWxlLmRhdGFVcmwhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgYGJ5dGVzPTAtYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VwcG9ydHMgcmFuZ2UgcmVxdWVzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgeGhyLnN0YXR1cyA9PSAyMDYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9ICtjb250ZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEhFQUQgcmVxdWVzdCB3aXRoIHJhbmdlIGhlYWRlciBmYWlsZWQ6ICR7ZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBmYWxsYmFjayB0byBmdWxsIHJlYWQ/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuYWxsb3dGdWxsSHR0cFJlYWRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY29udGVudExlbmd0aCAhPT0gbnVsbCkgJiYgKCtjb250ZW50TGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIuIFNlbmQgYSBkdW1teSBHRVQgcmFuZ2UgcmVxdWVzdCBxdWVyeWluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgLT4gZ29vZCBJRkYgc3RhdHVzIGlzIDIwNiBhbmQgY29udGVudExlbmdodDIgaXMgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgLT4gb3RoZXJ3aXNlLCBpZmYgMjAwIGFuZCBjb250ZW50TGVuZ2h0MiA9PSBjb250ZW50TGVuZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgd2UganVzdCBkb3dubG9hZGVkIHRoZSBmaWxlLCBzYXZlIGl0IGFuZCBtb3ZlIGZ1cnRoZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZGF0YVByb3RvY29sID09IER1Y2tEQkRhdGFQcm90b2NvbC5TMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBnZXRIVFRQVXJsKGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISwgJ0dFVCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgZmlsZS5kYXRhVXJsISwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgYGJ5dGVzPTAtMGApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoMiA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1MZW5ndGgnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDYgJiYgY29udGVudExlbmd0aDIgIT09IG51bGwgJiYgK2NvbnRlbnRMZW5ndGgyID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBtb2QuX21hbGxvYygyICogOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDBdID0gK2NvbnRlbnRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwICYmIGNvbnRlbnRMZW5ndGgyICE9PSBudWxsICYmICtjb250ZW50TGVuZ3RoMiA9PSArY29udGVudExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgZmFsbCBiYWNrIHRvIGZ1bGwgSFRUUCByZWFkIGZvcjogJHtmaWxlLmRhdGFVcmx9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG1vZC5fbWFsbG9jKHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UsIDAsIHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUFU4LnNldChzcmMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSB4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMV0gPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBmYWxsaW5nIGJhY2sgdG8gZnVsbCBIVFRQIHJlYWQgZm9yOiAke2ZpbGUuZGF0YVVybH1gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gU2VuZCBub24tcmFuZ2UgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZGF0YVByb3RvY29sID09IER1Y2tEQkRhdGFQcm90b2NvbC5TMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGdldEhUVFBVcmwoZmlsZS5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIsIGZpbGUuczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdHRVQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBmaWxlLmRhdGFVcmwhLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtb2QuX21hbGxvYyh4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UsIDAsIHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQVTguc2V0KHNyYywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBtb2QuX21hbGxvYygyICogOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUEY2NFsocmVzdWx0ID4+IDMpICsgMF0gPSB4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAxXSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSYWlzZSBlcnJvcj9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlYWRpbmcgZmlsZSAke2ZpbGUuZmlsZU5hbWV9IGZhaWxlZCB3aXRoIGVycm9yOiAke2Vycm9yfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIEZpbGUgcmVhZGVyIEZpbGVcclxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDBdID0gaGFuZGxlLnNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gZW1wdHkgYnVmZmVyZWQgZmlsZSBpbiB0aGUgYnJvd3NlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQnVmZmVyaW5nIG1pc3NpbmcgZmlsZTogJHtmaWxlLmZpbGVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZC5fbWFsbG9jKDIgKiA4KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBtb2QuX21hbGxvYygxKTsgLy8gbWFsbG9jKDApIGlzIGFsbG93ZWQgdG8gcmV0dXJuIGEgbnVsbHB0clxyXG4gICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQRjY0WyhyZXN1bHQgPj4gMykgKyAwXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBGNjRbKHJlc3VsdCA+PiAzKSArIDFdID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyAoc2FtYW5zbWluayk6IHRoaXMgcGF0aCBjYXVzZXMgdGhlIFdBU00gY29kZSB0byBoYW5nXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH0sXHJcbiAgICBnbG9iOiAobW9kOiBEdWNrREJNb2R1bGUsIHBhdGhQdHI6IG51bWJlciwgcGF0aExlbjogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHJlYWRTdHJpbmcobW9kLCBwYXRoUHRyLCBwYXRoTGVuKTtcclxuICAgICAgICAgICAgLy8gU3RhcnRzIHdpdGggaHR0cD9cclxuICAgICAgICAgICAgLy8gVHJ5IGEgSFRUUCBIRUFEIHJlcXVlc3RcclxuICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnaHR0cCcpIHx8IHBhdGguc3RhcnRzV2l0aCgnczM6Ly8nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VuZCBhIGR1bW15IHJhbmdlIHJlcXVlc3QgcXVlcnlpbmcgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIGZpbGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnczM6Ly8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbEluZm8gPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kKTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbignSEVBRCcsIGdldEhUVFBVcmwoZ2xvYmFsSW5mbz8uczNDb25maWcsIHBhdGgpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZ2xvYmFsSW5mbz8uczNDb25maWcsIHBhdGgsICdIRUFEJyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgcGF0aCEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT0gMjAwICYmIHhoci5zdGF0dXMgIT09IDIwNikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZS1zaWduZWQgcmVzb3VyY2VzIG9uIFMzIGluIGNvbW1vbiBjb25maWd1cmF0aW9ucyBmYWlsIG9uIGFueSBIRUFEIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vc2RrLWZvci1nby92MS9kZXZlbG9wZXItZ3VpZGUvczMtZXhhbXBsZS1wcmVzaWduZWQtdXJscy5odG1sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCAoaWYgZW5hYmxlZCkgdG8gYnVtcCB0byBhIHJhbmdlZCBHRVRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpPy5hbGxvd0Z1bGxIdHRwUmVhZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBgSEVBRCByZXF1ZXN0IGZhaWxlZDogJHtwYXRofSwgd2l0aCBmdWxsIGh0dHAgcmVhZHMgYXJlIGRpc2FibGVkYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeGhyMiA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ3MzOi8vJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsSW5mbyA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIyLm9wZW4oJ0dFVCcsIGdldEhUVFBVcmwoZ2xvYmFsSW5mbz8uczNDb25maWcsIHBhdGgpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFMzSGVhZGVycyh4aHIyLCBnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCwgJ0hFQUQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIyLm9wZW4oJ0dFVCcsIHBhdGghLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHhocjIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCBgYnl0ZXM9MC0wYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyMi5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIyLnN0YXR1cyAhPSAyMDAgJiYgeGhyMi5zdGF0dXMgIT09IDIwNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsIGBIRUFEIGFuZCBHRVQgcmVxdWVzdHMgZmFpbGVkOiAke3BhdGh9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IHhocjIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtTGVuZ3RoJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggJiYgKCtjb250ZW50TGVuZ3RoID4gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBSYW5nZSByZXF1ZXN0IGZvciAke3BhdGh9IGRpZCBub3QgcmV0dXJuIGEgcGFydGlhbCByZXNwb25zZTogJHt4aHIyLnN0YXR1c30gXCIke3hocjIuc3RhdHVzVGV4dH1cImApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1vZC5jY2FsbCgnZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoJywgbnVsbCwgWydzdHJpbmcnXSwgW3BhdGhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICBmYWlsV2l0aChtb2QsIGUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjaGVja0ZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpOiBib29sZWFuID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBodHRwIG9yIFMzP1xyXG4gICAgICAgICAgICAvLyBUcnkgYSBIVFRQIEhFQUQgcmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdodHRwJykgfHwgcGF0aC5zdGFydHNXaXRoKCdzMzovLycpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZW5kIGEgZHVtbXkgcmFuZ2UgcmVxdWVzdCBxdWVyeWluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgZmlsZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdzMzovLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsSW5mbyA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vcGVuKCdIRUFEJywgZ2V0SFRUUFVybChnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBnbG9iYWxJbmZvPy5zM0NvbmZpZywgcGF0aCwgJ0hFQUQnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0hFQUQnLCBwYXRoISwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geGhyLnN0YXR1cyA9PSAyMDYgfHwgeGhyLnN0YXR1cyA9PSAyMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgc3luY0ZpbGU6IChfbW9kOiBEdWNrREJNb2R1bGUsIF9maWxlSWQ6IG51bWJlcikgPT4ge30sXHJcbiAgICBjbG9zZUZpbGU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBmaWxlID0gQlJPV1NFUl9SVU5USU1FLmdldEZpbGVJbmZvKG1vZCwgZmlsZUlkKTtcclxuICAgICAgICBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVJbmZvQ2FjaGUuZGVsZXRlKGZpbGVJZCk7XHJcbiAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlVGRkVSOlxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5OT0RFX0ZTOlxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6XHJcbiAgICAgICAgICAgICAgICAvLyBYWFggUmVtb3ZlIGZyb20gcmVnaXN0cnlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GU0FDQ0VTUzoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gQlJPV1NFUl9SVU5USU1FLl9maWxlcz8uZ2V0KGZpbGUuZmlsZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIE9QRlMgYWNjZXNzIGhhbmRsZSByZWdpc3RlcmVkIHdpdGggbmFtZTogJHtmaWxlLmZpbGVOYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZS5mbHVzaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHRydW5jYXRlRmlsZTogKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgbmV3U2l6ZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZmlsZSA9IEJST1dTRVJfUlVOVElNRS5nZXRGaWxlSW5mbyhtb2QsIGZpbGVJZCk7XHJcbiAgICAgICAgc3dpdGNoIChmaWxlPy5kYXRhUHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuSFRUUDpcclxuICAgICAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgYENhbm5vdCB0cnVuY2F0ZSBhIGh0dHAgZmlsZWApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcclxuICAgICAgICAgICAgICAgIGZhaWxXaXRoKG1vZCwgYENhbm5vdCB0cnVuY2F0ZSBhbiBzMyBmaWxlYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJVRkZFUjpcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuTk9ERV9GUzpcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSOlxyXG4gICAgICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBgdHJ1bmNhdGVGaWxlIG5vdCBpbXBsZW1lbnRlZGApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZTQUNDRVNTOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gT1BGUyBhY2Nlc3MgaGFuZGxlIHJlZ2lzdGVyZWQgd2l0aCBuYW1lOiAke2ZpbGUuZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLnRydW5jYXRlKG5ld1NpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfSxcclxuICAgIHJlYWRGaWxlKG1vZDogRHVja0RCTW9kdWxlLCBmaWxlSWQ6IG51bWJlciwgYnVmOiBudW1iZXIsIGJ5dGVzOiBudW1iZXIsIGxvY2F0aW9uOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoYnl0ZXMgPT0gMCkge1xyXG4gICAgICAgICAgICAvLyBCZSByb2J1c3QgdG8gZW1wdHkgcmVhZHNcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGZpbGU/LmRhdGFQcm90b2NvbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmlsZSByZWFkaW5nIGZyb20gQkxPQiBvciBIVFRQIE1VU1QgYmUgZG9uZSB3aXRoIHJhbmdlIHJlcXVlc3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBjaGVjayBpbiBPUEVOIGlmIHN1Y2ggZmlsZSBzdXBwb3J0cyByYW5nZSByZXF1ZXN0cyBhbmQgdXBncmFkZSB0byBCVUZGRVIgaWYgbm90LlxyXG4gICAgICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuSFRUUDpcclxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLlMzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWxlLmRhdGFVcmwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGRhdGEgVVJMIGZvciBmaWxlICR7ZmlsZUlkfWApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUuZGF0YVByb3RvY29sID09IER1Y2tEQkRhdGFQcm90b2NvbC5TMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGdldEhUVFBVcmwoZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTM0hlYWRlcnMoeGhyLCBmaWxlPy5zM0NvbmZpZywgZmlsZS5kYXRhVXJsISwgJ0dFVCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGZpbGUuZGF0YVVybCEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgYGJ5dGVzPSR7bG9jYXRpb259LSR7bG9jYXRpb24gKyBieXRlcyAtIDF9YCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzID09IDIwNiAvKiBQYXJ0aWFsIGNvbnRlbnQgKi8gfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh4aHIuc3RhdHVzID09IDIwMCAmJiBieXRlcyA9PSB4aHIucmVzcG9uc2UuYnl0ZUxlbmd0aCAmJiBsb2NhdGlvbiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSwgMCwgTWF0aC5taW4oeGhyLnJlc3BvbnNlLmJ5dGVMZW5ndGgsIGJ5dGVzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2QuSEVBUFU4LnNldChzcmMsIGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3JjLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGhlcmUgd2UgYXJlIGFjdHVhbGx5IHRocm93aW5nIGF3YXkgYWxsIG5vbi1yZWxldmFudCBieXRlcywgYnV0IHRoaXMgaXMgc3RpbGwgYmV0dGVyIHRoYW4gZmFpbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgcHJvcGVyIHNvbHV0aW9uIHdvdWxkIHJlcXVpcmUgbm90aWZ5aW5nIGR1Y2tkYi13YXNtIGNhY2hlLCB3aGlsZSB3ZSBhcmUgcGlnZ3liYWNraWduIG9uIGJyb3dzZXIgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgUmFuZ2UgcmVxdWVzdCBmb3IgJHtmaWxlLmRhdGFVcmx9IGRpZCBub3QgcmV0dXJuIGEgcGFydGlhbCByZXNwb25zZTogJHt4aHIuc3RhdHVzfSBcIiR7eGhyLnN0YXR1c1RleHR9XCJgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSwgbG9jYXRpb24sIE1hdGgubWluKHhoci5yZXNwb25zZS5ieXRlTGVuZ3RoLWxvY2F0aW9uLCBieXRlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kLkhFQVBVOC5zZXQoc3JjLCBidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNyYy5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBSYW5nZSByZXF1ZXN0IGZvciAke2ZpbGUuZGF0YVVybH0gZGlkIHJldHVybmVkIG5vbi1zdWNjZXNzIHN0YXR1czogJHt4aHIuc3RhdHVzfSBcIiR7eGhyLnN0YXR1c1RleHR9XCJgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSYW5nZSByZXF1ZXN0IGZvciAke2ZpbGUuZGF0YVVybH0gZmFpbGVkIHdpdGggZXJyb3I6ICR7ZX1cImApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIEhUTUw1IGZpbGUgcmVnaXN0ZXJlZCB3aXRoIG5hbWU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpY2VkID0gaGFuZGxlIS5zbGljZShsb2NhdGlvbiwgbG9jYXRpb24gKyBieXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG5ldyBGaWxlUmVhZGVyU3luYygpLnJlYWRBc0FycmF5QnVmZmVyKHNsaWNlZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZC5IRUFQVTguc2V0KGRhdGEsIGJ1Zik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRlNBQ0NFU1M6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBPUEZTIGFjY2VzcyBoYW5kbGUgcmVnaXN0ZXJlZCB3aXRoIG5hbWU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gbW9kLkhFQVBVOC5zdWJhcnJheShidWYsIGJ1ZiArIGJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLnJlYWQob3V0LCB7IGF0OiBsb2NhdGlvbiB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgZmFpbFdpdGgobW9kLCBlLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgd3JpdGVGaWxlOiAobW9kOiBEdWNrREJNb2R1bGUsIGZpbGVJZDogbnVtYmVyLCBidWY6IG51bWJlciwgYnl0ZXM6IG51bWJlciwgbG9jYXRpb246IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGUgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0RmlsZUluZm8obW9kLCBmaWxlSWQpO1xyXG4gICAgICAgIHN3aXRjaCAoZmlsZT8uZGF0YVByb3RvY29sKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRHVja0RCRGF0YVByb3RvY29sLkhUVFA6XHJcbiAgICAgICAgICAgICAgICBmYWlsV2l0aChtb2QsICdDYW5ub3Qgd3JpdGUgdG8gSFRUUCBmaWxlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuUzM6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgIHhoci5vcGVuKCdQVVQnLCBnZXRIVFRQVXJsKGZpbGU/LnMzQ29uZmlnLCBmaWxlLmRhdGFVcmwhKSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYWRkUzNIZWFkZXJzKHhociwgZmlsZT8uczNDb25maWcsIGZpbGUuZGF0YVVybCEsICdQVVQnLCAnJywgYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIHhoci5zZW5kKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSOlxyXG4gICAgICAgICAgICAgICAgZmFpbFdpdGgobW9kLCAnY2Fubm90IHdyaXRlIHVzaW5nIHRoZSBodG1sNSBmaWxlIHJlYWRlciBhcGknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZTQUNDRVNTOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBCUk9XU0VSX1JVTlRJTUUuX2ZpbGVzPy5nZXQoZmlsZS5maWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhbmRsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gT1BGUyBhY2Nlc3MgaGFuZGxlIHJlZ2lzdGVyZWQgd2l0aCBuYW1lOiAke2ZpbGUuZmlsZU5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IG1vZC5IRUFQVTguc3ViYXJyYXkoYnVmLCBidWYgKyBieXRlcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlLndyaXRlKGlucHV0LCB7IGF0OiBsb2NhdGlvbiB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH0sXHJcbiAgICBnZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWU6IChtb2Q6IER1Y2tEQk1vZHVsZSwgZmlsZUlkOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBmaWxlID0gQlJPV1NFUl9SVU5USU1FLmdldEZpbGVJbmZvKG1vZCwgZmlsZUlkKTtcclxuICAgICAgICBzd2l0Y2ggKGZpbGU/LmRhdGFQcm90b2NvbCkge1xyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5CUk9XU0VSX0ZJTEVSRUFERVI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmaWxlLmZpbGVOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghaGFuZGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE5vIGhhbmRsZSBhdmFpbGFibGUgZm9yIGZpbGU6ICR7ZmlsZS5maWxlTmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5IVFRQOlxyXG4gICAgICAgICAgICBjYXNlIER1Y2tEQkRhdGFQcm90b2NvbC5TMzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG4gICAgY2hlY2tEaXJlY3Rvcnk6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBjaGVja0RpcmVjdG9yeTogJHtwYXRofWApO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVEaXJlY3Rvcnk6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBjcmVhdGVEaXJlY3Rvcnk6ICR7cGF0aH1gKTtcclxuICAgIH0sXHJcbiAgICByZW1vdmVEaXJlY3Rvcnk6IChtb2Q6IER1Y2tEQk1vZHVsZSwgcGF0aFB0cjogbnVtYmVyLCBwYXRoTGVuOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCBwYXRoID0gcmVhZFN0cmluZyhtb2QsIHBhdGhQdHIsIHBhdGhMZW4pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGByZW1vdmVEaXJlY3Rvcnk6ICR7cGF0aH1gKTtcclxuICAgIH0sXHJcbiAgICBsaXN0RGlyZWN0b3J5RW50cmllczogKG1vZDogRHVja0RCTW9kdWxlLCBwYXRoUHRyOiBudW1iZXIsIHBhdGhMZW46IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSByZWFkU3RyaW5nKG1vZCwgcGF0aFB0ciwgcGF0aExlbik7XHJcbiAgICAgICAgY29uc29sZS5sb2coYGxpc3REaXJlY3RvcnlFbnRyaWVzOiAke3BhdGh9YCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIG1vdmVGaWxlOiAobW9kOiBEdWNrREJNb2R1bGUsIGZyb21QdHI6IG51bWJlciwgZnJvbUxlbjogbnVtYmVyLCB0b1B0cjogbnVtYmVyLCB0b0xlbjogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZnJvbSA9IHJlYWRTdHJpbmcobW9kLCBmcm9tUHRyLCBmcm9tTGVuKTtcclxuICAgICAgICBjb25zdCB0byA9IHJlYWRTdHJpbmcobW9kLCB0b1B0ciwgdG9MZW4pO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IEJST1dTRVJfUlVOVElNRS5fZmlsZXM/LmdldChmcm9tKTtcclxuICAgICAgICBpZiAoaGFuZGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlcyEuZGVsZXRlKGhhbmRsZSk7XHJcbiAgICAgICAgICAgIEJST1dTRVJfUlVOVElNRS5fZmlsZXMhLnNldCh0bywgaGFuZGxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlPy5lbnRyaWVzKCkgfHwgW10pIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmRhdGFVcmwgPT0gZnJvbSkge1xyXG4gICAgICAgICAgICAgICAgQlJPV1NFUl9SVU5USU1FLl9maWxlSW5mb0NhY2hlLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRmlsZTogKF9tb2Q6IER1Y2tEQk1vZHVsZSwgX3BhdGhQdHI6IG51bWJlciwgX3BhdGhMZW46IG51bWJlcikgPT4ge30sXHJcbiAgICBjYWxsU2NhbGFyVURGOiAoXHJcbiAgICAgICAgbW9kOiBEdWNrREJNb2R1bGUsXHJcbiAgICAgICAgcmVzcG9uc2U6IG51bWJlcixcclxuICAgICAgICBmdW5jSWQ6IG51bWJlcixcclxuICAgICAgICBkZXNjUHRyOiBudW1iZXIsXHJcbiAgICAgICAgZGVzY1NpemU6IG51bWJlcixcclxuICAgICAgICBwdHJzUHRyOiBudW1iZXIsXHJcbiAgICAgICAgcHRyc1NpemU6IG51bWJlcixcclxuICAgICk6IHZvaWQgPT4ge1xyXG4gICAgICAgIHVkZi5jYWxsU2NhbGFyVURGKEJST1dTRVJfUlVOVElNRSwgbW9kLCByZXNwb25zZSwgZnVuY0lkLCBkZXNjUHRyLCBkZXNjU2l6ZSwgcHRyc1B0ciwgcHRyc1NpemUpO1xyXG4gICAgfSxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJST1dTRVJfUlVOVElNRTtcclxuIiwgIlxudmFyIER1Y2tEQiA9ICgoKSA9PiB7XG4gIHZhciBfc2NyaXB0RGlyID0gaW1wb3J0Lm1ldGEudXJsO1xuICBcbiAgcmV0dXJuIChcbmFzeW5jIGZ1bmN0aW9uKER1Y2tEQiA9IHt9KSAge1xuXG52YXIgTW9kdWxlID0gdHlwZW9mIER1Y2tEQiAhPSBcInVuZGVmaW5lZFwiID8gRHVja0RCIDoge307XG5cbnZhciByZWFkeVByb21pc2VSZXNvbHZlLCByZWFkeVByb21pc2VSZWplY3Q7XG5cbk1vZHVsZVtcInJlYWR5XCJdID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuIHJlYWR5UHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuIHJlYWR5UHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbn0pO1xuXG5bIFwiX21haW5cIiwgXCJfbWFsbG9jXCIsIFwiX2ZyZWVcIiwgXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiLCBcIl9kdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0c1wiLCBcIl9kdWNrZGJfd2ViX2Nvbm5lY3RcIiwgXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyXCIsIFwiX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9kaXNjb25uZWN0XCIsIFwiX2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHNcIiwgXCJfZHVja2RiX3dlYl9mYWlsX3dpdGhcIiwgXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlXCIsIFwiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIiwgXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVcIiwgXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZFwiLCBcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZVwiLCBcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9mc19nbG9iX2ZpbGVfaW5mb3NcIiwgXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX2J1ZmZlclwiLCBcIl9kdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsXCIsIFwiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIiwgXCJfZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mb1wiLCBcIl9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCIsIFwiX2R1Y2tkYl93ZWJfZ2V0X3ZlcnNpb25cIiwgXCJfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCIsIFwiX2R1Y2tkYl93ZWJfaW5zZXJ0X2Nzdl9mcm9tX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9pbnNlcnRfanNvbl9mcm9tX3BhdGhcIiwgXCJfZHVja2RiX3dlYl9vcGVuXCIsIFwiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIiwgXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3BvbGxcIiwgXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0XCIsIFwiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2VcIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jcmVhdGVcIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9ydW5cIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCIsIFwiX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0c1wiLCBcIl9kdWNrZGJfd2ViX3F1ZXJ5X3J1blwiLCBcIl9kdWNrZGJfd2ViX3Jlc2V0XCIsIFwiX2R1Y2tkYl93ZWJfdG9rZW5pemVcIiwgXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiLCBcIl9mZmx1c2hcIiwgXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiIF0uZm9yRWFjaChwcm9wID0+IHtcbiBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlW1wicmVhZHlcIl0sIHByb3ApKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNb2R1bGVbXCJyZWFkeVwiXSwgcHJvcCwge1xuICAgZ2V0OiAoKSA9PiBhYm9ydChcIllvdSBhcmUgZ2V0dGluZyBcIiArIHByb3AgKyBcIiBvbiB0aGUgUHJvbWlzZSBvYmplY3QsIGluc3RlYWQgb2YgdGhlIGluc3RhbmNlLiBVc2UgLnRoZW4oKSB0byBnZXQgY2FsbGVkIGJhY2sgd2l0aCB0aGUgaW5zdGFuY2UsIHNlZSB0aGUgTU9EVUxBUklaRSBkb2NzIGluIHNyYy9zZXR0aW5ncy5qc1wiKSxcbiAgIHNldDogKCkgPT4gYWJvcnQoXCJZb3UgYXJlIHNldHRpbmcgXCIgKyBwcm9wICsgXCIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanNcIilcbiAgfSk7XG4gfVxufSk7XG5cbnZhciBtb2R1bGVPdmVycmlkZXMgPSBPYmplY3QuYXNzaWduKHt9LCBNb2R1bGUpO1xuXG52YXIgYXJndW1lbnRzXyA9IFtdO1xuXG52YXIgdGhpc1Byb2dyYW0gPSBcIi4vdGhpcy5wcm9ncmFtXCI7XG5cbnZhciBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiB0aHJvdyB0b1Rocm93O1xufTtcblxudmFyIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIjtcblxudmFyIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09IFwiZnVuY3Rpb25cIjtcblxudmFyIEVOVklST05NRU5UX0lTX05PREUgPSB0eXBlb2YgcHJvY2VzcyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSA9PSBcInN0cmluZ1wiO1xuXG52YXIgRU5WSVJPTk1FTlRfSVNfU0hFTEwgPSAhRU5WSVJPTk1FTlRfSVNfV0VCICYmICFFTlZJUk9OTUVOVF9JU19OT0RFICYmICFFTlZJUk9OTUVOVF9JU19XT1JLRVI7XG5cbmlmIChNb2R1bGVbXCJFTlZJUk9OTUVOVFwiXSkge1xuIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZS5FTlZJUk9OTUVOVCBoYXMgYmVlbiBkZXByZWNhdGVkLiBUbyBmb3JjZSB0aGUgZW52aXJvbm1lbnQsIHVzZSB0aGUgRU5WSVJPTk1FTlQgY29tcGlsZS10aW1lIG9wdGlvbiAoZm9yIGV4YW1wbGUsIC1zRU5WSVJPTk1FTlQ9d2ViIG9yIC1zRU5WSVJPTk1FTlQ9bm9kZSlcIik7XG59XG5cbnZhciBzY3JpcHREaXJlY3RvcnkgPSBcIlwiO1xuXG5mdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpIHtcbiBpZiAoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSkge1xuICByZXR1cm4gTW9kdWxlW1wibG9jYXRlRmlsZVwiXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuIH1cbiByZXR1cm4gc2NyaXB0RGlyZWN0b3J5ICsgcGF0aDtcbn1cblxudmFyIHJlYWRfLCByZWFkQXN5bmMsIHJlYWRCaW5hcnksIHNldFdpbmRvd1RpdGxlO1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuIGlmICh0eXBlb2YgcHJvY2VzcyA9PSBcInVuZGVmaW5lZFwiIHx8ICFwcm9jZXNzLnJlbGVhc2UgfHwgcHJvY2Vzcy5yZWxlYXNlLm5hbWUgIT09IFwibm9kZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KVwiKTtcbiB2YXIgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gdmFyIG51bWVyaWNWZXJzaW9uID0gbm9kZVZlcnNpb24uc3BsaXQoXCIuXCIpLnNsaWNlKDAsIDMpO1xuIG51bWVyaWNWZXJzaW9uID0gbnVtZXJpY1ZlcnNpb25bMF0gKiAxZTQgKyBudW1lcmljVmVyc2lvblsxXSAqIDEwMCArIG51bWVyaWNWZXJzaW9uWzJdLnNwbGl0KFwiLVwiKVswXSAqIDE7XG4gdmFyIG1pblZlcnNpb24gPSAxMDE5MDA7XG4gaWYgKG51bWVyaWNWZXJzaW9uIDwgMTAxOTAwKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZW1zY3JpcHRlbi1nZW5lcmF0ZWQgY29kZSByZXF1aXJlcyBub2RlIHYxMC4xOS4xOS4wIChkZXRlY3RlZCB2XCIgKyBub2RlVmVyc2lvbiArIFwiKVwiKTtcbiB9XG4gY29uc3Qge2NyZWF0ZVJlcXVpcmU6IGNyZWF0ZVJlcXVpcmV9ID0gYXdhaXQgaW1wb3J0KFwibW9kdWxlXCIpO1xuIHZhciByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuIHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiB2YXIgbm9kZVBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IG5vZGVQYXRoLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KSArIFwiL1wiO1xuIH0gZWxzZSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IHJlcXVpcmUoXCJ1cmxcIikuZmlsZVVSTFRvUGF0aChuZXcgVVJMKFwiLi9cIiwgaW1wb3J0Lm1ldGEudXJsKSk7XG4gfVxuIHJlYWRfID0gKGZpbGVuYW1lLCBiaW5hcnkpID0+IHtcbiAgZmlsZW5hbWUgPSBpc0ZpbGVVUkkoZmlsZW5hbWUpID8gbmV3IFVSTChmaWxlbmFtZSkgOiBub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO1xuICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCBiaW5hcnkgPyB1bmRlZmluZWQgOiBcInV0ZjhcIik7XG4gfTtcbiByZWFkQmluYXJ5ID0gZmlsZW5hbWUgPT4ge1xuICB2YXIgcmV0ID0gcmVhZF8oZmlsZW5hbWUsIHRydWUpO1xuICBpZiAoIXJldC5idWZmZXIpIHtcbiAgIHJldCA9IG5ldyBVaW50OEFycmF5KHJldCk7XG4gIH1cbiAgYXNzZXJ0KHJldC5idWZmZXIpO1xuICByZXR1cm4gcmV0O1xuIH07XG4gcmVhZEFzeW5jID0gKGZpbGVuYW1lLCBvbmxvYWQsIG9uZXJyb3IsIGJpbmFyeSA9IHRydWUpID0+IHtcbiAgZmlsZW5hbWUgPSBpc0ZpbGVVUkkoZmlsZW5hbWUpID8gbmV3IFVSTChmaWxlbmFtZSkgOiBub2RlUGF0aC5ub3JtYWxpemUoZmlsZW5hbWUpO1xuICBmcy5yZWFkRmlsZShmaWxlbmFtZSwgYmluYXJ5ID8gdW5kZWZpbmVkIDogXCJ1dGY4XCIsIChlcnIsIGRhdGEpID0+IHtcbiAgIGlmIChlcnIpIG9uZXJyb3IoZXJyKTsgZWxzZSBvbmxvYWQoYmluYXJ5ID8gZGF0YS5idWZmZXIgOiBkYXRhKTtcbiAgfSk7XG4gfTtcbiBpZiAoIU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdICYmIHByb2Nlc3MuYXJndi5sZW5ndGggPiAxKSB7XG4gIHRoaXNQcm9ncmFtID0gcHJvY2Vzcy5hcmd2WzFdLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xuIH1cbiBhcmd1bWVudHNfID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICBwcm9jZXNzLmV4aXRDb2RlID0gc3RhdHVzO1xuICB0aHJvdyB0b1Rocm93O1xuIH07XG4gTW9kdWxlW1wiaW5zcGVjdFwiXSA9ICgpID0+IFwiW0Vtc2NyaXB0ZW4gTW9kdWxlIG9iamVjdF1cIjtcbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfU0hFTEwpIHtcbiBpZiAodHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIpO1xuIGlmICh0eXBlb2YgcmVhZCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIHJlYWRfID0gZiA9PiB7XG4gICByZXR1cm4gcmVhZChmKTtcbiAgfTtcbiB9XG4gcmVhZEJpbmFyeSA9IGYgPT4ge1xuICBsZXQgZGF0YTtcbiAgaWYgKHR5cGVvZiByZWFkYnVmZmVyID09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlYWRidWZmZXIoZikpO1xuICB9XG4gIGRhdGEgPSByZWFkKGYsIFwiYmluYXJ5XCIpO1xuICBhc3NlcnQodHlwZW9mIGRhdGEgPT0gXCJvYmplY3RcIik7XG4gIHJldHVybiBkYXRhO1xuIH07XG4gcmVhZEFzeW5jID0gKGYsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICBzZXRUaW1lb3V0KCgpID0+IG9ubG9hZChyZWFkQmluYXJ5KGYpKSwgMCk7XG4gfTtcbiBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0ID0gaWQgPT4ge307XG4gfVxuIGlmICh0eXBlb2Ygc2NyaXB0QXJncyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBzY3JpcHRBcmdzO1xuIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50cyAhPSBcInVuZGVmaW5lZFwiKSB7XG4gIGFyZ3VtZW50c18gPSBhcmd1bWVudHM7XG4gfVxuIGlmICh0eXBlb2YgcXVpdCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoISh0b1Rocm93IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHtcbiAgICAgbGV0IHRvTG9nID0gdG9UaHJvdztcbiAgICAgaWYgKHRvVGhyb3cgJiYgdHlwZW9mIHRvVGhyb3cgPT0gXCJvYmplY3RcIiAmJiB0b1Rocm93LnN0YWNrKSB7XG4gICAgICB0b0xvZyA9IFsgdG9UaHJvdywgdG9UaHJvdy5zdGFjayBdO1xuICAgICB9XG4gICAgIGVycihgZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiAke3RvTG9nfWApO1xuICAgIH1cbiAgICBxdWl0KHN0YXR1cyk7XG4gICB9KTtcbiAgIHRocm93IHRvVGhyb3c7XG4gIH07XG4gfVxuIGlmICh0eXBlb2YgcHJpbnQgIT0gXCJ1bmRlZmluZWRcIikge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZSA9IHt9O1xuICBjb25zb2xlLmxvZyA9IHByaW50O1xuICBjb25zb2xlLndhcm4gPSBjb25zb2xlLmVycm9yID0gdHlwZW9mIHByaW50RXJyICE9IFwidW5kZWZpbmVkXCIgPyBwcmludEVyciA6IHByaW50O1xuIH1cbn0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfV0VCIHx8IEVOVklST05NRU5UX0lTX1dPUktFUikge1xuIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2VsZi5sb2NhdGlvbi5ocmVmO1xuIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiB9XG4gaWYgKF9zY3JpcHREaXIpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gX3NjcmlwdERpcjtcbiB9XG4gaWYgKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKFwiYmxvYjpcIikgIT09IDApIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gc2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLCBzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLywgXCJcIikubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gfSBlbHNlIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gXCJcIjtcbiB9XG4gaWYgKCEodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBpbXBvcnRTY3JpcHRzID09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBFcnJvcihcIm5vdCBjb21waWxlZCBmb3IgdGhpcyBlbnZpcm9ubWVudCAoZGlkIHlvdSBidWlsZCB0byBIVE1MIGFuZCB0cnkgdG8gcnVuIGl0IG5vdCBvbiB0aGUgd2ViLCBvciBzZXQgRU5WSVJPTk1FTlQgdG8gc29tZXRoaW5nIC0gbGlrZSBub2RlIC0gYW5kIHJ1biBpdCBzb21lcGxhY2UgZWxzZSAtIGxpa2Ugb24gdGhlIHdlYj8pXCIpO1xuIHtcbiAgcmVhZF8gPSB1cmwgPT4ge1xuICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gICB4aHIuc2VuZChudWxsKTtcbiAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICB9O1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICByZWFkQmluYXJ5ID0gdXJsID0+IHtcbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCBmYWxzZSk7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgIH07XG4gIH1cbiAgcmVhZEFzeW5jID0gKHVybCwgb25sb2FkLCBvbmVycm9yKSA9PiB7XG4gICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICB4aHIub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgeGhyLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwIHx8IHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpIHtcbiAgICAgb25sb2FkKHhoci5yZXNwb25zZSk7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgb25lcnJvcigpO1xuICAgfTtcbiAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgIHhoci5zZW5kKG51bGwpO1xuICB9O1xuIH1cbiBzZXRXaW5kb3dUaXRsZSA9IHRpdGxlID0+IGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG59IGVsc2Uge1xuIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IGRldGVjdGlvbiBlcnJvclwiKTtcbn1cblxudmFyIG91dCA9IE1vZHVsZVtcInByaW50XCJdIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5cbnZhciBlcnIgPSBNb2R1bGVbXCJwcmludEVyclwiXSB8fCBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cbk9iamVjdC5hc3NpZ24oTW9kdWxlLCBtb2R1bGVPdmVycmlkZXMpO1xuXG5tb2R1bGVPdmVycmlkZXMgPSBudWxsO1xuXG5jaGVja0luY29taW5nTW9kdWxlQVBJKCk7XG5cbmlmIChNb2R1bGVbXCJhcmd1bWVudHNcIl0pIGFyZ3VtZW50c18gPSBNb2R1bGVbXCJhcmd1bWVudHNcIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJhcmd1bWVudHNcIiwgXCJhcmd1bWVudHNfXCIpO1xuXG5pZiAoTW9kdWxlW1widGhpc1Byb2dyYW1cIl0pIHRoaXNQcm9ncmFtID0gTW9kdWxlW1widGhpc1Byb2dyYW1cIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJ0aGlzUHJvZ3JhbVwiLCBcInRoaXNQcm9ncmFtXCIpO1xuXG5pZiAoTW9kdWxlW1wicXVpdFwiXSkgcXVpdF8gPSBNb2R1bGVbXCJxdWl0XCJdO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwicXVpdFwiLCBcInF1aXRfXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcIm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLm1lbW9yeUluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWRcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wicHRocmVhZE1haW5QcmVmaXhVUkxcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucHRocmVhZE1haW5QcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJjZEluaXRpYWxpemVyUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLmNkSW5pdGlhbGl6ZXJQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJmaWxlUGFja2FnZVByZWZpeFVSTFwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5maWxlUGFja2FnZVByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucmVhZCBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkXyBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wicmVhZEFzeW5jXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLnJlYWRBc3luYyBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQXN5bmMgaW4gSlMpXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRCaW5hcnlcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUucmVhZEJpbmFyeSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSByZWFkQmluYXJ5IGluIEpTKVwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJzZXRXaW5kb3dUaXRsZVwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5zZXRXaW5kb3dUaXRsZSBvcHRpb24gd2FzIHJlbW92ZWQgKG1vZGlmeSBzZXRXaW5kb3dUaXRsZSBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wiVE9UQUxfTUVNT1JZXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLlRPVEFMX01FTU9SWSBoYXMgYmVlbiByZW5hbWVkIE1vZHVsZS5JTklUSUFMX01FTU9SWVwiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRcIiwgXCJyZWFkX1wiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRBc3luY1wiLCBcInJlYWRBc3luY1wiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInJlYWRCaW5hcnlcIiwgXCJyZWFkQmluYXJ5XCIpO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwic2V0V2luZG93VGl0bGVcIiwgXCJzZXRXaW5kb3dUaXRsZVwiKTtcblxudmFyIElEQkZTID0gXCJJREJGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbGlkYmZzLmpzXCI7XG5cbnZhciBQUk9YWUZTID0gXCJQUk9YWUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1scHJveHlmcy5qc1wiO1xuXG52YXIgV09SS0VSRlMgPSBcIldPUktFUkZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sd29ya2VyZnMuanNcIjtcblxudmFyIE5PREVGUyA9IFwiTk9ERUZTIGlzIG5vIGxvbmdlciBpbmNsdWRlZCBieSBkZWZhdWx0OyBidWlsZCB3aXRoIC1sbm9kZWZzLmpzXCI7XG5cbmFzc2VydCghRU5WSVJPTk1FTlRfSVNfU0hFTEwsIFwic2hlbGwgZW52aXJvbm1lbnQgZGV0ZWN0ZWQgYnV0IG5vdCBlbmFibGVkIGF0IGJ1aWxkIHRpbWUuICBBZGQgJ3NoZWxsJyB0byBgLXNFTlZJUk9OTUVOVGAgdG8gZW5hYmxlLlwiKTtcblxudmFyIHdhc21CaW5hcnk7XG5cbmlmIChNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKSB3YXNtQmluYXJ5ID0gTW9kdWxlW1wid2FzbUJpbmFyeVwiXTtcblxubGVnYWN5TW9kdWxlUHJvcChcIndhc21CaW5hcnlcIiwgXCJ3YXNtQmluYXJ5XCIpO1xuXG52YXIgbm9FeGl0UnVudGltZSA9IE1vZHVsZVtcIm5vRXhpdFJ1bnRpbWVcIl0gfHwgdHJ1ZTtcblxubGVnYWN5TW9kdWxlUHJvcChcIm5vRXhpdFJ1bnRpbWVcIiwgXCJub0V4aXRSdW50aW1lXCIpO1xuXG5pZiAodHlwZW9mIFdlYkFzc2VtYmx5ICE9IFwib2JqZWN0XCIpIHtcbiBhYm9ydChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIik7XG59XG5cbnZhciB3YXNtTWVtb3J5O1xuXG52YXIgQUJPUlQgPSBmYWxzZTtcblxudmFyIEVYSVRTVEFUVVM7XG5cbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIHRleHQpIHtcbiBpZiAoIWNvbmRpdGlvbikge1xuICBhYm9ydChcIkFzc2VydGlvbiBmYWlsZWRcIiArICh0ZXh0ID8gXCI6IFwiICsgdGV4dCA6IFwiXCIpKTtcbiB9XG59XG5cbnZhciBIRUFQLCBIRUFQOCwgSEVBUFU4LCBIRUFQMTYsIEhFQVBVMTYsIEhFQVAzMiwgSEVBUFUzMiwgSEVBUEYzMiwgSEVBUEY2NDtcblxuZnVuY3Rpb24gdXBkYXRlTWVtb3J5Vmlld3MoKSB7XG4gdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiBNb2R1bGVbXCJIRUFQOFwiXSA9IEhFQVA4ID0gbmV3IEludDhBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQMTZcIl0gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQMzJcIl0gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVThcIl0gPSBIRUFQVTggPSBuZXcgVWludDhBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVTE2XCJdID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQVTMyXCJdID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShiKTtcbiBNb2R1bGVbXCJIRUFQRjMyXCJdID0gSEVBUEYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUEY2NFwiXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGIpO1xufVxuXG5hc3NlcnQoIU1vZHVsZVtcIlNUQUNLX1NJWkVcIl0sIFwiU1RBQ0tfU0laRSBjYW4gbm8gbG9uZ2VyIGJlIHNldCBhdCBydW50aW1lLiAgVXNlIC1zU1RBQ0tfU0laRSBhdCBsaW5rIHRpbWVcIik7XG5cbmFzc2VydCh0eXBlb2YgSW50MzJBcnJheSAhPSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgSW50MzJBcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgIT0gdW5kZWZpbmVkICYmIEludDMyQXJyYXkucHJvdG90eXBlLnNldCAhPSB1bmRlZmluZWQsIFwiSlMgZW5naW5lIGRvZXMgbm90IHByb3ZpZGUgZnVsbCB0eXBlZCBhcnJheSBzdXBwb3J0XCIpO1xuXG5hc3NlcnQoIU1vZHVsZVtcIndhc21NZW1vcnlcIl0sIFwiVXNlIG9mIGB3YXNtTWVtb3J5YCBkZXRlY3RlZC4gIFVzZSAtc0lNUE9SVEVEX01FTU9SWSB0byBkZWZpbmUgd2FzbU1lbW9yeSBleHRlcm5hbGx5XCIpO1xuXG5hc3NlcnQoIU1vZHVsZVtcIklOSVRJQUxfTUVNT1JZXCJdLCBcIkRldGVjdGVkIHJ1bnRpbWUgSU5JVElBTF9NRU1PUlkgc2V0dGluZy4gIFVzZSAtc0lNUE9SVEVEX01FTU9SWSB0byBkZWZpbmUgd2FzbU1lbW9yeSBkeW5hbWljYWxseVwiKTtcblxudmFyIHdhc21UYWJsZTtcblxuZnVuY3Rpb24gd3JpdGVTdGFja0Nvb2tpZSgpIHtcbiB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuIGFzc2VydCgobWF4ICYgMykgPT0gMCk7XG4gaWYgKG1heCA9PSAwKSB7XG4gIG1heCArPSA0O1xuIH1cbiBIRUFQVTMyW21heCA+Pj4gMl0gPSAzNDgyMTIyMztcbiBIRUFQVTMyW21heCArIDQgPj4+IDJdID0gMjMxMDcyMTAyMjtcbiBIRUFQVTMyWzAgPj4+IDJdID0gMTY2ODUwOTAyOTtcbn1cblxuZnVuY3Rpb24gY2hlY2tTdGFja0Nvb2tpZSgpIHtcbiBpZiAoQUJPUlQpIHJldHVybjtcbiB2YXIgbWF4ID0gX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZCgpO1xuIGlmIChtYXggPT0gMCkge1xuICBtYXggKz0gNDtcbiB9XG4gdmFyIGNvb2tpZTEgPSBIRUFQVTMyW21heCA+Pj4gMl07XG4gdmFyIGNvb2tpZTIgPSBIRUFQVTMyW21heCArIDQgPj4+IDJdO1xuIGlmIChjb29raWUxICE9IDM0ODIxMjIzIHx8IGNvb2tpZTIgIT0gMjMxMDcyMTAyMikge1xuICBhYm9ydChgU3RhY2sgb3ZlcmZsb3chIFN0YWNrIGNvb2tpZSBoYXMgYmVlbiBvdmVyd3JpdHRlbiBhdCAke3B0clRvU3RyaW5nKG1heCl9LCBleHBlY3RlZCBoZXggZHdvcmRzIDB4ODlCQUNERkUgYW5kIDB4MjEzNTQ2NywgYnV0IHJlY2VpdmVkICR7cHRyVG9TdHJpbmcoY29va2llMil9ICR7cHRyVG9TdHJpbmcoY29va2llMSl9YCk7XG4gfVxuIGlmIChIRUFQVTMyWzAgPj4+IDJdICE9IDE2Njg1MDkwMjkpIHtcbiAgYWJvcnQoXCJSdW50aW1lIGVycm9yOiBUaGUgYXBwbGljYXRpb24gaGFzIGNvcnJ1cHRlZCBpdHMgaGVhcCBtZW1vcnkgYXJlYSAoYWRkcmVzcyB6ZXJvKSFcIik7XG4gfVxufVxuXG4oZnVuY3Rpb24oKSB7XG4gdmFyIGgxNiA9IG5ldyBJbnQxNkFycmF5KDEpO1xuIHZhciBoOCA9IG5ldyBJbnQ4QXJyYXkoaDE2LmJ1ZmZlcik7XG4gaDE2WzBdID0gMjU0NTk7XG4gaWYgKGg4WzBdICE9PSAxMTUgfHwgaDhbMV0gIT09IDk5KSB0aHJvdyBcIlJ1bnRpbWUgZXJyb3I6IGV4cGVjdGVkIHRoZSBzeXN0ZW0gdG8gYmUgbGl0dGxlLWVuZGlhbiEgKFJ1biB3aXRoIC1zU1VQUE9SVF9CSUdfRU5ESUFOIHRvIGJ5cGFzcylcIjtcbn0pKCk7XG5cbnZhciBfX0FUUFJFUlVOX18gPSBbXTtcblxudmFyIF9fQVRJTklUX18gPSBbXTtcblxudmFyIF9fQVRNQUlOX18gPSBbXTtcblxudmFyIF9fQVRFWElUX18gPSBbXTtcblxudmFyIF9fQVRQT1NUUlVOX18gPSBbXTtcblxudmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xuXG52YXIgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPSAwO1xuXG5mdW5jdGlvbiBrZWVwUnVudGltZUFsaXZlKCkge1xuIHJldHVybiBub0V4aXRSdW50aW1lIHx8IHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID4gMDtcbn1cblxuZnVuY3Rpb24gcHJlUnVuKCkge1xuIGlmIChNb2R1bGVbXCJwcmVSdW5cIl0pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl0gPT0gXCJmdW5jdGlvblwiKSBNb2R1bGVbXCJwcmVSdW5cIl0gPSBbIE1vZHVsZVtcInByZVJ1blwiXSBdO1xuICB3aGlsZSAoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCkge1xuICAgYWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpO1xuICB9XG4gfVxuIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGluaXRSdW50aW1lKCkge1xuIGFzc2VydCghcnVudGltZUluaXRpYWxpemVkKTtcbiBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlO1xuIGNoZWNrU3RhY2tDb29raWUoKTtcbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTtcbn1cblxuZnVuY3Rpb24gcHJlTWFpbigpIHtcbiBjaGVja1N0YWNrQ29va2llKCk7XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVE1BSU5fXyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RSdW4oKSB7XG4gY2hlY2tTdGFja0Nvb2tpZSgpO1xuIGlmIChNb2R1bGVbXCJwb3N0UnVuXCJdKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXSA9PSBcImZ1bmN0aW9uXCIpIE1vZHVsZVtcInBvc3RSdW5cIl0gPSBbIE1vZHVsZVtcInBvc3RSdW5cIl0gXTtcbiAgd2hpbGUgKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKSB7XG4gICBhZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKTtcbiAgfVxuIH1cbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTtcbn1cblxuZnVuY3Rpb24gYWRkT25QcmVSdW4oY2IpIHtcbiBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uSW5pdChjYikge1xuIF9fQVRJTklUX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlTWFpbihjYikge1xuIF9fQVRNQUlOX18udW5zaGlmdChjYik7XG59XG5cbmZ1bmN0aW9uIGFkZE9uRXhpdChjYikge31cblxuZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKSB7XG4gX19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKTtcbn1cblxuYXNzZXJ0KE1hdGguaW11bCwgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmltdWwoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGxcIik7XG5cbmFzc2VydChNYXRoLmZyb3VuZCwgXCJUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNYXRoLmZyb3VuZCgpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxuYXNzZXJ0KE1hdGguY2x6MzIsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5jbHozMigpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxuYXNzZXJ0KE1hdGgudHJ1bmMsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC50cnVuYygpLCBidWlsZCB3aXRoIExFR0FDWV9WTV9TVVBQT1JUIG9yIFBPTFlGSUxMX09MRF9NQVRIX0ZVTkNUSU9OUyB0byBhZGQgaW4gYSBwb2x5ZmlsbFwiKTtcblxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG5cbnZhciBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG5cbnZhciBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuXG52YXIgcnVuRGVwZW5kZW5jeVRyYWNraW5nID0ge307XG5cbmZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiB2YXIgb3JpZyA9IGlkO1xuIHdoaWxlICgxKSB7XG4gIGlmICghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSkgcmV0dXJuIGlkO1xuICBpZCA9IG9yaWcgKyBNYXRoLnJhbmRvbSgpO1xuIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcysrO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKGlkKSB7XG4gIGFzc2VydCghcnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0gPSAxO1xuICBpZiAocnVuRGVwZW5kZW5jeVdhdGNoZXIgPT09IG51bGwgJiYgdHlwZW9mIHNldEludGVydmFsICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmIChBQk9SVCkge1xuICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgICAgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaG93biA9IGZhbHNlO1xuICAgIGZvciAodmFyIGRlcCBpbiBydW5EZXBlbmRlbmN5VHJhY2tpbmcpIHtcbiAgICAgaWYgKCFzaG93bikge1xuICAgICAgc2hvd24gPSB0cnVlO1xuICAgICAgZXJyKFwic3RpbGwgd2FpdGluZyBvbiBydW4gZGVwZW5kZW5jaWVzOlwiKTtcbiAgICAgfVxuICAgICBlcnIoXCJkZXBlbmRlbmN5OiBcIiArIGRlcCk7XG4gICAgfVxuICAgIGlmIChzaG93bikge1xuICAgICBlcnIoXCIoZW5kIG9mIGxpc3QpXCIpO1xuICAgIH1cbiAgIH0sIDFlNCk7XG4gIH1cbiB9IGVsc2Uge1xuICBlcnIoXCJ3YXJuaW5nOiBydW4gZGVwZW5kZW5jeSBhZGRlZCB3aXRob3V0IElEXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCkge1xuIHJ1bkRlcGVuZGVuY2llcy0tO1xuIGlmIChNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKSB7XG4gIE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKTtcbiB9XG4gaWYgKGlkKSB7XG4gIGFzc2VydChydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdKTtcbiAgZGVsZXRlIHJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF07XG4gfSBlbHNlIHtcbiAgZXJyKFwid2FybmluZzogcnVuIGRlcGVuZGVuY3kgcmVtb3ZlZCB3aXRob3V0IElEXCIpO1xuIH1cbiBpZiAocnVuRGVwZW5kZW5jaWVzID09IDApIHtcbiAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XG4gICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgfVxuICBpZiAoZGVwZW5kZW5jaWVzRnVsZmlsbGVkKSB7XG4gICB2YXIgY2FsbGJhY2sgPSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQ7XG4gICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBudWxsO1xuICAgY2FsbGJhY2soKTtcbiAgfVxuIH1cbn1cblxuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuIGlmIChNb2R1bGVbXCJvbkFib3J0XCJdKSB7XG4gIE1vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCk7XG4gfVxuIHdoYXQgPSBcIkFib3J0ZWQoXCIgKyB3aGF0ICsgXCIpXCI7XG4gZXJyKHdoYXQpO1xuIEFCT1JUID0gdHJ1ZTtcbiBFWElUU1RBVFVTID0gMTtcbiB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG4gcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuIHRocm93IGU7XG59XG5cbnZhciBkYXRhVVJJUHJlZml4ID0gXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7XG5cbmZ1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSkge1xuIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpIHtcbiByZXR1cm4gZmlsZW5hbWUuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4cG9ydFdyYXBwZXIobmFtZSwgZml4ZWRhc20pIHtcbiByZXR1cm4gZnVuY3Rpb24oKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG5hbWU7XG4gIHZhciBhc20gPSBmaXhlZGFzbTtcbiAgaWYgKCFmaXhlZGFzbSkge1xuICAgYXNtID0gTW9kdWxlW1wiYXNtXCJdO1xuICB9XG4gIGFzc2VydChydW50aW1lSW5pdGlhbGl6ZWQsIFwibmF0aXZlIGZ1bmN0aW9uIGBcIiArIGRpc3BsYXlOYW1lICsgXCJgIGNhbGxlZCBiZWZvcmUgcnVudGltZSBpbml0aWFsaXphdGlvblwiKTtcbiAgaWYgKCFhc21bbmFtZV0pIHtcbiAgIGFzc2VydChhc21bbmFtZV0sIFwiZXhwb3J0ZWQgbmF0aXZlIGZ1bmN0aW9uIGBcIiArIGRpc3BsYXlOYW1lICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgfVxuICByZXR1cm4gYXNtW25hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gfTtcbn1cblxudmFyIHdhc21CaW5hcnlGaWxlO1xuXG5pZiAoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSkge1xuIHdhc21CaW5hcnlGaWxlID0gXCIuL2R1Y2tkYi1tdnAud2FzbVwiO1xuIGlmICghaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICB3YXNtQmluYXJ5RmlsZSA9IGxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpO1xuIH1cbn0gZWxzZSB7XG4gd2FzbUJpbmFyeUZpbGUgPSBuZXcgVVJMKFwiLi9kdWNrZGItbXZwLndhc21cIiwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSkge1xuIHRyeSB7XG4gIGlmIChmaWxlID09IHdhc21CaW5hcnlGaWxlICYmIHdhc21CaW5hcnkpIHtcbiAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgfVxuICBpZiAocmVhZEJpbmFyeSkge1xuICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gIH1cbiAgdGhyb3cgXCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO1xuIH0gY2F0Y2ggKGVycikge1xuICBhYm9ydChlcnIpO1xuIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKSB7XG4gaWYgKCF3YXNtQmluYXJ5ICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSkge1xuICBpZiAodHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIGZldGNoKGJpbmFyeUZpbGUsIHtcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAoIXJlc3BvbnNlW1wib2tcIl0pIHtcbiAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIGJpbmFyeUZpbGUgKyBcIidcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlW1wiYXJyYXlCdWZmZXJcIl0oKTtcbiAgIH0pLmNhdGNoKCgpID0+IGdldEJpbmFyeShiaW5hcnlGaWxlKSk7XG4gIH1cbiB9XG4gcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2V0QmluYXJ5KGJpbmFyeUZpbGUpKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCByZWNlaXZlcikge1xuIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5ID0+IHtcbiAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW1wb3J0cyk7XG4gfSkudGhlbihpbnN0YW5jZSA9PiB7XG4gIHJldHVybiBpbnN0YW5jZTtcbiB9KS50aGVuKHJlY2VpdmVyLCByZWFzb24gPT4ge1xuICBlcnIoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIiArIHJlYXNvbik7XG4gIGlmIChpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICBlcnIoXCJ3YXJuaW5nOiBMb2FkaW5nIGZyb20gYSBmaWxlIFVSSSAoXCIgKyB3YXNtQmluYXJ5RmlsZSArIFwiKSBpcyBub3Qgc3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMuIFNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvZ2V0dGluZ19zdGFydGVkL0ZBUS5odG1sI2hvdy1kby1pLXJ1bi1hLWxvY2FsLXdlYnNlcnZlci1mb3ItdGVzdGluZy13aHktZG9lcy1teS1wcm9ncmFtLXN0YWxsLWluLWRvd25sb2FkaW5nLW9yLXByZXBhcmluZ1wiKTtcbiAgfVxuICBhYm9ydChyZWFzb24pO1xuIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSwgYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spIHtcbiBpZiAoIWJpbmFyeSAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gXCJmdW5jdGlvblwiICYmICFpc0RhdGFVUkkoYmluYXJ5RmlsZSkgJiYgIUVOVklST05NRU5UX0lTX05PREUgJiYgdHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIikge1xuICByZXR1cm4gZmV0Y2goYmluYXJ5RmlsZSwge1xuICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW1wb3J0cyk7XG4gICByZXR1cm4gcmVzdWx0LnRoZW4oY2FsbGJhY2ssIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGVycihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIiArIHJlYXNvbik7XG4gICAgZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7XG4gICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuICAgfSk7XG4gIH0pO1xuIH0gZWxzZSB7XG4gIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIGNhbGxiYWNrKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhc20oKSB7XG4gdmFyIGluZm8gPSB7XG4gIFwiZW52XCI6IHdhc21JbXBvcnRzLFxuICBcIndhc2lfc25hcHNob3RfcHJldmlldzFcIjogd2FzbUltcG9ydHNcbiB9O1xuIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gIHZhciBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgTW9kdWxlW1wiYXNtXCJdID0gZXhwb3J0cztcbiAgd2FzbU1lbW9yeSA9IE1vZHVsZVtcImFzbVwiXVtcIm1lbW9yeVwiXTtcbiAgYXNzZXJ0KHdhc21NZW1vcnksIFwibWVtb3J5IG5vdCBmb3VuZCBpbiB3YXNtIGV4cG9ydHNcIik7XG4gIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gIHdhc21UYWJsZSA9IE1vZHVsZVtcImFzbVwiXVtcIl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGVcIl07XG4gIGFzc2VydCh3YXNtVGFibGUsIFwidGFibGUgbm90IGZvdW5kIGluIHdhc20gZXhwb3J0c1wiKTtcbiAgYWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcIl9fd2FzbV9jYWxsX2N0b3JzXCJdKTtcbiAgcmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7XG4gIHJldHVybiBleHBvcnRzO1xuIH1cbiBhZGRSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtcbiB2YXIgdHJ1ZU1vZHVsZSA9IE1vZHVsZTtcbiBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgYXNzZXJ0KE1vZHVsZSA9PT0gdHJ1ZU1vZHVsZSwgXCJ0aGUgTW9kdWxlIG9iamVjdCBzaG91bGQgbm90IGJlIHJlcGxhY2VkIGR1cmluZyBhc3luYyBjb21waWxhdGlvbiAtIHBlcmhhcHMgdGhlIG9yZGVyIG9mIEhUTUwgZWxlbWVudHMgaXMgd3Jvbmc/XCIpO1xuICB0cnVlTW9kdWxlID0gbnVsbDtcbiAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdKTtcbiB9XG4gaWYgKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSkge1xuICB0cnkge1xuICAgcmV0dXJuIE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICBlcnIoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIiArIGUpO1xuICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICB9XG4gfVxuIGluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSwgd2FzbUJpbmFyeUZpbGUsIGluZm8sIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuIHJldHVybiB7fTtcbn1cblxudmFyIHRlbXBEb3VibGU7XG5cbnZhciB0ZW1wSTY0O1xuXG5mdW5jdGlvbiBsZWdhY3lNb2R1bGVQcm9wKHByb3AsIG5ld05hbWUpIHtcbiBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBwcm9wLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGFib3J0KFwiTW9kdWxlLlwiICsgcHJvcCArIFwiIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggcGxhaW4gXCIgKyBuZXdOYW1lICsgXCIgKHRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBwcm92aWRlZCBvbiBNb2R1bGUsIGJ1dCBhZnRlciBzdGFydHVwIHRoZSB2YWx1ZSBpcyBvbmx5IGxvb2tlZCBmb3Igb24gYSBsb2NhbCB2YXJpYWJsZSBvZiB0aGF0IG5hbWUpXCIpO1xuICAgfVxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRNb2R1bGVQcm9wKHByb3ApIHtcbiBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gIGFib3J0KFwiYE1vZHVsZS5cIiArIHByb3AgKyBcImAgd2FzIHN1cHBsaWVkIGJ1dCBgXCIgKyBwcm9wICsgXCJgIG5vdCBpbmNsdWRlZCBpbiBJTkNPTUlOR19NT0RVTEVfSlNfQVBJXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKG5hbWUpIHtcbiByZXR1cm4gbmFtZSA9PT0gXCJGU19jcmVhdGVQYXRoXCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVEYXRhRmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfdW5saW5rXCIgfHwgbmFtZSA9PT0gXCJhZGRSdW5EZXBlbmRlbmN5XCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVMYXp5RmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfY3JlYXRlRGV2aWNlXCIgfHwgbmFtZSA9PT0gXCJyZW1vdmVSdW5EZXBlbmRlbmN5XCI7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdHbG9iYWwoc3ltLCBtc2cpIHtcbiBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHN5bSwge1xuICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB3YXJuT25jZShcImBcIiArIHN5bSArIFwiYCBpcyBub3QgbG9uZ2VyIGRlZmluZWQgYnkgZW1zY3JpcHRlbi4gXCIgKyBtc2cpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICB9XG4gIH0pO1xuIH1cbn1cblxubWlzc2luZ0dsb2JhbChcImJ1ZmZlclwiLCBcIlBsZWFzZSB1c2UgSEVBUDguYnVmZmVyIG9yIHdhc21NZW1vcnkuYnVmZmVyXCIpO1xuXG5mdW5jdGlvbiBtaXNzaW5nTGlicmFyeVN5bWJvbChzeW0pIHtcbiBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywgc3ltKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSBcImBcIiArIHN5bSArIFwiYCBpcyBhIGxpYnJhcnkgc3ltYm9sIGFuZCBub3QgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYWRkIGl0IHRvIHlvdXIgbGlicmFyeS5qcyBfX2RlcHMgb3IgdG8gREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREUgb24gdGhlIGNvbW1hbmQgbGluZVwiO1xuICAgIHZhciBsaWJyYXJ5U3ltYm9sID0gc3ltO1xuICAgIGlmICghbGlicmFyeVN5bWJvbC5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICBsaWJyYXJ5U3ltYm9sID0gXCIkXCIgKyBzeW07XG4gICAgfVxuICAgIG1zZyArPSBcIiAoZS5nLiAtc0RFRkFVTFRfTElCUkFSWV9GVU5DU19UT19JTkNMVURFPVwiICsgbGlicmFyeVN5bWJvbCArIFwiKVwiO1xuICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xuICAgICBtc2cgKz0gXCIuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtc0ZPUkNFX0ZJTEVTWVNURU0pIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCI7XG4gICAgfVxuICAgIHdhcm5PbmNlKG1zZyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgIH1cbiAgfSk7XG4gfVxuIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSk7XG59XG5cbmZ1bmN0aW9uIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSkge1xuIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHN5bSkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSBcIidcIiArIHN5bSArIFwiJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIjtcbiAgICBpZiAoaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKHN5bSkpIHtcbiAgICAgbXNnICs9IFwiLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXNGT1JDRV9GSUxFU1lTVEVNKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiO1xuICAgIH1cbiAgICBhYm9ydChtc2cpO1xuICAgfVxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGRiZyh0ZXh0KSB7XG4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gdGhpcy5uYW1lID0gXCJFeGl0U3RhdHVzXCI7XG4gdGhpcy5tZXNzYWdlID0gYFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzdGF0dXN9KWA7XG4gdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG59XG5cbmZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuIH1cbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUocHRyLCB0eXBlID0gXCJpOFwiKSB7XG4gaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB0eXBlID0gXCIqXCI7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSBcImkxXCI6XG4gIHJldHVybiBIRUFQOFtwdHIgPj4+IDBdO1xuXG4gY2FzZSBcImk4XCI6XG4gIHJldHVybiBIRUFQOFtwdHIgPj4+IDBdO1xuXG4gY2FzZSBcImkxNlwiOlxuICByZXR1cm4gSEVBUDE2W3B0ciA+Pj4gMV07XG5cbiBjYXNlIFwiaTMyXCI6XG4gIHJldHVybiBIRUFQMzJbcHRyID4+PiAyXTtcblxuIGNhc2UgXCJpNjRcIjpcbiAgYWJvcnQoXCJ0byBkbyBnZXRWYWx1ZShpNjQpIHVzZSBXQVNNX0JJR0lOVFwiKTtcblxuIGNhc2UgXCJmbG9hdFwiOlxuICByZXR1cm4gSEVBUEYzMltwdHIgPj4+IDJdO1xuXG4gY2FzZSBcImRvdWJsZVwiOlxuICByZXR1cm4gSEVBUEY2NFtwdHIgPj4+IDNdO1xuXG4gY2FzZSBcIipcIjpcbiAgcmV0dXJuIEhFQVBVMzJbcHRyID4+PiAyXTtcblxuIGRlZmF1bHQ6XG4gIGFib3J0KGBpbnZhbGlkIHR5cGUgZm9yIGdldFZhbHVlOiAke3R5cGV9YCk7XG4gfVxufVxuXG5mdW5jdGlvbiBwdHJUb1N0cmluZyhwdHIpIHtcbiBhc3NlcnQodHlwZW9mIHB0ciA9PT0gXCJudW1iZXJcIik7XG4gcmV0dXJuIFwiMHhcIiArIHB0ci50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gXCJpOFwiKSB7XG4gaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB0eXBlID0gXCIqXCI7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSBcImkxXCI6XG4gIEhFQVA4W3B0ciA+Pj4gMF0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaThcIjpcbiAgSEVBUDhbcHRyID4+PiAwXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJpMTZcIjpcbiAgSEVBUDE2W3B0ciA+Pj4gMV0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaTMyXCI6XG4gIEhFQVAzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcImk2NFwiOlxuICBhYm9ydChcInRvIGRvIHNldFZhbHVlKGk2NCkgdXNlIFdBU01fQklHSU5UXCIpO1xuXG4gY2FzZSBcImZsb2F0XCI6XG4gIEhFQVBGMzJbcHRyID4+PiAyXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJkb3VibGVcIjpcbiAgSEVBUEY2NFtwdHIgPj4+IDNdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcIipcIjpcbiAgSEVBUFUzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgYWJvcnQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7dHlwZX1gKTtcbiB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKHRleHQpIHtcbiBpZiAoIXdhcm5PbmNlLnNob3duKSB3YXJuT25jZS5zaG93biA9IHt9O1xuIGlmICghd2Fybk9uY2Uuc2hvd25bdGV4dF0pIHtcbiAgd2Fybk9uY2Uuc2hvd25bdGV4dF0gPSAxO1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkgdGV4dCA9IFwid2FybmluZzogXCIgKyB0ZXh0O1xuICBlcnIodGV4dCk7XG4gfVxufVxuXG5mdW5jdGlvbiBfWE1MX0dldEJ1ZmZlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfR2V0QnVmZmVyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9HZXRFcnJvckNvZGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX0dldEVycm9yQ29kZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfUGFyc2UoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1BhcnNlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZUJ1ZmZlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VCdWZmZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1BhcnNlckNyZWF0ZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VyQ3JlYXRlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZXJGcmVlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZXJGcmVlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9SZXN1bWVQYXJzZXIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1Jlc3VtZVBhcnNlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9TZXRFbGVtZW50SGFuZGxlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0RWxlbWVudEhhbmRsZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1NldFVzZXJEYXRhKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9TZXRVc2VyRGF0YVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU3RvcFBhcnNlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU3RvcFBhcnNlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbkluZm8oZXhjUHRyKSB7XG4gdGhpcy5leGNQdHIgPSBleGNQdHI7XG4gdGhpcy5wdHIgPSBleGNQdHIgLSAyNDtcbiB0aGlzLnNldF90eXBlID0gZnVuY3Rpb24odHlwZSkge1xuICBIRUFQVTMyW3RoaXMucHRyICsgNCA+Pj4gMl0gPSB0eXBlO1xuIH07XG4gdGhpcy5nZXRfdHlwZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSEVBUFUzMlt0aGlzLnB0ciArIDQgPj4+IDJdO1xuIH07XG4gdGhpcy5zZXRfZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKGRlc3RydWN0b3IpIHtcbiAgSEVBUFUzMlt0aGlzLnB0ciArIDggPj4+IDJdID0gZGVzdHJ1Y3RvcjtcbiB9O1xuIHRoaXMuZ2V0X2Rlc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIgKyA4ID4+PiAyXTtcbiB9O1xuIHRoaXMuc2V0X2NhdWdodCA9IGZ1bmN0aW9uKGNhdWdodCkge1xuICBjYXVnaHQgPSBjYXVnaHQgPyAxIDogMDtcbiAgSEVBUDhbdGhpcy5wdHIgKyAxMiA+Pj4gMF0gPSBjYXVnaHQ7XG4gfTtcbiB0aGlzLmdldF9jYXVnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEhFQVA4W3RoaXMucHRyICsgMTIgPj4+IDBdICE9IDA7XG4gfTtcbiB0aGlzLnNldF9yZXRocm93biA9IGZ1bmN0aW9uKHJldGhyb3duKSB7XG4gIHJldGhyb3duID0gcmV0aHJvd24gPyAxIDogMDtcbiAgSEVBUDhbdGhpcy5wdHIgKyAxMyA+Pj4gMF0gPSByZXRocm93bjtcbiB9O1xuIHRoaXMuZ2V0X3JldGhyb3duID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBIRUFQOFt0aGlzLnB0ciArIDEzID4+PiAwXSAhPSAwO1xuIH07XG4gdGhpcy5pbml0ID0gZnVuY3Rpb24odHlwZSwgZGVzdHJ1Y3Rvcikge1xuICB0aGlzLnNldF9hZGp1c3RlZF9wdHIoMCk7XG4gIHRoaXMuc2V0X3R5cGUodHlwZSk7XG4gIHRoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcik7XG4gfTtcbiB0aGlzLnNldF9hZGp1c3RlZF9wdHIgPSBmdW5jdGlvbihhZGp1c3RlZFB0cikge1xuICBIRUFQVTMyW3RoaXMucHRyICsgMTYgPj4+IDJdID0gYWRqdXN0ZWRQdHI7XG4gfTtcbiB0aGlzLmdldF9hZGp1c3RlZF9wdHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIgKyAxNiA+Pj4gMl07XG4gfTtcbiB0aGlzLmdldF9leGNlcHRpb25fcHRyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc1BvaW50ZXIgPSBfX19jeGFfaXNfcG9pbnRlcl90eXBlKHRoaXMuZ2V0X3R5cGUoKSk7XG4gIGlmIChpc1BvaW50ZXIpIHtcbiAgIHJldHVybiBIRUFQVTMyW3RoaXMuZXhjUHRyID4+PiAyXTtcbiAgfVxuICB2YXIgYWRqdXN0ZWQgPSB0aGlzLmdldF9hZGp1c3RlZF9wdHIoKTtcbiAgaWYgKGFkanVzdGVkICE9PSAwKSByZXR1cm4gYWRqdXN0ZWQ7XG4gIHJldHVybiB0aGlzLmV4Y1B0cjtcbiB9O1xufVxuXG52YXIgZXhjZXB0aW9uTGFzdCA9IDA7XG5cbnZhciB1bmNhdWdodEV4Y2VwdGlvbkNvdW50ID0gMDtcblxuZnVuY3Rpb24gX19fY3hhX3Rocm93KHB0ciwgdHlwZSwgZGVzdHJ1Y3Rvcikge1xuIHZhciBpbmZvID0gbmV3IEV4Y2VwdGlvbkluZm8ocHRyKTtcbiBpbmZvLmluaXQodHlwZSwgZGVzdHJ1Y3Rvcik7XG4gZXhjZXB0aW9uTGFzdCA9IHB0cjtcbiB1bmNhdWdodEV4Y2VwdGlvbkNvdW50Kys7XG4gYXNzZXJ0KGZhbHNlLCBcIkV4Y2VwdGlvbiB0aHJvd24sIGJ1dCBleGNlcHRpb24gY2F0Y2hpbmcgaXMgbm90IGVuYWJsZWQuIENvbXBpbGUgd2l0aCAtc05PX0RJU0FCTEVfRVhDRVBUSU9OX0NBVENISU5HIG9yIC1zRVhDRVBUSU9OX0NBVENISU5HX0FMTE9XRUQ9Wy4uXSB0byBjYXRjaC5cIik7XG59XG5cbnZhciBkbG9wZW5NaXNzaW5nRXJyb3IgPSBcIlRvIHVzZSBkbG9wZW4sIHlvdSBuZWVkIGVuYWJsZSBkeW5hbWljIGxpbmtpbmcsIHNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvY29tcGlsaW5nL0R5bmFtaWMtTGlua2luZy5odG1sXCI7XG5cbmZ1bmN0aW9uIF9fX2Rsc3ltKGhhbmRsZSwgc3ltYm9sLCByYSkge1xuIGFib3J0KGRsb3Blbk1pc3NpbmdFcnJvcik7XG59XG5cbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSBcInVuZGVmaW5lZFwiID8gbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcoaGVhcE9yQXJyYXksIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiBpZHggPj4+PSAwO1xuIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiB2YXIgZW5kUHRyID0gaWR4O1xuIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuIH1cbiB2YXIgc3RyID0gXCJcIjtcbiB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgaWYgKCEodTAgJiAxMjgpKSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICBjb250aW51ZTtcbiAgfVxuICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgaWYgKCh1MCAmIDIyNCkgPT0gMTkyKSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodTAgJiAzMSkgPDwgNiB8IHUxKTtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICBpZiAoKHUwICYgMjQwKSA9PSAyMjQpIHtcbiAgIHUwID0gKHUwICYgMTUpIDw8IDEyIHwgdTEgPDwgNiB8IHUyO1xuICB9IGVsc2Uge1xuICAgaWYgKCh1MCAmIDI0OCkgIT0gMjQwKSB3YXJuT25jZShcIkludmFsaWQgVVRGLTggbGVhZGluZyBieXRlIFwiICsgcHRyVG9TdHJpbmcodTApICsgXCIgZW5jb3VudGVyZWQgd2hlbiBkZXNlcmlhbGl6aW5nIGEgVVRGLTggc3RyaW5nIGluIHdhc20gbWVtb3J5IHRvIGEgSlMgc3RyaW5nIVwiKTtcbiAgIHUwID0gKHUwICYgNykgPDwgMTggfCB1MSA8PCAxMiB8IHUyIDw8IDYgfCBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgfVxuICBpZiAodTAgPCA2NTUzNikge1xuICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICB9IGVsc2Uge1xuICAgdmFyIGNoID0gdTAgLSA2NTUzNjtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgY2ggPj4gMTAsIDU2MzIwIHwgY2ggJiAxMDIzKTtcbiAgfVxuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkge1xuIGFzc2VydCh0eXBlb2YgcHRyID09IFwibnVtYmVyXCIpO1xuIHB0ciA+Pj49IDA7XG4gcmV0dXJuIHB0ciA/IFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiBcIlwiO1xufVxuXG52YXIgU1lTQ0FMTFMgPSB7XG4gdmFyYXJnczogdW5kZWZpbmVkLFxuIGdldDogZnVuY3Rpb24oKSB7XG4gIGFzc2VydChTWVNDQUxMUy52YXJhcmdzICE9IHVuZGVmaW5lZCk7XG4gIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgdmFyIHJldCA9IEhFQVAzMltTWVNDQUxMUy52YXJhcmdzIC0gNCA+Pj4gMl07XG4gIHJldHVybiByZXQ7XG4gfSxcbiBnZXRTdHI6IGZ1bmN0aW9uKHB0cikge1xuICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gIHJldHVybiByZXQ7XG4gfVxufTtcblxuZnVuY3Rpb24gX19fc3lzY2FsbF9fbmV3c2VsZWN0KG5mZHMsIHJlYWRmZHMsIHdyaXRlZmRzLCBleGNlcHRmZHMsIHRpbWVvdXQpIHtcbiBhc3NlcnQobmZkcyA8PSA2NCwgXCJuZmRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDY0XCIpO1xuIGFzc2VydCghZXhjZXB0ZmRzLCBcImV4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkXCIpO1xuIHZhciB0b3RhbCA9IDA7XG4gdmFyIHNyY1JlYWRMb3cgPSByZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgPj4+IDJdIDogMCwgc3JjUmVhZEhpZ2ggPSByZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIHNyY1dyaXRlTG93ID0gd3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdIDogMCwgc3JjV3JpdGVIaWdoID0gd3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIHNyY0V4Y2VwdExvdyA9IGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgPj4+IDJdIDogMCwgc3JjRXhjZXB0SGlnaCA9IGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIGRzdFJlYWRMb3cgPSAwLCBkc3RSZWFkSGlnaCA9IDA7XG4gdmFyIGRzdFdyaXRlTG93ID0gMCwgZHN0V3JpdGVIaWdoID0gMDtcbiB2YXIgZHN0RXhjZXB0TG93ID0gMCwgZHN0RXhjZXB0SGlnaCA9IDA7XG4gdmFyIGFsbExvdyA9IChyZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgPj4+IDJdIDogMCkgfCAod3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdIDogMCkgfCAoZXhjZXB0ZmRzID8gSEVBUDMyW2V4Y2VwdGZkcyA+Pj4gMl0gOiAwKTtcbiB2YXIgYWxsSGlnaCA9IChyZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA6IDApIHwgKHdyaXRlZmRzID8gSEVBUDMyW3dyaXRlZmRzICsgNCA+Pj4gMl0gOiAwKSB8IChleGNlcHRmZHMgPyBIRUFQMzJbZXhjZXB0ZmRzICsgNCA+Pj4gMl0gOiAwKTtcbiB2YXIgY2hlY2sgPSBmdW5jdGlvbihmZCwgbG93LCBoaWdoLCB2YWwpIHtcbiAgcmV0dXJuIGZkIDwgMzIgPyBsb3cgJiB2YWwgOiBoaWdoICYgdmFsO1xuIH07XG4gZm9yICh2YXIgZmQgPSAwOyBmZCA8IG5mZHM7IGZkKyspIHtcbiAgdmFyIG1hc2sgPSAxIDw8IGZkICUgMzI7XG4gIGlmICghY2hlY2soZmQsIGFsbExvdywgYWxsSGlnaCwgbWFzaykpIHtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICB2YXIgZmxhZ3MgPSBTWVNDQUxMUy5ERUZBVUxUX1BPTExNQVNLO1xuICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMucG9sbCkge1xuICAgZmxhZ3MgPSBzdHJlYW0uc3RyZWFtX29wcy5wb2xsKHN0cmVhbSk7XG4gIH1cbiAgaWYgKGZsYWdzICYgMSAmJiBjaGVjayhmZCwgc3JjUmVhZExvdywgc3JjUmVhZEhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0UmVhZExvdyA9IGRzdFJlYWRMb3cgfCBtYXNrIDogZHN0UmVhZEhpZ2ggPSBkc3RSZWFkSGlnaCB8IG1hc2s7XG4gICB0b3RhbCsrO1xuICB9XG4gIGlmIChmbGFncyAmIDQgJiYgY2hlY2soZmQsIHNyY1dyaXRlTG93LCBzcmNXcml0ZUhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0V3JpdGVMb3cgPSBkc3RXcml0ZUxvdyB8IG1hc2sgOiBkc3RXcml0ZUhpZ2ggPSBkc3RXcml0ZUhpZ2ggfCBtYXNrO1xuICAgdG90YWwrKztcbiAgfVxuICBpZiAoZmxhZ3MgJiAyICYmIGNoZWNrKGZkLCBzcmNFeGNlcHRMb3csIHNyY0V4Y2VwdEhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0RXhjZXB0TG93ID0gZHN0RXhjZXB0TG93IHwgbWFzayA6IGRzdEV4Y2VwdEhpZ2ggPSBkc3RFeGNlcHRIaWdoIHwgbWFzaztcbiAgIHRvdGFsKys7XG4gIH1cbiB9XG4gaWYgKHJlYWRmZHMpIHtcbiAgSEVBUDMyW3JlYWRmZHMgPj4+IDJdID0gZHN0UmVhZExvdztcbiAgSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA9IGRzdFJlYWRIaWdoO1xuIH1cbiBpZiAod3JpdGVmZHMpIHtcbiAgSEVBUDMyW3dyaXRlZmRzID4+PiAyXSA9IGRzdFdyaXRlTG93O1xuICBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA9IGRzdFdyaXRlSGlnaDtcbiB9XG4gaWYgKGV4Y2VwdGZkcykge1xuICBIRUFQMzJbZXhjZXB0ZmRzID4+PiAyXSA9IGRzdEV4Y2VwdExvdztcbiAgSEVBUDMyW2V4Y2VwdGZkcyArIDQgPj4+IDJdID0gZHN0RXhjZXB0SGlnaDtcbiB9XG4gcmV0dXJuIHRvdGFsO1xufVxuXG5mdW5jdGlvbiBTT0NLRlMoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogJFNPQ0tGU1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIEZTKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246ICRGU1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvY2tldEZyb21GRChmZCkge1xuIHZhciBzb2NrZXQgPSBTT0NLRlMuZ2V0U29ja2V0KGZkKTtcbiBpZiAoIXNvY2tldCkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gcmV0dXJuIHNvY2tldDtcbn1cblxuZnVuY3Rpb24gc2V0RXJyTm8odmFsdWUpIHtcbiBIRUFQMzJbX19fZXJybm9fbG9jYXRpb24oKSA+Pj4gMl0gPSB2YWx1ZTtcbiByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBTb2NrZXRzID0ge1xuIEJVRkZFUl9TSVpFOiAxMDI0MCxcbiBNQVhfQlVGRkVSX1NJWkU6IDEwNDg1NzYwLFxuIG5leHRGZDogMSxcbiBmZHM6IHt9LFxuIG5leHRwb3J0OiAxLFxuIG1heHBvcnQ6IDY1NTM1LFxuIHBlZXI6IG51bGwsXG4gY29ubmVjdGlvbnM6IHt9LFxuIHBvcnRtYXA6IHt9LFxuIGxvY2FsQWRkcjogNDI2MTQxMjg3NCxcbiBhZGRyUG9vbDogWyAzMzU1NDQ0MiwgNTAzMzE2NTgsIDY3MTA4ODc0LCA4Mzg4NjA5MCwgMTAwNjYzMzA2LCAxMTc0NDA1MjIsIDEzNDIxNzczOCwgMTUwOTk0OTU0LCAxNjc3NzIxNzAsIDE4NDU0OTM4NiwgMjAxMzI2NjAyLCAyMTgxMDM4MTgsIDIzNDg4MTAzNCBdXG59O1xuXG5mdW5jdGlvbiBpbmV0TnRvcDQoYWRkcikge1xuIHJldHVybiAoYWRkciAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDggJiAyNTUpICsgXCIuXCIgKyAoYWRkciA+PiAxNiAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDI0ICYgMjU1KTtcbn1cblxuZnVuY3Rpb24gaW5ldE50b3A2KGludHMpIHtcbiB2YXIgc3RyID0gXCJcIjtcbiB2YXIgd29yZCA9IDA7XG4gdmFyIGxvbmdlc3QgPSAwO1xuIHZhciBsYXN0emVybyA9IDA7XG4gdmFyIHpzdGFydCA9IDA7XG4gdmFyIGxlbiA9IDA7XG4gdmFyIGkgPSAwO1xuIHZhciBwYXJ0cyA9IFsgaW50c1swXSAmIDY1NTM1LCBpbnRzWzBdID4+IDE2LCBpbnRzWzFdICYgNjU1MzUsIGludHNbMV0gPj4gMTYsIGludHNbMl0gJiA2NTUzNSwgaW50c1syXSA+PiAxNiwgaW50c1szXSAmIDY1NTM1LCBpbnRzWzNdID4+IDE2IF07XG4gdmFyIGhhc2lwdjQgPSB0cnVlO1xuIHZhciB2NHBhcnQgPSBcIlwiO1xuIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgaWYgKHBhcnRzW2ldICE9PSAwKSB7XG4gICBoYXNpcHY0ID0gZmFsc2U7XG4gICBicmVhaztcbiAgfVxuIH1cbiBpZiAoaGFzaXB2NCkge1xuICB2NHBhcnQgPSBpbmV0TnRvcDQocGFydHNbNl0gfCBwYXJ0c1s3XSA8PCAxNik7XG4gIGlmIChwYXJ0c1s1XSA9PT0gLTEpIHtcbiAgIHN0ciA9IFwiOjpmZmZmOlwiO1xuICAgc3RyICs9IHY0cGFydDtcbiAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKHBhcnRzWzVdID09PSAwKSB7XG4gICBzdHIgPSBcIjo6XCI7XG4gICBpZiAodjRwYXJ0ID09PSBcIjAuMC4wLjBcIikgdjRwYXJ0ID0gXCJcIjtcbiAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMVwiKSB2NHBhcnQgPSBcIjFcIjtcbiAgIHN0ciArPSB2NHBhcnQ7XG4gICByZXR1cm4gc3RyO1xuICB9XG4gfVxuIGZvciAod29yZCA9IDA7IHdvcmQgPCA4OyB3b3JkKyspIHtcbiAgaWYgKHBhcnRzW3dvcmRdID09PSAwKSB7XG4gICBpZiAod29yZCAtIGxhc3R6ZXJvID4gMSkge1xuICAgIGxlbiA9IDA7XG4gICB9XG4gICBsYXN0emVybyA9IHdvcmQ7XG4gICBsZW4rKztcbiAgfVxuICBpZiAobGVuID4gbG9uZ2VzdCkge1xuICAgbG9uZ2VzdCA9IGxlbjtcbiAgIHpzdGFydCA9IHdvcmQgLSBsb25nZXN0ICsgMTtcbiAgfVxuIH1cbiBmb3IgKHdvcmQgPSAwOyB3b3JkIDwgODsgd29yZCsrKSB7XG4gIGlmIChsb25nZXN0ID4gMSkge1xuICAgaWYgKHBhcnRzW3dvcmRdID09PSAwICYmIHdvcmQgPj0genN0YXJ0ICYmIHdvcmQgPCB6c3RhcnQgKyBsb25nZXN0KSB7XG4gICAgaWYgKHdvcmQgPT09IHpzdGFydCkge1xuICAgICBzdHIgKz0gXCI6XCI7XG4gICAgIGlmICh6c3RhcnQgPT09IDApIHN0ciArPSBcIjpcIjtcbiAgICB9XG4gICAgY29udGludWU7XG4gICB9XG4gIH1cbiAgc3RyICs9IE51bWJlcihfbnRvaHMocGFydHNbd29yZF0gJiA2NTUzNSkpLnRvU3RyaW5nKDE2KTtcbiAgc3RyICs9IHdvcmQgPCA3ID8gXCI6XCIgOiBcIlwiO1xuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiByZWFkU29ja2FkZHIoc2EsIHNhbGVuKSB7XG4gdmFyIGZhbWlseSA9IEhFQVAxNltzYSA+Pj4gMV07XG4gdmFyIHBvcnQgPSBfbnRvaHMoSEVBUFUxNltzYSArIDIgPj4+IDFdKTtcbiB2YXIgYWRkcjtcbiBzd2l0Y2ggKGZhbWlseSkge1xuIGNhc2UgMjpcbiAgaWYgKHNhbGVuICE9PSAxNikge1xuICAgcmV0dXJuIHtcbiAgICBlcnJubzogMjhcbiAgIH07XG4gIH1cbiAgYWRkciA9IEhFQVAzMltzYSArIDQgPj4+IDJdO1xuICBhZGRyID0gaW5ldE50b3A0KGFkZHIpO1xuICBicmVhaztcblxuIGNhc2UgMTA6XG4gIGlmIChzYWxlbiAhPT0gMjgpIHtcbiAgIHJldHVybiB7XG4gICAgZXJybm86IDI4XG4gICB9O1xuICB9XG4gIGFkZHIgPSBbIEhFQVAzMltzYSArIDggPj4+IDJdLCBIRUFQMzJbc2EgKyAxMiA+Pj4gMl0sIEhFQVAzMltzYSArIDE2ID4+PiAyXSwgSEVBUDMyW3NhICsgMjAgPj4+IDJdIF07XG4gIGFkZHIgPSBpbmV0TnRvcDYoYWRkcik7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgcmV0dXJuIHtcbiAgIGVycm5vOiA1XG4gIH07XG4gfVxuIHJldHVybiB7XG4gIGZhbWlseTogZmFtaWx5LFxuICBhZGRyOiBhZGRyLFxuICBwb3J0OiBwb3J0XG4gfTtcbn1cblxuZnVuY3Rpb24gaW5ldFB0b240KHN0cikge1xuIHZhciBiID0gc3RyLnNwbGl0KFwiLlwiKTtcbiBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICB2YXIgdG1wID0gTnVtYmVyKGJbaV0pO1xuICBpZiAoaXNOYU4odG1wKSkgcmV0dXJuIG51bGw7XG4gIGJbaV0gPSB0bXA7XG4gfVxuIHJldHVybiAoYlswXSB8IGJbMV0gPDwgOCB8IGJbMl0gPDwgMTYgfCBiWzNdIDw8IDI0KSA+Pj4gMDtcbn1cblxuZnVuY3Rpb24ganN0b2lfcShzdHIpIHtcbiByZXR1cm4gcGFyc2VJbnQoc3RyKTtcbn1cblxuZnVuY3Rpb24gaW5ldFB0b242KHN0cikge1xuIHZhciB3b3JkcztcbiB2YXIgdywgb2Zmc2V0LCB6LCBpO1xuIHZhciB2YWxpZDZyZWd4ID0gL14oKD89Lio6OikoPyEuKjo6Lis6OikoOjopPyhbXFxkQS1GXXsxLDR9Oig6fFxcYil8KXs1fXwoW1xcZEEtRl17MSw0fTopezZ9KSgoKFtcXGRBLUZdezEsNH0oKD8hXFwzKTo6fDpcXGJ8JCkpfCg/IVxcMlxcMykpezJ9fCgoKDJbMC00XXwxXFxkfFsxLTldKT9cXGR8MjVbMC01XSlcXC4/XFxiKXs0fSkkL2k7XG4gdmFyIHBhcnRzID0gW107XG4gaWYgKCF2YWxpZDZyZWd4LnRlc3Qoc3RyKSkge1xuICByZXR1cm4gbnVsbDtcbiB9XG4gaWYgKHN0ciA9PT0gXCI6OlwiKSB7XG4gIHJldHVybiBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXTtcbiB9XG4gaWYgKHN0ci5zdGFydHNXaXRoKFwiOjpcIikpIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UoXCI6OlwiLCBcIlo6XCIpO1xuIH0gZWxzZSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKFwiOjpcIiwgXCI6WjpcIik7XG4gfVxuIGlmIChzdHIuaW5kZXhPZihcIi5cIikgPiAwKSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbLl1cIiwgXCJnXCIpLCBcIjpcIik7XG4gIHdvcmRzID0gc3RyLnNwbGl0KFwiOlwiKTtcbiAgd29yZHNbd29yZHMubGVuZ3RoIC0gNF0gPSBqc3RvaV9xKHdvcmRzW3dvcmRzLmxlbmd0aCAtIDRdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gM10pICogMjU2O1xuICB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAzXSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gMl0pICsganN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSkgKiAyNTY7XG4gIHdvcmRzID0gd29yZHMuc2xpY2UoMCwgd29yZHMubGVuZ3RoIC0gMik7XG4gfSBlbHNlIHtcbiAgd29yZHMgPSBzdHIuc3BsaXQoXCI6XCIpO1xuIH1cbiBvZmZzZXQgPSAwO1xuIHogPSAwO1xuIGZvciAodyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICBpZiAodHlwZW9mIHdvcmRzW3ddID09IFwic3RyaW5nXCIpIHtcbiAgIGlmICh3b3Jkc1t3XSA9PT0gXCJaXCIpIHtcbiAgICBmb3IgKHogPSAwOyB6IDwgOCAtIHdvcmRzLmxlbmd0aCArIDE7IHorKykge1xuICAgICBwYXJ0c1t3ICsgel0gPSAwO1xuICAgIH1cbiAgICBvZmZzZXQgPSB6IC0gMTtcbiAgIH0gZWxzZSB7XG4gICAgcGFydHNbdyArIG9mZnNldF0gPSBfaHRvbnMocGFyc2VJbnQod29yZHNbd10sIDE2KSk7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBwYXJ0c1t3ICsgb2Zmc2V0XSA9IHdvcmRzW3ddO1xuICB9XG4gfVxuIHJldHVybiBbIHBhcnRzWzFdIDw8IDE2IHwgcGFydHNbMF0sIHBhcnRzWzNdIDw8IDE2IHwgcGFydHNbMl0sIHBhcnRzWzVdIDw8IDE2IHwgcGFydHNbNF0sIHBhcnRzWzddIDw8IDE2IHwgcGFydHNbNl0gXTtcbn1cblxudmFyIEROUyA9IHtcbiBhZGRyZXNzX21hcDoge1xuICBpZDogMSxcbiAgYWRkcnM6IHt9LFxuICBuYW1lczoge31cbiB9LFxuIGxvb2t1cF9uYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciByZXMgPSBpbmV0UHRvbjQobmFtZSk7XG4gIGlmIChyZXMgIT09IG51bGwpIHtcbiAgIHJldHVybiBuYW1lO1xuICB9XG4gIHJlcyA9IGluZXRQdG9uNihuYW1lKTtcbiAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgdmFyIGFkZHI7XG4gIGlmIChETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV0pIHtcbiAgIGFkZHIgPSBETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV07XG4gIH0gZWxzZSB7XG4gICB2YXIgaWQgPSBETlMuYWRkcmVzc19tYXAuaWQrKztcbiAgIGFzc2VydChpZCA8IDY1NTM1LCBcImV4Y2VlZGVkIG1heCBhZGRyZXNzIG1hcHBpbmdzIG9mIDY1NTM1XCIpO1xuICAgYWRkciA9IFwiMTcyLjI5LlwiICsgKGlkICYgMjU1KSArIFwiLlwiICsgKGlkICYgNjUyODApO1xuICAgRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdID0gbmFtZTtcbiAgIEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSA9IGFkZHI7XG4gIH1cbiAgcmV0dXJuIGFkZHI7XG4gfSxcbiBsb29rdXBfYWRkcjogZnVuY3Rpb24oYWRkcikge1xuICBpZiAoRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdKSB7XG4gICByZXR1cm4gRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdO1xuICB9XG4gIHJldHVybiBudWxsO1xuIH1cbn07XG5cbmZ1bmN0aW9uIGdldFNvY2tldEFkZHJlc3MoYWRkcnAsIGFkZHJsZW4sIGFsbG93TnVsbCkge1xuIGlmIChhbGxvd051bGwgJiYgYWRkcnAgPT09IDApIHJldHVybiBudWxsO1xuIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKGFkZHJwLCBhZGRybGVuKTtcbiBpZiAoaW5mby5lcnJubykgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoaW5mby5lcnJubyk7XG4gaW5mby5hZGRyID0gRE5TLmxvb2t1cF9hZGRyKGluZm8uYWRkcikgfHwgaW5mby5hZGRyO1xuIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2JpbmQoZmQsIGFkZHIsIGFkZHJsZW4sIGQxLCBkMiwgZDMpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gdmFyIGluZm8gPSBnZXRTb2NrZXRBZGRyZXNzKGFkZHIsIGFkZHJsZW4pO1xuIHNvY2suc29ja19vcHMuYmluZChzb2NrLCBpbmZvLmFkZHIsIGluZm8ucG9ydCk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfY29ubmVjdChmZCwgYWRkciwgYWRkcmxlbiwgZDEsIGQyLCBkMykge1xuIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiB2YXIgaW5mbyA9IGdldFNvY2tldEFkZHJlc3MoYWRkciwgYWRkcmxlbik7XG4gc29jay5zb2NrX29wcy5jb25uZWN0KHNvY2ssIGluZm8uYWRkciwgaW5mby5wb3J0KTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsIGNtZCwgdmFyYXJncykge1xuIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZChsbywgaGkpIHtcbiBhc3NlcnQobG8gPT0gbG8gPj4+IDAgfHwgbG8gPT0gKGxvIHwgMCkpO1xuIGFzc2VydChoaSA9PT0gKGhpIHwgMCkpO1xuIHJldHVybiBoaSArIDIwOTcxNTIgPj4+IDAgPCA0MTk0MzA1IC0gISFsbyA/IChsbyA+Pj4gMCkgKyBoaSAqIDQyOTQ5NjcyOTYgOiBOYU47XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZnRydW5jYXRlNjQoZmQsIGxlbmd0aF9sb3csIGxlbmd0aF9oaWdoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiBvdXRJZHggPj4+PSAwO1xuIGFzc2VydCh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKTtcbiBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDA7XG4gdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHtcbiAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICB1ID0gNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkgfCB1MSAmIDEwMjM7XG4gIH1cbiAgaWYgKHUgPD0gMTI3KSB7XG4gICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IHU7XG4gIH0gZWxzZSBpZiAodSA8PSAyMDQ3KSB7XG4gICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxOTIgfCB1ID4+IDY7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDEyOCB8IHUgJiA2MztcbiAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7XG4gICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAyMjQgfCB1ID4+IDEyO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9IGVsc2Uge1xuICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgIGlmICh1ID4gMTExNDExMSkgd2Fybk9uY2UoXCJJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCBcIiArIHB0clRvU3RyaW5nKHUpICsgXCIgZW5jb3VudGVyZWQgd2hlbiBzZXJpYWxpemluZyBhIEpTIHN0cmluZyB0byBhIFVURi04IHN0cmluZyBpbiB3YXNtIG1lbW9yeSEgKFZhbGlkIHVuaWNvZGUgY29kZSBwb2ludHMgc2hvdWxkIGJlIGluIHJhbmdlIDAtMHgxMEZGRkYpLlwiKTtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMjQwIHwgdSA+PiAxODtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSA+PiAxMiAmIDYzO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9XG4gfVxuIGhlYXBbb3V0SWR4ID4+PiAwXSA9IDA7XG4gcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09IFwibnVtYmVyXCIsIFwic3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIVwiKTtcbiByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRkZW50czY0KGZkLCBkaXJwLCBjb3VudCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3MsIHNpemUpIHtcbiBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gcmV0dXJuIGFkZHJlc3M7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCwgYWRkcmxlbikge1xuIHN3aXRjaCAoZmFtaWx5KSB7XG4gY2FzZSAyOlxuICBhZGRyID0gaW5ldFB0b240KGFkZHIpO1xuICB6ZXJvTWVtb3J5KHNhLCAxNik7XG4gIGlmIChhZGRybGVuKSB7XG4gICBIRUFQMzJbYWRkcmxlbiA+Pj4gMl0gPSAxNjtcbiAgfVxuICBIRUFQMTZbc2EgPj4+IDFdID0gZmFtaWx5O1xuICBIRUFQMzJbc2EgKyA0ID4+PiAyXSA9IGFkZHI7XG4gIEhFQVAxNltzYSArIDIgPj4+IDFdID0gX2h0b25zKHBvcnQpO1xuICBicmVhaztcblxuIGNhc2UgMTA6XG4gIGFkZHIgPSBpbmV0UHRvbjYoYWRkcik7XG4gIHplcm9NZW1vcnkoc2EsIDI4KTtcbiAgaWYgKGFkZHJsZW4pIHtcbiAgIEhFQVAzMlthZGRybGVuID4+PiAyXSA9IDI4O1xuICB9XG4gIEhFQVAzMltzYSA+Pj4gMl0gPSBmYW1pbHk7XG4gIEhFQVAzMltzYSArIDggPj4+IDJdID0gYWRkclswXTtcbiAgSEVBUDMyW3NhICsgMTIgPj4+IDJdID0gYWRkclsxXTtcbiAgSEVBUDMyW3NhICsgMTYgPj4+IDJdID0gYWRkclsyXTtcbiAgSEVBUDMyW3NhICsgMjAgPj4+IDJdID0gYWRkclszXTtcbiAgSEVBUDE2W3NhICsgMiA+Pj4gMV0gPSBfaHRvbnMocG9ydCk7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgcmV0dXJuIDU7XG4gfVxuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldHBlZXJuYW1lKGZkLCBhZGRyLCBhZGRybGVuLCBkMSwgZDIsIGQzKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIGlmICghc29jay5kYWRkcikge1xuICByZXR1cm4gLTUzO1xuIH1cbiB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIHNvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUoc29jay5kYWRkciksIHNvY2suZHBvcnQsIGFkZHJsZW4pO1xuIGFzc2VydCghZXJybm8pO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldHNvY2tvcHQoZmQsIGxldmVsLCBvcHRuYW1lLCBvcHR2YWwsIG9wdGxlbiwgZDEpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gaWYgKGxldmVsID09PSAxKSB7XG4gIGlmIChvcHRuYW1lID09PSA0KSB7XG4gICBIRUFQMzJbb3B0dmFsID4+PiAyXSA9IHNvY2suZXJyb3I7XG4gICBIRUFQMzJbb3B0bGVuID4+PiAyXSA9IDQ7XG4gICBzb2NrLmVycm9yID0gbnVsbDtcbiAgIHJldHVybiAwO1xuICB9XG4gfVxuIHJldHVybiAtNTA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9ta2RpcmF0KGRpcmZkLCBwYXRoLCBtb2RlKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfbmV3ZnN0YXRhdChkaXJmZCwgcGF0aCwgYnVmLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9yZWN2ZnJvbShmZCwgYnVmLCBsZW4sIGZsYWdzLCBhZGRyLCBhZGRybGVuKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIHZhciBtc2cgPSBzb2NrLnNvY2tfb3BzLnJlY3Ztc2coc29jaywgbGVuKTtcbiBpZiAoIW1zZykgcmV0dXJuIDA7XG4gaWYgKGFkZHIpIHtcbiAgdmFyIGVycm5vID0gd3JpdGVTb2NrYWRkcihhZGRyLCBzb2NrLmZhbWlseSwgRE5TLmxvb2t1cF9uYW1lKG1zZy5hZGRyKSwgbXNnLnBvcnQsIGFkZHJsZW4pO1xuICBhc3NlcnQoIWVycm5vKTtcbiB9XG4gSEVBUFU4LnNldChtc2cuYnVmZmVyLCBidWYgPj4+IDApO1xuIHJldHVybiBtc2cuYnVmZmVyLmJ5dGVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVuYW1lYXQob2xkZGlyZmQsIG9sZHBhdGgsIG5ld2RpcmZkLCBuZXdwYXRoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3NlbmR0byhmZCwgbWVzc2FnZSwgbGVuZ3RoLCBmbGFncywgYWRkciwgYWRkcl9sZW4pIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9zb2NrZXQoZG9tYWluLCB0eXBlLCBwcm90b2NvbCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3N0YXQ2NChwYXRoLCBidWYpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF91bmxpbmthdChkaXJmZCwgcGF0aCwgZmxhZ3MpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxudmFyIG5vd0lzTW9ub3RvbmljID0gdHJ1ZTtcblxuZnVuY3Rpb24gX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljKCkge1xuIHJldHVybiBub3dJc01vbm90b25pYztcbn1cblxuZnVuY3Rpb24gcmVhZEk1M0Zyb21JNjQocHRyKSB7XG4gcmV0dXJuIEhFQVBVMzJbcHRyID4+PiAyXSArIEhFQVAzMltwdHIgKyA0ID4+PiAyXSAqIDQyOTQ5NjcyOTY7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cblxudmFyIE1PTlRIX0RBWVNfTEVBUF9DVU1VTEFUSVZFID0gWyAwLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNSBdO1xuXG52YXIgTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkUgPSBbIDAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0IF07XG5cbmZ1bmN0aW9uIHlkYXlGcm9tRGF0ZShkYXRlKSB7XG4gdmFyIGxlYXAgPSBpc0xlYXBZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gdmFyIG1vbnRoRGF5c0N1bXVsYXRpdmUgPSBsZWFwID8gTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUgOiBNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRTtcbiB2YXIgeWRheSA9IG1vbnRoRGF5c0N1bXVsYXRpdmVbZGF0ZS5nZXRNb250aCgpXSArIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbiByZXR1cm4geWRheTtcbn1cblxuZnVuY3Rpb24gX19sb2NhbHRpbWVfanModGltZSwgdG1QdHIpIHtcbiB2YXIgZGF0ZSA9IG5ldyBEYXRlKHJlYWRJNTNGcm9tSTY0KHRpbWUpICogMWUzKTtcbiBIRUFQMzJbdG1QdHIgPj4+IDJdID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gSEVBUDMyW3RtUHRyICsgNCA+Pj4gMl0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiBIRUFQMzJbdG1QdHIgKyA4ID4+PiAyXSA9IGRhdGUuZ2V0SG91cnMoKTtcbiBIRUFQMzJbdG1QdHIgKyAxMiA+Pj4gMl0gPSBkYXRlLmdldERhdGUoKTtcbiBIRUFQMzJbdG1QdHIgKyAxNiA+Pj4gMl0gPSBkYXRlLmdldE1vbnRoKCk7XG4gSEVBUDMyW3RtUHRyICsgMjAgPj4+IDJdID0gZGF0ZS5nZXRGdWxsWWVhcigpIC0gMTkwMDtcbiBIRUFQMzJbdG1QdHIgKyAyNCA+Pj4gMl0gPSBkYXRlLmdldERheSgpO1xuIHZhciB5ZGF5ID0geWRheUZyb21EYXRlKGRhdGUpIHwgMDtcbiBIRUFQMzJbdG1QdHIgKyAyOCA+Pj4gMl0gPSB5ZGF5O1xuIEhFQVAzMlt0bVB0ciArIDM2ID4+PiAyXSA9IC0oZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjApO1xuIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7XG4gdmFyIHN1bW1lck9mZnNldCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgNiwgMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgd2ludGVyT2Zmc2V0ID0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgZHN0ID0gKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiYgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KSkgfCAwO1xuIEhFQVAzMlt0bVB0ciArIDMyID4+PiAyXSA9IGRzdDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cikge1xuIHZhciBsZW4gPSAwO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIGlmIChjIDw9IDEyNykge1xuICAgbGVuKys7XG4gIH0gZWxzZSBpZiAoYyA8PSAyMDQ3KSB7XG4gICBsZW4gKz0gMjtcbiAgfSBlbHNlIGlmIChjID49IDU1Mjk2ICYmIGMgPD0gNTczNDMpIHtcbiAgIGxlbiArPSA0O1xuICAgKytpO1xuICB9IGVsc2Uge1xuICAgbGVuICs9IDM7XG4gIH1cbiB9XG4gcmV0dXJuIGxlbjtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9OZXdVVEY4KHN0cikge1xuIHZhciBzaXplID0gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgKyAxO1xuIHZhciByZXQgPSBfbWFsbG9jKHNpemUpO1xuIGlmIChyZXQpIHN0cmluZ1RvVVRGOChzdHIsIHJldCwgc2l6ZSk7XG4gcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gX190enNldF9qcyh0aW1lem9uZSwgZGF5bGlnaHQsIHR6bmFtZSkge1xuIHZhciBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiB2YXIgd2ludGVyID0gbmV3IERhdGUoY3VycmVudFllYXIsIDAsIDEpO1xuIHZhciBzdW1tZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgNiwgMSk7XG4gdmFyIHdpbnRlck9mZnNldCA9IHdpbnRlci5nZXRUaW1lem9uZU9mZnNldCgpO1xuIHZhciBzdW1tZXJPZmZzZXQgPSBzdW1tZXIuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiB2YXIgc3RkVGltZXpvbmVPZmZzZXQgPSBNYXRoLm1heCh3aW50ZXJPZmZzZXQsIHN1bW1lck9mZnNldCk7XG4gSEVBUFUzMlt0aW1lem9uZSA+Pj4gMl0gPSBzdGRUaW1lem9uZU9mZnNldCAqIDYwO1xuIEhFQVAzMltkYXlsaWdodCA+Pj4gMl0gPSBOdW1iZXIod2ludGVyT2Zmc2V0ICE9IHN1bW1lck9mZnNldCk7XG4gZnVuY3Rpb24gZXh0cmFjdFpvbmUoZGF0ZSkge1xuICB2YXIgbWF0Y2ggPSBkYXRlLnRvVGltZVN0cmluZygpLm1hdGNoKC9cXCgoW0EtWmEteiBdKylcXCkkLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogXCJHTVRcIjtcbiB9XG4gdmFyIHdpbnRlck5hbWUgPSBleHRyYWN0Wm9uZSh3aW50ZXIpO1xuIHZhciBzdW1tZXJOYW1lID0gZXh0cmFjdFpvbmUoc3VtbWVyKTtcbiB2YXIgd2ludGVyTmFtZVB0ciA9IHN0cmluZ1RvTmV3VVRGOCh3aW50ZXJOYW1lKTtcbiB2YXIgc3VtbWVyTmFtZVB0ciA9IHN0cmluZ1RvTmV3VVRGOChzdW1tZXJOYW1lKTtcbiBpZiAoc3VtbWVyT2Zmc2V0IDwgd2ludGVyT2Zmc2V0KSB7XG4gIEhFQVBVMzJbdHpuYW1lID4+PiAyXSA9IHdpbnRlck5hbWVQdHI7XG4gIEhFQVBVMzJbdHpuYW1lICsgNCA+Pj4gMl0gPSBzdW1tZXJOYW1lUHRyO1xuIH0gZWxzZSB7XG4gIEhFQVBVMzJbdHpuYW1lID4+PiAyXSA9IHN1bW1lck5hbWVQdHI7XG4gIEhFQVBVMzJbdHpuYW1lICsgNCA+Pj4gMl0gPSB3aW50ZXJOYW1lUHRyO1xuIH1cbn1cblxuZnVuY3Rpb24gX2Fib3J0KCkge1xuIGFib3J0KFwibmF0aXZlIGNvZGUgY2FsbGVkIGFib3J0KClcIik7XG59XG5cbmZ1bmN0aW9uIF9kbG9wZW4oZmlsZW5hbWUsIGZsYWdzKSB7XG4gYWJvcnQoZGxvcGVuTWlzc2luZ0Vycm9yKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2NyZWF0ZShwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY3JlYXRlRGlyZWN0b3J5KE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9leGlzdHMocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNoZWNrRGlyZWN0b3J5KE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9saXN0X2ZpbGVzKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5saXN0RGlyZWN0b3J5RW50cmllcyhNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfcmVtb3ZlKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5yZW1vdmVEaXJlY3RvcnkoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9jbG9zZShmaWxlSWQpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jbG9zZUZpbGUoTW9kdWxlLCBmaWxlSWQpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2V4aXN0cyhwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2hlY2tGaWxlKE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZ2V0X2xhc3RfbW9kaWZpZWRfdGltZShmaWxlSWQpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nZXRMYXN0RmlsZU1vZGlmaWNhdGlvblRpbWUoTW9kdWxlLCBmaWxlSWQpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX21vdmUoZnJvbSwgZnJvbUxlbiwgdG8sIHRvTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUubW92ZUZpbGUoTW9kdWxlLCBmcm9tLCBmcm9tTGVuLCB0bywgdG9MZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX29wZW4oZmlsZUlkLCBmbGFncykge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLm9wZW5GaWxlKE1vZHVsZSwgZmlsZUlkLCBmbGFncyk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfcmVhZChmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5yZWFkRmlsZShNb2R1bGUsIGZpbGVJZCwgYnVmLCBzaXplLCBsb2NhdGlvbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfdHJ1bmNhdGUoZmlsZUlkLCBuZXdTaXplKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUudHJ1bmNhdGVGaWxlKE1vZHVsZSwgZmlsZUlkLCBuZXdTaXplKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZShmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS53cml0ZUZpbGUoTW9kdWxlLCBmaWxlSWQsIGJ1Ziwgc2l6ZSwgbG9jYXRpb24pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19nZXRfZGVmYXVsdF9kYXRhX3Byb3RvY29sKE1vZHVsZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmdldERlZmF1bHREYXRhUHJvdG9jb2woTW9kdWxlKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZ2xvYihwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuZ2xvYihNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmUoZmVhdHVyZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnRlc3RQbGF0Zm9ybUZlYXR1cmUoTW9kdWxlLCBmZWF0dXJlKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jYWxsKGZ1bmNJZCwgZGVzY1B0ciwgZGVzY1NpemUsIHB0cnNQdHIsIHB0cnNTaXplLCByZXNwb25zZSkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNhbGxTY2FsYXJVREYoTW9kdWxlLCBmdW5jSWQsIGRlc2NQdHIsIGRlc2NTaXplLCBwdHJzUHRyLCBwdHJzU2l6ZSwgcmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9jb25zb2xlX2Vycm9yKHN0cikge1xuIGFzc2VydCh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpO1xuIGNvbnNvbGUuZXJyb3IoVVRGOFRvU3RyaW5nKHN0cikpO1xufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9kYXRlX25vdygpIHtcbiByZXR1cm4gRGF0ZS5ub3coKTtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhcE1heCgpIHtcbiByZXR1cm4gNDI5NDkwMTc2MDtcbn1cblxuZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4KCkge1xuIHJldHVybiBnZXRIZWFwTWF4KCk7XG59XG5cbnZhciBfZW1zY3JpcHRlbl9nZXRfbm93O1xuXG5pZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuIGdsb2JhbC5wZXJmb3JtYW5jZSA9IHJlcXVpcmUoXCJwZXJmX2hvb2tzXCIpLnBlcmZvcm1hbmNlO1xufVxuXG5fZW1zY3JpcHRlbl9nZXRfbm93ID0gKCkgPT4gcGVyZm9ybWFuY2Uubm93KCk7XG5cbmZ1bmN0aW9uIF9lbXNjcmlwdGVuX21lbWNweV9iaWcoZGVzdCwgc3JjLCBudW0pIHtcbiBIRUFQVTguY29weVdpdGhpbihkZXN0ID4+PiAwLCBzcmMgPj4+IDAsIHNyYyArIG51bSA+Pj4gMCk7XG59XG5cbmZ1bmN0aW9uIGVtc2NyaXB0ZW5fcmVhbGxvY19idWZmZXIoc2l6ZSkge1xuIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gdmFyIHBhZ2VzID0gc2l6ZSAtIGIuYnl0ZUxlbmd0aCArIDY1NTM1ID4+PiAxNjtcbiB0cnkge1xuICB3YXNtTWVtb3J5Lmdyb3cocGFnZXMpO1xuICB1cGRhdGVNZW1vcnlWaWV3cygpO1xuICByZXR1cm4gMTtcbiB9IGNhdGNoIChlKSB7XG4gIGVycihgZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcjogQXR0ZW1wdGVkIHRvIGdyb3cgaGVhcCBmcm9tICR7Yi5ieXRlTGVuZ3RofSBieXRlcyB0byAke3NpemV9IGJ5dGVzLCBidXQgZ290IGVycm9yOiAke2V9YCk7XG4gfVxufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcChyZXF1ZXN0ZWRTaXplKSB7XG4gdmFyIG9sZFNpemUgPSBIRUFQVTgubGVuZ3RoO1xuIHJlcXVlc3RlZFNpemUgPSByZXF1ZXN0ZWRTaXplID4+PiAwO1xuIGFzc2VydChyZXF1ZXN0ZWRTaXplID4gb2xkU2l6ZSk7XG4gdmFyIG1heEhlYXBTaXplID0gZ2V0SGVhcE1heCgpO1xuIGlmIChyZXF1ZXN0ZWRTaXplID4gbWF4SGVhcFNpemUpIHtcbiAgZXJyKGBDYW5ub3QgZW5sYXJnZSBtZW1vcnksIGFza2VkIHRvIGdvIHVwIHRvICR7cmVxdWVzdGVkU2l6ZX0gYnl0ZXMsIGJ1dCB0aGUgbGltaXQgaXMgJHttYXhIZWFwU2l6ZX0gYnl0ZXMhYCk7XG4gIHJldHVybiBmYWxzZTtcbiB9XG4gdmFyIGFsaWduVXAgPSAoeCwgbXVsdGlwbGUpID0+IHggKyAobXVsdGlwbGUgLSB4ICUgbXVsdGlwbGUpICUgbXVsdGlwbGU7XG4gZm9yICh2YXIgY3V0RG93biA9IDE7IGN1dERvd24gPD0gNDsgY3V0RG93biAqPSAyKSB7XG4gIHZhciBvdmVyR3Jvd25IZWFwU2l6ZSA9IG9sZFNpemUgKiAoMSArIC4yIC8gY3V0RG93bik7XG4gIG92ZXJHcm93bkhlYXBTaXplID0gTWF0aC5taW4ob3Zlckdyb3duSGVhcFNpemUsIHJlcXVlc3RlZFNpemUgKyAxMDA2NjMyOTYpO1xuICB2YXIgbmV3U2l6ZSA9IE1hdGgubWluKG1heEhlYXBTaXplLCBhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsIG92ZXJHcm93bkhlYXBTaXplKSwgNjU1MzYpKTtcbiAgdmFyIHJlcGxhY2VtZW50ID0gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihuZXdTaXplKTtcbiAgaWYgKHJlcGxhY2VtZW50KSB7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfVxuIH1cbiBlcnIoYEZhaWxlZCB0byBncm93IHRoZSBoZWFwIGZyb20gJHtvbGRTaXplfSBieXRlcyB0byAke25ld1NpemV9IGJ5dGVzLCBub3QgZW5vdWdoIG1lbW9yeSFgKTtcbiByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBFTlYgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RXhlY3V0YWJsZU5hbWUoKSB7XG4gcmV0dXJuIHRoaXNQcm9ncmFtIHx8IFwiLi90aGlzLnByb2dyYW1cIjtcbn1cblxuZnVuY3Rpb24gZ2V0RW52U3RyaW5ncygpIHtcbiBpZiAoIWdldEVudlN0cmluZ3Muc3RyaW5ncykge1xuICB2YXIgbGFuZyA9ICh0eXBlb2YgbmF2aWdhdG9yID09IFwib2JqZWN0XCIgJiYgbmF2aWdhdG9yLmxhbmd1YWdlcyAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdIHx8IFwiQ1wiKS5yZXBsYWNlKFwiLVwiLCBcIl9cIikgKyBcIi5VVEYtOFwiO1xuICB2YXIgZW52ID0ge1xuICAgXCJVU0VSXCI6IFwid2ViX3VzZXJcIixcbiAgIFwiTE9HTkFNRVwiOiBcIndlYl91c2VyXCIsXG4gICBcIlBBVEhcIjogXCIvXCIsXG4gICBcIlBXRFwiOiBcIi9cIixcbiAgIFwiSE9NRVwiOiBcIi9ob21lL3dlYl91c2VyXCIsXG4gICBcIkxBTkdcIjogbGFuZyxcbiAgIFwiX1wiOiBnZXRFeGVjdXRhYmxlTmFtZSgpXG4gIH07XG4gIGZvciAodmFyIHggaW4gRU5WKSB7XG4gICBpZiAoRU5WW3hdID09PSB1bmRlZmluZWQpIGRlbGV0ZSBlbnZbeF07IGVsc2UgZW52W3hdID0gRU5WW3hdO1xuICB9XG4gIHZhciBzdHJpbmdzID0gW107XG4gIGZvciAodmFyIHggaW4gZW52KSB7XG4gICBzdHJpbmdzLnB1c2goYCR7eH09JHtlbnZbeF19YCk7XG4gIH1cbiAgZ2V0RW52U3RyaW5ncy5zdHJpbmdzID0gc3RyaW5ncztcbiB9XG4gcmV0dXJuIGdldEVudlN0cmluZ3Muc3RyaW5ncztcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9Bc2NpaShzdHIsIGJ1ZmZlcikge1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIGFzc2VydChzdHIuY2hhckNvZGVBdChpKSA9PT0gKHN0ci5jaGFyQ29kZUF0KGkpICYgMjU1KSk7XG4gIEhFQVA4W2J1ZmZlcisrID4+PiAwXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuIH1cbiBIRUFQOFtidWZmZXIgPj4+IDBdID0gMDtcbn1cblxuZnVuY3Rpb24gX2Vudmlyb25fZ2V0KF9fZW52aXJvbiwgZW52aXJvbl9idWYpIHtcbiB2YXIgYnVmU2l6ZSA9IDA7XG4gZ2V0RW52U3RyaW5ncygpLmZvckVhY2goZnVuY3Rpb24oc3RyaW5nLCBpKSB7XG4gIHZhciBwdHIgPSBlbnZpcm9uX2J1ZiArIGJ1ZlNpemU7XG4gIEhFQVBVMzJbX19lbnZpcm9uICsgaSAqIDQgPj4+IDJdID0gcHRyO1xuICBzdHJpbmdUb0FzY2lpKHN0cmluZywgcHRyKTtcbiAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiB9KTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2Vudmlyb25fc2l6ZXNfZ2V0KHBlbnZpcm9uX2NvdW50LCBwZW52aXJvbl9idWZfc2l6ZSkge1xuIHZhciBzdHJpbmdzID0gZ2V0RW52U3RyaW5ncygpO1xuIEhFQVBVMzJbcGVudmlyb25fY291bnQgPj4+IDJdID0gc3RyaW5ncy5sZW5ndGg7XG4gdmFyIGJ1ZlNpemUgPSAwO1xuIHN0cmluZ3MuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcpIHtcbiAgYnVmU2l6ZSArPSBzdHJpbmcubGVuZ3RoICsgMTtcbiB9KTtcbiBIRUFQVTMyW3BlbnZpcm9uX2J1Zl9zaXplID4+PiAyXSA9IGJ1ZlNpemU7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuIGFib3J0KFwiZmRfY2xvc2UgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfZmRfZmRzdGF0X2dldChmZCwgcGJ1Zikge1xuIHZhciByaWdodHNCYXNlID0gMDtcbiB2YXIgcmlnaHRzSW5oZXJpdGluZyA9IDA7XG4gdmFyIGZsYWdzID0gMDtcbiB7XG4gIGFzc2VydChmZCA9PSAwIHx8IGZkID09IDEgfHwgZmQgPT0gMik7XG4gIHZhciB0eXBlID0gMjtcbiAgaWYgKGZkID09IDApIHtcbiAgIHJpZ2h0c0Jhc2UgPSAyO1xuICB9IGVsc2UgaWYgKGZkID09IDEgfHwgZmQgPT0gMikge1xuICAgcmlnaHRzQmFzZSA9IDY0O1xuICB9XG4gIGZsYWdzID0gMTtcbiB9XG4gSEVBUDhbcGJ1ZiA+Pj4gMF0gPSB0eXBlO1xuIEhFQVAxNltwYnVmICsgMiA+Pj4gMV0gPSBmbGFncztcbiB0ZW1wSTY0ID0gWyByaWdodHNCYXNlID4+PiAwLCAodGVtcERvdWJsZSA9IHJpZ2h0c0Jhc2UsICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxID8gdGVtcERvdWJsZSA+IDAgPyArTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5NikgPj4+IDAgOiB+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5NikgPj4+IDAgOiAwKSBdLCBcbiBIRUFQMzJbcGJ1ZiArIDggPj4+IDJdID0gdGVtcEk2NFswXSwgSEVBUDMyW3BidWYgKyAxMiA+Pj4gMl0gPSB0ZW1wSTY0WzFdO1xuIHRlbXBJNjQgPSBbIHJpZ2h0c0luaGVyaXRpbmcgPj4+IDAsICh0ZW1wRG91YmxlID0gcmlnaHRzSW5oZXJpdGluZywgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEgPyB0ZW1wRG91YmxlID4gMCA/ICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCA6IH5+K01hdGguY2VpbCgodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCA6IDApIF0sIFxuIEhFQVAzMltwYnVmICsgMTYgPj4+IDJdID0gdGVtcEk2NFswXSwgSEVBUDMyW3BidWYgKyAyMCA+Pj4gMl0gPSB0ZW1wSTY0WzFdO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZmRfcHJlYWQoZmQsIGlvdiwgaW92Y250LCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgcG51bSkge1xuIGFib3J0KFwiZmRfcHJlYWQgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfZmRfcHdyaXRlKGZkLCBpb3YsIGlvdmNudCwgb2Zmc2V0X2xvdywgb2Zmc2V0X2hpZ2gsIHBudW0pIHtcbiBhYm9ydChcImZkX3B3cml0ZSBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9mZF9yZWFkKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuIGFib3J0KFwiZmRfcmVhZCBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9mZF9zZWVrKGZkLCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgd2hlbmNlLCBuZXdPZmZzZXQpIHtcbiByZXR1cm4gNzA7XG59XG5cbmZ1bmN0aW9uIF9mZF9zeW5jKGZkKSB7XG4gYWJvcnQoXCJmZF9zeW5jIGNhbGxlZCB3aXRob3V0IFNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxudmFyIHByaW50Q2hhckJ1ZmZlcnMgPSBbIG51bGwsIFtdLCBbXSBdO1xuXG5mdW5jdGlvbiBwcmludENoYXIoc3RyZWFtLCBjdXJyKSB7XG4gdmFyIGJ1ZmZlciA9IHByaW50Q2hhckJ1ZmZlcnNbc3RyZWFtXTtcbiBhc3NlcnQoYnVmZmVyKTtcbiBpZiAoY3VyciA9PT0gMCB8fCBjdXJyID09PSAxMCkge1xuICAoc3RyZWFtID09PSAxID8gb3V0IDogZXJyKShVVEY4QXJyYXlUb1N0cmluZyhidWZmZXIsIDApKTtcbiAgYnVmZmVyLmxlbmd0aCA9IDA7XG4gfSBlbHNlIHtcbiAgYnVmZmVyLnB1c2goY3Vycik7XG4gfVxufVxuXG5mdW5jdGlvbiBmbHVzaF9OT19GSUxFU1lTVEVNKCkge1xuIF9mZmx1c2goMCk7XG4gaWYgKHByaW50Q2hhckJ1ZmZlcnNbMV0ubGVuZ3RoKSBwcmludENoYXIoMSwgMTApO1xuIGlmIChwcmludENoYXJCdWZmZXJzWzJdLmxlbmd0aCkgcHJpbnRDaGFyKDIsIDEwKTtcbn1cblxuZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLCBpb3YsIGlvdmNudCwgcG51bSkge1xuIHZhciBudW0gPSAwO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgdmFyIHB0ciA9IEhFQVBVMzJbaW92ID4+PiAyXTtcbiAgdmFyIGxlbiA9IEhFQVBVMzJbaW92ICsgNCA+Pj4gMl07XG4gIGlvdiArPSA4O1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICBwcmludENoYXIoZmQsIEhFQVBVOFtwdHIgKyBqID4+PiAwXSk7XG4gIH1cbiAgbnVtICs9IGxlbjtcbiB9XG4gSEVBUFUzMltwbnVtID4+PiAyXSA9IG51bTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2dldGFkZHJpbmZvKG5vZGUsIHNlcnZpY2UsIGhpbnQsIG91dCkge1xuIHZhciBhZGRycyA9IFtdO1xuIHZhciBjYW5vbiA9IG51bGw7XG4gdmFyIGFkZHIgPSAwO1xuIHZhciBwb3J0ID0gMDtcbiB2YXIgZmxhZ3MgPSAwO1xuIHZhciBmYW1pbHkgPSAwO1xuIHZhciB0eXBlID0gMDtcbiB2YXIgcHJvdG8gPSAwO1xuIHZhciBhaSwgbGFzdDtcbiBmdW5jdGlvbiBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIGNhbm9uLCBhZGRyLCBwb3J0KSB7XG4gIHZhciBzYSwgc2FsZW4sIGFpO1xuICB2YXIgZXJybm87XG4gIHNhbGVuID0gZmFtaWx5ID09PSAxMCA/IDI4IDogMTY7XG4gIGFkZHIgPSBmYW1pbHkgPT09IDEwID8gaW5ldE50b3A2KGFkZHIpIDogaW5ldE50b3A0KGFkZHIpO1xuICBzYSA9IF9tYWxsb2Moc2FsZW4pO1xuICBlcnJubyA9IHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCk7XG4gIGFzc2VydCghZXJybm8pO1xuICBhaSA9IF9tYWxsb2MoMzIpO1xuICBIRUFQMzJbYWkgKyA0ID4+PiAyXSA9IGZhbWlseTtcbiAgSEVBUDMyW2FpICsgOCA+Pj4gMl0gPSB0eXBlO1xuICBIRUFQMzJbYWkgKyAxMiA+Pj4gMl0gPSBwcm90bztcbiAgSEVBUFUzMlthaSArIDI0ID4+PiAyXSA9IGNhbm9uO1xuICBIRUFQVTMyW2FpICsgMjAgPj4+IDJdID0gc2E7XG4gIGlmIChmYW1pbHkgPT09IDEwKSB7XG4gICBIRUFQMzJbYWkgKyAxNiA+Pj4gMl0gPSAyODtcbiAgfSBlbHNlIHtcbiAgIEhFQVAzMlthaSArIDE2ID4+PiAyXSA9IDE2O1xuICB9XG4gIEhFQVAzMlthaSArIDI4ID4+PiAyXSA9IDA7XG4gIHJldHVybiBhaTtcbiB9XG4gaWYgKGhpbnQpIHtcbiAgZmxhZ3MgPSBIRUFQMzJbaGludCA+Pj4gMl07XG4gIGZhbWlseSA9IEhFQVAzMltoaW50ICsgNCA+Pj4gMl07XG4gIHR5cGUgPSBIRUFQMzJbaGludCArIDggPj4+IDJdO1xuICBwcm90byA9IEhFQVAzMltoaW50ICsgMTIgPj4+IDJdO1xuIH1cbiBpZiAodHlwZSAmJiAhcHJvdG8pIHtcbiAgcHJvdG8gPSB0eXBlID09PSAyID8gMTcgOiA2O1xuIH1cbiBpZiAoIXR5cGUgJiYgcHJvdG8pIHtcbiAgdHlwZSA9IHByb3RvID09PSAxNyA/IDIgOiAxO1xuIH1cbiBpZiAocHJvdG8gPT09IDApIHtcbiAgcHJvdG8gPSA2O1xuIH1cbiBpZiAodHlwZSA9PT0gMCkge1xuICB0eXBlID0gMTtcbiB9XG4gaWYgKCFub2RlICYmICFzZXJ2aWNlKSB7XG4gIHJldHVybiAtMjtcbiB9XG4gaWYgKGZsYWdzICYgfigxIHwgMiB8IDQgfCAxMDI0IHwgOCB8IDE2IHwgMzIpKSB7XG4gIHJldHVybiAtMTtcbiB9XG4gaWYgKGhpbnQgIT09IDAgJiYgSEVBUDMyW2hpbnQgPj4+IDJdICYgMiAmJiAhbm9kZSkge1xuICByZXR1cm4gLTE7XG4gfVxuIGlmIChmbGFncyAmIDMyKSB7XG4gIHJldHVybiAtMjtcbiB9XG4gaWYgKHR5cGUgIT09IDAgJiYgdHlwZSAhPT0gMSAmJiB0eXBlICE9PSAyKSB7XG4gIHJldHVybiAtNztcbiB9XG4gaWYgKGZhbWlseSAhPT0gMCAmJiBmYW1pbHkgIT09IDIgJiYgZmFtaWx5ICE9PSAxMCkge1xuICByZXR1cm4gLTY7XG4gfVxuIGlmIChzZXJ2aWNlKSB7XG4gIHNlcnZpY2UgPSBVVEY4VG9TdHJpbmcoc2VydmljZSk7XG4gIHBvcnQgPSBwYXJzZUludChzZXJ2aWNlLCAxMCk7XG4gIGlmIChpc05hTihwb3J0KSkge1xuICAgaWYgKGZsYWdzICYgMTAyNCkge1xuICAgIHJldHVybiAtMjtcbiAgIH1cbiAgIHJldHVybiAtODtcbiAgfVxuIH1cbiBpZiAoIW5vZGUpIHtcbiAgaWYgKGZhbWlseSA9PT0gMCkge1xuICAgZmFtaWx5ID0gMjtcbiAgfVxuICBpZiAoKGZsYWdzICYgMSkgPT09IDApIHtcbiAgIGlmIChmYW1pbHkgPT09IDIpIHtcbiAgICBhZGRyID0gX2h0b25sKDIxMzA3MDY0MzMpO1xuICAgfSBlbHNlIHtcbiAgICBhZGRyID0gWyAwLCAwLCAwLCAxIF07XG4gICB9XG4gIH1cbiAgYWkgPSBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIG51bGwsIGFkZHIsIHBvcnQpO1xuICBIRUFQVTMyW291dCA+Pj4gMl0gPSBhaTtcbiAgcmV0dXJuIDA7XG4gfVxuIG5vZGUgPSBVVEY4VG9TdHJpbmcobm9kZSk7XG4gYWRkciA9IGluZXRQdG9uNChub2RlKTtcbiBpZiAoYWRkciAhPT0gbnVsbCkge1xuICBpZiAoZmFtaWx5ID09PSAwIHx8IGZhbWlseSA9PT0gMikge1xuICAgZmFtaWx5ID0gMjtcbiAgfSBlbHNlIGlmIChmYW1pbHkgPT09IDEwICYmIGZsYWdzICYgOCkge1xuICAgYWRkciA9IFsgMCwgMCwgX2h0b25sKDY1NTM1KSwgYWRkciBdO1xuICAgZmFtaWx5ID0gMTA7XG4gIH0gZWxzZSB7XG4gICByZXR1cm4gLTI7XG4gIH1cbiB9IGVsc2Uge1xuICBhZGRyID0gaW5ldFB0b242KG5vZGUpO1xuICBpZiAoYWRkciAhPT0gbnVsbCkge1xuICAgaWYgKGZhbWlseSA9PT0gMCB8fCBmYW1pbHkgPT09IDEwKSB7XG4gICAgZmFtaWx5ID0gMTA7XG4gICB9IGVsc2Uge1xuICAgIHJldHVybiAtMjtcbiAgIH1cbiAgfVxuIH1cbiBpZiAoYWRkciAhPSBudWxsKSB7XG4gIGFpID0gYWxsb2NhZGRyaW5mbyhmYW1pbHksIHR5cGUsIHByb3RvLCBub2RlLCBhZGRyLCBwb3J0KTtcbiAgSEVBUFUzMltvdXQgPj4+IDJdID0gYWk7XG4gIHJldHVybiAwO1xuIH1cbiBpZiAoZmxhZ3MgJiA0KSB7XG4gIHJldHVybiAtMjtcbiB9XG4gbm9kZSA9IEROUy5sb29rdXBfbmFtZShub2RlKTtcbiBhZGRyID0gaW5ldFB0b240KG5vZGUpO1xuIGlmIChmYW1pbHkgPT09IDApIHtcbiAgZmFtaWx5ID0gMjtcbiB9IGVsc2UgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgYWRkciA9IFsgMCwgMCwgX2h0b25sKDY1NTM1KSwgYWRkciBdO1xuIH1cbiBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbnVsbCwgYWRkciwgcG9ydCk7XG4gSEVBUFUzMltvdXQgPj4+IDJdID0gYWk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGluaXRSYW5kb21GaWxsKCkge1xuIGlmICh0eXBlb2YgY3J5cHRvID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNyeXB0b1tcImdldFJhbmRvbVZhbHVlc1wiXSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgcmV0dXJuIHZpZXcgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2aWV3KTtcbiB9IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcbiAgdHJ5IHtcbiAgIHZhciBjcnlwdG9fbW9kdWxlID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgIHZhciByYW5kb21GaWxsU3luYyA9IGNyeXB0b19tb2R1bGVbXCJyYW5kb21GaWxsU3luY1wiXTtcbiAgIGlmIChyYW5kb21GaWxsU3luYykge1xuICAgIHJldHVybiB2aWV3ID0+IGNyeXB0b19tb2R1bGVbXCJyYW5kb21GaWxsU3luY1wiXSh2aWV3KTtcbiAgIH1cbiAgIHZhciByYW5kb21CeXRlcyA9IGNyeXB0b19tb2R1bGVbXCJyYW5kb21CeXRlc1wiXTtcbiAgIHJldHVybiB2aWV3ID0+ICh2aWV3LnNldChyYW5kb21CeXRlcyh2aWV3LmJ5dGVMZW5ndGgpKSwgdmlldyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gfVxuIGFib3J0KFwibm8gY3J5cHRvZ3JhcGhpYyBzdXBwb3J0IGZvdW5kIGZvciByYW5kb21EZXZpY2UuIGNvbnNpZGVyIHBvbHlmaWxsaW5nIGl0IGlmIHlvdSB3YW50IHRvIHVzZSBzb21ldGhpbmcgaW5zZWN1cmUgbGlrZSBNYXRoLnJhbmRvbSgpLCBlLmcuIHB1dCB0aGlzIGluIGEgLS1wcmUtanM6IHZhciBjcnlwdG8gPSB7IGdldFJhbmRvbVZhbHVlczogZnVuY3Rpb24oYXJyYXkpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgYXJyYXlbaV0gPSAoTWF0aC5yYW5kb20oKSoyNTYpfDAgfSB9O1wiKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tRmlsbCh2aWV3KSB7XG4gcmV0dXJuIChyYW5kb21GaWxsID0gaW5pdFJhbmRvbUZpbGwoKSkodmlldyk7XG59XG5cbmZ1bmN0aW9uIF9nZXRlbnRyb3B5KGJ1ZmZlciwgc2l6ZSkge1xuIHJhbmRvbUZpbGwoSEVBUFU4LnN1YmFycmF5KGJ1ZmZlciA+Pj4gMCwgYnVmZmVyICsgc2l6ZSA+Pj4gMCkpO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZ2V0bmFtZWluZm8oc2EsIHNhbGVuLCBub2RlLCBub2RlbGVuLCBzZXJ2LCBzZXJ2bGVuLCBmbGFncykge1xuIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKHNhLCBzYWxlbik7XG4gaWYgKGluZm8uZXJybm8pIHtcbiAgcmV0dXJuIC02O1xuIH1cbiB2YXIgcG9ydCA9IGluZm8ucG9ydDtcbiB2YXIgYWRkciA9IGluZm8uYWRkcjtcbiB2YXIgb3ZlcmZsb3dlZCA9IGZhbHNlO1xuIGlmIChub2RlICYmIG5vZGVsZW4pIHtcbiAgdmFyIGxvb2t1cDtcbiAgaWYgKGZsYWdzICYgMSB8fCAhKGxvb2t1cCA9IEROUy5sb29rdXBfYWRkcihhZGRyKSkpIHtcbiAgIGlmIChmbGFncyAmIDgpIHtcbiAgICByZXR1cm4gLTI7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBhZGRyID0gbG9va3VwO1xuICB9XG4gIHZhciBudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCA9IHN0cmluZ1RvVVRGOChhZGRyLCBub2RlLCBub2RlbGVuKTtcbiAgaWYgKG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsICsgMSA+PSBub2RlbGVuKSB7XG4gICBvdmVyZmxvd2VkID0gdHJ1ZTtcbiAgfVxuIH1cbiBpZiAoc2VydiAmJiBzZXJ2bGVuKSB7XG4gIHBvcnQgPSBcIlwiICsgcG9ydDtcbiAgdmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsID0gc3RyaW5nVG9VVEY4KHBvcnQsIHNlcnYsIHNlcnZsZW4pO1xuICBpZiAobnVtQnl0ZXNXcml0dGVuRXhjbE51bGwgKyAxID49IHNlcnZsZW4pIHtcbiAgIG92ZXJmbG93ZWQgPSB0cnVlO1xuICB9XG4gfVxuIGlmIChvdmVyZmxvd2VkKSB7XG4gIHJldHVybiAtMTI7XG4gfVxuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhcnJheVN1bShhcnJheSwgaW5kZXgpIHtcbiB2YXIgc3VtID0gMDtcbiBmb3IgKHZhciBpID0gMDsgaSA8PSBpbmRleDsgc3VtICs9IGFycmF5W2krK10pIHt9XG4gcmV0dXJuIHN1bTtcbn1cblxudmFyIE1PTlRIX0RBWVNfTEVBUCA9IFsgMzEsIDI5LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMSBdO1xuXG52YXIgTU9OVEhfREFZU19SRUdVTEFSID0gWyAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxIF07XG5cbmZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgZGF5cykge1xuIHZhciBuZXdEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuIHdoaWxlIChkYXlzID4gMCkge1xuICB2YXIgbGVhcCA9IGlzTGVhcFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKTtcbiAgdmFyIGN1cnJlbnRNb250aCA9IG5ld0RhdGUuZ2V0TW9udGgoKTtcbiAgdmFyIGRheXNJbkN1cnJlbnRNb250aCA9IChsZWFwID8gTU9OVEhfREFZU19MRUFQIDogTU9OVEhfREFZU19SRUdVTEFSKVtjdXJyZW50TW9udGhdO1xuICBpZiAoZGF5cyA+IGRheXNJbkN1cnJlbnRNb250aCAtIG5ld0RhdGUuZ2V0RGF0ZSgpKSB7XG4gICBkYXlzIC09IGRheXNJbkN1cnJlbnRNb250aCAtIG5ld0RhdGUuZ2V0RGF0ZSgpICsgMTtcbiAgIG5ld0RhdGUuc2V0RGF0ZSgxKTtcbiAgIGlmIChjdXJyZW50TW9udGggPCAxMSkge1xuICAgIG5ld0RhdGUuc2V0TW9udGgoY3VycmVudE1vbnRoICsgMSk7XG4gICB9IGVsc2Uge1xuICAgIG5ld0RhdGUuc2V0TW9udGgoMCk7XG4gICAgbmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgIH1cbiAgfSBlbHNlIHtcbiAgIG5ld0RhdGUuc2V0RGF0ZShuZXdEYXRlLmdldERhdGUoKSArIGRheXMpO1xuICAgcmV0dXJuIG5ld0RhdGU7XG4gIH1cbiB9XG4gcmV0dXJuIG5ld0RhdGU7XG59XG5cbmZ1bmN0aW9uIGludEFycmF5RnJvbVN0cmluZyhzdHJpbmd5LCBkb250QWRkTnVsbCwgbGVuZ3RoKSB7XG4gdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkgKyAxO1xuIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7XG4gdmFyIG51bUJ5dGVzV3JpdHRlbiA9IHN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksIHU4YXJyYXksIDAsIHU4YXJyYXkubGVuZ3RoKTtcbiBpZiAoZG9udEFkZE51bGwpIHU4YXJyYXkubGVuZ3RoID0gbnVtQnl0ZXNXcml0dGVuO1xuIHJldHVybiB1OGFycmF5O1xufVxuXG5mdW5jdGlvbiB3cml0ZUFycmF5VG9NZW1vcnkoYXJyYXksIGJ1ZmZlcikge1xuIGFzc2VydChhcnJheS5sZW5ndGggPj0gMCwgXCJ3cml0ZUFycmF5VG9NZW1vcnkgYXJyYXkgbXVzdCBoYXZlIGEgbGVuZ3RoIChzaG91bGQgYmUgYW4gYXJyYXkgb3IgdHlwZWQgYXJyYXkpXCIpO1xuIEhFQVA4LnNldChhcnJheSwgYnVmZmVyID4+PiAwKTtcbn1cblxuZnVuY3Rpb24gX3N0cmZ0aW1lKHMsIG1heHNpemUsIGZvcm1hdCwgdG0pIHtcbiB2YXIgdG1fem9uZSA9IEhFQVAzMlt0bSArIDQwID4+PiAyXTtcbiB2YXIgZGF0ZSA9IHtcbiAgdG1fc2VjOiBIRUFQMzJbdG0gPj4+IDJdLFxuICB0bV9taW46IEhFQVAzMlt0bSArIDQgPj4+IDJdLFxuICB0bV9ob3VyOiBIRUFQMzJbdG0gKyA4ID4+PiAyXSxcbiAgdG1fbWRheTogSEVBUDMyW3RtICsgMTIgPj4+IDJdLFxuICB0bV9tb246IEhFQVAzMlt0bSArIDE2ID4+PiAyXSxcbiAgdG1feWVhcjogSEVBUDMyW3RtICsgMjAgPj4+IDJdLFxuICB0bV93ZGF5OiBIRUFQMzJbdG0gKyAyNCA+Pj4gMl0sXG4gIHRtX3lkYXk6IEhFQVAzMlt0bSArIDI4ID4+PiAyXSxcbiAgdG1faXNkc3Q6IEhFQVAzMlt0bSArIDMyID4+PiAyXSxcbiAgdG1fZ210b2ZmOiBIRUFQMzJbdG0gKyAzNiA+Pj4gMl0sXG4gIHRtX3pvbmU6IHRtX3pvbmUgPyBVVEY4VG9TdHJpbmcodG1fem9uZSkgOiBcIlwiXG4gfTtcbiB2YXIgcGF0dGVybiA9IFVURjhUb1N0cmluZyhmb3JtYXQpO1xuIHZhciBFWFBBTlNJT05fUlVMRVNfMSA9IHtcbiAgXCIlY1wiOiBcIiVhICViICVkICVIOiVNOiVTICVZXCIsXG4gIFwiJURcIjogXCIlbS8lZC8leVwiLFxuICBcIiVGXCI6IFwiJVktJW0tJWRcIixcbiAgXCIlaFwiOiBcIiViXCIsXG4gIFwiJXJcIjogXCIlSTolTTolUyAlcFwiLFxuICBcIiVSXCI6IFwiJUg6JU1cIixcbiAgXCIlVFwiOiBcIiVIOiVNOiVTXCIsXG4gIFwiJXhcIjogXCIlbS8lZC8leVwiLFxuICBcIiVYXCI6IFwiJUg6JU06JVNcIixcbiAgXCIlRWNcIjogXCIlY1wiLFxuICBcIiVFQ1wiOiBcIiVDXCIsXG4gIFwiJUV4XCI6IFwiJW0vJWQvJXlcIixcbiAgXCIlRVhcIjogXCIlSDolTTolU1wiLFxuICBcIiVFeVwiOiBcIiV5XCIsXG4gIFwiJUVZXCI6IFwiJVlcIixcbiAgXCIlT2RcIjogXCIlZFwiLFxuICBcIiVPZVwiOiBcIiVlXCIsXG4gIFwiJU9IXCI6IFwiJUhcIixcbiAgXCIlT0lcIjogXCIlSVwiLFxuICBcIiVPbVwiOiBcIiVtXCIsXG4gIFwiJU9NXCI6IFwiJU1cIixcbiAgXCIlT1NcIjogXCIlU1wiLFxuICBcIiVPdVwiOiBcIiV1XCIsXG4gIFwiJU9VXCI6IFwiJVVcIixcbiAgXCIlT1ZcIjogXCIlVlwiLFxuICBcIiVPd1wiOiBcIiV3XCIsXG4gIFwiJU9XXCI6IFwiJVdcIixcbiAgXCIlT3lcIjogXCIleVwiXG4gfTtcbiBmb3IgKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18xKSB7XG4gIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLCBcImdcIiksIEVYUEFOU0lPTl9SVUxFU18xW3J1bGVdKTtcbiB9XG4gdmFyIFdFRUtEQVlTID0gWyBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIgXTtcbiB2YXIgTU9OVEhTID0gWyBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIgXTtcbiBmdW5jdGlvbiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLCBkaWdpdHMsIGNoYXJhY3Rlcikge1xuICB2YXIgc3RyID0gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUgfHwgXCJcIjtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCBkaWdpdHMpIHtcbiAgIHN0ciA9IGNoYXJhY3RlclswXSArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xuIH1cbiBmdW5jdGlvbiBsZWFkaW5nTnVsbHModmFsdWUsIGRpZ2l0cykge1xuICByZXR1cm4gbGVhZGluZ1NvbWV0aGluZyh2YWx1ZSwgZGlnaXRzLCBcIjBcIik7XG4gfVxuIGZ1bmN0aW9uIGNvbXBhcmVCeURheShkYXRlMSwgZGF0ZTIpIHtcbiAgZnVuY3Rpb24gc2duKHZhbHVlKSB7XG4gICByZXR1cm4gdmFsdWUgPCAwID8gLTEgOiB2YWx1ZSA+IDAgPyAxIDogMDtcbiAgfVxuICB2YXIgY29tcGFyZTtcbiAgaWYgKChjb21wYXJlID0gc2duKGRhdGUxLmdldEZ1bGxZZWFyKCkgLSBkYXRlMi5nZXRGdWxsWWVhcigpKSkgPT09IDApIHtcbiAgIGlmICgoY29tcGFyZSA9IHNnbihkYXRlMS5nZXRNb250aCgpIC0gZGF0ZTIuZ2V0TW9udGgoKSkpID09PSAwKSB7XG4gICAgY29tcGFyZSA9IHNnbihkYXRlMS5nZXREYXRlKCkgLSBkYXRlMi5nZXREYXRlKCkpO1xuICAgfVxuICB9XG4gIHJldHVybiBjb21wYXJlO1xuIH1cbiBmdW5jdGlvbiBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoKSB7XG4gIHN3aXRjaCAoamFuRm91cnRoLmdldERheSgpKSB7XG4gIGNhc2UgMDpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAyOSk7XG5cbiAgY2FzZSAxOlxuICAgcmV0dXJuIGphbkZvdXJ0aDtcblxuICBjYXNlIDI6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksIDAsIDMpO1xuXG4gIGNhc2UgMzpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwgMCwgMik7XG5cbiAgY2FzZSA0OlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLCAwLCAxKTtcblxuICBjYXNlIDU6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCkgLSAxLCAxMSwgMzEpO1xuXG4gIGNhc2UgNjpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAzMCk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKSB7XG4gIHZhciB0aGlzRGF0ZSA9IGFkZERheXMobmV3IERhdGUoZGF0ZS50bV95ZWFyICsgMTkwMCwgMCwgMSksIGRhdGUudG1feWRheSk7XG4gIHZhciBqYW5Gb3VydGhUaGlzWWVhciA9IG5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuICB2YXIgamFuRm91cnRoTmV4dFllYXIgPSBuZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpICsgMSwgMCwgNCk7XG4gIHZhciBmaXJzdFdlZWtTdGFydFRoaXNZZWFyID0gZ2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aFRoaXNZZWFyKTtcbiAgdmFyIGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIgPSBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoTmV4dFllYXIpO1xuICBpZiAoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIsIHRoaXNEYXRlKSA8PSAwKSB7XG4gICBpZiAoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIsIHRoaXNEYXRlKSA8PSAwKSB7XG4gICAgcmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkgKyAxO1xuICAgfVxuICAgcmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkgLSAxO1xuIH1cbiB2YXIgRVhQQU5TSU9OX1JVTEVTXzIgPSB7XG4gIFwiJWFcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV0uc3Vic3RyaW5nKDAsIDMpO1xuICB9LFxuICBcIiVBXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBXRUVLREFZU1tkYXRlLnRtX3dkYXldO1xuICB9LFxuICBcIiViXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBNT05USFNbZGF0ZS50bV9tb25dLnN1YnN0cmluZygwLCAzKTtcbiAgfSxcbiAgXCIlQlwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gTU9OVEhTW2RhdGUudG1fbW9uXTtcbiAgfSxcbiAgXCIlQ1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgeWVhciA9IGRhdGUudG1feWVhciArIDE5MDA7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKHllYXIgLyAxMDAgfCAwLCAyKTtcbiAgfSxcbiAgXCIlZFwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbWRheSwgMik7XG4gIH0sXG4gIFwiJWVcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdTb21ldGhpbmcoZGF0ZS50bV9tZGF5LCAyLCBcIiBcIik7XG4gIH0sXG4gIFwiJWdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMik7XG4gIH0sXG4gIFwiJUdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGdldFdlZWtCYXNlZFllYXIoZGF0ZSk7XG4gIH0sXG4gIFwiJUhcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX2hvdXIsIDIpO1xuICB9LFxuICBcIiVJXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciB0d2VsdmVIb3VyID0gZGF0ZS50bV9ob3VyO1xuICAgaWYgKHR3ZWx2ZUhvdXIgPT0gMCkgdHdlbHZlSG91ciA9IDEyOyBlbHNlIGlmICh0d2VsdmVIb3VyID4gMTIpIHR3ZWx2ZUhvdXIgLT0gMTI7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKHR3ZWx2ZUhvdXIsIDIpO1xuICB9LFxuICBcIiVqXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5ICsgYXJyYXlTdW0oaXNMZWFwWWVhcihkYXRlLnRtX3llYXIgKyAxOTAwKSA/IE1PTlRIX0RBWVNfTEVBUCA6IE1PTlRIX0RBWVNfUkVHVUxBUiwgZGF0ZS50bV9tb24gLSAxKSwgMyk7XG4gIH0sXG4gIFwiJW1cIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21vbiArIDEsIDIpO1xuICB9LFxuICBcIiVNXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9taW4sIDIpO1xuICB9LFxuICBcIiVuXCI6IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIFwiXFxuXCI7XG4gIH0sXG4gIFwiJXBcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgaWYgKGRhdGUudG1faG91ciA+PSAwICYmIGRhdGUudG1faG91ciA8IDEyKSB7XG4gICAgcmV0dXJuIFwiQU1cIjtcbiAgIH1cbiAgIHJldHVybiBcIlBNXCI7XG4gIH0sXG4gIFwiJVNcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX3NlYywgMik7XG4gIH0sXG4gIFwiJXRcIjogZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gXCJcXHRcIjtcbiAgfSxcbiAgXCIldVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV93ZGF5IHx8IDc7XG4gIH0sXG4gIFwiJVVcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIGRheXMgPSBkYXRlLnRtX3lkYXkgKyA3IC0gZGF0ZS50bV93ZGF5O1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMgLyA3KSwgMik7XG4gIH0sXG4gIFwiJVZcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIHZhbCA9IE1hdGguZmxvb3IoKGRhdGUudG1feWRheSArIDcgLSAoZGF0ZS50bV93ZGF5ICsgNikgJSA3KSAvIDcpO1xuICAgaWYgKChkYXRlLnRtX3dkYXkgKyAzNzEgLSBkYXRlLnRtX3lkYXkgLSAyKSAlIDcgPD0gMikge1xuICAgIHZhbCsrO1xuICAgfVxuICAgaWYgKCF2YWwpIHtcbiAgICB2YWwgPSA1MjtcbiAgICB2YXIgZGVjMzEgPSAoZGF0ZS50bV93ZGF5ICsgNyAtIGRhdGUudG1feWRheSAtIDEpICUgNztcbiAgICBpZiAoZGVjMzEgPT0gNCB8fCBkZWMzMSA9PSA1ICYmIGlzTGVhcFllYXIoZGF0ZS50bV95ZWFyICUgNDAwIC0gMSkpIHtcbiAgICAgdmFsKys7XG4gICAgfVxuICAgfSBlbHNlIGlmICh2YWwgPT0gNTMpIHtcbiAgICB2YXIgamFuMSA9IChkYXRlLnRtX3dkYXkgKyAzNzEgLSBkYXRlLnRtX3lkYXkpICUgNztcbiAgICBpZiAoamFuMSAhPSA0ICYmIChqYW4xICE9IDMgfHwgIWlzTGVhcFllYXIoZGF0ZS50bV95ZWFyKSkpIHZhbCA9IDE7XG4gICB9XG4gICByZXR1cm4gbGVhZGluZ051bGxzKHZhbCwgMik7XG4gIH0sXG4gIFwiJXdcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGRhdGUudG1fd2RheTtcbiAgfSxcbiAgXCIlV1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgZGF5cyA9IGRhdGUudG1feWRheSArIDcgLSAoZGF0ZS50bV93ZGF5ICsgNikgJSA3O1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMgLyA3KSwgMik7XG4gIH0sXG4gIFwiJXlcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIChkYXRlLnRtX3llYXIgKyAxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKTtcbiAgfSxcbiAgXCIlWVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV95ZWFyICsgMTkwMDtcbiAgfSxcbiAgXCIlelwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgb2ZmID0gZGF0ZS50bV9nbXRvZmY7XG4gICB2YXIgYWhlYWQgPSBvZmYgPj0gMDtcbiAgIG9mZiA9IE1hdGguYWJzKG9mZikgLyA2MDtcbiAgIG9mZiA9IG9mZiAvIDYwICogMTAwICsgb2ZmICUgNjA7XG4gICByZXR1cm4gKGFoZWFkID8gXCIrXCIgOiBcIi1cIikgKyBTdHJpbmcoXCIwMDAwXCIgKyBvZmYpLnNsaWNlKC00KTtcbiAgfSxcbiAgXCIlWlwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV96b25lO1xuICB9LFxuICBcIiUlXCI6IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIFwiJVwiO1xuICB9XG4gfTtcbiBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC8lJS9nLCBcIlxcMFxcMFwiKTtcbiBmb3IgKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18yKSB7XG4gIGlmIChwYXR0ZXJuLmluY2x1ZGVzKHJ1bGUpKSB7XG4gICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSwgXCJnXCIpLCBFWFBBTlNJT05fUlVMRVNfMltydWxlXShkYXRlKSk7XG4gIH1cbiB9XG4gcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgvXFwwXFwwL2csIFwiJVwiKTtcbiB2YXIgYnl0ZXMgPSBpbnRBcnJheUZyb21TdHJpbmcocGF0dGVybiwgZmFsc2UpO1xuIGlmIChieXRlcy5sZW5ndGggPiBtYXhzaXplKSB7XG4gIHJldHVybiAwO1xuIH1cbiB3cml0ZUFycmF5VG9NZW1vcnkoYnl0ZXMsIHMpO1xuIHJldHVybiBieXRlcy5sZW5ndGggLSAxO1xufVxuXG5mdW5jdGlvbiBfc3RyZnRpbWVfbChzLCBtYXhzaXplLCBmb3JtYXQsIHRtLCBsb2MpIHtcbiByZXR1cm4gX3N0cmZ0aW1lKHMsIG1heHNpemUsIGZvcm1hdCwgdG0pO1xufVxuXG5mdW5jdGlvbiBfdWNudl9jbG9zZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X2Nsb3NlXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VjbnZfY29udmVydEV4XzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfY29udmVydEV4XzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VjbnZfb3Blbl82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y252X29wZW5fNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNudl90b0FsZ29yaXRobWljXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfdG9BbGdvcml0aG1pY182NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfY2xvc2VfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2Nsb3NlXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9kZXRlY3RfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNzZGV0X2RldGVjdF82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfZ2V0TmFtZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZ2V0TmFtZV82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfb3Blbl82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfb3Blbl82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y3NkZXRfc2V0VGV4dF82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfc2V0VGV4dF82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpDbG9zZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpDbG9zZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpDbG9zZUN1cnJlbnRGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekNsb3NlQ3VycmVudEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R2V0Q3VycmVudEZpbGVJbmZvKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdldEN1cnJlbnRGaWxlSW5mb1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHZXRDdXJyZW50RmlsZUluZm82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHZXRDdXJyZW50RmlsZUluZm82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHZXRHbG9iYWxJbmZvKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdldEdsb2JhbEluZm9cIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R29Ub0ZpcnN0RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHb1RvRmlyc3RGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekdvVG9OZXh0RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpHb1RvTmV4dEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56TG9jYXRlRmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpMb2NhdGVGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vuek9wZW4oKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlblwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpPcGVuMigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuMlwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpPcGVuQ3VycmVudEZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56T3BlbkN1cnJlbnRGaWxlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuelJlYWRDdXJyZW50RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpSZWFkQ3VycmVudEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfcHJvY19leGl0KGNvZGUpIHtcbiBFWElUU1RBVFVTID0gY29kZTtcbiBpZiAoIWtlZXBSdW50aW1lQWxpdmUoKSkge1xuICBpZiAoTW9kdWxlW1wib25FeGl0XCJdKSBNb2R1bGVbXCJvbkV4aXRcIl0oY29kZSk7XG4gIEFCT1JUID0gdHJ1ZTtcbiB9XG4gcXVpdF8oY29kZSwgbmV3IEV4aXRTdGF0dXMoY29kZSkpO1xufVxuXG5mdW5jdGlvbiBleGl0SlMoc3RhdHVzLCBpbXBsaWNpdCkge1xuIEVYSVRTVEFUVVMgPSBzdGF0dXM7XG4gY2hlY2tVbmZsdXNoZWRDb250ZW50KCk7XG4gaWYgKGtlZXBSdW50aW1lQWxpdmUoKSAmJiAhaW1wbGljaXQpIHtcbiAgdmFyIG1zZyA9IGBwcm9ncmFtIGV4aXRlZCAod2l0aCBzdGF0dXM6ICR7c3RhdHVzfSksIGJ1dCBrZWVwUnVudGltZUFsaXZlKCkgaXMgc2V0IChjb3VudGVyPSR7cnVudGltZUtlZXBhbGl2ZUNvdW50ZXJ9KSBkdWUgdG8gYW4gYXN5bmMgb3BlcmF0aW9uLCBzbyBoYWx0aW5nIGV4ZWN1dGlvbiBidXQgbm90IGV4aXRpbmcgdGhlIHJ1bnRpbWUgb3IgcHJldmVudGluZyBmdXJ0aGVyIGFzeW5jIGV4ZWN1dGlvbiAoeW91IGNhbiB1c2UgZW1zY3JpcHRlbl9mb3JjZV9leGl0LCBpZiB5b3Ugd2FudCB0byBmb3JjZSBhIHRydWUgc2h1dGRvd24pYDtcbiAgcmVhZHlQcm9taXNlUmVqZWN0KG1zZyk7XG4gIGVycihtc2cpO1xuIH1cbiBfcHJvY19leGl0KHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV4Y2VwdGlvbihlKSB7XG4gaWYgKGUgaW5zdGFuY2VvZiBFeGl0U3RhdHVzIHx8IGUgPT0gXCJ1bndpbmRcIikge1xuICByZXR1cm4gRVhJVFNUQVRVUztcbiB9XG4gY2hlY2tTdGFja0Nvb2tpZSgpO1xuIGlmIChlIGluc3RhbmNlb2YgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKSB7XG4gIGlmIChfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCgpIDw9IDApIHtcbiAgIGVycihcIlN0YWNrIG92ZXJmbG93IGRldGVjdGVkLiAgWW91IGNhbiB0cnkgaW5jcmVhc2luZyAtc1NUQUNLX1NJWkUgKGN1cnJlbnRseSBzZXQgdG8gNjU1MzYpXCIpO1xuICB9XG4gfVxuIHF1aXRfKDEsIGUpO1xufVxuXG5mdW5jdGlvbiBnZXRDRnVuYyhpZGVudCkge1xuIHZhciBmdW5jID0gTW9kdWxlW1wiX1wiICsgaWRlbnRdO1xuIGFzc2VydChmdW5jLCBcIkNhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gXCIgKyBpZGVudCArIFwiLCBtYWtlIHN1cmUgaXQgaXMgZXhwb3J0ZWRcIik7XG4gcmV0dXJuIGZ1bmM7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKSB7XG4gdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gdmFyIHJldCA9IHN0YWNrQWxsb2Moc2l6ZSk7XG4gc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBzaXplKTtcbiByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBjY2FsbChpZGVudCwgcmV0dXJuVHlwZSwgYXJnVHlwZXMsIGFyZ3MsIG9wdHMpIHtcbiB2YXIgdG9DID0ge1xuICBcInN0cmluZ1wiOiBzdHIgPT4ge1xuICAgdmFyIHJldCA9IDA7XG4gICBpZiAoc3RyICE9PSBudWxsICYmIHN0ciAhPT0gdW5kZWZpbmVkICYmIHN0ciAhPT0gMCkge1xuICAgIHJldCA9IHN0cmluZ1RvVVRGOE9uU3RhY2soc3RyKTtcbiAgIH1cbiAgIHJldHVybiByZXQ7XG4gIH0sXG4gIFwiYXJyYXlcIjogYXJyID0+IHtcbiAgIHZhciByZXQgPSBzdGFja0FsbG9jKGFyci5sZW5ndGgpO1xuICAgd3JpdGVBcnJheVRvTWVtb3J5KGFyciwgcmV0KTtcbiAgIHJldHVybiByZXQ7XG4gIH1cbiB9O1xuIGZ1bmN0aW9uIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpIHtcbiAgaWYgKHJldHVyblR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgIHJldHVybiBVVEY4VG9TdHJpbmcocmV0KTtcbiAgfVxuICBpZiAocmV0dXJuVHlwZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiBCb29sZWFuKHJldCk7XG4gIHJldHVybiByZXQ7XG4gfVxuIHZhciBmdW5jID0gZ2V0Q0Z1bmMoaWRlbnQpO1xuIHZhciBjQXJncyA9IFtdO1xuIHZhciBzdGFjayA9IDA7XG4gYXNzZXJ0KHJldHVyblR5cGUgIT09IFwiYXJyYXlcIiwgJ1JldHVybiB0eXBlIHNob3VsZCBub3QgYmUgXCJhcnJheVwiLicpO1xuIGlmIChhcmdzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgdmFyIGNvbnZlcnRlciA9IHRvQ1thcmdUeXBlc1tpXV07XG4gICBpZiAoY29udmVydGVyKSB7XG4gICAgaWYgKHN0YWNrID09PSAwKSBzdGFjayA9IHN0YWNrU2F2ZSgpO1xuICAgIGNBcmdzW2ldID0gY29udmVydGVyKGFyZ3NbaV0pO1xuICAgfSBlbHNlIHtcbiAgICBjQXJnc1tpXSA9IGFyZ3NbaV07XG4gICB9XG4gIH1cbiB9XG4gdmFyIHJldCA9IGZ1bmMuYXBwbHkobnVsbCwgY0FyZ3MpO1xuIGZ1bmN0aW9uIG9uRG9uZShyZXQpIHtcbiAgaWYgKHN0YWNrICE9PSAwKSBzdGFja1Jlc3RvcmUoc3RhY2spO1xuICByZXR1cm4gY29udmVydFJldHVyblZhbHVlKHJldCk7XG4gfVxuIHJldCA9IG9uRG9uZShyZXQpO1xuIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5jb21pbmdNb2R1bGVBUEkoKSB7XG4gaWdub3JlZE1vZHVsZVByb3AoXCJmZXRjaFNldHRpbmdzXCIpO1xufVxuXG52YXIgd2FzbUltcG9ydHMgPSB7XG4gXCJYTUxfR2V0QnVmZmVyXCI6IF9YTUxfR2V0QnVmZmVyLFxuIFwiWE1MX0dldEVycm9yQ29kZVwiOiBfWE1MX0dldEVycm9yQ29kZSxcbiBcIlhNTF9QYXJzZVwiOiBfWE1MX1BhcnNlLFxuIFwiWE1MX1BhcnNlQnVmZmVyXCI6IF9YTUxfUGFyc2VCdWZmZXIsXG4gXCJYTUxfUGFyc2VyQ3JlYXRlXCI6IF9YTUxfUGFyc2VyQ3JlYXRlLFxuIFwiWE1MX1BhcnNlckZyZWVcIjogX1hNTF9QYXJzZXJGcmVlLFxuIFwiWE1MX1Jlc3VtZVBhcnNlclwiOiBfWE1MX1Jlc3VtZVBhcnNlcixcbiBcIlhNTF9TZXRDaGFyYWN0ZXJEYXRhSGFuZGxlclwiOiBfWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyLFxuIFwiWE1MX1NldEVsZW1lbnRIYW5kbGVyXCI6IF9YTUxfU2V0RWxlbWVudEhhbmRsZXIsXG4gXCJYTUxfU2V0VXNlckRhdGFcIjogX1hNTF9TZXRVc2VyRGF0YSxcbiBcIlhNTF9TdG9wUGFyc2VyXCI6IF9YTUxfU3RvcFBhcnNlcixcbiBcIl9fY3hhX3Rocm93XCI6IF9fX2N4YV90aHJvdyxcbiBcIl9fZGxzeW1cIjogX19fZGxzeW0sXG4gXCJfX3N5c2NhbGxfX25ld3NlbGVjdFwiOiBfX19zeXNjYWxsX19uZXdzZWxlY3QsXG4gXCJfX3N5c2NhbGxfYmluZFwiOiBfX19zeXNjYWxsX2JpbmQsXG4gXCJfX3N5c2NhbGxfY29ubmVjdFwiOiBfX19zeXNjYWxsX2Nvbm5lY3QsXG4gXCJfX3N5c2NhbGxfZmFjY2Vzc2F0XCI6IF9fX3N5c2NhbGxfZmFjY2Vzc2F0LFxuIFwiX19zeXNjYWxsX2ZjbnRsNjRcIjogX19fc3lzY2FsbF9mY250bDY0LFxuIFwiX19zeXNjYWxsX2ZzdGF0NjRcIjogX19fc3lzY2FsbF9mc3RhdDY0LFxuIFwiX19zeXNjYWxsX2Z0cnVuY2F0ZTY0XCI6IF9fX3N5c2NhbGxfZnRydW5jYXRlNjQsXG4gXCJfX3N5c2NhbGxfZ2V0ZGVudHM2NFwiOiBfX19zeXNjYWxsX2dldGRlbnRzNjQsXG4gXCJfX3N5c2NhbGxfZ2V0cGVlcm5hbWVcIjogX19fc3lzY2FsbF9nZXRwZWVybmFtZSxcbiBcIl9fc3lzY2FsbF9nZXRzb2Nrb3B0XCI6IF9fX3N5c2NhbGxfZ2V0c29ja29wdCxcbiBcIl9fc3lzY2FsbF9pb2N0bFwiOiBfX19zeXNjYWxsX2lvY3RsLFxuIFwiX19zeXNjYWxsX2xzdGF0NjRcIjogX19fc3lzY2FsbF9sc3RhdDY0LFxuIFwiX19zeXNjYWxsX21rZGlyYXRcIjogX19fc3lzY2FsbF9ta2RpcmF0LFxuIFwiX19zeXNjYWxsX25ld2ZzdGF0YXRcIjogX19fc3lzY2FsbF9uZXdmc3RhdGF0LFxuIFwiX19zeXNjYWxsX29wZW5hdFwiOiBfX19zeXNjYWxsX29wZW5hdCxcbiBcIl9fc3lzY2FsbF9yZWN2ZnJvbVwiOiBfX19zeXNjYWxsX3JlY3Zmcm9tLFxuIFwiX19zeXNjYWxsX3JlbmFtZWF0XCI6IF9fX3N5c2NhbGxfcmVuYW1lYXQsXG4gXCJfX3N5c2NhbGxfcm1kaXJcIjogX19fc3lzY2FsbF9ybWRpcixcbiBcIl9fc3lzY2FsbF9zZW5kdG9cIjogX19fc3lzY2FsbF9zZW5kdG8sXG4gXCJfX3N5c2NhbGxfc29ja2V0XCI6IF9fX3N5c2NhbGxfc29ja2V0LFxuIFwiX19zeXNjYWxsX3N0YXQ2NFwiOiBfX19zeXNjYWxsX3N0YXQ2NCxcbiBcIl9fc3lzY2FsbF91bmxpbmthdFwiOiBfX19zeXNjYWxsX3VubGlua2F0LFxuIFwiX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWNcIjogX19lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljLFxuIFwiX2xvY2FsdGltZV9qc1wiOiBfX2xvY2FsdGltZV9qcyxcbiBcIl90enNldF9qc1wiOiBfX3R6c2V0X2pzLFxuIFwiYWJvcnRcIjogX2Fib3J0LFxuIFwiZGxvcGVuXCI6IF9kbG9wZW4sXG4gXCJkdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGVcIjogX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2NyZWF0ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0c1wiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfZXhpc3RzLFxuIFwiZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlc1wiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfbGlzdF9maWxlcyxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X3JlbW92ZVwiOiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfcmVtb3ZlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2Nsb3NlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfY2xvc2UsXG4gXCJkdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2dldF9sYXN0X21vZGlmaWVkX3RpbWVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9nZXRfbGFzdF9tb2RpZmllZF90aW1lLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX21vdmVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX29wZW5cIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9vcGVuLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3JlYWRcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfdHJ1bmNhdGUsXG4gXCJkdWNrZGJfd2ViX2ZzX2ZpbGVfd3JpdGVcIjogX2R1Y2tkYl93ZWJfZnNfZmlsZV93cml0ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZ2V0X2RlZmF1bHRfZGF0YV9wcm90b2NvbFwiOiBfZHVja2RiX3dlYl9mc19nZXRfZGVmYXVsdF9kYXRhX3Byb3RvY29sLFxuIFwiZHVja2RiX3dlYl9mc19nbG9iXCI6IF9kdWNrZGJfd2ViX2ZzX2dsb2IsXG4gXCJkdWNrZGJfd2ViX3Rlc3RfcGxhdGZvcm1fZmVhdHVyZVwiOiBfZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmUsXG4gXCJkdWNrZGJfd2ViX3VkZl9zY2FsYXJfY2FsbFwiOiBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGwsXG4gXCJlbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3JcIjogX2Vtc2NyaXB0ZW5fY29uc29sZV9lcnJvcixcbiBcImVtc2NyaXB0ZW5fZGF0ZV9ub3dcIjogX2Vtc2NyaXB0ZW5fZGF0ZV9ub3csXG4gXCJlbXNjcmlwdGVuX2dldF9oZWFwX21heFwiOiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgsXG4gXCJlbXNjcmlwdGVuX2dldF9ub3dcIjogX2Vtc2NyaXB0ZW5fZ2V0X25vdyxcbiBcImVtc2NyaXB0ZW5fbWVtY3B5X2JpZ1wiOiBfZW1zY3JpcHRlbl9tZW1jcHlfYmlnLFxuIFwiZW1zY3JpcHRlbl9yZXNpemVfaGVhcFwiOiBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCxcbiBcImVudmlyb25fZ2V0XCI6IF9lbnZpcm9uX2dldCxcbiBcImVudmlyb25fc2l6ZXNfZ2V0XCI6IF9lbnZpcm9uX3NpemVzX2dldCxcbiBcImZkX2Nsb3NlXCI6IF9mZF9jbG9zZSxcbiBcImZkX2Zkc3RhdF9nZXRcIjogX2ZkX2Zkc3RhdF9nZXQsXG4gXCJmZF9wcmVhZFwiOiBfZmRfcHJlYWQsXG4gXCJmZF9wd3JpdGVcIjogX2ZkX3B3cml0ZSxcbiBcImZkX3JlYWRcIjogX2ZkX3JlYWQsXG4gXCJmZF9zZWVrXCI6IF9mZF9zZWVrLFxuIFwiZmRfc3luY1wiOiBfZmRfc3luYyxcbiBcImZkX3dyaXRlXCI6IF9mZF93cml0ZSxcbiBcImdldGFkZHJpbmZvXCI6IF9nZXRhZGRyaW5mbyxcbiBcImdldGVudHJvcHlcIjogX2dldGVudHJvcHksXG4gXCJnZXRuYW1laW5mb1wiOiBfZ2V0bmFtZWluZm8sXG4gXCJzdHJmdGltZV9sXCI6IF9zdHJmdGltZV9sLFxuIFwidWNudl9jbG9zZV82NFwiOiBfdWNudl9jbG9zZV82NCxcbiBcInVjbnZfY29udmVydEV4XzY0XCI6IF91Y252X2NvbnZlcnRFeF82NCxcbiBcInVjbnZfb3Blbl82NFwiOiBfdWNudl9vcGVuXzY0LFxuIFwidWNudl90b0FsZ29yaXRobWljXzY0XCI6IF91Y252X3RvQWxnb3JpdGhtaWNfNjQsXG4gXCJ1Y3NkZXRfY2xvc2VfNjRcIjogX3Vjc2RldF9jbG9zZV82NCxcbiBcInVjc2RldF9kZXRlY3RfNjRcIjogX3Vjc2RldF9kZXRlY3RfNjQsXG4gXCJ1Y3NkZXRfZ2V0Q29uZmlkZW5jZV82NFwiOiBfdWNzZGV0X2dldENvbmZpZGVuY2VfNjQsXG4gXCJ1Y3NkZXRfZ2V0TmFtZV82NFwiOiBfdWNzZGV0X2dldE5hbWVfNjQsXG4gXCJ1Y3NkZXRfb3Blbl82NFwiOiBfdWNzZGV0X29wZW5fNjQsXG4gXCJ1Y3NkZXRfc2V0VGV4dF82NFwiOiBfdWNzZGV0X3NldFRleHRfNjQsXG4gXCJ1bnpDbG9zZVwiOiBfdW56Q2xvc2UsXG4gXCJ1bnpDbG9zZUN1cnJlbnRGaWxlXCI6IF91bnpDbG9zZUN1cnJlbnRGaWxlLFxuIFwidW56R2V0Q3VycmVudEZpbGVJbmZvXCI6IF91bnpHZXRDdXJyZW50RmlsZUluZm8sXG4gXCJ1bnpHZXRDdXJyZW50RmlsZUluZm82NFwiOiBfdW56R2V0Q3VycmVudEZpbGVJbmZvNjQsXG4gXCJ1bnpHZXRHbG9iYWxJbmZvXCI6IF91bnpHZXRHbG9iYWxJbmZvLFxuIFwidW56R29Ub0ZpcnN0RmlsZVwiOiBfdW56R29Ub0ZpcnN0RmlsZSxcbiBcInVuekdvVG9OZXh0RmlsZVwiOiBfdW56R29Ub05leHRGaWxlLFxuIFwidW56TG9jYXRlRmlsZVwiOiBfdW56TG9jYXRlRmlsZSxcbiBcInVuek9wZW5cIjogX3Vuek9wZW4sXG4gXCJ1bnpPcGVuMlwiOiBfdW56T3BlbjIsXG4gXCJ1bnpPcGVuQ3VycmVudEZpbGVcIjogX3Vuek9wZW5DdXJyZW50RmlsZSxcbiBcInVuelJlYWRDdXJyZW50RmlsZVwiOiBfdW56UmVhZEN1cnJlbnRGaWxlXG59O1xuXG52YXIgYXNtID0gY3JlYXRlV2FzbSgpO1xuXG52YXIgX19fd2FzbV9jYWxsX2N0b3JzID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fd2FzbV9jYWxsX2N0b3JzXCIpO1xuXG52YXIgX21haW4gPSBNb2R1bGVbXCJfbWFpblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtYWluXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGhcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2UgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NsZWFyX3Jlc3BvbnNlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmFpbF93aXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmFpbF93aXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZmFpbF93aXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcmVzZXQgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9yZXNldFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3Jlc2V0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29ubmVjdCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2Nvbm5lY3RcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb25uZWN0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZGlzY29ubmVjdCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3RcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9kaXNjb25uZWN0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mbHVzaF9maWxlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfb3BlbiA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX29wZW5cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9vcGVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X2dsb2JhbF9maWxlX2luZm8gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mb1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9leHBvcnRfZmlsZV9zdGF0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZHJvcF9maWxlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZHJvcF9maWxlcyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2xvYl9maWxlX2luZm9zXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV91cmwgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXIgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX2J1ZmZlclwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlciA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X3ZlcnNpb24gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF92ZXJzaW9uXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3MgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfZmVhdHVyZV9mbGFnc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF9mZWF0dXJlX2ZsYWdzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfdG9rZW5pemUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl90b2tlbml6ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3Rva2VuaXplXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3VkZl9zY2FsYXJfY3JlYXRlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfY3JlYXRlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2UgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3ByZXBhcmVkX2Nsb3NlXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfcnVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcXVlcnlfcnVuID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcXVlcnlfcnVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcXVlcnlfcnVuXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0XCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9wb2xsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWwgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X2NhbmNlbFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0cyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfZ2V0X3RhYmxlbmFtZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9nZXRfdGFibGVuYW1lc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW1cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2Nzdl9mcm9tX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2luc2VydF9jc3ZfZnJvbV9wYXRoXCIpO1xuXG52YXIgX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfaW5zZXJ0X2pzb25fZnJvbV9wYXRoXCIpO1xuXG52YXIgX19fZXJybm9fbG9jYXRpb24gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19lcnJub19sb2NhdGlvblwiKTtcblxudmFyIF9mZmx1c2ggPSBNb2R1bGVbXCJfZmZsdXNoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZmbHVzaFwiKTtcblxudmFyIF9odG9ubCA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJodG9ubFwiKTtcblxudmFyIF9odG9ucyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJodG9uc1wiKTtcblxudmFyIF9udG9ocyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJudG9oc1wiKTtcblxudmFyIF9tYWxsb2MgPSBNb2R1bGVbXCJfbWFsbG9jXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIm1hbGxvY1wiKTtcblxudmFyIF9mcmVlID0gTW9kdWxlW1wiX2ZyZWVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZnJlZVwiKTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2luaXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgc3RhY2tTYXZlID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrU2F2ZVwiKTtcblxudmFyIHN0YWNrUmVzdG9yZSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdGFja1Jlc3RvcmVcIik7XG5cbnZhciBzdGFja0FsbG9jID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrQWxsb2NcIik7XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9fX2N4YV9pc19wb2ludGVyX3R5cGUgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19jeGFfaXNfcG9pbnRlcl90eXBlXCIpO1xuXG52YXIgZHluQ2FsbF9qaWppID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamppXCIpO1xuXG52YXIgZHluQ2FsbF9paWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqaVwiKTtcblxudmFyIGR5bkNhbGxfamkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpalwiKTtcblxudmFyIGR5bkNhbGxfdmpqaWppaiA9IE1vZHVsZVtcImR5bkNhbGxfdmpqaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZqamlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpampqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqamppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqamppXCIpO1xuXG52YXIgZHluQ2FsbF92amppaSA9IE1vZHVsZVtcImR5bkNhbGxfdmpqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92amppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpalwiKTtcblxudmFyIGR5bkNhbGxfamlqamlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqaWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWpqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpqalwiKTtcblxudmFyIGR5bkNhbGxfdmlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpampcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlqaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWppaVwiKTtcblxudmFyIGR5bkNhbGxfamlqaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlpaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlpalwiKTtcblxudmFyIGR5bkNhbGxfdmlqaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpamlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWppaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWpqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWpqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlpXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWppID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWpcIik7XG5cbnZhciBkeW5DYWxsX2lpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9paWppaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlcIik7XG5cbnZhciBkeW5DYWxsX2lpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWppXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpampcIik7XG5cbnZhciBkeW5DYWxsX2ppamogPSBNb2R1bGVbXCJkeW5DYWxsX2ppampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlcIik7XG5cbnZhciBkeW5DYWxsX2ppaSA9IE1vZHVsZVtcImR5bkNhbGxfamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2ogPSBNb2R1bGVbXCJkeW5DYWxsX2pcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfamlpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2pqID0gTW9kdWxlW1wiZHluQ2FsbF9qalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2pqXCIpO1xuXG52YXIgZHluQ2FsbF9paiA9IE1vZHVsZVtcImR5bkNhbGxfaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9palwiKTtcblxudmFyIGR5bkNhbGxfaWpqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWpqalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lqampcIik7XG5cbnZhciBkeW5DYWxsX2pqamQgPSBNb2R1bGVbXCJkeW5DYWxsX2pqamRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qampkXCIpO1xuXG52YXIgZHluQ2FsbF9qampqampkID0gTW9kdWxlW1wiZHluQ2FsbF9qampqampkXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfampqampqZFwiKTtcblxudmFyIGR5bkNhbGxfamlqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqaWlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpamlpaWppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaWlpamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWppaWlpID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlqaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppamlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppamlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWppaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppamlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpXCIpO1xuXG5Nb2R1bGVbXCJzdGFja0FsbG9jXCJdID0gc3RhY2tBbGxvYztcblxuTW9kdWxlW1wic3RhY2tTYXZlXCJdID0gc3RhY2tTYXZlO1xuXG5Nb2R1bGVbXCJzdGFja1Jlc3RvcmVcIl0gPSBzdGFja1Jlc3RvcmU7XG5cbk1vZHVsZVtcImNjYWxsXCJdID0gY2NhbGw7XG5cbnZhciBtaXNzaW5nTGlicmFyeVN5bWJvbHMgPSBbIFwiZ2V0SG9zdEJ5TmFtZVwiLCBcInRyYXZlcnNlU3RhY2tcIiwgXCJnZXRDYWxsc3RhY2tcIiwgXCJlbXNjcmlwdGVuTG9nXCIsIFwiY29udmVydFBDdG9Tb3VyY2VMb2NhdGlvblwiLCBcInJlYWRFbUFzbUFyZ3NcIiwgXCJqc3RvaV9zXCIsIFwibGlzdGVuT25jZVwiLCBcImF1dG9SZXN1bWVBdWRpb0NvbnRleHRcIiwgXCJkeW5DYWxsTGVnYWN5XCIsIFwiZ2V0RHluQ2FsbGVyXCIsIFwiZHluQ2FsbFwiLCBcInJ1bnRpbWVLZWVwYWxpdmVQdXNoXCIsIFwicnVudGltZUtlZXBhbGl2ZVBvcFwiLCBcImNhbGxVc2VyQ2FsbGJhY2tcIiwgXCJtYXliZUV4aXRcIiwgXCJzYWZlU2V0VGltZW91dFwiLCBcImFzbWpzTWFuZ2xlXCIsIFwiYXN5bmNMb2FkXCIsIFwiYWxpZ25NZW1vcnlcIiwgXCJtbWFwQWxsb2NcIiwgXCJIYW5kbGVBbGxvY2F0b3JcIiwgXCJnZXROYXRpdmVUeXBlU2l6ZVwiLCBcIlNUQUNLX1NJWkVcIiwgXCJTVEFDS19BTElHTlwiLCBcIlBPSU5URVJfU0laRVwiLCBcIkFTU0VSVElPTlNcIiwgXCJ3cml0ZUk1M1RvSTY0XCIsIFwid3JpdGVJNTNUb0k2NENsYW1wZWRcIiwgXCJ3cml0ZUk1M1RvSTY0U2lnbmFsaW5nXCIsIFwid3JpdGVJNTNUb1U2NENsYW1wZWRcIiwgXCJ3cml0ZUk1M1RvVTY0U2lnbmFsaW5nXCIsIFwicmVhZEk1M0Zyb21VNjRcIiwgXCJjb252ZXJ0STMyUGFpclRvSTUzXCIsIFwiY29udmVydFUzMlBhaXJUb0k1M1wiLCBcImN3cmFwXCIsIFwidWxlYjEyOEVuY29kZVwiLCBcInNpZ1RvV2FzbVR5cGVzXCIsIFwiZ2VuZXJhdGVGdW5jVHlwZVwiLCBcImNvbnZlcnRKc0Z1bmN0aW9uVG9XYXNtXCIsIFwiZ2V0RW1wdHlUYWJsZVNsb3RcIiwgXCJ1cGRhdGVUYWJsZU1hcFwiLCBcImdldEZ1bmN0aW9uQWRkcmVzc1wiLCBcImFkZEZ1bmN0aW9uXCIsIFwicmVtb3ZlRnVuY3Rpb25cIiwgXCJyZWFsbHlOZWdhdGl2ZVwiLCBcInVuU2lnblwiLCBcInN0ckxlblwiLCBcInJlU2lnblwiLCBcImZvcm1hdFN0cmluZ1wiLCBcImludEFycmF5VG9TdHJpbmdcIiwgXCJBc2NpaVRvU3RyaW5nXCIsIFwiVVRGMTZUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGMTZcIiwgXCJsZW5ndGhCeXRlc1VURjE2XCIsIFwiVVRGMzJUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGMzJcIiwgXCJsZW5ndGhCeXRlc1VURjMyXCIsIFwicmVnaXN0ZXJLZXlFdmVudENhbGxiYWNrXCIsIFwibWF5YmVDU3RyaW5nVG9Kc1N0cmluZ1wiLCBcImZpbmRFdmVudFRhcmdldFwiLCBcImZpbmRDYW52YXNFdmVudFRhcmdldFwiLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiLCBcImZpbGxNb3VzZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyTW91c2VFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJXaGVlbEV2ZW50Q2FsbGJhY2tcIiwgXCJyZWdpc3RlclVpRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyRm9jdXNFdmVudENhbGxiYWNrXCIsIFwiZmlsbERldmljZU9yaWVudGF0aW9uRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJEZXZpY2VPcmllbnRhdGlvbkV2ZW50Q2FsbGJhY2tcIiwgXCJmaWxsRGV2aWNlTW90aW9uRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJEZXZpY2VNb3Rpb25FdmVudENhbGxiYWNrXCIsIFwic2NyZWVuT3JpZW50YXRpb25cIiwgXCJmaWxsT3JpZW50YXRpb25DaGFuZ2VFdmVudERhdGFcIiwgXCJyZWdpc3Rlck9yaWVudGF0aW9uQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcImZpbGxGdWxsc2NyZWVuQ2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJGdWxsc2NyZWVuQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcIkpTRXZlbnRzX3JlcXVlc3RGdWxsc2NyZWVuXCIsIFwiSlNFdmVudHNfcmVzaXplQ2FudmFzRm9yRnVsbHNjcmVlblwiLCBcInJlZ2lzdGVyUmVzdG9yZU9sZFN0eWxlXCIsIFwiaGlkZUV2ZXJ5dGhpbmdFeGNlcHRHaXZlbkVsZW1lbnRcIiwgXCJyZXN0b3JlSGlkZGVuRWxlbWVudHNcIiwgXCJzZXRMZXR0ZXJib3hcIiwgXCJzb2Z0RnVsbHNjcmVlblJlc2l6ZVdlYkdMUmVuZGVyVGFyZ2V0XCIsIFwiZG9SZXF1ZXN0RnVsbHNjcmVlblwiLCBcImZpbGxQb2ludGVybG9ja0NoYW5nZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyUG9pbnRlcmxvY2tDaGFuZ2VFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJQb2ludGVybG9ja0Vycm9yRXZlbnRDYWxsYmFja1wiLCBcInJlcXVlc3RQb2ludGVyTG9ja1wiLCBcImZpbGxWaXNpYmlsaXR5Q2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyVG91Y2hFdmVudENhbGxiYWNrXCIsIFwiZmlsbEdhbWVwYWRFdmVudERhdGFcIiwgXCJyZWdpc3RlckdhbWVwYWRFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJCZWZvcmVVbmxvYWRFdmVudENhbGxiYWNrXCIsIFwiZmlsbEJhdHRlcnlFdmVudERhdGFcIiwgXCJiYXR0ZXJ5XCIsIFwicmVnaXN0ZXJCYXR0ZXJ5RXZlbnRDYWxsYmFja1wiLCBcInNldENhbnZhc0VsZW1lbnRTaXplXCIsIFwiZ2V0Q2FudmFzRWxlbWVudFNpemVcIiwgXCJkZW1hbmdsZVwiLCBcImRlbWFuZ2xlQWxsXCIsIFwianNTdGFja1RyYWNlXCIsIFwic3RhY2tUcmFjZVwiLCBcImNoZWNrV2FzaUNsb2NrXCIsIFwid2FzaVJpZ2h0c1RvTXVzbE9GbGFnc1wiLCBcIndhc2lPRmxhZ3NUb011c2xPRmxhZ3NcIiwgXCJjcmVhdGVEeW5jYWxsV3JhcHBlclwiLCBcInNldEltbWVkaWF0ZVdyYXBwZWRcIiwgXCJjbGVhckltbWVkaWF0ZVdyYXBwZWRcIiwgXCJwb2x5ZmlsbFNldEltbWVkaWF0ZVwiLCBcImdldFByb21pc2VcIiwgXCJtYWtlUHJvbWlzZVwiLCBcImlkc1RvUHJvbWlzZXNcIiwgXCJtYWtlUHJvbWlzZUNhbGxiYWNrXCIsIFwic2V0TWFpbkxvb3BcIiwgXCJoZWFwT2JqZWN0Rm9yV2ViR0xUeXBlXCIsIFwiaGVhcEFjY2Vzc1NoaWZ0Rm9yV2ViR0xIZWFwXCIsIFwid2ViZ2xfZW5hYmxlX0FOR0xFX2luc3RhbmNlZF9hcnJheXNcIiwgXCJ3ZWJnbF9lbmFibGVfT0VTX3ZlcnRleF9hcnJheV9vYmplY3RcIiwgXCJ3ZWJnbF9lbmFibGVfV0VCR0xfZHJhd19idWZmZXJzXCIsIFwid2ViZ2xfZW5hYmxlX1dFQkdMX211bHRpX2RyYXdcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRcIiwgXCJjb21wdXRlVW5wYWNrQWxpZ25lZEltYWdlU2l6ZVwiLCBcImNvbG9yQ2hhbm5lbHNJbkdsVGV4dHVyZUZvcm1hdFwiLCBcImVtc2NyaXB0ZW5XZWJHTEdldFRleFBpeGVsRGF0YVwiLCBcIl9fZ2xHZW5PYmplY3RcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRVbmlmb3JtXCIsIFwid2ViZ2xHZXRVbmlmb3JtTG9jYXRpb25cIiwgXCJ3ZWJnbFByZXBhcmVVbmlmb3JtTG9jYXRpb25zQmVmb3JlRmlyc3RVc2VcIiwgXCJ3ZWJnbEdldExlZnRCcmFjZVBvc1wiLCBcImVtc2NyaXB0ZW5XZWJHTEdldFZlcnRleEF0dHJpYlwiLCBcIl9fZ2xHZXRBY3RpdmVBdHRyaWJPclVuaWZvcm1cIiwgXCJ3cml0ZUdMQXJyYXlcIiwgXCJyZWdpc3RlcldlYkdsRXZlbnRDYWxsYmFja1wiLCBcInJ1bkFuZEFib3J0SWZFcnJvclwiLCBcIlNETF91bmljb2RlXCIsIFwiU0RMX3R0ZkNvbnRleHRcIiwgXCJTRExfYXVkaW9cIiwgXCJHTEZXX1dpbmRvd1wiLCBcIkFMTE9DX05PUk1BTFwiLCBcIkFMTE9DX1NUQUNLXCIsIFwiYWxsb2NhdGVcIiwgXCJ3cml0ZVN0cmluZ1RvTWVtb3J5XCIsIFwid3JpdGVBc2NpaVRvTWVtb3J5XCIgXTtcblxubWlzc2luZ0xpYnJhcnlTeW1ib2xzLmZvckVhY2gobWlzc2luZ0xpYnJhcnlTeW1ib2wpO1xuXG52YXIgdW5leHBvcnRlZFN5bWJvbHMgPSBbIFwicnVuXCIsIFwiYWRkT25QcmVSdW5cIiwgXCJhZGRPbkluaXRcIiwgXCJhZGRPblByZU1haW5cIiwgXCJhZGRPbkV4aXRcIiwgXCJhZGRPblBvc3RSdW5cIiwgXCJhZGRSdW5EZXBlbmRlbmN5XCIsIFwicmVtb3ZlUnVuRGVwZW5kZW5jeVwiLCBcIkZTX2NyZWF0ZUZvbGRlclwiLCBcIkZTX2NyZWF0ZVBhdGhcIiwgXCJGU19jcmVhdGVEYXRhRmlsZVwiLCBcIkZTX2NyZWF0ZUxhenlGaWxlXCIsIFwiRlNfY3JlYXRlTGlua1wiLCBcIkZTX2NyZWF0ZURldmljZVwiLCBcIkZTX3VubGlua1wiLCBcIm91dFwiLCBcImVyclwiLCBcImNhbGxNYWluXCIsIFwiYWJvcnRcIiwgXCJrZWVwUnVudGltZUFsaXZlXCIsIFwid2FzbU1lbW9yeVwiLCBcImdldFRlbXBSZXQwXCIsIFwic2V0VGVtcFJldDBcIiwgXCJ3cml0ZVN0YWNrQ29va2llXCIsIFwiY2hlY2tTdGFja0Nvb2tpZVwiLCBcInB0clRvU3RyaW5nXCIsIFwiemVyb01lbW9yeVwiLCBcImV4aXRKU1wiLCBcImdldEhlYXBNYXhcIiwgXCJlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyXCIsIFwiRU5WXCIsIFwiTU9OVEhfREFZU19SRUdVTEFSXCIsIFwiTU9OVEhfREFZU19MRUFQXCIsIFwiTU9OVEhfREFZU19SRUdVTEFSX0NVTVVMQVRJVkVcIiwgXCJNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRVwiLCBcImlzTGVhcFllYXJcIiwgXCJ5ZGF5RnJvbURhdGVcIiwgXCJhcnJheVN1bVwiLCBcImFkZERheXNcIiwgXCJFUlJOT19DT0RFU1wiLCBcIkVSUk5PX01FU1NBR0VTXCIsIFwic2V0RXJyTm9cIiwgXCJpbmV0UHRvbjRcIiwgXCJpbmV0TnRvcDRcIiwgXCJpbmV0UHRvbjZcIiwgXCJpbmV0TnRvcDZcIiwgXCJyZWFkU29ja2FkZHJcIiwgXCJ3cml0ZVNvY2thZGRyXCIsIFwiRE5TXCIsIFwiUHJvdG9jb2xzXCIsIFwiU29ja2V0c1wiLCBcImluaXRSYW5kb21GaWxsXCIsIFwicmFuZG9tRmlsbFwiLCBcInRpbWVyc1wiLCBcIndhcm5PbmNlXCIsIFwiVU5XSU5EX0NBQ0hFXCIsIFwicmVhZEVtQXNtQXJnc0FycmF5XCIsIFwianN0b2lfcVwiLCBcImdldEV4ZWN1dGFibGVOYW1lXCIsIFwiaGFuZGxlRXhjZXB0aW9uXCIsIFwicmVhZEk1M0Zyb21JNjRcIiwgXCJjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZFwiLCBcImdldENGdW5jXCIsIFwiZnJlZVRhYmxlSW5kZXhlc1wiLCBcImZ1bmN0aW9uc0luVGFibGVNYXBcIiwgXCJzZXRWYWx1ZVwiLCBcImdldFZhbHVlXCIsIFwiUEFUSFwiLCBcIlBBVEhfRlNcIiwgXCJVVEY4RGVjb2RlclwiLCBcIlVURjhBcnJheVRvU3RyaW5nXCIsIFwiVVRGOFRvU3RyaW5nXCIsIFwic3RyaW5nVG9VVEY4QXJyYXlcIiwgXCJzdHJpbmdUb1VURjhcIiwgXCJsZW5ndGhCeXRlc1VURjhcIiwgXCJpbnRBcnJheUZyb21TdHJpbmdcIiwgXCJzdHJpbmdUb0FzY2lpXCIsIFwiVVRGMTZEZWNvZGVyXCIsIFwic3RyaW5nVG9OZXdVVEY4XCIsIFwic3RyaW5nVG9VVEY4T25TdGFja1wiLCBcIndyaXRlQXJyYXlUb01lbW9yeVwiLCBcIkpTRXZlbnRzXCIsIFwic3BlY2lhbEhUTUxUYXJnZXRzXCIsIFwiY3VycmVudEZ1bGxzY3JlZW5TdHJhdGVneVwiLCBcInJlc3RvcmVPbGRXaW5kb3dlZFN0eWxlXCIsIFwiRXhpdFN0YXR1c1wiLCBcImdldEVudlN0cmluZ3NcIiwgXCJmbHVzaF9OT19GSUxFU1lTVEVNXCIsIFwiZGxvcGVuTWlzc2luZ0Vycm9yXCIsIFwicHJvbWlzZU1hcFwiLCBcInVuY2F1Z2h0RXhjZXB0aW9uQ291bnRcIiwgXCJleGNlcHRpb25MYXN0XCIsIFwiZXhjZXB0aW9uQ2F1Z2h0XCIsIFwiRXhjZXB0aW9uSW5mb1wiLCBcIkJyb3dzZXJcIiwgXCJ3Z2V0XCIsIFwiU1lTQ0FMTFNcIiwgXCJnZXRTb2NrZXRGcm9tRkRcIiwgXCJnZXRTb2NrZXRBZGRyZXNzXCIsIFwidGVtcEZpeGVkTGVuZ3RoQXJyYXlcIiwgXCJtaW5pVGVtcFdlYkdMRmxvYXRCdWZmZXJzXCIsIFwibWluaVRlbXBXZWJHTEludEJ1ZmZlcnNcIiwgXCJHTFwiLCBcImVtc2NyaXB0ZW5fd2ViZ2xfcG93ZXJfcHJlZmVyZW5jZXNcIiwgXCJBTFwiLCBcIkdMVVRcIiwgXCJFR0xcIiwgXCJHTEVXXCIsIFwiSURCU3RvcmVcIiwgXCJTRExcIiwgXCJTRExfZ2Z4XCIsIFwiR0xGV1wiLCBcImFsbG9jYXRlVVRGOFwiLCBcImFsbG9jYXRlVVRGOE9uU3RhY2tcIiwgXCJTT0NLRlNcIiwgXCJGU1wiIF07XG5cbnVuZXhwb3J0ZWRTeW1ib2xzLmZvckVhY2godW5leHBvcnRlZFJ1bnRpbWVTeW1ib2wpO1xuXG52YXIgY2FsbGVkUnVuO1xuXG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gaWYgKCFjYWxsZWRSdW4pIHJ1bigpO1xuIGlmICghY2FsbGVkUnVuKSBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBydW5DYWxsZXI7XG59O1xuXG5mdW5jdGlvbiBjYWxsTWFpbigpIHtcbiBhc3NlcnQocnVuRGVwZW5kZW5jaWVzID09IDAsICdjYW5ub3QgY2FsbCBtYWluIHdoZW4gYXN5bmMgZGVwZW5kZW5jaWVzIHJlbWFpbiEgKGxpc3RlbiBvbiBNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSknKTtcbiBhc3NlcnQoX19BVFBSRVJVTl9fLmxlbmd0aCA9PSAwLCBcImNhbm5vdCBjYWxsIG1haW4gd2hlbiBwcmVSdW4gZnVuY3Rpb25zIHJlbWFpbiB0byBiZSBjYWxsZWRcIik7XG4gdmFyIGVudHJ5RnVuY3Rpb24gPSBfbWFpbjtcbiB2YXIgYXJnYyA9IDA7XG4gdmFyIGFyZ3YgPSAwO1xuIHRyeSB7XG4gIHZhciByZXQgPSBlbnRyeUZ1bmN0aW9uKGFyZ2MsIGFyZ3YpO1xuICBleGl0SlMocmV0LCB0cnVlKTtcbiAgcmV0dXJuIHJldDtcbiB9IGNhdGNoIChlKSB7XG4gIHJldHVybiBoYW5kbGVFeGNlcHRpb24oZSk7XG4gfVxufVxuXG5mdW5jdGlvbiBzdGFja0NoZWNrSW5pdCgpIHtcbiBfZW1zY3JpcHRlbl9zdGFja19pbml0KCk7XG4gd3JpdGVTdGFja0Nvb2tpZSgpO1xufVxuXG5mdW5jdGlvbiBydW4oKSB7XG4gaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgcmV0dXJuO1xuIH1cbiBzdGFja0NoZWNrSW5pdCgpO1xuIHByZVJ1bigpO1xuIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gIHJldHVybjtcbiB9XG4gZnVuY3Rpb24gZG9SdW4oKSB7XG4gIGlmIChjYWxsZWRSdW4pIHJldHVybjtcbiAgY2FsbGVkUnVuID0gdHJ1ZTtcbiAgTW9kdWxlW1wiY2FsbGVkUnVuXCJdID0gdHJ1ZTtcbiAgaWYgKEFCT1JUKSByZXR1cm47XG4gIGluaXRSdW50aW1lKCk7XG4gIHByZU1haW4oKTtcbiAgcmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO1xuICBpZiAoTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pIE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7XG4gIGlmIChzaG91bGRSdW5Ob3cpIGNhbGxNYWluKCk7XG4gIHBvc3RSdW4oKTtcbiB9XG4gaWYgKE1vZHVsZVtcInNldFN0YXR1c1wiXSkge1xuICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJSdW5uaW5nLi4uXCIpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJcIik7XG4gICB9LCAxKTtcbiAgIGRvUnVuKCk7XG4gIH0sIDEpO1xuIH0gZWxzZSB7XG4gIGRvUnVuKCk7XG4gfVxuIGNoZWNrU3RhY2tDb29raWUoKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tVbmZsdXNoZWRDb250ZW50KCkge1xuIHZhciBvbGRPdXQgPSBvdXQ7XG4gdmFyIG9sZEVyciA9IGVycjtcbiB2YXIgaGFzID0gZmFsc2U7XG4gb3V0ID0gZXJyID0geCA9PiB7XG4gIGhhcyA9IHRydWU7XG4gfTtcbiB0cnkge1xuICBmbHVzaF9OT19GSUxFU1lTVEVNKCk7XG4gfSBjYXRjaCAoZSkge31cbiBvdXQgPSBvbGRPdXQ7XG4gZXJyID0gb2xkRXJyO1xuIGlmIChoYXMpIHtcbiAgd2Fybk9uY2UoXCJzdGRpbyBzdHJlYW1zIGhhZCBjb250ZW50IGluIHRoZW0gdGhhdCB3YXMgbm90IGZsdXNoZWQuIHlvdSBzaG91bGQgc2V0IEVYSVRfUlVOVElNRSB0byAxIChzZWUgdGhlIEZBUSksIG9yIG1ha2Ugc3VyZSB0byBlbWl0IGEgbmV3bGluZSB3aGVuIHlvdSBwcmludGYgZXRjLlwiKTtcbiAgd2Fybk9uY2UoXCIodGhpcyBtYXkgYWxzbyBiZSBkdWUgdG8gbm90IGluY2x1ZGluZyBmdWxsIGZpbGVzeXN0ZW0gc3VwcG9ydCAtIHRyeSBidWlsZGluZyB3aXRoIC1zRk9SQ0VfRklMRVNZU1RFTSlcIik7XG4gfVxufVxuXG5pZiAoTW9kdWxlW1wicHJlSW5pdFwiXSkge1xuIGlmICh0eXBlb2YgTW9kdWxlW1wicHJlSW5pdFwiXSA9PSBcImZ1bmN0aW9uXCIpIE1vZHVsZVtcInByZUluaXRcIl0gPSBbIE1vZHVsZVtcInByZUluaXRcIl0gXTtcbiB3aGlsZSAoTW9kdWxlW1wicHJlSW5pdFwiXS5sZW5ndGggPiAwKSB7XG4gIE1vZHVsZVtcInByZUluaXRcIl0ucG9wKCkoKTtcbiB9XG59XG5cbnZhciBzaG91bGRSdW5Ob3cgPSB0cnVlO1xuXG5pZiAoTW9kdWxlW1wibm9Jbml0aWFsUnVuXCJdKSBzaG91bGRSdW5Ob3cgPSBmYWxzZTtcblxucnVuKCk7XG5cblxuICByZXR1cm4gRHVja0RCLnJlYWR5XG59XG5cbik7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgRHVja0RCOyIsICJpbXBvcnQgeyBEdWNrREJNb2R1bGUgfSBmcm9tICcuL2R1Y2tkYl9tb2R1bGUnO1xyXG5pbXBvcnQgeyBEdWNrREJCaW5kaW5nc0Jhc2UgfSBmcm9tICcuL2JpbmRpbmdzX2Jhc2UnO1xyXG5pbXBvcnQgeyBEdWNrREJSdW50aW1lIH0gZnJvbSAnLi9ydW50aW1lJztcclxuaW1wb3J0IHsgTG9nTGV2ZWwsIExvZ1RvcGljLCBMb2dPcmlnaW4sIExvZ0V2ZW50IH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLic7XHJcblxyXG4vKiogRHVja0RCIGJpbmRpbmdzIGZvciB0aGUgYnJvd3NlciAqL1xyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRHVja0RCQnJvd3NlckJpbmRpbmdzIGV4dGVuZHMgRHVja0RCQmluZGluZ3NCYXNlIHtcclxuICAgIC8qKiBUaGUgcGF0aCBvZiB0aGUgd2FzbSBtb2R1bGUgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBtYWluTW9kdWxlVVJMOiBzdHJpbmc7XHJcbiAgICAvKiogVGhlIHBhdGggb2YgdGhlIHB0aHJlYWQgd29ya2VyIHNjcmlwdCAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGw7XHJcblxyXG4gICAgLyoqIENvbnN0cnVjdG9yICovXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IobG9nZ2VyOiBMb2dnZXIsIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsIG1haW5Nb2R1bGVVUkw6IHN0cmluZywgcHRocmVhZFdvcmtlclVSTDogc3RyaW5nIHwgbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKGxvZ2dlciwgcnVudGltZSk7XHJcbiAgICAgICAgdGhpcy5tYWluTW9kdWxlVVJMID0gbWFpbk1vZHVsZVVSTDtcclxuICAgICAgICB0aGlzLnB0aHJlYWRXb3JrZXJVUkwgPSBwdGhyZWFkV29ya2VyVVJMO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBMb2NhdGUgYSBmaWxlICovXHJcbiAgICBwcm90ZWN0ZWQgbG9jYXRlRmlsZShwYXRoOiBzdHJpbmcsIHByZWZpeDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICBpZiAocGF0aC5lbmRzV2l0aCgnLndhc20nKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWluTW9kdWxlVVJMO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0aC5lbmRzV2l0aCgnLndvcmtlci5qcycpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wdGhyZWFkV29ya2VyVVJMKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgRHVja0RCIHdvcmtlciBVUkwhJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHRocmVhZFdvcmtlclVSTCE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV0FTTSBpbnN0YW50aWF0aW9uIHJlcXVlc3RlZCB1bmV4cGVjdGVkIGZpbGU6IHByZWZpeD0ke3ByZWZpeH0gcGF0aD0ke3BhdGh9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSB3YXNtIG1vZHVsZSAqL1xyXG4gICAgcHJvdGVjdGVkIGluc3RhbnRpYXRlV2FzbShcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xyXG4gICAgICAgIGltcG9ydHM6IGFueSxcclxuICAgICAgICBzdWNjZXNzOiAoaW5zdGFuY2U6IFdlYkFzc2VtYmx5Lkluc3RhbmNlLCBtb2R1bGU6IFdlYkFzc2VtYmx5Lk1vZHVsZSkgPT4gdm9pZCxcclxuICAgICk6IEVtc2NyaXB0ZW4uV2ViQXNzZW1ibHlFeHBvcnRzIHtcclxuICAgICAgICAvLyBXZSByZWx5IG9uIHRoZSBmb2xsb3dpbmcgaGVyZTpcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIC4uLndoZW4gYSBSZXF1ZXN0IG9iamVjdCBpcyBjcmVhdGVkIHVzaW5nIHRoZSBSZXF1ZXN0LlJlcXVlc3QgY29uc3RydWN0b3IsXHJcbiAgICAgICAgLy8gdGhlIHZhbHVlIG9mIHRoZSBtb2RlIHByb3BlcnR5IGZvciB0aGF0IFJlcXVlc3QgaXMgc2V0IHRvIGNvcnMuXHJcbiAgICAgICAgLy8gW3JlZjogTUROXVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gQ2xvdWRmbGFyZSB0aHJvd3Mgd2hlbiBtb2RlOiAnY29ycycgaXMgc2V0XHJcbiAgICAgICAgLy9cclxuICAgICAgICBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FID0gdGhpcy5fcnVudGltZTtcclxuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMub25JbnN0YW50aWF0aW9uUHJvZ3Jlc3M7XHJcblxyXG4gICAgICAgIC8vIERvZXMgdGhlIGJyb3dzZXIgc3VwcG9ydCBzdHJlYW1pbmcgaW5zdGFudGlhdGlvbj9cclxuICAgICAgICBpZiAoV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcpIHtcclxuICAgICAgICAgICAgLy8gRG9lcyB0aGUgYnJvd3NlciBzdXBwb3J0IHRyYW5zZm9ybSBzdHJlYW1zP1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIFRyYW5zZm9ybVN0cmVhbSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hXaXRoUHJvZ3Jlc3MgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSBmaWxlIHNpemVcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5tYWluTW9kdWxlVVJMKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGhIZHIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC1sZW5ndGgnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aEhkciA/IHBhcnNlSW50KGNvbnRlbnRMZW5ndGhIZHIsIDEwKSB8fCAwIDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBzdHJlYW1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3M6IEluc3RhbnRpYXRpb25Qcm9ncmVzcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZEF0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNUb3RhbDogY29udGVudExlbmd0aCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlc0xvYWRlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuazogYW55LCBjdHJsOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MuYnl0ZXNMb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm93LmdldFRpbWUoKSAtIHByb2dyZXNzLnVwZGF0ZWRBdC5nZXRUaW1lKCkgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzLnVwZGF0ZWRBdCA9IG5vdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoY2h1bmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBoYW5kbGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAocHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3RybC5lbnF1ZXVlKGNodW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRzID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh0cmFja2VyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmJvZHk/LnBpcGVUaHJvdWdoKHRzKSwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIEluc3RhbnRpYXRlIHN0cmVhbWluZ1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBmZXRjaFdpdGhQcm9ncmVzcygpO1xyXG4gICAgICAgICAgICAgICAgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcocmVzcG9uc2UsIGltcG9ydHMpLnRoZW4ob3V0cHV0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG91dHB1dC5pbnN0YW5jZSwgb3V0cHV0Lm1vZHVsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5zdGFudGlhdGluZyB3aXRob3V0IHByb2dyZXNzIGhhbmRsZXIgc2luY2UgdHJhbnNmb3JtIHN0cmVhbXMgYXJlIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodGhpcy5tYWluTW9kdWxlVVJMKTtcclxuICAgICAgICAgICAgICAgIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKGZldGNoKHJlcXVlc3QpLCBpbXBvcnRzKS50aGVuKG91dHB1dCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhvdXRwdXQuaW5zdGFuY2UsIG91dHB1dC5tb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBmYWxsIGJhY2sgdG8gWEhSc1xyXG4gICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5tYWluTW9kdWxlVVJMO1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzOiBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MgPSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydGVkQXQ6IHN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBzdGFydCxcclxuICAgICAgICAgICAgICAgIGJ5dGVzVG90YWw6IDAsXHJcbiAgICAgICAgICAgICAgICBieXRlc0xvYWRlZDogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCk7XHJcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICB4aHIub25lcnJvciA9IGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZyh7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5FUlJPUixcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IExvZ09yaWdpbi5CSU5ESU5HUyxcclxuICAgICAgICAgICAgICAgICAgICB0b3BpYzogTG9nVG9waWMuSU5TVEFOVElBVEUsXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IExvZ0V2ZW50LkVSUk9SLFxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnRmFpbGVkIHRvIGxvYWQgV0FTTTogJyArIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0gZSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcy5ieXRlc1RvdGFsID0gZS50b3RhbDtcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzLmJ5dGVzTG9hZGVkID0gZS5sb2FkZWQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vdy5nZXRUaW1lKCkgLSBwcm9ncmVzcy51cGRhdGVkQXQuZ2V0VGltZSgpIDwgMjApIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcy51cGRhdGVkQXQgPSBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIGhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcChwcm9ncmVzcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh4aHIucmVzcG9uc2UsIGltcG9ydHMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ob3V0cHV0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhvdXRwdXQuaW5zdGFuY2UsIG91dHB1dC5tb2R1bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIubG9nKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5FUlJPUixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogTG9nT3JpZ2luLkJJTkRJTkdTLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IExvZ1RvcGljLklOU1RBTlRJQVRFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IExvZ0V2ZW50LkVSUk9SLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6ICdGYWlsZWQgdG8gaW5zdGFudGlhdGUgV0FTTTogJyArIGVycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luc3RhbnRpYXRpbmcgd2l0aCBtYW51YWwgZmV0Y2ggc2luY2Ugc3RyZWFtaW5nIGluc3RhbnRpYXRpb24gYW5kIHhocnMgYXJlIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1biA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh0aGlzLm1haW5Nb2R1bGVVUkwpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShidWZmZXIsIGltcG9ydHMpLnRoZW4ob3V0cHV0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKG91dHB1dC5pbnN0YW5jZSwgb3V0cHV0Lm1vZHVsZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuXHJcbiAgICAvLy8gSW5zdGFudGlhdGlvbiBtdXN0IGJlIGRvbmUgYnkgdGhlIGJyb3dzZXIgdmFyaWFudHNcclxuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbnN0YW50aWF0ZUltcGwobW9kdWxlT3ZlcnJpZGVzOiBQYXJ0aWFsPER1Y2tEQk1vZHVsZT4pOiBQcm9taXNlPER1Y2tEQk1vZHVsZT47XHJcbn1cclxuIiwgImltcG9ydCBEdWNrREJXYXNtIGZyb20gJy4vZHVja2RiLW12cC5qcyc7XHJcbmltcG9ydCB7IER1Y2tEQkJyb3dzZXJCaW5kaW5ncyB9IGZyb20gJy4vYmluZGluZ3NfYnJvd3Nlcl9iYXNlJztcclxuaW1wb3J0IHsgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi9kdWNrZGJfbW9kdWxlJztcclxuaW1wb3J0IHsgRHVja0RCUnVudGltZSB9IGZyb20gJy4vcnVudGltZSc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZyc7XHJcblxyXG4vKiogRHVja0RCIGJpbmRpbmdzIGZvciB0aGUgYnJvd3NlciAqL1xyXG5leHBvcnQgY2xhc3MgRHVja0RCIGV4dGVuZHMgRHVja0RCQnJvd3NlckJpbmRpbmdzIHtcclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIGxvZ2dlcjogTG9nZ2VyLFxyXG4gICAgICAgIHJ1bnRpbWU6IER1Y2tEQlJ1bnRpbWUsXHJcbiAgICAgICAgbWFpbk1vZHVsZVVSTDogc3RyaW5nLFxyXG4gICAgICAgIHB0aHJlYWRXb3JrZXJVUkw6IHN0cmluZyB8IG51bGwgPSBudWxsLFxyXG4gICAgKSB7XHJcbiAgICAgICAgc3VwZXIobG9nZ2VyLCBydW50aW1lLCBtYWluTW9kdWxlVVJMLCBwdGhyZWFkV29ya2VyVVJMKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIGJpbmRpbmdzICovXHJcbiAgICBwcm90ZWN0ZWQgaW5zdGFudGlhdGVJbXBsKG1vZHVsZU92ZXJyaWRlczogUGFydGlhbDxEdWNrREJNb2R1bGU+KTogUHJvbWlzZTxEdWNrREJNb2R1bGU+IHtcclxuICAgICAgICByZXR1cm4gRHVja0RCV2FzbSh7XHJcbiAgICAgICAgICAgIC4uLm1vZHVsZU92ZXJyaWRlcyxcclxuICAgICAgICAgICAgaW5zdGFudGlhdGVXYXNtOiB0aGlzLmluc3RhbnRpYXRlV2FzbS5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgICBsb2NhdGVGaWxlOiB0aGlzLmxvY2F0ZUZpbGUuYmluZCh0aGlzKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCAiXG52YXIgRHVja0RCID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSBpbXBvcnQubWV0YS51cmw7XG4gIFxuICByZXR1cm4gKFxuYXN5bmMgZnVuY3Rpb24oRHVja0RCID0ge30pICB7XG5cbnZhciBNb2R1bGUgPSB0eXBlb2YgRHVja0RCICE9IFwidW5kZWZpbmVkXCIgPyBEdWNrREIgOiB7fTtcblxudmFyIHJlYWR5UHJvbWlzZVJlc29sdmUsIHJlYWR5UHJvbWlzZVJlamVjdDtcblxuTW9kdWxlW1wicmVhZHlcIl0gPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gcmVhZHlQcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gcmVhZHlQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xufSk7XG5cblsgXCJfbWFpblwiLCBcIl9tYWxsb2NcIiwgXCJfZnJlZVwiLCBcIl9kdWNrZGJfd2ViX2NsZWFyX3Jlc3BvbnNlXCIsIFwiX2R1Y2tkYl93ZWJfY29sbGVjdF9maWxlX3N0YXRzXCIsIFwiX2R1Y2tkYl93ZWJfY29ubmVjdFwiLCBcIl9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXJcIiwgXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fcGF0aFwiLCBcIl9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3RcIiwgXCJfZHVja2RiX3dlYl9leHBvcnRfZmlsZV9zdGF0c1wiLCBcIl9kdWNrZGJfd2ViX2ZhaWxfd2l0aFwiLCBcIl9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVcIiwgXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlc1wiLCBcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZVwiLCBcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXNcIiwgXCJfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9uYW1lXCIsIFwiX2R1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aFwiLCBcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvc1wiLCBcIl9kdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyXCIsIFwiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV91cmxcIiwgXCJfZHVja2RiX3dlYl9nZXRfZmVhdHVyZV9mbGFnc1wiLCBcIl9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvXCIsIFwiX2R1Y2tkYl93ZWJfZ2V0X3RhYmxlbmFtZXNcIiwgXCJfZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiLCBcIl9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW1cIiwgXCJfZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiLCBcIl9kdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aFwiLCBcIl9kdWNrZGJfd2ViX29wZW5cIiwgXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X2NhbmNlbFwiLCBcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbFwiLCBcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnRcIiwgXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiLCBcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX2NyZWF0ZVwiLCBcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3J1blwiLCBcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmRcIiwgXCJfZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzXCIsIFwiX2R1Y2tkYl93ZWJfcXVlcnlfcnVuXCIsIFwiX2R1Y2tkYl93ZWJfcmVzZXRcIiwgXCJfZHVja2RiX3dlYl90b2tlbml6ZVwiLCBcIl9kdWNrZGJfd2ViX3VkZl9zY2FsYXJfY3JlYXRlXCIsIFwiZ2V0RXhjZXB0aW9uTWVzc2FnZVwiLCBcIl9fX2dldF9leGNlcHRpb25fbWVzc2FnZVwiLCBcIl9fX2NwcF9leGNlcHRpb25cIiwgXCJfX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiLCBcIl9fX2N4YV9kZWNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50XCIsIFwiX19fdGhyb3duX29iamVjdF9mcm9tX3Vud2luZF9leGNlcHRpb25cIiwgXCJfZmZsdXNoXCIsIFwib25SdW50aW1lSW5pdGlhbGl6ZWRcIiBdLmZvckVhY2gocHJvcCA9PiB7XG4gaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1vZHVsZVtcInJlYWR5XCJdLCBwcm9wKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlW1wicmVhZHlcIl0sIHByb3AsIHtcbiAgIGdldDogKCkgPT4gYWJvcnQoXCJZb3UgYXJlIGdldHRpbmcgXCIgKyBwcm9wICsgXCIgb24gdGhlIFByb21pc2Ugb2JqZWN0LCBpbnN0ZWFkIG9mIHRoZSBpbnN0YW5jZS4gVXNlIC50aGVuKCkgdG8gZ2V0IGNhbGxlZCBiYWNrIHdpdGggdGhlIGluc3RhbmNlLCBzZWUgdGhlIE1PRFVMQVJJWkUgZG9jcyBpbiBzcmMvc2V0dGluZ3MuanNcIiksXG4gICBzZXQ6ICgpID0+IGFib3J0KFwiWW91IGFyZSBzZXR0aW5nIFwiICsgcHJvcCArIFwiIG9uIHRoZSBQcm9taXNlIG9iamVjdCwgaW5zdGVhZCBvZiB0aGUgaW5zdGFuY2UuIFVzZSAudGhlbigpIHRvIGdldCBjYWxsZWQgYmFjayB3aXRoIHRoZSBpbnN0YW5jZSwgc2VlIHRoZSBNT0RVTEFSSVpFIGRvY3MgaW4gc3JjL3NldHRpbmdzLmpzXCIpXG4gIH0pO1xuIH1cbn0pO1xuXG52YXIgbW9kdWxlT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbih7fSwgTW9kdWxlKTtcblxudmFyIGFyZ3VtZW50c18gPSBbXTtcblxudmFyIHRoaXNQcm9ncmFtID0gXCIuL3RoaXMucHJvZ3JhbVwiO1xuXG52YXIgcXVpdF8gPSAoc3RhdHVzLCB0b1Rocm93KSA9PiB7XG4gdGhyb3cgdG9UaHJvdztcbn07XG5cbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCI7XG5cbnZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSBcImZ1bmN0aW9uXCI7XG5cbnZhciBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHlwZW9mIHByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLm5vZGUgPT0gXCJzdHJpbmdcIjtcblxudmFyIEVOVklST05NRU5UX0lTX1NIRUxMID0gIUVOVklST05NRU5UX0lTX1dFQiAmJiAhRU5WSVJPTk1FTlRfSVNfTk9ERSAmJiAhRU5WSVJPTk1FTlRfSVNfV09SS0VSO1xuXG5pZiAoTW9kdWxlW1wiRU5WSVJPTk1FTlRcIl0pIHtcbiB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUuRU5WSVJPTk1FTlQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVG8gZm9yY2UgdGhlIGVudmlyb25tZW50LCB1c2UgdGhlIEVOVklST05NRU5UIGNvbXBpbGUtdGltZSBvcHRpb24gKGZvciBleGFtcGxlLCAtc0VOVklST05NRU5UPXdlYiBvciAtc0VOVklST05NRU5UPW5vZGUpXCIpO1xufVxuXG52YXIgc2NyaXB0RGlyZWN0b3J5ID0gXCJcIjtcblxuZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gaWYgKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pIHtcbiAgcmV0dXJuIE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0ocGF0aCwgc2NyaXB0RGlyZWN0b3J5KTtcbiB9XG4gcmV0dXJuIHNjcmlwdERpcmVjdG9yeSArIHBhdGg7XG59XG5cbnZhciByZWFkXywgcmVhZEFzeW5jLCByZWFkQmluYXJ5LCBzZXRXaW5kb3dUaXRsZTtcblxuaWYgKEVOVklST05NRU5UX0lTX05PREUpIHtcbiBpZiAodHlwZW9mIHByb2Nlc3MgPT0gXCJ1bmRlZmluZWRcIiB8fCAhcHJvY2Vzcy5yZWxlYXNlIHx8IHByb2Nlc3MucmVsZWFzZS5uYW1lICE9PSBcIm5vZGVcIikgdGhyb3cgbmV3IEVycm9yKFwibm90IGNvbXBpbGVkIGZvciB0aGlzIGVudmlyb25tZW50IChkaWQgeW91IGJ1aWxkIHRvIEhUTUwgYW5kIHRyeSB0byBydW4gaXQgbm90IG9uIHRoZSB3ZWIsIG9yIHNldCBFTlZJUk9OTUVOVCB0byBzb21ldGhpbmcgLSBsaWtlIG5vZGUgLSBhbmQgcnVuIGl0IHNvbWVwbGFjZSBlbHNlIC0gbGlrZSBvbiB0aGUgd2ViPylcIik7XG4gdmFyIG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuIHZhciBudW1lcmljVmVyc2lvbiA9IG5vZGVWZXJzaW9uLnNwbGl0KFwiLlwiKS5zbGljZSgwLCAzKTtcbiBudW1lcmljVmVyc2lvbiA9IG51bWVyaWNWZXJzaW9uWzBdICogMWU0ICsgbnVtZXJpY1ZlcnNpb25bMV0gKiAxMDAgKyBudW1lcmljVmVyc2lvblsyXS5zcGxpdChcIi1cIilbMF0gKiAxO1xuIHZhciBtaW5WZXJzaW9uID0gMTAxOTAwO1xuIGlmIChudW1lcmljVmVyc2lvbiA8IDEwMTkwMCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGVtc2NyaXB0ZW4tZ2VuZXJhdGVkIGNvZGUgcmVxdWlyZXMgbm9kZSB2MTAuMTkuMTkuMCAoZGV0ZWN0ZWQgdlwiICsgbm9kZVZlcnNpb24gKyBcIilcIik7XG4gfVxuIGNvbnN0IHtjcmVhdGVSZXF1aXJlOiBjcmVhdGVSZXF1aXJlfSA9IGF3YWl0IGltcG9ydChcIm1vZHVsZVwiKTtcbiB2YXIgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbiB2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gdmFyIG5vZGVQYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG4gaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICBzY3JpcHREaXJlY3RvcnkgPSBub2RlUGF0aC5kaXJuYW1lKHNjcmlwdERpcmVjdG9yeSkgKyBcIi9cIjtcbiB9IGVsc2Uge1xuICBzY3JpcHREaXJlY3RvcnkgPSByZXF1aXJlKFwidXJsXCIpLmZpbGVVUkxUb1BhdGgobmV3IFVSTChcIi4vXCIsIGltcG9ydC5tZXRhLnVybCkpO1xuIH1cbiByZWFkXyA9IChmaWxlbmFtZSwgYmluYXJ5KSA9PiB7XG4gIGZpbGVuYW1lID0gaXNGaWxlVVJJKGZpbGVuYW1lKSA/IG5ldyBVUkwoZmlsZW5hbWUpIDogbm9kZVBhdGgubm9ybWFsaXplKGZpbGVuYW1lKTtcbiAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgYmluYXJ5ID8gdW5kZWZpbmVkIDogXCJ1dGY4XCIpO1xuIH07XG4gcmVhZEJpbmFyeSA9IGZpbGVuYW1lID0+IHtcbiAgdmFyIHJldCA9IHJlYWRfKGZpbGVuYW1lLCB0cnVlKTtcbiAgaWYgKCFyZXQuYnVmZmVyKSB7XG4gICByZXQgPSBuZXcgVWludDhBcnJheShyZXQpO1xuICB9XG4gIGFzc2VydChyZXQuYnVmZmVyKTtcbiAgcmV0dXJuIHJldDtcbiB9O1xuIHJlYWRBc3luYyA9IChmaWxlbmFtZSwgb25sb2FkLCBvbmVycm9yLCBiaW5hcnkgPSB0cnVlKSA9PiB7XG4gIGZpbGVuYW1lID0gaXNGaWxlVVJJKGZpbGVuYW1lKSA/IG5ldyBVUkwoZmlsZW5hbWUpIDogbm9kZVBhdGgubm9ybWFsaXplKGZpbGVuYW1lKTtcbiAgZnMucmVhZEZpbGUoZmlsZW5hbWUsIGJpbmFyeSA/IHVuZGVmaW5lZCA6IFwidXRmOFwiLCAoZXJyLCBkYXRhKSA9PiB7XG4gICBpZiAoZXJyKSBvbmVycm9yKGVycik7IGVsc2Ugb25sb2FkKGJpbmFyeSA/IGRhdGEuYnVmZmVyIDogZGF0YSk7XG4gIH0pO1xuIH07XG4gaWYgKCFNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSAmJiBwcm9jZXNzLmFyZ3YubGVuZ3RoID4gMSkge1xuICB0aGlzUHJvZ3JhbSA9IHByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiB9XG4gYXJndW1lbnRzXyA9IHByb2Nlc3MuYXJndi5zbGljZSgyKTtcbiBxdWl0XyA9IChzdGF0dXMsIHRvVGhyb3cpID0+IHtcbiAgcHJvY2Vzcy5leGl0Q29kZSA9IHN0YXR1cztcbiAgdGhyb3cgdG9UaHJvdztcbiB9O1xuIE1vZHVsZVtcImluc3BlY3RcIl0gPSAoKSA9PiBcIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdXCI7XG59IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX1NIRUxMKSB7XG4gaWYgKHR5cGVvZiBwcm9jZXNzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygd2luZG93ID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGltcG9ydFNjcmlwdHMgPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KVwiKTtcbiBpZiAodHlwZW9mIHJlYWQgIT0gXCJ1bmRlZmluZWRcIikge1xuICByZWFkXyA9IGYgPT4ge1xuICAgcmV0dXJuIHJlYWQoZik7XG4gIH07XG4gfVxuIHJlYWRCaW5hcnkgPSBmID0+IHtcbiAgbGV0IGRhdGE7XG4gIGlmICh0eXBlb2YgcmVhZGJ1ZmZlciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgIHJldHVybiBuZXcgVWludDhBcnJheShyZWFkYnVmZmVyKGYpKTtcbiAgfVxuICBkYXRhID0gcmVhZChmLCBcImJpbmFyeVwiKTtcbiAgYXNzZXJ0KHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIpO1xuICByZXR1cm4gZGF0YTtcbiB9O1xuIHJlYWRBc3luYyA9IChmLCBvbmxvYWQsIG9uZXJyb3IpID0+IHtcbiAgc2V0VGltZW91dCgoKSA9PiBvbmxvYWQocmVhZEJpbmFyeShmKSksIDApO1xuIH07XG4gaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT0gXCJ1bmRlZmluZWRcIikge1xuICBnbG9iYWxUaGlzLmNsZWFyVGltZW91dCA9IGlkID0+IHt9O1xuIH1cbiBpZiAodHlwZW9mIHNjcmlwdEFyZ3MgIT0gXCJ1bmRlZmluZWRcIikge1xuICBhcmd1bWVudHNfID0gc2NyaXB0QXJncztcbiB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHMgIT0gXCJ1bmRlZmluZWRcIikge1xuICBhcmd1bWVudHNfID0gYXJndW1lbnRzO1xuIH1cbiBpZiAodHlwZW9mIHF1aXQgPT0gXCJmdW5jdGlvblwiKSB7XG4gIHF1aXRfID0gKHN0YXR1cywgdG9UaHJvdykgPT4ge1xuICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKCEodG9UaHJvdyBpbnN0YW5jZW9mIEV4aXRTdGF0dXMpKSB7XG4gICAgIGxldCB0b0xvZyA9IHRvVGhyb3c7XG4gICAgIGlmICh0b1Rocm93ICYmIHR5cGVvZiB0b1Rocm93ID09IFwib2JqZWN0XCIgJiYgdG9UaHJvdy5zdGFjaykge1xuICAgICAgdG9Mb2cgPSBbIHRvVGhyb3csIHRvVGhyb3cuc3RhY2sgXTtcbiAgICAgfVxuICAgICBlcnIoYGV4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogJHt0b0xvZ31gKTtcbiAgICB9XG4gICAgcXVpdChzdGF0dXMpO1xuICAgfSk7XG4gICB0aHJvdyB0b1Rocm93O1xuICB9O1xuIH1cbiBpZiAodHlwZW9mIHByaW50ICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlID09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUgPSB7fTtcbiAgY29uc29sZS5sb2cgPSBwcmludDtcbiAgY29uc29sZS53YXJuID0gY29uc29sZS5lcnJvciA9IHR5cGVvZiBwcmludEVyciAhPSBcInVuZGVmaW5lZFwiID8gcHJpbnRFcnIgOiBwcmludDtcbiB9XG59IGVsc2UgaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgc2NyaXB0RGlyZWN0b3J5ID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG4gfVxuIGlmIChfc2NyaXB0RGlyKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IF9zY3JpcHREaXI7XG4gfVxuIGlmIChzY3JpcHREaXJlY3RvcnkuaW5kZXhPZihcImJsb2I6XCIpICE9PSAwKSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IHNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCwgc2NyaXB0RGlyZWN0b3J5LnJlcGxhY2UoL1s/I10uKi8sIFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuIH0gZWxzZSB7XG4gIHNjcmlwdERpcmVjdG9yeSA9IFwiXCI7XG4gfVxuIGlmICghKHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgRXJyb3IoXCJub3QgY29tcGlsZWQgZm9yIHRoaXMgZW52aXJvbm1lbnQgKGRpZCB5b3UgYnVpbGQgdG8gSFRNTCBhbmQgdHJ5IHRvIHJ1biBpdCBub3Qgb24gdGhlIHdlYiwgb3Igc2V0IEVOVklST05NRU5UIHRvIHNvbWV0aGluZyAtIGxpa2Ugbm9kZSAtIGFuZCBydW4gaXQgc29tZXBsYWNlIGVsc2UgLSBsaWtlIG9uIHRoZSB3ZWI/KVwiKTtcbiB7XG4gIHJlYWRfID0gdXJsID0+IHtcbiAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgIHhoci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgeGhyLnNlbmQobnVsbCk7XG4gICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgfTtcbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgcmVhZEJpbmFyeSA9IHVybCA9PiB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHVybCwgZmFsc2UpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSk7XG4gICB9O1xuICB9XG4gIHJlYWRBc3luYyA9ICh1cmwsIG9ubG9hZCwgb25lcnJvcikgPT4ge1xuICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsLCB0cnVlKTtcbiAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICB4aHIub25sb2FkID0gKCkgPT4ge1xuICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCB4aHIuc3RhdHVzID09IDAgJiYgeGhyLnJlc3BvbnNlKSB7XG4gICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpO1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uZXJyb3IoKTtcbiAgIH07XG4gICB4aHIub25lcnJvciA9IG9uZXJyb3I7XG4gICB4aHIuc2VuZChudWxsKTtcbiAgfTtcbiB9XG4gc2V0V2luZG93VGl0bGUgPSB0aXRsZSA9PiBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xufSBlbHNlIHtcbiB0aHJvdyBuZXcgRXJyb3IoXCJlbnZpcm9ubWVudCBkZXRlY3Rpb24gZXJyb3JcIik7XG59XG5cbnZhciBvdXQgPSBNb2R1bGVbXCJwcmludFwiXSB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuXG52YXIgZXJyID0gTW9kdWxlW1wicHJpbnRFcnJcIl0gfHwgY29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO1xuXG5PYmplY3QuYXNzaWduKE1vZHVsZSwgbW9kdWxlT3ZlcnJpZGVzKTtcblxubW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcblxuY2hlY2tJbmNvbWluZ01vZHVsZUFQSSgpO1xuXG5pZiAoTW9kdWxlW1wiYXJndW1lbnRzXCJdKSBhcmd1bWVudHNfID0gTW9kdWxlW1wiYXJndW1lbnRzXCJdO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwiYXJndW1lbnRzXCIsIFwiYXJndW1lbnRzX1wiKTtcblxuaWYgKE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdKSB0aGlzUHJvZ3JhbSA9IE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdO1xuXG5sZWdhY3lNb2R1bGVQcm9wKFwidGhpc1Byb2dyYW1cIiwgXCJ0aGlzUHJvZ3JhbVwiKTtcblxuaWYgKE1vZHVsZVtcInF1aXRcIl0pIHF1aXRfID0gTW9kdWxlW1wicXVpdFwiXTtcblxubGVnYWN5TW9kdWxlUHJvcChcInF1aXRcIiwgXCJxdWl0X1wiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJtZW1vcnlJbml0aWFsaXplclByZWZpeFVSTFwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5tZW1vcnlJbml0aWFsaXplclByZWZpeFVSTCBvcHRpb24gd2FzIHJlbW92ZWQsIHVzZSBNb2R1bGUubG9jYXRlRmlsZSBpbnN0ZWFkXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInB0aHJlYWRNYWluUHJlZml4VVJMXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLnB0aHJlYWRNYWluUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWRcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wiY2RJbml0aWFsaXplclByZWZpeFVSTFwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5jZEluaXRpYWxpemVyUHJlZml4VVJMIG9wdGlvbiB3YXMgcmVtb3ZlZCwgdXNlIE1vZHVsZS5sb2NhdGVGaWxlIGluc3RlYWRcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wiZmlsZVBhY2thZ2VQcmVmaXhVUkxcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUuZmlsZVBhY2thZ2VQcmVmaXhVUkwgb3B0aW9uIHdhcyByZW1vdmVkLCB1c2UgTW9kdWxlLmxvY2F0ZUZpbGUgaW5zdGVhZFwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJyZWFkXCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLnJlYWQgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZF8gaW4gSlMpXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcInJlYWRBc3luY1wiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5yZWFkQXN5bmMgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZEFzeW5jIGluIEpTKVwiKTtcblxuYXNzZXJ0KHR5cGVvZiBNb2R1bGVbXCJyZWFkQmluYXJ5XCJdID09IFwidW5kZWZpbmVkXCIsIFwiTW9kdWxlLnJlYWRCaW5hcnkgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgcmVhZEJpbmFyeSBpbiBKUylcIik7XG5cbmFzc2VydCh0eXBlb2YgTW9kdWxlW1wic2V0V2luZG93VGl0bGVcIl0gPT0gXCJ1bmRlZmluZWRcIiwgXCJNb2R1bGUuc2V0V2luZG93VGl0bGUgb3B0aW9uIHdhcyByZW1vdmVkIChtb2RpZnkgc2V0V2luZG93VGl0bGUgaW4gSlMpXCIpO1xuXG5hc3NlcnQodHlwZW9mIE1vZHVsZVtcIlRPVEFMX01FTU9SWVwiXSA9PSBcInVuZGVmaW5lZFwiLCBcIk1vZHVsZS5UT1RBTF9NRU1PUlkgaGFzIGJlZW4gcmVuYW1lZCBNb2R1bGUuSU5JVElBTF9NRU1PUllcIik7XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJyZWFkXCIsIFwicmVhZF9cIik7XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJyZWFkQXN5bmNcIiwgXCJyZWFkQXN5bmNcIik7XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJyZWFkQmluYXJ5XCIsIFwicmVhZEJpbmFyeVwiKTtcblxubGVnYWN5TW9kdWxlUHJvcChcInNldFdpbmRvd1RpdGxlXCIsIFwic2V0V2luZG93VGl0bGVcIik7XG5cbnZhciBJREJGUyA9IFwiSURCRlMgaXMgbm8gbG9uZ2VyIGluY2x1ZGVkIGJ5IGRlZmF1bHQ7IGJ1aWxkIHdpdGggLWxpZGJmcy5qc1wiO1xuXG52YXIgUFJPWFlGUyA9IFwiUFJPWFlGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbHByb3h5ZnMuanNcIjtcblxudmFyIFdPUktFUkZTID0gXCJXT1JLRVJGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbHdvcmtlcmZzLmpzXCI7XG5cbnZhciBOT0RFRlMgPSBcIk5PREVGUyBpcyBubyBsb25nZXIgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYnVpbGQgd2l0aCAtbG5vZGVmcy5qc1wiO1xuXG5hc3NlcnQoIUVOVklST05NRU5UX0lTX1NIRUxMLCBcInNoZWxsIGVudmlyb25tZW50IGRldGVjdGVkIGJ1dCBub3QgZW5hYmxlZCBhdCBidWlsZCB0aW1lLiAgQWRkICdzaGVsbCcgdG8gYC1zRU5WSVJPTk1FTlRgIHRvIGVuYWJsZS5cIik7XG5cbnZhciB3YXNtQmluYXJ5O1xuXG5pZiAoTW9kdWxlW1wid2FzbUJpbmFyeVwiXSkgd2FzbUJpbmFyeSA9IE1vZHVsZVtcIndhc21CaW5hcnlcIl07XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJ3YXNtQmluYXJ5XCIsIFwid2FzbUJpbmFyeVwiKTtcblxudmFyIG5vRXhpdFJ1bnRpbWUgPSBNb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdIHx8IHRydWU7XG5cbmxlZ2FjeU1vZHVsZVByb3AoXCJub0V4aXRSdW50aW1lXCIsIFwibm9FeGl0UnVudGltZVwiKTtcblxuaWYgKHR5cGVvZiBXZWJBc3NlbWJseSAhPSBcIm9iamVjdFwiKSB7XG4gYWJvcnQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO1xufVxuXG52YXIgd2FzbU1lbW9yeTtcblxudmFyIEFCT1JUID0gZmFsc2U7XG5cbnZhciBFWElUU1RBVFVTO1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCB0ZXh0KSB7XG4gaWYgKCFjb25kaXRpb24pIHtcbiAgYWJvcnQoXCJBc3NlcnRpb24gZmFpbGVkXCIgKyAodGV4dCA/IFwiOiBcIiArIHRleHQgOiBcIlwiKSk7XG4gfVxufVxuXG52YXIgSEVBUCwgSEVBUDgsIEhFQVBVOCwgSEVBUDE2LCBIRUFQVTE2LCBIRUFQMzIsIEhFQVBVMzIsIEhFQVBGMzIsIEhFQVBGNjQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCkge1xuIHZhciBiID0gd2FzbU1lbW9yeS5idWZmZXI7XG4gTW9kdWxlW1wiSEVBUDhcIl0gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUDE2XCJdID0gSEVBUDE2ID0gbmV3IEludDE2QXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUDMyXCJdID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUFU4XCJdID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUFUxNlwiXSA9IEhFQVBVMTYgPSBuZXcgVWludDE2QXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUFUzMlwiXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYik7XG4gTW9kdWxlW1wiSEVBUEYzMlwiXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGIpO1xuIE1vZHVsZVtcIkhFQVBGNjRcIl0gPSBIRUFQRjY0ID0gbmV3IEZsb2F0NjRBcnJheShiKTtcbn1cblxuYXNzZXJ0KCFNb2R1bGVbXCJTVEFDS19TSVpFXCJdLCBcIlNUQUNLX1NJWkUgY2FuIG5vIGxvbmdlciBiZSBzZXQgYXQgcnVudGltZS4gIFVzZSAtc1NUQUNLX1NJWkUgYXQgbGluayB0aW1lXCIpO1xuXG5hc3NlcnQodHlwZW9mIEludDMyQXJyYXkgIT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiICYmIEludDMyQXJyYXkucHJvdG90eXBlLnN1YmFycmF5ICE9IHVuZGVmaW5lZCAmJiBJbnQzMkFycmF5LnByb3RvdHlwZS5zZXQgIT0gdW5kZWZpbmVkLCBcIkpTIGVuZ2luZSBkb2VzIG5vdCBwcm92aWRlIGZ1bGwgdHlwZWQgYXJyYXkgc3VwcG9ydFwiKTtcblxuYXNzZXJ0KCFNb2R1bGVbXCJ3YXNtTWVtb3J5XCJdLCBcIlVzZSBvZiBgd2FzbU1lbW9yeWAgZGV0ZWN0ZWQuICBVc2UgLXNJTVBPUlRFRF9NRU1PUlkgdG8gZGVmaW5lIHdhc21NZW1vcnkgZXh0ZXJuYWxseVwiKTtcblxuYXNzZXJ0KCFNb2R1bGVbXCJJTklUSUFMX01FTU9SWVwiXSwgXCJEZXRlY3RlZCBydW50aW1lIElOSVRJQUxfTUVNT1JZIHNldHRpbmcuICBVc2UgLXNJTVBPUlRFRF9NRU1PUlkgdG8gZGVmaW5lIHdhc21NZW1vcnkgZHluYW1pY2FsbHlcIik7XG5cbnZhciB3YXNtVGFibGU7XG5cbmZ1bmN0aW9uIHdyaXRlU3RhY2tDb29raWUoKSB7XG4gdmFyIG1heCA9IF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQoKTtcbiBhc3NlcnQoKG1heCAmIDMpID09IDApO1xuIGlmIChtYXggPT0gMCkge1xuICBtYXggKz0gNDtcbiB9XG4gSEVBUFUzMlttYXggPj4+IDJdID0gMzQ4MjEyMjM7XG4gSEVBUFUzMlttYXggKyA0ID4+PiAyXSA9IDIzMTA3MjEwMjI7XG4gSEVBUFUzMlswID4+PiAyXSA9IDE2Njg1MDkwMjk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RhY2tDb29raWUoKSB7XG4gaWYgKEFCT1JUKSByZXR1cm47XG4gdmFyIG1heCA9IF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQoKTtcbiBpZiAobWF4ID09IDApIHtcbiAgbWF4ICs9IDQ7XG4gfVxuIHZhciBjb29raWUxID0gSEVBUFUzMlttYXggPj4+IDJdO1xuIHZhciBjb29raWUyID0gSEVBUFUzMlttYXggKyA0ID4+PiAyXTtcbiBpZiAoY29va2llMSAhPSAzNDgyMTIyMyB8fCBjb29raWUyICE9IDIzMTA3MjEwMjIpIHtcbiAgYWJvcnQoYFN0YWNrIG92ZXJmbG93ISBTdGFjayBjb29raWUgaGFzIGJlZW4gb3ZlcndyaXR0ZW4gYXQgJHtwdHJUb1N0cmluZyhtYXgpfSwgZXhwZWN0ZWQgaGV4IGR3b3JkcyAweDg5QkFDREZFIGFuZCAweDIxMzU0NjcsIGJ1dCByZWNlaXZlZCAke3B0clRvU3RyaW5nKGNvb2tpZTIpfSAke3B0clRvU3RyaW5nKGNvb2tpZTEpfWApO1xuIH1cbiBpZiAoSEVBUFUzMlswID4+PiAyXSAhPSAxNjY4NTA5MDI5KSB7XG4gIGFib3J0KFwiUnVudGltZSBlcnJvcjogVGhlIGFwcGxpY2F0aW9uIGhhcyBjb3JydXB0ZWQgaXRzIGhlYXAgbWVtb3J5IGFyZWEgKGFkZHJlc3MgemVybykhXCIpO1xuIH1cbn1cblxuKGZ1bmN0aW9uKCkge1xuIHZhciBoMTYgPSBuZXcgSW50MTZBcnJheSgxKTtcbiB2YXIgaDggPSBuZXcgSW50OEFycmF5KGgxNi5idWZmZXIpO1xuIGgxNlswXSA9IDI1NDU5O1xuIGlmIChoOFswXSAhPT0gMTE1IHx8IGg4WzFdICE9PSA5OSkgdGhyb3cgXCJSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hIChSdW4gd2l0aCAtc1NVUFBPUlRfQklHX0VORElBTiB0byBieXBhc3MpXCI7XG59KSgpO1xuXG52YXIgX19BVFBSRVJVTl9fID0gW107XG5cbnZhciBfX0FUSU5JVF9fID0gW107XG5cbnZhciBfX0FUTUFJTl9fID0gW107XG5cbnZhciBfX0FURVhJVF9fID0gW107XG5cbnZhciBfX0FUUE9TVFJVTl9fID0gW107XG5cbnZhciBydW50aW1lSW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxudmFyIHJ1bnRpbWVLZWVwYWxpdmVDb3VudGVyID0gMDtcblxuZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpIHtcbiByZXR1cm4gbm9FeGl0UnVudGltZSB8fCBydW50aW1lS2VlcGFsaXZlQ291bnRlciA+IDA7XG59XG5cbmZ1bmN0aW9uIHByZVJ1bigpIHtcbiBpZiAoTW9kdWxlW1wicHJlUnVuXCJdKSB7XG4gIGlmICh0eXBlb2YgTW9kdWxlW1wicHJlUnVuXCJdID09IFwiZnVuY3Rpb25cIikgTW9kdWxlW1wicHJlUnVuXCJdID0gWyBNb2R1bGVbXCJwcmVSdW5cIl0gXTtcbiAgd2hpbGUgKE1vZHVsZVtcInByZVJ1blwiXS5sZW5ndGgpIHtcbiAgIGFkZE9uUHJlUnVuKE1vZHVsZVtcInByZVJ1blwiXS5zaGlmdCgpKTtcbiAgfVxuIH1cbiBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pO1xufVxuXG5mdW5jdGlvbiBpbml0UnVudGltZSgpIHtcbiBhc3NlcnQoIXJ1bnRpbWVJbml0aWFsaXplZCk7XG4gcnVudGltZUluaXRpYWxpemVkID0gdHJ1ZTtcbiBjaGVja1N0YWNrQ29va2llKCk7XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVElOSVRfXyk7XG59XG5cbmZ1bmN0aW9uIHByZU1haW4oKSB7XG4gY2hlY2tTdGFja0Nvb2tpZSgpO1xuIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pO1xufVxuXG5mdW5jdGlvbiBwb3N0UnVuKCkge1xuIGNoZWNrU3RhY2tDb29raWUoKTtcbiBpZiAoTW9kdWxlW1wicG9zdFJ1blwiXSkge1xuICBpZiAodHlwZW9mIE1vZHVsZVtcInBvc3RSdW5cIl0gPT0gXCJmdW5jdGlvblwiKSBNb2R1bGVbXCJwb3N0UnVuXCJdID0gWyBNb2R1bGVbXCJwb3N0UnVuXCJdIF07XG4gIHdoaWxlIChNb2R1bGVbXCJwb3N0UnVuXCJdLmxlbmd0aCkge1xuICAgYWRkT25Qb3N0UnVuKE1vZHVsZVtcInBvc3RSdW5cIl0uc2hpZnQoKSk7XG4gIH1cbiB9XG4gY2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyk7XG59XG5cbmZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7XG4gX19BVFBSRVJVTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkluaXQoY2IpIHtcbiBfX0FUSU5JVF9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPblByZU1haW4oY2IpIHtcbiBfX0FUTUFJTl9fLnVuc2hpZnQoY2IpO1xufVxuXG5mdW5jdGlvbiBhZGRPbkV4aXQoY2IpIHt9XG5cbmZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xuIF9fQVRQT1NUUlVOX18udW5zaGlmdChjYik7XG59XG5cbmFzc2VydChNYXRoLmltdWwsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5pbXVsKCksIGJ1aWxkIHdpdGggTEVHQUNZX1ZNX1NVUFBPUlQgb3IgUE9MWUZJTExfT0xEX01BVEhfRlVOQ1RJT05TIHRvIGFkZCBpbiBhIHBvbHlmaWxsXCIpO1xuXG5hc3NlcnQoTWF0aC5mcm91bmQsIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTWF0aC5mcm91bmQoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGxcIik7XG5cbmFzc2VydChNYXRoLmNsejMyLCBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1hdGguY2x6MzIoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGxcIik7XG5cbmFzc2VydChNYXRoLnRydW5jLCBcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1hdGgudHJ1bmMoKSwgYnVpbGQgd2l0aCBMRUdBQ1lfVk1fU1VQUE9SVCBvciBQT0xZRklMTF9PTERfTUFUSF9GVU5DVElPTlMgdG8gYWRkIGluIGEgcG9seWZpbGxcIik7XG5cbnZhciBydW5EZXBlbmRlbmNpZXMgPSAwO1xuXG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xuXG52YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcblxudmFyIHJ1bkRlcGVuZGVuY3lUcmFja2luZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRVbmlxdWVSdW5EZXBlbmRlbmN5KGlkKSB7XG4gdmFyIG9yaWcgPSBpZDtcbiB3aGlsZSAoMSkge1xuICBpZiAoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pIHJldHVybiBpZDtcbiAgaWQgPSBvcmlnICsgTWF0aC5yYW5kb20oKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHtcbiBydW5EZXBlbmRlbmNpZXMrKztcbiBpZiAoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSkge1xuICBNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyk7XG4gfVxuIGlmIChpZCkge1xuICBhc3NlcnQoIXJ1bkRlcGVuZGVuY3lUcmFja2luZ1tpZF0pO1xuICBydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdID0gMTtcbiAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyID09PSBudWxsICYmIHR5cGVvZiBzZXRJbnRlcnZhbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBpZiAoQUJPUlQpIHtcbiAgICAgY2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7XG4gICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2hvd24gPSBmYWxzZTtcbiAgICBmb3IgKHZhciBkZXAgaW4gcnVuRGVwZW5kZW5jeVRyYWNraW5nKSB7XG4gICAgIGlmICghc2hvd24pIHtcbiAgICAgIHNob3duID0gdHJ1ZTtcbiAgICAgIGVycihcInN0aWxsIHdhaXRpbmcgb24gcnVuIGRlcGVuZGVuY2llczpcIik7XG4gICAgIH1cbiAgICAgZXJyKFwiZGVwZW5kZW5jeTogXCIgKyBkZXApO1xuICAgIH1cbiAgICBpZiAoc2hvd24pIHtcbiAgICAgZXJyKFwiKGVuZCBvZiBsaXN0KVwiKTtcbiAgICB9XG4gICB9LCAxZTQpO1xuICB9XG4gfSBlbHNlIHtcbiAgZXJyKFwid2FybmluZzogcnVuIGRlcGVuZGVuY3kgYWRkZWQgd2l0aG91dCBJRFwiKTtcbiB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiBydW5EZXBlbmRlbmNpZXMtLTtcbiBpZiAoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSkge1xuICBNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyk7XG4gfVxuIGlmIChpZCkge1xuICBhc3NlcnQocnVuRGVwZW5kZW5jeVRyYWNraW5nW2lkXSk7XG4gIGRlbGV0ZSBydW5EZXBlbmRlbmN5VHJhY2tpbmdbaWRdO1xuIH0gZWxzZSB7XG4gIGVycihcIndhcm5pbmc6IHJ1biBkZXBlbmRlbmN5IHJlbW92ZWQgd2l0aG91dCBJRFwiKTtcbiB9XG4gaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gIGlmIChydW5EZXBlbmRlbmN5V2F0Y2hlciAhPT0gbnVsbCkge1xuICAgY2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7XG4gICBydW5EZXBlbmRlbmN5V2F0Y2hlciA9IG51bGw7XG4gIH1cbiAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xuICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgIGNhbGxiYWNrKCk7XG4gIH1cbiB9XG59XG5cbmZ1bmN0aW9uIGFib3J0KHdoYXQpIHtcbiBpZiAoTW9kdWxlW1wib25BYm9ydFwiXSkge1xuICBNb2R1bGVbXCJvbkFib3J0XCJdKHdoYXQpO1xuIH1cbiB3aGF0ID0gXCJBYm9ydGVkKFwiICsgd2hhdCArIFwiKVwiO1xuIGVycih3aGF0KTtcbiBBQk9SVCA9IHRydWU7XG4gRVhJVFNUQVRVUyA9IDE7XG4gaWYgKHJ1bnRpbWVJbml0aWFsaXplZCkge1xuICBfX190cmFwKCk7XG4gfVxuIHZhciBlID0gbmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtcbiByZWFkeVByb21pc2VSZWplY3QoZSk7XG4gdGhyb3cgZTtcbn1cblxudmFyIGRhdGFVUklQcmVmaXggPSBcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIjtcblxuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7XG59XG5cbmZ1bmN0aW9uIGlzRmlsZVVSSShmaWxlbmFtZSkge1xuIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXhwb3J0V3JhcHBlcihuYW1lLCBmaXhlZGFzbSkge1xuIHJldHVybiBmdW5jdGlvbigpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gbmFtZTtcbiAgdmFyIGFzbSA9IGZpeGVkYXNtO1xuICBpZiAoIWZpeGVkYXNtKSB7XG4gICBhc20gPSBNb2R1bGVbXCJhc21cIl07XG4gIH1cbiAgYXNzZXJ0KHJ1bnRpbWVJbml0aWFsaXplZCwgXCJuYXRpdmUgZnVuY3Rpb24gYFwiICsgZGlzcGxheU5hbWUgKyBcImAgY2FsbGVkIGJlZm9yZSBydW50aW1lIGluaXRpYWxpemF0aW9uXCIpO1xuICBpZiAoIWFzbVtuYW1lXSkge1xuICAgYXNzZXJ0KGFzbVtuYW1lXSwgXCJleHBvcnRlZCBuYXRpdmUgZnVuY3Rpb24gYFwiICsgZGlzcGxheU5hbWUgKyBcImAgbm90IGZvdW5kXCIpO1xuICB9XG4gIHJldHVybiBhc21bbmFtZV0uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiB9O1xufVxuXG52YXIgd2FzbUJpbmFyeUZpbGU7XG5cbmlmIChNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKSB7XG4gd2FzbUJpbmFyeUZpbGUgPSBcIi4vZHVja2RiLWVoLndhc21cIjtcbiBpZiAoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpIHtcbiAgd2FzbUJpbmFyeUZpbGUgPSBsb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKTtcbiB9XG59IGVsc2Uge1xuIHdhc21CaW5hcnlGaWxlID0gbmV3IFVSTChcIi4vZHVja2RiLWVoLndhc21cIiwgaW1wb3J0Lm1ldGEudXJsKS5ocmVmO1xufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnkoZmlsZSkge1xuIHRyeSB7XG4gIGlmIChmaWxlID09IHdhc21CaW5hcnlGaWxlICYmIHdhc21CaW5hcnkpIHtcbiAgIHJldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KTtcbiAgfVxuICBpZiAocmVhZEJpbmFyeSkge1xuICAgcmV0dXJuIHJlYWRCaW5hcnkoZmlsZSk7XG4gIH1cbiAgdGhyb3cgXCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO1xuIH0gY2F0Y2ggKGVycikge1xuICBhYm9ydChlcnIpO1xuIH1cbn1cblxuZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKSB7XG4gaWYgKCF3YXNtQmluYXJ5ICYmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSkge1xuICBpZiAodHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIikge1xuICAgcmV0dXJuIGZldGNoKGJpbmFyeUZpbGUsIHtcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAoIXJlc3BvbnNlW1wib2tcIl0pIHtcbiAgICAgdGhyb3cgXCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIiArIGJpbmFyeUZpbGUgKyBcIidcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlW1wiYXJyYXlCdWZmZXJcIl0oKTtcbiAgIH0pLmNhdGNoKCgpID0+IGdldEJpbmFyeShiaW5hcnlGaWxlKSk7XG4gIH1cbiB9XG4gcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2V0QmluYXJ5KGJpbmFyeUZpbGUpKTtcbn1cblxuZnVuY3Rpb24gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLCBpbXBvcnRzLCByZWNlaXZlcikge1xuIHJldHVybiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpLnRoZW4oYmluYXJ5ID0+IHtcbiAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSwgaW1wb3J0cyk7XG4gfSkudGhlbihpbnN0YW5jZSA9PiB7XG4gIHJldHVybiBpbnN0YW5jZTtcbiB9KS50aGVuKHJlY2VpdmVyLCByZWFzb24gPT4ge1xuICBlcnIoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIiArIHJlYXNvbik7XG4gIGlmIChpc0ZpbGVVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gICBlcnIoXCJ3YXJuaW5nOiBMb2FkaW5nIGZyb20gYSBmaWxlIFVSSSAoXCIgKyB3YXNtQmluYXJ5RmlsZSArIFwiKSBpcyBub3Qgc3VwcG9ydGVkIGluIG1vc3QgYnJvd3NlcnMuIFNlZSBodHRwczovL2Vtc2NyaXB0ZW4ub3JnL2RvY3MvZ2V0dGluZ19zdGFydGVkL0ZBUS5odG1sI2hvdy1kby1pLXJ1bi1hLWxvY2FsLXdlYnNlcnZlci1mb3ItdGVzdGluZy13aHktZG9lcy1teS1wcm9ncmFtLXN0YWxsLWluLWRvd25sb2FkaW5nLW9yLXByZXBhcmluZ1wiKTtcbiAgfVxuICBhYm9ydChyZWFzb24pO1xuIH0pO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSwgYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spIHtcbiBpZiAoIWJpbmFyeSAmJiB0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcgPT0gXCJmdW5jdGlvblwiICYmICFpc0RhdGFVUkkoYmluYXJ5RmlsZSkgJiYgIUVOVklST05NRU5UX0lTX05PREUgJiYgdHlwZW9mIGZldGNoID09IFwiZnVuY3Rpb25cIikge1xuICByZXR1cm4gZmV0Y2goYmluYXJ5RmlsZSwge1xuICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICB9KS50aGVuKHJlc3BvbnNlID0+IHtcbiAgIHZhciByZXN1bHQgPSBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSwgaW1wb3J0cyk7XG4gICByZXR1cm4gcmVzdWx0LnRoZW4oY2FsbGJhY2ssIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGVycihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIiArIHJlYXNvbik7XG4gICAgZXJyKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIik7XG4gICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSwgaW1wb3J0cywgY2FsbGJhY2spO1xuICAgfSk7XG4gIH0pO1xuIH0gZWxzZSB7XG4gIHJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsIGltcG9ydHMsIGNhbGxiYWNrKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhc20oKSB7XG4gdmFyIGluZm8gPSB7XG4gIFwiZW52XCI6IHdhc21JbXBvcnRzLFxuICBcIndhc2lfc25hcHNob3RfcHJldmlldzFcIjogd2FzbUltcG9ydHNcbiB9O1xuIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7XG4gIHZhciBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0cztcbiAgTW9kdWxlW1wiYXNtXCJdID0gZXhwb3J0cztcbiAgd2FzbU1lbW9yeSA9IE1vZHVsZVtcImFzbVwiXVtcIm1lbW9yeVwiXTtcbiAgYXNzZXJ0KHdhc21NZW1vcnksIFwibWVtb3J5IG5vdCBmb3VuZCBpbiB3YXNtIGV4cG9ydHNcIik7XG4gIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gIHdhc21UYWJsZSA9IE1vZHVsZVtcImFzbVwiXVtcIl9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGVcIl07XG4gIGFzc2VydCh3YXNtVGFibGUsIFwidGFibGUgbm90IGZvdW5kIGluIHdhc20gZXhwb3J0c1wiKTtcbiAgYWRkT25Jbml0KE1vZHVsZVtcImFzbVwiXVtcIl9fd2FzbV9jYWxsX2N0b3JzXCJdKTtcbiAgcmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7XG4gIHJldHVybiBleHBvcnRzO1xuIH1cbiBhZGRSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtcbiB2YXIgdHJ1ZU1vZHVsZSA9IE1vZHVsZTtcbiBmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpIHtcbiAgYXNzZXJ0KE1vZHVsZSA9PT0gdHJ1ZU1vZHVsZSwgXCJ0aGUgTW9kdWxlIG9iamVjdCBzaG91bGQgbm90IGJlIHJlcGxhY2VkIGR1cmluZyBhc3luYyBjb21waWxhdGlvbiAtIHBlcmhhcHMgdGhlIG9yZGVyIG9mIEhUTUwgZWxlbWVudHMgaXMgd3Jvbmc/XCIpO1xuICB0cnVlTW9kdWxlID0gbnVsbDtcbiAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdKTtcbiB9XG4gaWYgKE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXSkge1xuICB0cnkge1xuICAgcmV0dXJuIE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICB9IGNhdGNoIChlKSB7XG4gICBlcnIoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIiArIGUpO1xuICAgcmVhZHlQcm9taXNlUmVqZWN0KGUpO1xuICB9XG4gfVxuIGluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSwgd2FzbUJpbmFyeUZpbGUsIGluZm8sIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO1xuIHJldHVybiB7fTtcbn1cblxudmFyIHRlbXBEb3VibGU7XG5cbnZhciB0ZW1wSTY0O1xuXG5mdW5jdGlvbiBsZWdhY3lNb2R1bGVQcm9wKHByb3AsIG5ld05hbWUpIHtcbiBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTW9kdWxlLCBwcm9wKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTW9kdWxlLCBwcm9wLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIGFib3J0KFwiTW9kdWxlLlwiICsgcHJvcCArIFwiIGhhcyBiZWVuIHJlcGxhY2VkIHdpdGggcGxhaW4gXCIgKyBuZXdOYW1lICsgXCIgKHRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBwcm92aWRlZCBvbiBNb2R1bGUsIGJ1dCBhZnRlciBzdGFydHVwIHRoZSB2YWx1ZSBpcyBvbmx5IGxvb2tlZCBmb3Igb24gYSBsb2NhbCB2YXJpYWJsZSBvZiB0aGF0IG5hbWUpXCIpO1xuICAgfVxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZWRNb2R1bGVQcm9wKHByb3ApIHtcbiBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHByb3ApKSB7XG4gIGFib3J0KFwiYE1vZHVsZS5cIiArIHByb3AgKyBcImAgd2FzIHN1cHBsaWVkIGJ1dCBgXCIgKyBwcm9wICsgXCJgIG5vdCBpbmNsdWRlZCBpbiBJTkNPTUlOR19NT0RVTEVfSlNfQVBJXCIpO1xuIH1cbn1cblxuZnVuY3Rpb24gaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKG5hbWUpIHtcbiByZXR1cm4gbmFtZSA9PT0gXCJGU19jcmVhdGVQYXRoXCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVEYXRhRmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfdW5saW5rXCIgfHwgbmFtZSA9PT0gXCJhZGRSdW5EZXBlbmRlbmN5XCIgfHwgbmFtZSA9PT0gXCJGU19jcmVhdGVMYXp5RmlsZVwiIHx8IG5hbWUgPT09IFwiRlNfY3JlYXRlRGV2aWNlXCIgfHwgbmFtZSA9PT0gXCJyZW1vdmVSdW5EZXBlbmRlbmN5XCI7XG59XG5cbmZ1bmN0aW9uIG1pc3NpbmdHbG9iYWwoc3ltLCBtc2cpIHtcbiBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIHN5bSwge1xuICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICB3YXJuT25jZShcImBcIiArIHN5bSArIFwiYCBpcyBub3QgbG9uZ2VyIGRlZmluZWQgYnkgZW1zY3JpcHRlbi4gXCIgKyBtc2cpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICB9XG4gIH0pO1xuIH1cbn1cblxubWlzc2luZ0dsb2JhbChcImJ1ZmZlclwiLCBcIlBsZWFzZSB1c2UgSEVBUDguYnVmZmVyIG9yIHdhc21NZW1vcnkuYnVmZmVyXCIpO1xuXG5mdW5jdGlvbiBtaXNzaW5nTGlicmFyeVN5bWJvbChzeW0pIHtcbiBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2xvYmFsVGhpcywgc3ltKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSBcImBcIiArIHN5bSArIFwiYCBpcyBhIGxpYnJhcnkgc3ltYm9sIGFuZCBub3QgaW5jbHVkZWQgYnkgZGVmYXVsdDsgYWRkIGl0IHRvIHlvdXIgbGlicmFyeS5qcyBfX2RlcHMgb3IgdG8gREVGQVVMVF9MSUJSQVJZX0ZVTkNTX1RPX0lOQ0xVREUgb24gdGhlIGNvbW1hbmQgbGluZVwiO1xuICAgIHZhciBsaWJyYXJ5U3ltYm9sID0gc3ltO1xuICAgIGlmICghbGlicmFyeVN5bWJvbC5zdGFydHNXaXRoKFwiX1wiKSkge1xuICAgICBsaWJyYXJ5U3ltYm9sID0gXCIkXCIgKyBzeW07XG4gICAgfVxuICAgIG1zZyArPSBcIiAoZS5nLiAtc0RFRkFVTFRfTElCUkFSWV9GVU5DU19UT19JTkNMVURFPVwiICsgbGlicmFyeVN5bWJvbCArIFwiKVwiO1xuICAgIGlmIChpc0V4cG9ydGVkQnlGb3JjZUZpbGVzeXN0ZW0oc3ltKSkge1xuICAgICBtc2cgKz0gXCIuIEFsdGVybmF0aXZlbHksIGZvcmNpbmcgZmlsZXN5c3RlbSBzdXBwb3J0ICgtc0ZPUkNFX0ZJTEVTWVNURU0pIGNhbiBleHBvcnQgdGhpcyBmb3IgeW91XCI7XG4gICAgfVxuICAgIHdhcm5PbmNlKG1zZyk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgIH1cbiAgfSk7XG4gfVxuIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSk7XG59XG5cbmZ1bmN0aW9uIHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKHN5bSkge1xuIGlmICghT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihNb2R1bGUsIHN5bSkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1vZHVsZSwgc3ltLCB7XG4gICBjb25maWd1cmFibGU6IHRydWUsXG4gICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtc2cgPSBcIidcIiArIHN5bSArIFwiJyB3YXMgbm90IGV4cG9ydGVkLiBhZGQgaXQgdG8gRVhQT1JURURfUlVOVElNRV9NRVRIT0RTIChzZWUgdGhlIEZBUSlcIjtcbiAgICBpZiAoaXNFeHBvcnRlZEJ5Rm9yY2VGaWxlc3lzdGVtKHN5bSkpIHtcbiAgICAgbXNnICs9IFwiLiBBbHRlcm5hdGl2ZWx5LCBmb3JjaW5nIGZpbGVzeXN0ZW0gc3VwcG9ydCAoLXNGT1JDRV9GSUxFU1lTVEVNKSBjYW4gZXhwb3J0IHRoaXMgZm9yIHlvdVwiO1xuICAgIH1cbiAgICBhYm9ydChtc2cpO1xuICAgfVxuICB9KTtcbiB9XG59XG5cbmZ1bmN0aW9uIGRiZyh0ZXh0KSB7XG4gY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIEV4aXRTdGF0dXMoc3RhdHVzKSB7XG4gdGhpcy5uYW1lID0gXCJFeGl0U3RhdHVzXCI7XG4gdGhpcy5tZXNzYWdlID0gYFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzdGF0dXN9KWA7XG4gdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG59XG5cbmZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICBjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpO1xuIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q3BwRXhjZXB0aW9uVGFnKCkge1xuIHJldHVybiBNb2R1bGVbXCJhc21cIl1bXCJfX2NwcF9leGNlcHRpb25cIl07XG59XG5cbmZ1bmN0aW9uIGdldENwcEV4Y2VwdGlvblRocm93bk9iamVjdEZyb21XZWJBc3NlbWJseUV4Y2VwdGlvbihleCkge1xuIHZhciB1bndpbmRfaGVhZGVyID0gZXguZ2V0QXJnKGdldENwcEV4Y2VwdGlvblRhZygpLCAwKTtcbiByZXR1cm4gX19fdGhyb3duX29iamVjdF9mcm9tX3Vud2luZF9leGNlcHRpb24odW53aW5kX2hlYWRlcik7XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudEV4Y2VwdGlvblJlZmNvdW50KGV4KSB7XG4gdmFyIHB0ciA9IGdldENwcEV4Y2VwdGlvblRocm93bk9iamVjdEZyb21XZWJBc3NlbWJseUV4Y2VwdGlvbihleCk7XG4gX19fY3hhX2RlY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQocHRyKTtcbn1cblxuZnVuY3Rpb24gd2l0aFN0YWNrU2F2ZShmKSB7XG4gdmFyIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gdmFyIHJldCA9IGYoKTtcbiBzdGFja1Jlc3RvcmUoc3RhY2spO1xuIHJldHVybiByZXQ7XG59XG5cbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPSBcInVuZGVmaW5lZFwiID8gbmV3IFRleHREZWNvZGVyKFwidXRmOFwiKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcoaGVhcE9yQXJyYXksIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiBpZHggPj4+PSAwO1xuIHZhciBlbmRJZHggPSBpZHggKyBtYXhCeXRlc1RvUmVhZDtcbiB2YXIgZW5kUHRyID0gaWR4O1xuIHdoaWxlIChoZWFwT3JBcnJheVtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuIGlmIChlbmRQdHIgLSBpZHggPiAxNiAmJiBoZWFwT3JBcnJheS5idWZmZXIgJiYgVVRGOERlY29kZXIpIHtcbiAgcmV0dXJuIFVURjhEZWNvZGVyLmRlY29kZShoZWFwT3JBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuIH1cbiB2YXIgc3RyID0gXCJcIjtcbiB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gIHZhciB1MCA9IGhlYXBPckFycmF5W2lkeCsrXTtcbiAgaWYgKCEodTAgJiAxMjgpKSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICBjb250aW51ZTtcbiAgfVxuICB2YXIgdTEgPSBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgaWYgKCh1MCAmIDIyNCkgPT0gMTkyKSB7XG4gICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgodTAgJiAzMSkgPDwgNiB8IHUxKTtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciB1MiA9IGhlYXBPckFycmF5W2lkeCsrXSAmIDYzO1xuICBpZiAoKHUwICYgMjQwKSA9PSAyMjQpIHtcbiAgIHUwID0gKHUwICYgMTUpIDw8IDEyIHwgdTEgPDwgNiB8IHUyO1xuICB9IGVsc2Uge1xuICAgaWYgKCh1MCAmIDI0OCkgIT0gMjQwKSB3YXJuT25jZShcIkludmFsaWQgVVRGLTggbGVhZGluZyBieXRlIFwiICsgcHRyVG9TdHJpbmcodTApICsgXCIgZW5jb3VudGVyZWQgd2hlbiBkZXNlcmlhbGl6aW5nIGEgVVRGLTggc3RyaW5nIGluIHdhc20gbWVtb3J5IHRvIGEgSlMgc3RyaW5nIVwiKTtcbiAgIHUwID0gKHUwICYgNykgPDwgMTggfCB1MSA8PCAxMiB8IHUyIDw8IDYgfCBoZWFwT3JBcnJheVtpZHgrK10gJiA2MztcbiAgfVxuICBpZiAodTAgPCA2NTUzNikge1xuICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApO1xuICB9IGVsc2Uge1xuICAgdmFyIGNoID0gdTAgLSA2NTUzNjtcbiAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgY2ggPj4gMTAsIDU2MzIwIHwgY2ggJiAxMDIzKTtcbiAgfVxuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBVVEY4VG9TdHJpbmcocHRyLCBtYXhCeXRlc1RvUmVhZCkge1xuIGFzc2VydCh0eXBlb2YgcHRyID09IFwibnVtYmVyXCIpO1xuIHB0ciA+Pj49IDA7XG4gcmV0dXJuIHB0ciA/IFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyLCBtYXhCeXRlc1RvUmVhZCkgOiBcIlwiO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNlcHRpb25NZXNzYWdlQ29tbW9uKHB0cikge1xuIHJldHVybiB3aXRoU3RhY2tTYXZlKGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZV9hZGRyX2FkZHIgPSBzdGFja0FsbG9jKDQpO1xuICB2YXIgbWVzc2FnZV9hZGRyX2FkZHIgPSBzdGFja0FsbG9jKDQpO1xuICBfX19nZXRfZXhjZXB0aW9uX21lc3NhZ2UocHRyLCB0eXBlX2FkZHJfYWRkciwgbWVzc2FnZV9hZGRyX2FkZHIpO1xuICB2YXIgdHlwZV9hZGRyID0gSEVBUFUzMlt0eXBlX2FkZHJfYWRkciA+Pj4gMl07XG4gIHZhciBtZXNzYWdlX2FkZHIgPSBIRUFQVTMyW21lc3NhZ2VfYWRkcl9hZGRyID4+PiAyXTtcbiAgdmFyIHR5cGUgPSBVVEY4VG9TdHJpbmcodHlwZV9hZGRyKTtcbiAgX2ZyZWUodHlwZV9hZGRyKTtcbiAgdmFyIG1lc3NhZ2U7XG4gIGlmIChtZXNzYWdlX2FkZHIpIHtcbiAgIG1lc3NhZ2UgPSBVVEY4VG9TdHJpbmcobWVzc2FnZV9hZGRyKTtcbiAgIF9mcmVlKG1lc3NhZ2VfYWRkcik7XG4gIH1cbiAgcmV0dXJuIFsgdHlwZSwgbWVzc2FnZSBdO1xuIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNlcHRpb25NZXNzYWdlKGV4KSB7XG4gdmFyIHB0ciA9IGdldENwcEV4Y2VwdGlvblRocm93bk9iamVjdEZyb21XZWJBc3NlbWJseUV4Y2VwdGlvbihleCk7XG4gcmV0dXJuIGdldEV4Y2VwdGlvbk1lc3NhZ2VDb21tb24ocHRyKTtcbn1cblxuTW9kdWxlW1wiZ2V0RXhjZXB0aW9uTWVzc2FnZVwiXSA9IGdldEV4Y2VwdGlvbk1lc3NhZ2U7XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHB0ciwgdHlwZSA9IFwiaThcIikge1xuIGlmICh0eXBlLmVuZHNXaXRoKFwiKlwiKSkgdHlwZSA9IFwiKlwiO1xuIHN3aXRjaCAodHlwZSkge1xuIGNhc2UgXCJpMVwiOlxuICByZXR1cm4gSEVBUDhbcHRyID4+PiAwXTtcblxuIGNhc2UgXCJpOFwiOlxuICByZXR1cm4gSEVBUDhbcHRyID4+PiAwXTtcblxuIGNhc2UgXCJpMTZcIjpcbiAgcmV0dXJuIEhFQVAxNltwdHIgPj4+IDFdO1xuXG4gY2FzZSBcImkzMlwiOlxuICByZXR1cm4gSEVBUDMyW3B0ciA+Pj4gMl07XG5cbiBjYXNlIFwiaTY0XCI6XG4gIGFib3J0KFwidG8gZG8gZ2V0VmFsdWUoaTY0KSB1c2UgV0FTTV9CSUdJTlRcIik7XG5cbiBjYXNlIFwiZmxvYXRcIjpcbiAgcmV0dXJuIEhFQVBGMzJbcHRyID4+PiAyXTtcblxuIGNhc2UgXCJkb3VibGVcIjpcbiAgcmV0dXJuIEhFQVBGNjRbcHRyID4+PiAzXTtcblxuIGNhc2UgXCIqXCI6XG4gIHJldHVybiBIRUFQVTMyW3B0ciA+Pj4gMl07XG5cbiBkZWZhdWx0OlxuICBhYm9ydChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHt0eXBlfWApO1xuIH1cbn1cblxuZnVuY3Rpb24gaW5jcmVtZW50RXhjZXB0aW9uUmVmY291bnQoZXgpIHtcbiB2YXIgcHRyID0gZ2V0Q3BwRXhjZXB0aW9uVGhyb3duT2JqZWN0RnJvbVdlYkFzc2VtYmx5RXhjZXB0aW9uKGV4KTtcbiBfX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudChwdHIpO1xufVxuXG5mdW5jdGlvbiBwdHJUb1N0cmluZyhwdHIpIHtcbiBhc3NlcnQodHlwZW9mIHB0ciA9PT0gXCJudW1iZXJcIik7XG4gcmV0dXJuIFwiMHhcIiArIHB0ci50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZShwdHIsIHZhbHVlLCB0eXBlID0gXCJpOFwiKSB7XG4gaWYgKHR5cGUuZW5kc1dpdGgoXCIqXCIpKSB0eXBlID0gXCIqXCI7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSBcImkxXCI6XG4gIEhFQVA4W3B0ciA+Pj4gMF0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaThcIjpcbiAgSEVBUDhbcHRyID4+PiAwXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJpMTZcIjpcbiAgSEVBUDE2W3B0ciA+Pj4gMV0gPSB2YWx1ZTtcbiAgYnJlYWs7XG5cbiBjYXNlIFwiaTMyXCI6XG4gIEhFQVAzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcImk2NFwiOlxuICBhYm9ydChcInRvIGRvIHNldFZhbHVlKGk2NCkgdXNlIFdBU01fQklHSU5UXCIpO1xuXG4gY2FzZSBcImZsb2F0XCI6XG4gIEhFQVBGMzJbcHRyID4+PiAyXSA9IHZhbHVlO1xuICBicmVhaztcblxuIGNhc2UgXCJkb3VibGVcIjpcbiAgSEVBUEY2NFtwdHIgPj4+IDNdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gY2FzZSBcIipcIjpcbiAgSEVBUFUzMltwdHIgPj4+IDJdID0gdmFsdWU7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgYWJvcnQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7dHlwZX1gKTtcbiB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbmNlKHRleHQpIHtcbiBpZiAoIXdhcm5PbmNlLnNob3duKSB3YXJuT25jZS5zaG93biA9IHt9O1xuIGlmICghd2Fybk9uY2Uuc2hvd25bdGV4dF0pIHtcbiAgd2Fybk9uY2Uuc2hvd25bdGV4dF0gPSAxO1xuICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkgdGV4dCA9IFwid2FybmluZzogXCIgKyB0ZXh0O1xuICBlcnIodGV4dCk7XG4gfVxufVxuXG5mdW5jdGlvbiBfWE1MX0dldEJ1ZmZlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfR2V0QnVmZmVyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9HZXRFcnJvckNvZGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX0dldEVycm9yQ29kZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfUGFyc2UoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1BhcnNlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZUJ1ZmZlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VCdWZmZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1BhcnNlckNyZWF0ZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfUGFyc2VyQ3JlYXRlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9QYXJzZXJGcmVlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9QYXJzZXJGcmVlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9SZXN1bWVQYXJzZXIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1Jlc3VtZVBhcnNlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXIoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX1hNTF9TZXRFbGVtZW50SGFuZGxlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU2V0RWxlbWVudEhhbmRsZXJcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfWE1MX1NldFVzZXJEYXRhKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IFhNTF9TZXRVc2VyRGF0YVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9YTUxfU3RvcFBhcnNlcigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiBYTUxfU3RvcFBhcnNlclwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9fX2Fzc2VydF9mYWlsKGNvbmRpdGlvbiwgZmlsZW5hbWUsIGxpbmUsIGZ1bmMpIHtcbiBhYm9ydChgQXNzZXJ0aW9uIGZhaWxlZDogJHtVVEY4VG9TdHJpbmcoY29uZGl0aW9uKX0sIGF0OiBgICsgWyBmaWxlbmFtZSA/IFVURjhUb1N0cmluZyhmaWxlbmFtZSkgOiBcInVua25vd24gZmlsZW5hbWVcIiwgbGluZSwgZnVuYyA/IFVURjhUb1N0cmluZyhmdW5jKSA6IFwidW5rbm93biBmdW5jdGlvblwiIF0pO1xufVxuXG52YXIgZGxvcGVuTWlzc2luZ0Vycm9yID0gXCJUbyB1c2UgZGxvcGVuLCB5b3UgbmVlZCBlbmFibGUgZHluYW1pYyBsaW5raW5nLCBzZWUgaHR0cHM6Ly9lbXNjcmlwdGVuLm9yZy9kb2NzL2NvbXBpbGluZy9EeW5hbWljLUxpbmtpbmcuaHRtbFwiO1xuXG5mdW5jdGlvbiBfX19kbHN5bShoYW5kbGUsIHN5bWJvbCwgcmEpIHtcbiBhYm9ydChkbG9wZW5NaXNzaW5nRXJyb3IpO1xufVxuXG52YXIgU1lTQ0FMTFMgPSB7XG4gdmFyYXJnczogdW5kZWZpbmVkLFxuIGdldDogZnVuY3Rpb24oKSB7XG4gIGFzc2VydChTWVNDQUxMUy52YXJhcmdzICE9IHVuZGVmaW5lZCk7XG4gIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgdmFyIHJldCA9IEhFQVAzMltTWVNDQUxMUy52YXJhcmdzIC0gNCA+Pj4gMl07XG4gIHJldHVybiByZXQ7XG4gfSxcbiBnZXRTdHI6IGZ1bmN0aW9uKHB0cikge1xuICB2YXIgcmV0ID0gVVRGOFRvU3RyaW5nKHB0cik7XG4gIHJldHVybiByZXQ7XG4gfVxufTtcblxuZnVuY3Rpb24gX19fc3lzY2FsbF9fbmV3c2VsZWN0KG5mZHMsIHJlYWRmZHMsIHdyaXRlZmRzLCBleGNlcHRmZHMsIHRpbWVvdXQpIHtcbiBhc3NlcnQobmZkcyA8PSA2NCwgXCJuZmRzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDY0XCIpO1xuIGFzc2VydCghZXhjZXB0ZmRzLCBcImV4Y2VwdGZkcyBub3Qgc3VwcG9ydGVkXCIpO1xuIHZhciB0b3RhbCA9IDA7XG4gdmFyIHNyY1JlYWRMb3cgPSByZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgPj4+IDJdIDogMCwgc3JjUmVhZEhpZ2ggPSByZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIHNyY1dyaXRlTG93ID0gd3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdIDogMCwgc3JjV3JpdGVIaWdoID0gd3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIHNyY0V4Y2VwdExvdyA9IGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgPj4+IDJdIDogMCwgc3JjRXhjZXB0SGlnaCA9IGV4Y2VwdGZkcyA/IEhFQVAzMltleGNlcHRmZHMgKyA0ID4+PiAyXSA6IDA7XG4gdmFyIGRzdFJlYWRMb3cgPSAwLCBkc3RSZWFkSGlnaCA9IDA7XG4gdmFyIGRzdFdyaXRlTG93ID0gMCwgZHN0V3JpdGVIaWdoID0gMDtcbiB2YXIgZHN0RXhjZXB0TG93ID0gMCwgZHN0RXhjZXB0SGlnaCA9IDA7XG4gdmFyIGFsbExvdyA9IChyZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgPj4+IDJdIDogMCkgfCAod3JpdGVmZHMgPyBIRUFQMzJbd3JpdGVmZHMgPj4+IDJdIDogMCkgfCAoZXhjZXB0ZmRzID8gSEVBUDMyW2V4Y2VwdGZkcyA+Pj4gMl0gOiAwKTtcbiB2YXIgYWxsSGlnaCA9IChyZWFkZmRzID8gSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA6IDApIHwgKHdyaXRlZmRzID8gSEVBUDMyW3dyaXRlZmRzICsgNCA+Pj4gMl0gOiAwKSB8IChleGNlcHRmZHMgPyBIRUFQMzJbZXhjZXB0ZmRzICsgNCA+Pj4gMl0gOiAwKTtcbiB2YXIgY2hlY2sgPSBmdW5jdGlvbihmZCwgbG93LCBoaWdoLCB2YWwpIHtcbiAgcmV0dXJuIGZkIDwgMzIgPyBsb3cgJiB2YWwgOiBoaWdoICYgdmFsO1xuIH07XG4gZm9yICh2YXIgZmQgPSAwOyBmZCA8IG5mZHM7IGZkKyspIHtcbiAgdmFyIG1hc2sgPSAxIDw8IGZkICUgMzI7XG4gIGlmICghY2hlY2soZmQsIGFsbExvdywgYWxsSGlnaCwgbWFzaykpIHtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICB2YXIgZmxhZ3MgPSBTWVNDQUxMUy5ERUZBVUxUX1BPTExNQVNLO1xuICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMucG9sbCkge1xuICAgZmxhZ3MgPSBzdHJlYW0uc3RyZWFtX29wcy5wb2xsKHN0cmVhbSk7XG4gIH1cbiAgaWYgKGZsYWdzICYgMSAmJiBjaGVjayhmZCwgc3JjUmVhZExvdywgc3JjUmVhZEhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0UmVhZExvdyA9IGRzdFJlYWRMb3cgfCBtYXNrIDogZHN0UmVhZEhpZ2ggPSBkc3RSZWFkSGlnaCB8IG1hc2s7XG4gICB0b3RhbCsrO1xuICB9XG4gIGlmIChmbGFncyAmIDQgJiYgY2hlY2soZmQsIHNyY1dyaXRlTG93LCBzcmNXcml0ZUhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0V3JpdGVMb3cgPSBkc3RXcml0ZUxvdyB8IG1hc2sgOiBkc3RXcml0ZUhpZ2ggPSBkc3RXcml0ZUhpZ2ggfCBtYXNrO1xuICAgdG90YWwrKztcbiAgfVxuICBpZiAoZmxhZ3MgJiAyICYmIGNoZWNrKGZkLCBzcmNFeGNlcHRMb3csIHNyY0V4Y2VwdEhpZ2gsIG1hc2spKSB7XG4gICBmZCA8IDMyID8gZHN0RXhjZXB0TG93ID0gZHN0RXhjZXB0TG93IHwgbWFzayA6IGRzdEV4Y2VwdEhpZ2ggPSBkc3RFeGNlcHRIaWdoIHwgbWFzaztcbiAgIHRvdGFsKys7XG4gIH1cbiB9XG4gaWYgKHJlYWRmZHMpIHtcbiAgSEVBUDMyW3JlYWRmZHMgPj4+IDJdID0gZHN0UmVhZExvdztcbiAgSEVBUDMyW3JlYWRmZHMgKyA0ID4+PiAyXSA9IGRzdFJlYWRIaWdoO1xuIH1cbiBpZiAod3JpdGVmZHMpIHtcbiAgSEVBUDMyW3dyaXRlZmRzID4+PiAyXSA9IGRzdFdyaXRlTG93O1xuICBIRUFQMzJbd3JpdGVmZHMgKyA0ID4+PiAyXSA9IGRzdFdyaXRlSGlnaDtcbiB9XG4gaWYgKGV4Y2VwdGZkcykge1xuICBIRUFQMzJbZXhjZXB0ZmRzID4+PiAyXSA9IGRzdEV4Y2VwdExvdztcbiAgSEVBUDMyW2V4Y2VwdGZkcyArIDQgPj4+IDJdID0gZHN0RXhjZXB0SGlnaDtcbiB9XG4gcmV0dXJuIHRvdGFsO1xufVxuXG5mdW5jdGlvbiBTT0NLRlMoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogJFNPQ0tGU1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIEZTKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246ICRGU1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvY2tldEZyb21GRChmZCkge1xuIHZhciBzb2NrZXQgPSBTT0NLRlMuZ2V0U29ja2V0KGZkKTtcbiBpZiAoIXNvY2tldCkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gcmV0dXJuIHNvY2tldDtcbn1cblxuZnVuY3Rpb24gc2V0RXJyTm8odmFsdWUpIHtcbiBIRUFQMzJbX19fZXJybm9fbG9jYXRpb24oKSA+Pj4gMl0gPSB2YWx1ZTtcbiByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBTb2NrZXRzID0ge1xuIEJVRkZFUl9TSVpFOiAxMDI0MCxcbiBNQVhfQlVGRkVSX1NJWkU6IDEwNDg1NzYwLFxuIG5leHRGZDogMSxcbiBmZHM6IHt9LFxuIG5leHRwb3J0OiAxLFxuIG1heHBvcnQ6IDY1NTM1LFxuIHBlZXI6IG51bGwsXG4gY29ubmVjdGlvbnM6IHt9LFxuIHBvcnRtYXA6IHt9LFxuIGxvY2FsQWRkcjogNDI2MTQxMjg3NCxcbiBhZGRyUG9vbDogWyAzMzU1NDQ0MiwgNTAzMzE2NTgsIDY3MTA4ODc0LCA4Mzg4NjA5MCwgMTAwNjYzMzA2LCAxMTc0NDA1MjIsIDEzNDIxNzczOCwgMTUwOTk0OTU0LCAxNjc3NzIxNzAsIDE4NDU0OTM4NiwgMjAxMzI2NjAyLCAyMTgxMDM4MTgsIDIzNDg4MTAzNCBdXG59O1xuXG5mdW5jdGlvbiBpbmV0TnRvcDQoYWRkcikge1xuIHJldHVybiAoYWRkciAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDggJiAyNTUpICsgXCIuXCIgKyAoYWRkciA+PiAxNiAmIDI1NSkgKyBcIi5cIiArIChhZGRyID4+IDI0ICYgMjU1KTtcbn1cblxuZnVuY3Rpb24gaW5ldE50b3A2KGludHMpIHtcbiB2YXIgc3RyID0gXCJcIjtcbiB2YXIgd29yZCA9IDA7XG4gdmFyIGxvbmdlc3QgPSAwO1xuIHZhciBsYXN0emVybyA9IDA7XG4gdmFyIHpzdGFydCA9IDA7XG4gdmFyIGxlbiA9IDA7XG4gdmFyIGkgPSAwO1xuIHZhciBwYXJ0cyA9IFsgaW50c1swXSAmIDY1NTM1LCBpbnRzWzBdID4+IDE2LCBpbnRzWzFdICYgNjU1MzUsIGludHNbMV0gPj4gMTYsIGludHNbMl0gJiA2NTUzNSwgaW50c1syXSA+PiAxNiwgaW50c1szXSAmIDY1NTM1LCBpbnRzWzNdID4+IDE2IF07XG4gdmFyIGhhc2lwdjQgPSB0cnVlO1xuIHZhciB2NHBhcnQgPSBcIlwiO1xuIGZvciAoaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgaWYgKHBhcnRzW2ldICE9PSAwKSB7XG4gICBoYXNpcHY0ID0gZmFsc2U7XG4gICBicmVhaztcbiAgfVxuIH1cbiBpZiAoaGFzaXB2NCkge1xuICB2NHBhcnQgPSBpbmV0TnRvcDQocGFydHNbNl0gfCBwYXJ0c1s3XSA8PCAxNik7XG4gIGlmIChwYXJ0c1s1XSA9PT0gLTEpIHtcbiAgIHN0ciA9IFwiOjpmZmZmOlwiO1xuICAgc3RyICs9IHY0cGFydDtcbiAgIHJldHVybiBzdHI7XG4gIH1cbiAgaWYgKHBhcnRzWzVdID09PSAwKSB7XG4gICBzdHIgPSBcIjo6XCI7XG4gICBpZiAodjRwYXJ0ID09PSBcIjAuMC4wLjBcIikgdjRwYXJ0ID0gXCJcIjtcbiAgIGlmICh2NHBhcnQgPT09IFwiMC4wLjAuMVwiKSB2NHBhcnQgPSBcIjFcIjtcbiAgIHN0ciArPSB2NHBhcnQ7XG4gICByZXR1cm4gc3RyO1xuICB9XG4gfVxuIGZvciAod29yZCA9IDA7IHdvcmQgPCA4OyB3b3JkKyspIHtcbiAgaWYgKHBhcnRzW3dvcmRdID09PSAwKSB7XG4gICBpZiAod29yZCAtIGxhc3R6ZXJvID4gMSkge1xuICAgIGxlbiA9IDA7XG4gICB9XG4gICBsYXN0emVybyA9IHdvcmQ7XG4gICBsZW4rKztcbiAgfVxuICBpZiAobGVuID4gbG9uZ2VzdCkge1xuICAgbG9uZ2VzdCA9IGxlbjtcbiAgIHpzdGFydCA9IHdvcmQgLSBsb25nZXN0ICsgMTtcbiAgfVxuIH1cbiBmb3IgKHdvcmQgPSAwOyB3b3JkIDwgODsgd29yZCsrKSB7XG4gIGlmIChsb25nZXN0ID4gMSkge1xuICAgaWYgKHBhcnRzW3dvcmRdID09PSAwICYmIHdvcmQgPj0genN0YXJ0ICYmIHdvcmQgPCB6c3RhcnQgKyBsb25nZXN0KSB7XG4gICAgaWYgKHdvcmQgPT09IHpzdGFydCkge1xuICAgICBzdHIgKz0gXCI6XCI7XG4gICAgIGlmICh6c3RhcnQgPT09IDApIHN0ciArPSBcIjpcIjtcbiAgICB9XG4gICAgY29udGludWU7XG4gICB9XG4gIH1cbiAgc3RyICs9IE51bWJlcihfbnRvaHMocGFydHNbd29yZF0gJiA2NTUzNSkpLnRvU3RyaW5nKDE2KTtcbiAgc3RyICs9IHdvcmQgPCA3ID8gXCI6XCIgOiBcIlwiO1xuIH1cbiByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiByZWFkU29ja2FkZHIoc2EsIHNhbGVuKSB7XG4gdmFyIGZhbWlseSA9IEhFQVAxNltzYSA+Pj4gMV07XG4gdmFyIHBvcnQgPSBfbnRvaHMoSEVBUFUxNltzYSArIDIgPj4+IDFdKTtcbiB2YXIgYWRkcjtcbiBzd2l0Y2ggKGZhbWlseSkge1xuIGNhc2UgMjpcbiAgaWYgKHNhbGVuICE9PSAxNikge1xuICAgcmV0dXJuIHtcbiAgICBlcnJubzogMjhcbiAgIH07XG4gIH1cbiAgYWRkciA9IEhFQVAzMltzYSArIDQgPj4+IDJdO1xuICBhZGRyID0gaW5ldE50b3A0KGFkZHIpO1xuICBicmVhaztcblxuIGNhc2UgMTA6XG4gIGlmIChzYWxlbiAhPT0gMjgpIHtcbiAgIHJldHVybiB7XG4gICAgZXJybm86IDI4XG4gICB9O1xuICB9XG4gIGFkZHIgPSBbIEhFQVAzMltzYSArIDggPj4+IDJdLCBIRUFQMzJbc2EgKyAxMiA+Pj4gMl0sIEhFQVAzMltzYSArIDE2ID4+PiAyXSwgSEVBUDMyW3NhICsgMjAgPj4+IDJdIF07XG4gIGFkZHIgPSBpbmV0TnRvcDYoYWRkcik7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgcmV0dXJuIHtcbiAgIGVycm5vOiA1XG4gIH07XG4gfVxuIHJldHVybiB7XG4gIGZhbWlseTogZmFtaWx5LFxuICBhZGRyOiBhZGRyLFxuICBwb3J0OiBwb3J0XG4gfTtcbn1cblxuZnVuY3Rpb24gaW5ldFB0b240KHN0cikge1xuIHZhciBiID0gc3RyLnNwbGl0KFwiLlwiKTtcbiBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICB2YXIgdG1wID0gTnVtYmVyKGJbaV0pO1xuICBpZiAoaXNOYU4odG1wKSkgcmV0dXJuIG51bGw7XG4gIGJbaV0gPSB0bXA7XG4gfVxuIHJldHVybiAoYlswXSB8IGJbMV0gPDwgOCB8IGJbMl0gPDwgMTYgfCBiWzNdIDw8IDI0KSA+Pj4gMDtcbn1cblxuZnVuY3Rpb24ganN0b2lfcShzdHIpIHtcbiByZXR1cm4gcGFyc2VJbnQoc3RyKTtcbn1cblxuZnVuY3Rpb24gaW5ldFB0b242KHN0cikge1xuIHZhciB3b3JkcztcbiB2YXIgdywgb2Zmc2V0LCB6LCBpO1xuIHZhciB2YWxpZDZyZWd4ID0gL14oKD89Lio6OikoPyEuKjo6Lis6OikoOjopPyhbXFxkQS1GXXsxLDR9Oig6fFxcYil8KXs1fXwoW1xcZEEtRl17MSw0fTopezZ9KSgoKFtcXGRBLUZdezEsNH0oKD8hXFwzKTo6fDpcXGJ8JCkpfCg/IVxcMlxcMykpezJ9fCgoKDJbMC00XXwxXFxkfFsxLTldKT9cXGR8MjVbMC01XSlcXC4/XFxiKXs0fSkkL2k7XG4gdmFyIHBhcnRzID0gW107XG4gaWYgKCF2YWxpZDZyZWd4LnRlc3Qoc3RyKSkge1xuICByZXR1cm4gbnVsbDtcbiB9XG4gaWYgKHN0ciA9PT0gXCI6OlwiKSB7XG4gIHJldHVybiBbIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAgXTtcbiB9XG4gaWYgKHN0ci5zdGFydHNXaXRoKFwiOjpcIikpIHtcbiAgc3RyID0gc3RyLnJlcGxhY2UoXCI6OlwiLCBcIlo6XCIpO1xuIH0gZWxzZSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKFwiOjpcIiwgXCI6WjpcIik7XG4gfVxuIGlmIChzdHIuaW5kZXhPZihcIi5cIikgPiAwKSB7XG4gIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbLl1cIiwgXCJnXCIpLCBcIjpcIik7XG4gIHdvcmRzID0gc3RyLnNwbGl0KFwiOlwiKTtcbiAgd29yZHNbd29yZHMubGVuZ3RoIC0gNF0gPSBqc3RvaV9xKHdvcmRzW3dvcmRzLmxlbmd0aCAtIDRdKSArIGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gM10pICogMjU2O1xuICB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAzXSA9IGpzdG9pX3Eod29yZHNbd29yZHMubGVuZ3RoIC0gMl0pICsganN0b2lfcSh3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXSkgKiAyNTY7XG4gIHdvcmRzID0gd29yZHMuc2xpY2UoMCwgd29yZHMubGVuZ3RoIC0gMik7XG4gfSBlbHNlIHtcbiAgd29yZHMgPSBzdHIuc3BsaXQoXCI6XCIpO1xuIH1cbiBvZmZzZXQgPSAwO1xuIHogPSAwO1xuIGZvciAodyA9IDA7IHcgPCB3b3Jkcy5sZW5ndGg7IHcrKykge1xuICBpZiAodHlwZW9mIHdvcmRzW3ddID09IFwic3RyaW5nXCIpIHtcbiAgIGlmICh3b3Jkc1t3XSA9PT0gXCJaXCIpIHtcbiAgICBmb3IgKHogPSAwOyB6IDwgOCAtIHdvcmRzLmxlbmd0aCArIDE7IHorKykge1xuICAgICBwYXJ0c1t3ICsgel0gPSAwO1xuICAgIH1cbiAgICBvZmZzZXQgPSB6IC0gMTtcbiAgIH0gZWxzZSB7XG4gICAgcGFydHNbdyArIG9mZnNldF0gPSBfaHRvbnMocGFyc2VJbnQod29yZHNbd10sIDE2KSk7XG4gICB9XG4gIH0gZWxzZSB7XG4gICBwYXJ0c1t3ICsgb2Zmc2V0XSA9IHdvcmRzW3ddO1xuICB9XG4gfVxuIHJldHVybiBbIHBhcnRzWzFdIDw8IDE2IHwgcGFydHNbMF0sIHBhcnRzWzNdIDw8IDE2IHwgcGFydHNbMl0sIHBhcnRzWzVdIDw8IDE2IHwgcGFydHNbNF0sIHBhcnRzWzddIDw8IDE2IHwgcGFydHNbNl0gXTtcbn1cblxudmFyIEROUyA9IHtcbiBhZGRyZXNzX21hcDoge1xuICBpZDogMSxcbiAgYWRkcnM6IHt9LFxuICBuYW1lczoge31cbiB9LFxuIGxvb2t1cF9uYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciByZXMgPSBpbmV0UHRvbjQobmFtZSk7XG4gIGlmIChyZXMgIT09IG51bGwpIHtcbiAgIHJldHVybiBuYW1lO1xuICB9XG4gIHJlcyA9IGluZXRQdG9uNihuYW1lKTtcbiAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgdmFyIGFkZHI7XG4gIGlmIChETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV0pIHtcbiAgIGFkZHIgPSBETlMuYWRkcmVzc19tYXAuYWRkcnNbbmFtZV07XG4gIH0gZWxzZSB7XG4gICB2YXIgaWQgPSBETlMuYWRkcmVzc19tYXAuaWQrKztcbiAgIGFzc2VydChpZCA8IDY1NTM1LCBcImV4Y2VlZGVkIG1heCBhZGRyZXNzIG1hcHBpbmdzIG9mIDY1NTM1XCIpO1xuICAgYWRkciA9IFwiMTcyLjI5LlwiICsgKGlkICYgMjU1KSArIFwiLlwiICsgKGlkICYgNjUyODApO1xuICAgRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdID0gbmFtZTtcbiAgIEROUy5hZGRyZXNzX21hcC5hZGRyc1tuYW1lXSA9IGFkZHI7XG4gIH1cbiAgcmV0dXJuIGFkZHI7XG4gfSxcbiBsb29rdXBfYWRkcjogZnVuY3Rpb24oYWRkcikge1xuICBpZiAoRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdKSB7XG4gICByZXR1cm4gRE5TLmFkZHJlc3NfbWFwLm5hbWVzW2FkZHJdO1xuICB9XG4gIHJldHVybiBudWxsO1xuIH1cbn07XG5cbmZ1bmN0aW9uIGdldFNvY2tldEFkZHJlc3MoYWRkcnAsIGFkZHJsZW4sIGFsbG93TnVsbCkge1xuIGlmIChhbGxvd051bGwgJiYgYWRkcnAgPT09IDApIHJldHVybiBudWxsO1xuIHZhciBpbmZvID0gcmVhZFNvY2thZGRyKGFkZHJwLCBhZGRybGVuKTtcbiBpZiAoaW5mby5lcnJubykgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoaW5mby5lcnJubyk7XG4gaW5mby5hZGRyID0gRE5TLmxvb2t1cF9hZGRyKGluZm8uYWRkcikgfHwgaW5mby5hZGRyO1xuIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2JpbmQoZmQsIGFkZHIsIGFkZHJsZW4sIGQxLCBkMiwgZDMpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gdmFyIGluZm8gPSBnZXRTb2NrZXRBZGRyZXNzKGFkZHIsIGFkZHJsZW4pO1xuIHNvY2suc29ja19vcHMuYmluZChzb2NrLCBpbmZvLmFkZHIsIGluZm8ucG9ydCk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfY29ubmVjdChmZCwgYWRkciwgYWRkcmxlbiwgZDEsIGQyLCBkMykge1xuIHZhciBzb2NrID0gZ2V0U29ja2V0RnJvbUZEKGZkKTtcbiB2YXIgaW5mbyA9IGdldFNvY2tldEFkZHJlc3MoYWRkciwgYWRkcmxlbik7XG4gc29jay5zb2NrX29wcy5jb25uZWN0KHNvY2ssIGluZm8uYWRkciwgaW5mby5wb3J0KTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9mYWNjZXNzYXQoZGlyZmQsIHBhdGgsIGFtb2RlLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZjbnRsNjQoZmQsIGNtZCwgdmFyYXJncykge1xuIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2ZzdGF0NjQoZmQsIGJ1Zikge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZChsbywgaGkpIHtcbiBhc3NlcnQobG8gPT0gbG8gPj4+IDAgfHwgbG8gPT0gKGxvIHwgMCkpO1xuIGFzc2VydChoaSA9PT0gKGhpIHwgMCkpO1xuIHJldHVybiBoaSArIDIwOTcxNTIgPj4+IDAgPCA0MTk0MzA1IC0gISFsbyA/IChsbyA+Pj4gMCkgKyBoaSAqIDQyOTQ5NjcyOTYgOiBOYU47XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfZnRydW5jYXRlNjQoZmQsIGxlbmd0aF9sb3csIGxlbmd0aF9oaWdoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOEFycmF5KHN0ciwgaGVhcCwgb3V0SWR4LCBtYXhCeXRlc1RvV3JpdGUpIHtcbiBvdXRJZHggPj4+PSAwO1xuIGFzc2VydCh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiKTtcbiBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDA7XG4gdmFyIHN0YXJ0SWR4ID0gb3V0SWR4O1xuIHZhciBlbmRJZHggPSBvdXRJZHggKyBtYXhCeXRlc1RvV3JpdGUgLSAxO1xuIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gIHZhciB1ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHtcbiAgIHZhciB1MSA9IHN0ci5jaGFyQ29kZUF0KCsraSk7XG4gICB1ID0gNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkgfCB1MSAmIDEwMjM7XG4gIH1cbiAgaWYgKHUgPD0gMTI3KSB7XG4gICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IHU7XG4gIH0gZWxzZSBpZiAodSA8PSAyMDQ3KSB7XG4gICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxOTIgfCB1ID4+IDY7XG4gICBoZWFwW291dElkeCsrID4+PiAwXSA9IDEyOCB8IHUgJiA2MztcbiAgfSBlbHNlIGlmICh1IDw9IDY1NTM1KSB7XG4gICBpZiAob3V0SWR4ICsgMiA+PSBlbmRJZHgpIGJyZWFrO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAyMjQgfCB1ID4+IDEyO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9IGVsc2Uge1xuICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgIGlmICh1ID4gMTExNDExMSkgd2Fybk9uY2UoXCJJbnZhbGlkIFVuaWNvZGUgY29kZSBwb2ludCBcIiArIHB0clRvU3RyaW5nKHUpICsgXCIgZW5jb3VudGVyZWQgd2hlbiBzZXJpYWxpemluZyBhIEpTIHN0cmluZyB0byBhIFVURi04IHN0cmluZyBpbiB3YXNtIG1lbW9yeSEgKFZhbGlkIHVuaWNvZGUgY29kZSBwb2ludHMgc2hvdWxkIGJlIGluIHJhbmdlIDAtMHgxMEZGRkYpLlwiKTtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMjQwIHwgdSA+PiAxODtcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSA+PiAxMiAmIDYzO1xuICAgaGVhcFtvdXRJZHgrKyA+Pj4gMF0gPSAxMjggfCB1ID4+IDYgJiA2MztcbiAgIGhlYXBbb3V0SWR4KysgPj4+IDBdID0gMTI4IHwgdSAmIDYzO1xuICB9XG4gfVxuIGhlYXBbb3V0SWR4ID4+PiAwXSA9IDA7XG4gcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4O1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuIGFzc2VydCh0eXBlb2YgbWF4Qnl0ZXNUb1dyaXRlID09IFwibnVtYmVyXCIsIFwic3RyaW5nVG9VVEY4KHN0ciwgb3V0UHRyLCBtYXhCeXRlc1RvV3JpdGUpIGlzIG1pc3NpbmcgdGhlIHRoaXJkIHBhcmFtZXRlciB0aGF0IHNwZWNpZmllcyB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgYnVmZmVyIVwiKTtcbiByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9nZXRkZW50czY0KGZkLCBkaXJwLCBjb3VudCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiB6ZXJvTWVtb3J5KGFkZHJlc3MsIHNpemUpIHtcbiBIRUFQVTguZmlsbCgwLCBhZGRyZXNzLCBhZGRyZXNzICsgc2l6ZSk7XG4gcmV0dXJuIGFkZHJlc3M7XG59XG5cbmZ1bmN0aW9uIHdyaXRlU29ja2FkZHIoc2EsIGZhbWlseSwgYWRkciwgcG9ydCwgYWRkcmxlbikge1xuIHN3aXRjaCAoZmFtaWx5KSB7XG4gY2FzZSAyOlxuICBhZGRyID0gaW5ldFB0b240KGFkZHIpO1xuICB6ZXJvTWVtb3J5KHNhLCAxNik7XG4gIGlmIChhZGRybGVuKSB7XG4gICBIRUFQMzJbYWRkcmxlbiA+Pj4gMl0gPSAxNjtcbiAgfVxuICBIRUFQMTZbc2EgPj4+IDFdID0gZmFtaWx5O1xuICBIRUFQMzJbc2EgKyA0ID4+PiAyXSA9IGFkZHI7XG4gIEhFQVAxNltzYSArIDIgPj4+IDFdID0gX2h0b25zKHBvcnQpO1xuICBicmVhaztcblxuIGNhc2UgMTA6XG4gIGFkZHIgPSBpbmV0UHRvbjYoYWRkcik7XG4gIHplcm9NZW1vcnkoc2EsIDI4KTtcbiAgaWYgKGFkZHJsZW4pIHtcbiAgIEhFQVAzMlthZGRybGVuID4+PiAyXSA9IDI4O1xuICB9XG4gIEhFQVAzMltzYSA+Pj4gMl0gPSBmYW1pbHk7XG4gIEhFQVAzMltzYSArIDggPj4+IDJdID0gYWRkclswXTtcbiAgSEVBUDMyW3NhICsgMTIgPj4+IDJdID0gYWRkclsxXTtcbiAgSEVBUDMyW3NhICsgMTYgPj4+IDJdID0gYWRkclsyXTtcbiAgSEVBUDMyW3NhICsgMjAgPj4+IDJdID0gYWRkclszXTtcbiAgSEVBUDE2W3NhICsgMiA+Pj4gMV0gPSBfaHRvbnMocG9ydCk7XG4gIGJyZWFrO1xuXG4gZGVmYXVsdDpcbiAgcmV0dXJuIDU7XG4gfVxuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldHBlZXJuYW1lKGZkLCBhZGRyLCBhZGRybGVuLCBkMSwgZDIsIGQzKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIGlmICghc29jay5kYWRkcikge1xuICByZXR1cm4gLTUzO1xuIH1cbiB2YXIgZXJybm8gPSB3cml0ZVNvY2thZGRyKGFkZHIsIHNvY2suZmFtaWx5LCBETlMubG9va3VwX25hbWUoc29jay5kYWRkciksIHNvY2suZHBvcnQsIGFkZHJsZW4pO1xuIGFzc2VydCghZXJybm8pO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX2dldHNvY2tvcHQoZmQsIGxldmVsLCBvcHRuYW1lLCBvcHR2YWwsIG9wdGxlbiwgZDEpIHtcbiB2YXIgc29jayA9IGdldFNvY2tldEZyb21GRChmZCk7XG4gaWYgKGxldmVsID09PSAxKSB7XG4gIGlmIChvcHRuYW1lID09PSA0KSB7XG4gICBIRUFQMzJbb3B0dmFsID4+PiAyXSA9IHNvY2suZXJyb3I7XG4gICBIRUFQMzJbb3B0bGVuID4+PiAyXSA9IDQ7XG4gICBzb2NrLmVycm9yID0gbnVsbDtcbiAgIHJldHVybiAwO1xuICB9XG4gfVxuIHJldHVybiAtNTA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfaW9jdGwoZmQsIG9wLCB2YXJhcmdzKSB7XG4gU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfbHN0YXQ2NChwYXRoLCBidWYpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9ta2RpcmF0KGRpcmZkLCBwYXRoLCBtb2RlKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfbmV3ZnN0YXRhdChkaXJmZCwgcGF0aCwgYnVmLCBmbGFncykge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX29wZW5hdChkaXJmZCwgcGF0aCwgZmxhZ3MsIHZhcmFyZ3MpIHtcbiBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJncztcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9yZWN2ZnJvbShmZCwgYnVmLCBsZW4sIGZsYWdzLCBhZGRyLCBhZGRybGVuKSB7XG4gdmFyIHNvY2sgPSBnZXRTb2NrZXRGcm9tRkQoZmQpO1xuIHZhciBtc2cgPSBzb2NrLnNvY2tfb3BzLnJlY3Ztc2coc29jaywgbGVuKTtcbiBpZiAoIW1zZykgcmV0dXJuIDA7XG4gaWYgKGFkZHIpIHtcbiAgdmFyIGVycm5vID0gd3JpdGVTb2NrYWRkcihhZGRyLCBzb2NrLmZhbWlseSwgRE5TLmxvb2t1cF9uYW1lKG1zZy5hZGRyKSwgbXNnLnBvcnQsIGFkZHJsZW4pO1xuICBhc3NlcnQoIWVycm5vKTtcbiB9XG4gSEVBUFU4LnNldChtc2cuYnVmZmVyLCBidWYgPj4+IDApO1xuIHJldHVybiBtc2cuYnVmZmVyLmJ5dGVMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfcmVuYW1lYXQob2xkZGlyZmQsIG9sZHBhdGgsIG5ld2RpcmZkLCBuZXdwYXRoKSB7XG4gYWJvcnQoXCJpdCBzaG91bGQgbm90IGJlIHBvc3NpYmxlIHRvIG9wZXJhdGUgb24gc3RyZWFtcyB3aGVuICFTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9fX3N5c2NhbGxfcm1kaXIocGF0aCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3NlbmR0byhmZCwgbWVzc2FnZSwgbGVuZ3RoLCBmbGFncywgYWRkciwgYWRkcl9sZW4pIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF9zb2NrZXQoZG9tYWluLCB0eXBlLCBwcm90b2NvbCkge1xuIGFib3J0KFwiaXQgc2hvdWxkIG5vdCBiZSBwb3NzaWJsZSB0byBvcGVyYXRlIG9uIHN0cmVhbXMgd2hlbiAhU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG5mdW5jdGlvbiBfX19zeXNjYWxsX3N0YXQ2NChwYXRoLCBidWYpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fc3lzY2FsbF91bmxpbmthdChkaXJmZCwgcGF0aCwgZmxhZ3MpIHtcbiBhYm9ydChcIml0IHNob3VsZCBub3QgYmUgcG9zc2libGUgdG8gb3BlcmF0ZSBvbiBzdHJlYW1zIHdoZW4gIVNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX19fdGhyb3dfZXhjZXB0aW9uX3dpdGhfc3RhY2tfdHJhY2UoZXgpIHtcbiB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5FeGNlcHRpb24oZ2V0Q3BwRXhjZXB0aW9uVGFnKCksIFsgZXggXSwge1xuICB0cmFjZVN0YWNrOiB0cnVlXG4gfSk7XG4gZS5tZXNzYWdlID0gZ2V0RXhjZXB0aW9uTWVzc2FnZShlKTtcbiBpZiAoZS5zdGFjaykge1xuICB2YXIgYXJyID0gZS5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgYXJyLnNwbGljZSgxLCAxKTtcbiAgZS5zdGFjayA9IGFyci5qb2luKFwiXFxuXCIpO1xuIH1cbiB0aHJvdyBlO1xufVxuXG52YXIgbm93SXNNb25vdG9uaWMgPSB0cnVlO1xuXG5mdW5jdGlvbiBfX2Vtc2NyaXB0ZW5fZ2V0X25vd19pc19tb25vdG9uaWMoKSB7XG4gcmV0dXJuIG5vd0lzTW9ub3RvbmljO1xufVxuXG5mdW5jdGlvbiByZWFkSTUzRnJvbUk2NChwdHIpIHtcbiByZXR1cm4gSEVBUFUzMltwdHIgPj4+IDJdICsgSEVBUDMyW3B0ciArIDQgPj4+IDJdICogNDI5NDk2NzI5Njtcbn1cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApO1xufVxuXG52YXIgTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkUgPSBbIDAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1IF07XG5cbnZhciBNT05USF9EQVlTX1JFR1VMQVJfQ1VNVUxBVElWRSA9IFsgMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQgXTtcblxuZnVuY3Rpb24geWRheUZyb21EYXRlKGRhdGUpIHtcbiB2YXIgbGVhcCA9IGlzTGVhcFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcbiB2YXIgbW9udGhEYXlzQ3VtdWxhdGl2ZSA9IGxlYXAgPyBNT05USF9EQVlTX0xFQVBfQ1VNVUxBVElWRSA6IE1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFO1xuIHZhciB5ZGF5ID0gbW9udGhEYXlzQ3VtdWxhdGl2ZVtkYXRlLmdldE1vbnRoKCldICsgZGF0ZS5nZXREYXRlKCkgLSAxO1xuIHJldHVybiB5ZGF5O1xufVxuXG5mdW5jdGlvbiBfX2xvY2FsdGltZV9qcyh0aW1lLCB0bVB0cikge1xuIHZhciBkYXRlID0gbmV3IERhdGUocmVhZEk1M0Zyb21JNjQodGltZSkgKiAxZTMpO1xuIEhFQVAzMlt0bVB0ciA+Pj4gMl0gPSBkYXRlLmdldFNlY29uZHMoKTtcbiBIRUFQMzJbdG1QdHIgKyA0ID4+PiAyXSA9IGRhdGUuZ2V0TWludXRlcygpO1xuIEhFQVAzMlt0bVB0ciArIDggPj4+IDJdID0gZGF0ZS5nZXRIb3VycygpO1xuIEhFQVAzMlt0bVB0ciArIDEyID4+PiAyXSA9IGRhdGUuZ2V0RGF0ZSgpO1xuIEhFQVAzMlt0bVB0ciArIDE2ID4+PiAyXSA9IGRhdGUuZ2V0TW9udGgoKTtcbiBIRUFQMzJbdG1QdHIgKyAyMCA+Pj4gMl0gPSBkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTAwO1xuIEhFQVAzMlt0bVB0ciArIDI0ID4+PiAyXSA9IGRhdGUuZ2V0RGF5KCk7XG4gdmFyIHlkYXkgPSB5ZGF5RnJvbURhdGUoZGF0ZSkgfCAwO1xuIEhFQVAzMlt0bVB0ciArIDI4ID4+PiAyXSA9IHlkYXk7XG4gSEVBUDMyW3RtUHRyICsgMzYgPj4+IDJdID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7XG4gdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiB2YXIgc3VtbWVyT2Zmc2V0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCA2LCAxKS5nZXRUaW1lem9uZU9mZnNldCgpO1xuIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpO1xuIHZhciBkc3QgPSAoc3VtbWVyT2Zmc2V0ICE9IHdpbnRlck9mZnNldCAmJiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT0gTWF0aC5taW4od2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpKSB8IDA7XG4gSEVBUDMyW3RtUHRyICsgMzIgPj4+IDJdID0gZHN0O1xufVxuXG5mdW5jdGlvbiBsZW5ndGhCeXRlc1VURjgoc3RyKSB7XG4gdmFyIGxlbiA9IDA7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgaWYgKGMgPD0gMTI3KSB7XG4gICBsZW4rKztcbiAgfSBlbHNlIGlmIChjIDw9IDIwNDcpIHtcbiAgIGxlbiArPSAyO1xuICB9IGVsc2UgaWYgKGMgPj0gNTUyOTYgJiYgYyA8PSA1NzM0Mykge1xuICAgbGVuICs9IDQ7XG4gICArK2k7XG4gIH0gZWxzZSB7XG4gICBsZW4gKz0gMztcbiAgfVxuIH1cbiByZXR1cm4gbGVuO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb05ld1VURjgoc3RyKSB7XG4gdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7XG4gdmFyIHJldCA9IF9tYWxsb2Moc2l6ZSk7XG4gaWYgKHJldCkgc3RyaW5nVG9VVEY4KHN0ciwgcmV0LCBzaXplKTtcbiByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBfX3R6c2V0X2pzKHRpbWV6b25lLCBkYXlsaWdodCwgdHpuYW1lKSB7XG4gdmFyIGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuIHZhciB3aW50ZXIgPSBuZXcgRGF0ZShjdXJyZW50WWVhciwgMCwgMSk7XG4gdmFyIHN1bW1lciA9IG5ldyBEYXRlKGN1cnJlbnRZZWFyLCA2LCAxKTtcbiB2YXIgd2ludGVyT2Zmc2V0ID0gd2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gdmFyIHN1bW1lck9mZnNldCA9IHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpO1xuIHZhciBzdGRUaW1lem9uZU9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTtcbiBIRUFQVTMyW3RpbWV6b25lID4+PiAyXSA9IHN0ZFRpbWV6b25lT2Zmc2V0ICogNjA7XG4gSEVBUDMyW2RheWxpZ2h0ID4+PiAyXSA9IE51bWJlcih3aW50ZXJPZmZzZXQgIT0gc3VtbWVyT2Zmc2V0KTtcbiBmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKSB7XG4gIHZhciBtYXRjaCA9IGRhdGUudG9UaW1lU3RyaW5nKCkubWF0Y2goL1xcKChbQS1aYS16IF0rKVxcKSQvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiBcIkdNVFwiO1xuIH1cbiB2YXIgd2ludGVyTmFtZSA9IGV4dHJhY3Rab25lKHdpbnRlcik7XG4gdmFyIHN1bW1lck5hbWUgPSBleHRyYWN0Wm9uZShzdW1tZXIpO1xuIHZhciB3aW50ZXJOYW1lUHRyID0gc3RyaW5nVG9OZXdVVEY4KHdpbnRlck5hbWUpO1xuIHZhciBzdW1tZXJOYW1lUHRyID0gc3RyaW5nVG9OZXdVVEY4KHN1bW1lck5hbWUpO1xuIGlmIChzdW1tZXJPZmZzZXQgPCB3aW50ZXJPZmZzZXQpIHtcbiAgSEVBUFUzMlt0em5hbWUgPj4+IDJdID0gd2ludGVyTmFtZVB0cjtcbiAgSEVBUFUzMlt0em5hbWUgKyA0ID4+PiAyXSA9IHN1bW1lck5hbWVQdHI7XG4gfSBlbHNlIHtcbiAgSEVBUFUzMlt0em5hbWUgPj4+IDJdID0gc3VtbWVyTmFtZVB0cjtcbiAgSEVBUFUzMlt0em5hbWUgKyA0ID4+PiAyXSA9IHdpbnRlck5hbWVQdHI7XG4gfVxufVxuXG5mdW5jdGlvbiBfYWJvcnQoKSB7XG4gYWJvcnQoXCJuYXRpdmUgY29kZSBjYWxsZWQgYWJvcnQoKVwiKTtcbn1cblxuZnVuY3Rpb24gX2Rsb3BlbihmaWxlbmFtZSwgZmxhZ3MpIHtcbiBhYm9ydChkbG9wZW5NaXNzaW5nRXJyb3IpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfY3JlYXRlKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jcmVhdGVEaXJlY3RvcnkoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0cyhwYXRoLCBwYXRoTGVuKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2hlY2tEaXJlY3RvcnkoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2xpc3RfZmlsZXMocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmxpc3REaXJlY3RvcnlFbnRyaWVzKE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9yZW1vdmUocGF0aCwgcGF0aExlbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnJlbW92ZURpcmVjdG9yeShNb2R1bGUsIHBhdGgsIHBhdGhMZW4pO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX2Nsb3NlKGZpbGVJZCkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmNsb3NlRmlsZShNb2R1bGUsIGZpbGVJZCk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZXhpc3RzKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5jaGVja0ZpbGUoTW9kdWxlLCBwYXRoLCBwYXRoTGVuKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9nZXRfbGFzdF9tb2RpZmllZF90aW1lKGZpbGVJZCkge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLmdldExhc3RGaWxlTW9kaWZpY2F0aW9uVGltZShNb2R1bGUsIGZpbGVJZCk7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfbW92ZShmcm9tLCBmcm9tTGVuLCB0bywgdG9MZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5tb3ZlRmlsZShNb2R1bGUsIGZyb20sIGZyb21MZW4sIHRvLCB0b0xlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2ZpbGVfb3BlbihmaWxlSWQsIGZsYWdzKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUub3BlbkZpbGUoTW9kdWxlLCBmaWxlSWQsIGZsYWdzKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkKGZpbGVJZCwgYnVmLCBzaXplLCBsb2NhdGlvbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLnJlYWRGaWxlKE1vZHVsZSwgZmlsZUlkLCBidWYsIHNpemUsIGxvY2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gX2R1Y2tkYl93ZWJfZnNfZmlsZV90cnVuY2F0ZShmaWxlSWQsIG5ld1NpemUpIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS50cnVuY2F0ZUZpbGUoTW9kdWxlLCBmaWxlSWQsIG5ld1NpemUpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19maWxlX3dyaXRlKGZpbGVJZCwgYnVmLCBzaXplLCBsb2NhdGlvbikge1xuIHJldHVybiBnbG9iYWxUaGlzLkRVQ0tEQl9SVU5USU1FLndyaXRlRmlsZShNb2R1bGUsIGZpbGVJZCwgYnVmLCBzaXplLCBsb2NhdGlvbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX2ZzX2dldF9kZWZhdWx0X2RhdGFfcHJvdG9jb2woTW9kdWxlKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuZ2V0RGVmYXVsdERhdGFQcm90b2NvbChNb2R1bGUpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl9mc19nbG9iKHBhdGgsIHBhdGhMZW4pIHtcbiByZXR1cm4gZ2xvYmFsVGhpcy5EVUNLREJfUlVOVElNRS5nbG9iKE1vZHVsZSwgcGF0aCwgcGF0aExlbik7XG59XG5cbmZ1bmN0aW9uIF9kdWNrZGJfd2ViX3Rlc3RfcGxhdGZvcm1fZmVhdHVyZShmZWF0dXJlKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUudGVzdFBsYXRmb3JtRmVhdHVyZShNb2R1bGUsIGZlYXR1cmUpO1xufVxuXG5mdW5jdGlvbiBfZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGwoZnVuY0lkLCBkZXNjUHRyLCBkZXNjU2l6ZSwgcHRyc1B0ciwgcHRyc1NpemUsIHJlc3BvbnNlKSB7XG4gcmV0dXJuIGdsb2JhbFRoaXMuRFVDS0RCX1JVTlRJTUUuY2FsbFNjYWxhclVERihNb2R1bGUsIGZ1bmNJZCwgZGVzY1B0ciwgZGVzY1NpemUsIHB0cnNQdHIsIHB0cnNTaXplLCByZXNwb25zZSk7XG59XG5cbmZ1bmN0aW9uIF9lbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3Ioc3RyKSB7XG4gYXNzZXJ0KHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIik7XG4gY29uc29sZS5lcnJvcihVVEY4VG9TdHJpbmcoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIF9lbXNjcmlwdGVuX2RhdGVfbm93KCkge1xuIHJldHVybiBEYXRlLm5vdygpO1xufVxuXG5mdW5jdGlvbiBnZXRIZWFwTWF4KCkge1xuIHJldHVybiA0Mjk0OTAxNzYwO1xufVxuXG5mdW5jdGlvbiBfZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXgoKSB7XG4gcmV0dXJuIGdldEhlYXBNYXgoKTtcbn1cblxudmFyIF9lbXNjcmlwdGVuX2dldF9ub3c7XG5cbmlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gZ2xvYmFsLnBlcmZvcm1hbmNlID0gcmVxdWlyZShcInBlcmZfaG9va3NcIikucGVyZm9ybWFuY2U7XG59XG5cbl9lbXNjcmlwdGVuX2dldF9ub3cgPSAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKTtcblxuZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyhkZXN0LCBzcmMsIG51bSkge1xuIEhFQVBVOC5jb3B5V2l0aGluKGRlc3QgPj4+IDAsIHNyYyA+Pj4gMCwgc3JjICsgbnVtID4+PiAwKTtcbn1cblxuZnVuY3Rpb24gZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlcihzaXplKSB7XG4gdmFyIGIgPSB3YXNtTWVtb3J5LmJ1ZmZlcjtcbiB2YXIgcGFnZXMgPSBzaXplIC0gYi5ieXRlTGVuZ3RoICsgNjU1MzUgPj4+IDE2O1xuIHRyeSB7XG4gIHdhc21NZW1vcnkuZ3JvdyhwYWdlcyk7XG4gIHVwZGF0ZU1lbW9yeVZpZXdzKCk7XG4gIHJldHVybiAxO1xuIH0gY2F0Y2ggKGUpIHtcbiAgZXJyKGBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyOiBBdHRlbXB0ZWQgdG8gZ3JvdyBoZWFwIGZyb20gJHtiLmJ5dGVMZW5ndGh9IGJ5dGVzIHRvICR7c2l6ZX0gYnl0ZXMsIGJ1dCBnb3QgZXJyb3I6ICR7ZX1gKTtcbiB9XG59XG5cbmZ1bmN0aW9uIF9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwKHJlcXVlc3RlZFNpemUpIHtcbiB2YXIgb2xkU2l6ZSA9IEhFQVBVOC5sZW5ndGg7XG4gcmVxdWVzdGVkU2l6ZSA9IHJlcXVlc3RlZFNpemUgPj4+IDA7XG4gYXNzZXJ0KHJlcXVlc3RlZFNpemUgPiBvbGRTaXplKTtcbiB2YXIgbWF4SGVhcFNpemUgPSBnZXRIZWFwTWF4KCk7XG4gaWYgKHJlcXVlc3RlZFNpemUgPiBtYXhIZWFwU2l6ZSkge1xuICBlcnIoYENhbm5vdCBlbmxhcmdlIG1lbW9yeSwgYXNrZWQgdG8gZ28gdXAgdG8gJHtyZXF1ZXN0ZWRTaXplfSBieXRlcywgYnV0IHRoZSBsaW1pdCBpcyAke21heEhlYXBTaXplfSBieXRlcyFgKTtcbiAgcmV0dXJuIGZhbHNlO1xuIH1cbiB2YXIgYWxpZ25VcCA9ICh4LCBtdWx0aXBsZSkgPT4geCArIChtdWx0aXBsZSAtIHggJSBtdWx0aXBsZSkgJSBtdWx0aXBsZTtcbiBmb3IgKHZhciBjdXREb3duID0gMTsgY3V0RG93biA8PSA0OyBjdXREb3duICo9IDIpIHtcbiAgdmFyIG92ZXJHcm93bkhlYXBTaXplID0gb2xkU2l6ZSAqICgxICsgLjIgLyBjdXREb3duKTtcbiAgb3Zlckdyb3duSGVhcFNpemUgPSBNYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSwgcmVxdWVzdGVkU2l6ZSArIDEwMDY2MzI5Nik7XG4gIHZhciBuZXdTaXplID0gTWF0aC5taW4obWF4SGVhcFNpemUsIGFsaWduVXAoTWF0aC5tYXgocmVxdWVzdGVkU2l6ZSwgb3Zlckdyb3duSGVhcFNpemUpLCA2NTUzNikpO1xuICB2YXIgcmVwbGFjZW1lbnQgPSBlbXNjcmlwdGVuX3JlYWxsb2NfYnVmZmVyKG5ld1NpemUpO1xuICBpZiAocmVwbGFjZW1lbnQpIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gfVxuIGVycihgRmFpbGVkIHRvIGdyb3cgdGhlIGhlYXAgZnJvbSAke29sZFNpemV9IGJ5dGVzIHRvICR7bmV3U2l6ZX0gYnl0ZXMsIG5vdCBlbm91Z2ggbWVtb3J5IWApO1xuIHJldHVybiBmYWxzZTtcbn1cblxudmFyIEVOViA9IHt9O1xuXG5mdW5jdGlvbiBnZXRFeGVjdXRhYmxlTmFtZSgpIHtcbiByZXR1cm4gdGhpc1Byb2dyYW0gfHwgXCIuL3RoaXMucHJvZ3JhbVwiO1xufVxuXG5mdW5jdGlvbiBnZXRFbnZTdHJpbmdzKCkge1xuIGlmICghZ2V0RW52U3RyaW5ncy5zdHJpbmdzKSB7XG4gIHZhciBsYW5nID0gKHR5cGVvZiBuYXZpZ2F0b3IgPT0gXCJvYmplY3RcIiAmJiBuYXZpZ2F0b3IubGFuZ3VhZ2VzICYmIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgXCJDXCIpLnJlcGxhY2UoXCItXCIsIFwiX1wiKSArIFwiLlVURi04XCI7XG4gIHZhciBlbnYgPSB7XG4gICBcIlVTRVJcIjogXCJ3ZWJfdXNlclwiLFxuICAgXCJMT0dOQU1FXCI6IFwid2ViX3VzZXJcIixcbiAgIFwiUEFUSFwiOiBcIi9cIixcbiAgIFwiUFdEXCI6IFwiL1wiLFxuICAgXCJIT01FXCI6IFwiL2hvbWUvd2ViX3VzZXJcIixcbiAgIFwiTEFOR1wiOiBsYW5nLFxuICAgXCJfXCI6IGdldEV4ZWN1dGFibGVOYW1lKClcbiAgfTtcbiAgZm9yICh2YXIgeCBpbiBFTlYpIHtcbiAgIGlmIChFTlZbeF0gPT09IHVuZGVmaW5lZCkgZGVsZXRlIGVudlt4XTsgZWxzZSBlbnZbeF0gPSBFTlZbeF07XG4gIH1cbiAgdmFyIHN0cmluZ3MgPSBbXTtcbiAgZm9yICh2YXIgeCBpbiBlbnYpIHtcbiAgIHN0cmluZ3MucHVzaChgJHt4fT0ke2Vudlt4XX1gKTtcbiAgfVxuICBnZXRFbnZTdHJpbmdzLnN0cmluZ3MgPSBzdHJpbmdzO1xuIH1cbiByZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdUb0FzY2lpKHN0ciwgYnVmZmVyKSB7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgYXNzZXJ0KHN0ci5jaGFyQ29kZUF0KGkpID09PSAoc3RyLmNoYXJDb2RlQXQoaSkgJiAyNTUpKTtcbiAgSEVBUDhbYnVmZmVyKysgPj4+IDBdID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gfVxuIEhFQVA4W2J1ZmZlciA+Pj4gMF0gPSAwO1xufVxuXG5mdW5jdGlvbiBfZW52aXJvbl9nZXQoX19lbnZpcm9uLCBlbnZpcm9uX2J1Zikge1xuIHZhciBidWZTaXplID0gMDtcbiBnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaChmdW5jdGlvbihzdHJpbmcsIGkpIHtcbiAgdmFyIHB0ciA9IGVudmlyb25fYnVmICsgYnVmU2l6ZTtcbiAgSEVBUFUzMltfX2Vudmlyb24gKyBpICogNCA+Pj4gMl0gPSBwdHI7XG4gIHN0cmluZ1RvQXNjaWkoc3RyaW5nLCBwdHIpO1xuICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuIH0pO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZW52aXJvbl9zaXplc19nZXQocGVudmlyb25fY291bnQsIHBlbnZpcm9uX2J1Zl9zaXplKSB7XG4gdmFyIHN0cmluZ3MgPSBnZXRFbnZTdHJpbmdzKCk7XG4gSEVBUFUzMltwZW52aXJvbl9jb3VudCA+Pj4gMl0gPSBzdHJpbmdzLmxlbmd0aDtcbiB2YXIgYnVmU2l6ZSA9IDA7XG4gc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZykge1xuICBidWZTaXplICs9IHN0cmluZy5sZW5ndGggKyAxO1xuIH0pO1xuIEhFQVBVMzJbcGVudmlyb25fYnVmX3NpemUgPj4+IDJdID0gYnVmU2l6ZTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gX2ZkX2Nsb3NlKGZkKSB7XG4gYWJvcnQoXCJmZF9jbG9zZSBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9mZF9mZHN0YXRfZ2V0KGZkLCBwYnVmKSB7XG4gdmFyIHJpZ2h0c0Jhc2UgPSAwO1xuIHZhciByaWdodHNJbmhlcml0aW5nID0gMDtcbiB2YXIgZmxhZ3MgPSAwO1xuIHtcbiAgYXNzZXJ0KGZkID09IDAgfHwgZmQgPT0gMSB8fCBmZCA9PSAyKTtcbiAgdmFyIHR5cGUgPSAyO1xuICBpZiAoZmQgPT0gMCkge1xuICAgcmlnaHRzQmFzZSA9IDI7XG4gIH0gZWxzZSBpZiAoZmQgPT0gMSB8fCBmZCA9PSAyKSB7XG4gICByaWdodHNCYXNlID0gNjQ7XG4gIH1cbiAgZmxhZ3MgPSAxO1xuIH1cbiBIRUFQOFtwYnVmID4+PiAwXSA9IHR5cGU7XG4gSEVBUDE2W3BidWYgKyAyID4+PiAxXSA9IGZsYWdzO1xuIHRlbXBJNjQgPSBbIHJpZ2h0c0Jhc2UgPj4+IDAsICh0ZW1wRG91YmxlID0gcmlnaHRzQmFzZSwgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDEgPyB0ZW1wRG91YmxlID4gMCA/ICtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCA6IH5+K01hdGguY2VpbCgodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCA6IDApIF0sIFxuIEhFQVAzMltwYnVmICsgOCA+Pj4gMl0gPSB0ZW1wSTY0WzBdLCBIRUFQMzJbcGJ1ZiArIDEyID4+PiAyXSA9IHRlbXBJNjRbMV07XG4gdGVtcEk2NCA9IFsgcmlnaHRzSW5oZXJpdGluZyA+Pj4gMCwgKHRlbXBEb3VibGUgPSByaWdodHNJbmhlcml0aW5nLCArTWF0aC5hYnModGVtcERvdWJsZSkgPj0gMSA/IHRlbXBEb3VibGUgPiAwID8gK01hdGguZmxvb3IodGVtcERvdWJsZSAvIDQyOTQ5NjcyOTYpID4+PiAwIDogfn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYpID4+PiAwIDogMCkgXSwgXG4gSEVBUDMyW3BidWYgKyAxNiA+Pj4gMl0gPSB0ZW1wSTY0WzBdLCBIRUFQMzJbcGJ1ZiArIDIwID4+PiAyXSA9IHRlbXBJNjRbMV07XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9mZF9wcmVhZChmZCwgaW92LCBpb3ZjbnQsIG9mZnNldF9sb3csIG9mZnNldF9oaWdoLCBwbnVtKSB7XG4gYWJvcnQoXCJmZF9wcmVhZCBjYWxsZWQgd2l0aG91dCBTWVNDQUxMU19SRVFVSVJFX0ZJTEVTWVNURU1cIik7XG59XG5cbmZ1bmN0aW9uIF9mZF9wd3JpdGUoZmQsIGlvdiwgaW92Y250LCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgcG51bSkge1xuIGFib3J0KFwiZmRfcHdyaXRlIGNhbGxlZCB3aXRob3V0IFNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX2ZkX3JlYWQoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gYWJvcnQoXCJmZF9yZWFkIGNhbGxlZCB3aXRob3V0IFNZU0NBTExTX1JFUVVJUkVfRklMRVNZU1RFTVwiKTtcbn1cblxuZnVuY3Rpb24gX2ZkX3NlZWsoZmQsIG9mZnNldF9sb3csIG9mZnNldF9oaWdoLCB3aGVuY2UsIG5ld09mZnNldCkge1xuIHJldHVybiA3MDtcbn1cblxuZnVuY3Rpb24gX2ZkX3N5bmMoZmQpIHtcbiBhYm9ydChcImZkX3N5bmMgY2FsbGVkIHdpdGhvdXQgU1lTQ0FMTFNfUkVRVUlSRV9GSUxFU1lTVEVNXCIpO1xufVxuXG52YXIgcHJpbnRDaGFyQnVmZmVycyA9IFsgbnVsbCwgW10sIFtdIF07XG5cbmZ1bmN0aW9uIHByaW50Q2hhcihzdHJlYW0sIGN1cnIpIHtcbiB2YXIgYnVmZmVyID0gcHJpbnRDaGFyQnVmZmVyc1tzdHJlYW1dO1xuIGFzc2VydChidWZmZXIpO1xuIGlmIChjdXJyID09PSAwIHx8IGN1cnIgPT09IDEwKSB7XG4gIChzdHJlYW0gPT09IDEgPyBvdXQgOiBlcnIpKFVURjhBcnJheVRvU3RyaW5nKGJ1ZmZlciwgMCkpO1xuICBidWZmZXIubGVuZ3RoID0gMDtcbiB9IGVsc2Uge1xuICBidWZmZXIucHVzaChjdXJyKTtcbiB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoX05PX0ZJTEVTWVNURU0oKSB7XG4gX2ZmbHVzaCgwKTtcbiBpZiAocHJpbnRDaGFyQnVmZmVyc1sxXS5sZW5ndGgpIHByaW50Q2hhcigxLCAxMCk7XG4gaWYgKHByaW50Q2hhckJ1ZmZlcnNbMl0ubGVuZ3RoKSBwcmludENoYXIoMiwgMTApO1xufVxuXG5mdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gdmFyIG51bSA9IDA7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBpb3ZjbnQ7IGkrKykge1xuICB2YXIgcHRyID0gSEVBUFUzMltpb3YgPj4+IDJdO1xuICB2YXIgbGVuID0gSEVBUFUzMltpb3YgKyA0ID4+PiAyXTtcbiAgaW92ICs9IDg7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgIHByaW50Q2hhcihmZCwgSEVBUFU4W3B0ciArIGogPj4+IDBdKTtcbiAgfVxuICBudW0gKz0gbGVuO1xuIH1cbiBIRUFQVTMyW3BudW0gPj4+IDJdID0gbnVtO1xuIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBfZ2V0YWRkcmluZm8obm9kZSwgc2VydmljZSwgaGludCwgb3V0KSB7XG4gdmFyIGFkZHJzID0gW107XG4gdmFyIGNhbm9uID0gbnVsbDtcbiB2YXIgYWRkciA9IDA7XG4gdmFyIHBvcnQgPSAwO1xuIHZhciBmbGFncyA9IDA7XG4gdmFyIGZhbWlseSA9IDA7XG4gdmFyIHR5cGUgPSAwO1xuIHZhciBwcm90byA9IDA7XG4gdmFyIGFpLCBsYXN0O1xuIGZ1bmN0aW9uIGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgY2Fub24sIGFkZHIsIHBvcnQpIHtcbiAgdmFyIHNhLCBzYWxlbiwgYWk7XG4gIHZhciBlcnJubztcbiAgc2FsZW4gPSBmYW1pbHkgPT09IDEwID8gMjggOiAxNjtcbiAgYWRkciA9IGZhbWlseSA9PT0gMTAgPyBpbmV0TnRvcDYoYWRkcikgOiBpbmV0TnRvcDQoYWRkcik7XG4gIHNhID0gX21hbGxvYyhzYWxlbik7XG4gIGVycm5vID0gd3JpdGVTb2NrYWRkcihzYSwgZmFtaWx5LCBhZGRyLCBwb3J0KTtcbiAgYXNzZXJ0KCFlcnJubyk7XG4gIGFpID0gX21hbGxvYygzMik7XG4gIEhFQVAzMlthaSArIDQgPj4+IDJdID0gZmFtaWx5O1xuICBIRUFQMzJbYWkgKyA4ID4+PiAyXSA9IHR5cGU7XG4gIEhFQVAzMlthaSArIDEyID4+PiAyXSA9IHByb3RvO1xuICBIRUFQVTMyW2FpICsgMjQgPj4+IDJdID0gY2Fub247XG4gIEhFQVBVMzJbYWkgKyAyMCA+Pj4gMl0gPSBzYTtcbiAgaWYgKGZhbWlseSA9PT0gMTApIHtcbiAgIEhFQVAzMlthaSArIDE2ID4+PiAyXSA9IDI4O1xuICB9IGVsc2Uge1xuICAgSEVBUDMyW2FpICsgMTYgPj4+IDJdID0gMTY7XG4gIH1cbiAgSEVBUDMyW2FpICsgMjggPj4+IDJdID0gMDtcbiAgcmV0dXJuIGFpO1xuIH1cbiBpZiAoaGludCkge1xuICBmbGFncyA9IEhFQVAzMltoaW50ID4+PiAyXTtcbiAgZmFtaWx5ID0gSEVBUDMyW2hpbnQgKyA0ID4+PiAyXTtcbiAgdHlwZSA9IEhFQVAzMltoaW50ICsgOCA+Pj4gMl07XG4gIHByb3RvID0gSEVBUDMyW2hpbnQgKyAxMiA+Pj4gMl07XG4gfVxuIGlmICh0eXBlICYmICFwcm90bykge1xuICBwcm90byA9IHR5cGUgPT09IDIgPyAxNyA6IDY7XG4gfVxuIGlmICghdHlwZSAmJiBwcm90bykge1xuICB0eXBlID0gcHJvdG8gPT09IDE3ID8gMiA6IDE7XG4gfVxuIGlmIChwcm90byA9PT0gMCkge1xuICBwcm90byA9IDY7XG4gfVxuIGlmICh0eXBlID09PSAwKSB7XG4gIHR5cGUgPSAxO1xuIH1cbiBpZiAoIW5vZGUgJiYgIXNlcnZpY2UpIHtcbiAgcmV0dXJuIC0yO1xuIH1cbiBpZiAoZmxhZ3MgJiB+KDEgfCAyIHwgNCB8IDEwMjQgfCA4IHwgMTYgfCAzMikpIHtcbiAgcmV0dXJuIC0xO1xuIH1cbiBpZiAoaGludCAhPT0gMCAmJiBIRUFQMzJbaGludCA+Pj4gMl0gJiAyICYmICFub2RlKSB7XG4gIHJldHVybiAtMTtcbiB9XG4gaWYgKGZsYWdzICYgMzIpIHtcbiAgcmV0dXJuIC0yO1xuIH1cbiBpZiAodHlwZSAhPT0gMCAmJiB0eXBlICE9PSAxICYmIHR5cGUgIT09IDIpIHtcbiAgcmV0dXJuIC03O1xuIH1cbiBpZiAoZmFtaWx5ICE9PSAwICYmIGZhbWlseSAhPT0gMiAmJiBmYW1pbHkgIT09IDEwKSB7XG4gIHJldHVybiAtNjtcbiB9XG4gaWYgKHNlcnZpY2UpIHtcbiAgc2VydmljZSA9IFVURjhUb1N0cmluZyhzZXJ2aWNlKTtcbiAgcG9ydCA9IHBhcnNlSW50KHNlcnZpY2UsIDEwKTtcbiAgaWYgKGlzTmFOKHBvcnQpKSB7XG4gICBpZiAoZmxhZ3MgJiAxMDI0KSB7XG4gICAgcmV0dXJuIC0yO1xuICAgfVxuICAgcmV0dXJuIC04O1xuICB9XG4gfVxuIGlmICghbm9kZSkge1xuICBpZiAoZmFtaWx5ID09PSAwKSB7XG4gICBmYW1pbHkgPSAyO1xuICB9XG4gIGlmICgoZmxhZ3MgJiAxKSA9PT0gMCkge1xuICAgaWYgKGZhbWlseSA9PT0gMikge1xuICAgIGFkZHIgPSBfaHRvbmwoMjEzMDcwNjQzMyk7XG4gICB9IGVsc2Uge1xuICAgIGFkZHIgPSBbIDAsIDAsIDAsIDEgXTtcbiAgIH1cbiAgfVxuICBhaSA9IGFsbG9jYWRkcmluZm8oZmFtaWx5LCB0eXBlLCBwcm90bywgbnVsbCwgYWRkciwgcG9ydCk7XG4gIEhFQVBVMzJbb3V0ID4+PiAyXSA9IGFpO1xuICByZXR1cm4gMDtcbiB9XG4gbm9kZSA9IFVURjhUb1N0cmluZyhub2RlKTtcbiBhZGRyID0gaW5ldFB0b240KG5vZGUpO1xuIGlmIChhZGRyICE9PSBudWxsKSB7XG4gIGlmIChmYW1pbHkgPT09IDAgfHwgZmFtaWx5ID09PSAyKSB7XG4gICBmYW1pbHkgPSAyO1xuICB9IGVsc2UgaWYgKGZhbWlseSA9PT0gMTAgJiYgZmxhZ3MgJiA4KSB7XG4gICBhZGRyID0gWyAwLCAwLCBfaHRvbmwoNjU1MzUpLCBhZGRyIF07XG4gICBmYW1pbHkgPSAxMDtcbiAgfSBlbHNlIHtcbiAgIHJldHVybiAtMjtcbiAgfVxuIH0gZWxzZSB7XG4gIGFkZHIgPSBpbmV0UHRvbjYobm9kZSk7XG4gIGlmIChhZGRyICE9PSBudWxsKSB7XG4gICBpZiAoZmFtaWx5ID09PSAwIHx8IGZhbWlseSA9PT0gMTApIHtcbiAgICBmYW1pbHkgPSAxMDtcbiAgIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0yO1xuICAgfVxuICB9XG4gfVxuIGlmIChhZGRyICE9IG51bGwpIHtcbiAgYWkgPSBhbGxvY2FkZHJpbmZvKGZhbWlseSwgdHlwZSwgcHJvdG8sIG5vZGUsIGFkZHIsIHBvcnQpO1xuICBIRUFQVTMyW291dCA+Pj4gMl0gPSBhaTtcbiAgcmV0dXJuIDA7XG4gfVxuIGlmIChmbGFncyAmIDQpIHtcbiAgcmV0dXJuIC0yO1xuIH1cbiBub2RlID0gRE5TLmxvb2t1cF9uYW1lKG5vZGUpO1xuIGFkZHIgPSBpbmV0UHRvbjQobm9kZSk7XG4gaWYgKGZhbWlseSA9PT0gMCkge1xuICBmYW1pbHkgPSAyO1xuIH0gZWxzZSBpZiAoZmFtaWx5ID09PSAxMCkge1xuICBhZGRyID0gWyAwLCAwLCBfaHRvbmwoNjU1MzUpLCBhZGRyIF07XG4gfVxuIGFpID0gYWxsb2NhZGRyaW5mbyhmYW1pbHksIHR5cGUsIHByb3RvLCBudWxsLCBhZGRyLCBwb3J0KTtcbiBIRUFQVTMyW291dCA+Pj4gMl0gPSBhaTtcbiByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5pdFJhbmRvbUZpbGwoKSB7XG4gaWYgKHR5cGVvZiBjcnlwdG8gPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgY3J5cHRvW1wiZ2V0UmFuZG9tVmFsdWVzXCJdID09IFwiZnVuY3Rpb25cIikge1xuICByZXR1cm4gdmlldyA9PiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHZpZXcpO1xuIH0gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICB0cnkge1xuICAgdmFyIGNyeXB0b19tb2R1bGUgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuICAgdmFyIHJhbmRvbUZpbGxTeW5jID0gY3J5cHRvX21vZHVsZVtcInJhbmRvbUZpbGxTeW5jXCJdO1xuICAgaWYgKHJhbmRvbUZpbGxTeW5jKSB7XG4gICAgcmV0dXJuIHZpZXcgPT4gY3J5cHRvX21vZHVsZVtcInJhbmRvbUZpbGxTeW5jXCJdKHZpZXcpO1xuICAgfVxuICAgdmFyIHJhbmRvbUJ5dGVzID0gY3J5cHRvX21vZHVsZVtcInJhbmRvbUJ5dGVzXCJdO1xuICAgcmV0dXJuIHZpZXcgPT4gKHZpZXcuc2V0KHJhbmRvbUJ5dGVzKHZpZXcuYnl0ZUxlbmd0aCkpLCB2aWV3KTtcbiAgfSBjYXRjaCAoZSkge31cbiB9XG4gYWJvcnQoXCJubyBjcnlwdG9ncmFwaGljIHN1cHBvcnQgZm91bmQgZm9yIHJhbmRvbURldmljZS4gY29uc2lkZXIgcG9seWZpbGxpbmcgaXQgaWYgeW91IHdhbnQgdG8gdXNlIHNvbWV0aGluZyBpbnNlY3VyZSBsaWtlIE1hdGgucmFuZG9tKCksIGUuZy4gcHV0IHRoaXMgaW4gYSAtLXByZS1qczogdmFyIGNyeXB0byA9IHsgZ2V0UmFuZG9tVmFsdWVzOiBmdW5jdGlvbihhcnJheSkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSBhcnJheVtpXSA9IChNYXRoLnJhbmRvbSgpKjI1Nil8MCB9IH07XCIpO1xufVxuXG5mdW5jdGlvbiByYW5kb21GaWxsKHZpZXcpIHtcbiByZXR1cm4gKHJhbmRvbUZpbGwgPSBpbml0UmFuZG9tRmlsbCgpKSh2aWV3KTtcbn1cblxuZnVuY3Rpb24gX2dldGVudHJvcHkoYnVmZmVyLCBzaXplKSB7XG4gcmFuZG9tRmlsbChIRUFQVTguc3ViYXJyYXkoYnVmZmVyID4+PiAwLCBidWZmZXIgKyBzaXplID4+PiAwKSk7XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIF9nZXRuYW1laW5mbyhzYSwgc2FsZW4sIG5vZGUsIG5vZGVsZW4sIHNlcnYsIHNlcnZsZW4sIGZsYWdzKSB7XG4gdmFyIGluZm8gPSByZWFkU29ja2FkZHIoc2EsIHNhbGVuKTtcbiBpZiAoaW5mby5lcnJubykge1xuICByZXR1cm4gLTY7XG4gfVxuIHZhciBwb3J0ID0gaW5mby5wb3J0O1xuIHZhciBhZGRyID0gaW5mby5hZGRyO1xuIHZhciBvdmVyZmxvd2VkID0gZmFsc2U7XG4gaWYgKG5vZGUgJiYgbm9kZWxlbikge1xuICB2YXIgbG9va3VwO1xuICBpZiAoZmxhZ3MgJiAxIHx8ICEobG9va3VwID0gRE5TLmxvb2t1cF9hZGRyKGFkZHIpKSkge1xuICAgaWYgKGZsYWdzICYgOCkge1xuICAgIHJldHVybiAtMjtcbiAgIH1cbiAgfSBlbHNlIHtcbiAgIGFkZHIgPSBsb29rdXA7XG4gIH1cbiAgdmFyIG51bUJ5dGVzV3JpdHRlbkV4Y2xOdWxsID0gc3RyaW5nVG9VVEY4KGFkZHIsIG5vZGUsIG5vZGVsZW4pO1xuICBpZiAobnVtQnl0ZXNXcml0dGVuRXhjbE51bGwgKyAxID49IG5vZGVsZW4pIHtcbiAgIG92ZXJmbG93ZWQgPSB0cnVlO1xuICB9XG4gfVxuIGlmIChzZXJ2ICYmIHNlcnZsZW4pIHtcbiAgcG9ydCA9IFwiXCIgKyBwb3J0O1xuICB2YXIgbnVtQnl0ZXNXcml0dGVuRXhjbE51bGwgPSBzdHJpbmdUb1VURjgocG9ydCwgc2Vydiwgc2Vydmxlbik7XG4gIGlmIChudW1CeXRlc1dyaXR0ZW5FeGNsTnVsbCArIDEgPj0gc2Vydmxlbikge1xuICAgb3ZlcmZsb3dlZCA9IHRydWU7XG4gIH1cbiB9XG4gaWYgKG92ZXJmbG93ZWQpIHtcbiAgcmV0dXJuIC0xMjtcbiB9XG4gcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGFycmF5U3VtKGFycmF5LCBpbmRleCkge1xuIHZhciBzdW0gPSAwO1xuIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyBzdW0gKz0gYXJyYXlbaSsrXSkge31cbiByZXR1cm4gc3VtO1xufVxuXG52YXIgTU9OVEhfREFZU19MRUFQID0gWyAzMSwgMjksIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxIF07XG5cbnZhciBNT05USF9EQVlTX1JFR1VMQVIgPSBbIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzEgXTtcblxuZnVuY3Rpb24gYWRkRGF5cyhkYXRlLCBkYXlzKSB7XG4gdmFyIG5ld0RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gd2hpbGUgKGRheXMgPiAwKSB7XG4gIHZhciBsZWFwID0gaXNMZWFwWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICB2YXIgY3VycmVudE1vbnRoID0gbmV3RGF0ZS5nZXRNb250aCgpO1xuICB2YXIgZGF5c0luQ3VycmVudE1vbnRoID0gKGxlYXAgPyBNT05USF9EQVlTX0xFQVAgOiBNT05USF9EQVlTX1JFR1VMQVIpW2N1cnJlbnRNb250aF07XG4gIGlmIChkYXlzID4gZGF5c0luQ3VycmVudE1vbnRoIC0gbmV3RGF0ZS5nZXREYXRlKCkpIHtcbiAgIGRheXMgLT0gZGF5c0luQ3VycmVudE1vbnRoIC0gbmV3RGF0ZS5nZXREYXRlKCkgKyAxO1xuICAgbmV3RGF0ZS5zZXREYXRlKDEpO1xuICAgaWYgKGN1cnJlbnRNb250aCA8IDExKSB7XG4gICAgbmV3RGF0ZS5zZXRNb250aChjdXJyZW50TW9udGggKyAxKTtcbiAgIH0gZWxzZSB7XG4gICAgbmV3RGF0ZS5zZXRNb250aCgwKTtcbiAgICBuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSArIDEpO1xuICAgfVxuICB9IGVsc2Uge1xuICAgbmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpICsgZGF5cyk7XG4gICByZXR1cm4gbmV3RGF0ZTtcbiAgfVxuIH1cbiByZXR1cm4gbmV3RGF0ZTtcbn1cblxuZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHtcbiB2YXIgbGVuID0gbGVuZ3RoID4gMCA/IGxlbmd0aCA6IGxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSArIDE7XG4gdmFyIHU4YXJyYXkgPSBuZXcgQXJyYXkobGVuKTtcbiB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSwgdThhcnJheSwgMCwgdThhcnJheS5sZW5ndGgpO1xuIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47XG4gcmV0dXJuIHU4YXJyYXk7XG59XG5cbmZ1bmN0aW9uIHdyaXRlQXJyYXlUb01lbW9yeShhcnJheSwgYnVmZmVyKSB7XG4gYXNzZXJ0KGFycmF5Lmxlbmd0aCA+PSAwLCBcIndyaXRlQXJyYXlUb01lbW9yeSBhcnJheSBtdXN0IGhhdmUgYSBsZW5ndGggKHNob3VsZCBiZSBhbiBhcnJheSBvciB0eXBlZCBhcnJheSlcIik7XG4gSEVBUDguc2V0KGFycmF5LCBidWZmZXIgPj4+IDApO1xufVxuXG5mdW5jdGlvbiBfc3RyZnRpbWUocywgbWF4c2l6ZSwgZm9ybWF0LCB0bSkge1xuIHZhciB0bV96b25lID0gSEVBUDMyW3RtICsgNDAgPj4+IDJdO1xuIHZhciBkYXRlID0ge1xuICB0bV9zZWM6IEhFQVAzMlt0bSA+Pj4gMl0sXG4gIHRtX21pbjogSEVBUDMyW3RtICsgNCA+Pj4gMl0sXG4gIHRtX2hvdXI6IEhFQVAzMlt0bSArIDggPj4+IDJdLFxuICB0bV9tZGF5OiBIRUFQMzJbdG0gKyAxMiA+Pj4gMl0sXG4gIHRtX21vbjogSEVBUDMyW3RtICsgMTYgPj4+IDJdLFxuICB0bV95ZWFyOiBIRUFQMzJbdG0gKyAyMCA+Pj4gMl0sXG4gIHRtX3dkYXk6IEhFQVAzMlt0bSArIDI0ID4+PiAyXSxcbiAgdG1feWRheTogSEVBUDMyW3RtICsgMjggPj4+IDJdLFxuICB0bV9pc2RzdDogSEVBUDMyW3RtICsgMzIgPj4+IDJdLFxuICB0bV9nbXRvZmY6IEhFQVAzMlt0bSArIDM2ID4+PiAyXSxcbiAgdG1fem9uZTogdG1fem9uZSA/IFVURjhUb1N0cmluZyh0bV96b25lKSA6IFwiXCJcbiB9O1xuIHZhciBwYXR0ZXJuID0gVVRGOFRvU3RyaW5nKGZvcm1hdCk7XG4gdmFyIEVYUEFOU0lPTl9SVUxFU18xID0ge1xuICBcIiVjXCI6IFwiJWEgJWIgJWQgJUg6JU06JVMgJVlcIixcbiAgXCIlRFwiOiBcIiVtLyVkLyV5XCIsXG4gIFwiJUZcIjogXCIlWS0lbS0lZFwiLFxuICBcIiVoXCI6IFwiJWJcIixcbiAgXCIlclwiOiBcIiVJOiVNOiVTICVwXCIsXG4gIFwiJVJcIjogXCIlSDolTVwiLFxuICBcIiVUXCI6IFwiJUg6JU06JVNcIixcbiAgXCIleFwiOiBcIiVtLyVkLyV5XCIsXG4gIFwiJVhcIjogXCIlSDolTTolU1wiLFxuICBcIiVFY1wiOiBcIiVjXCIsXG4gIFwiJUVDXCI6IFwiJUNcIixcbiAgXCIlRXhcIjogXCIlbS8lZC8leVwiLFxuICBcIiVFWFwiOiBcIiVIOiVNOiVTXCIsXG4gIFwiJUV5XCI6IFwiJXlcIixcbiAgXCIlRVlcIjogXCIlWVwiLFxuICBcIiVPZFwiOiBcIiVkXCIsXG4gIFwiJU9lXCI6IFwiJWVcIixcbiAgXCIlT0hcIjogXCIlSFwiLFxuICBcIiVPSVwiOiBcIiVJXCIsXG4gIFwiJU9tXCI6IFwiJW1cIixcbiAgXCIlT01cIjogXCIlTVwiLFxuICBcIiVPU1wiOiBcIiVTXCIsXG4gIFwiJU91XCI6IFwiJXVcIixcbiAgXCIlT1VcIjogXCIlVVwiLFxuICBcIiVPVlwiOiBcIiVWXCIsXG4gIFwiJU93XCI6IFwiJXdcIixcbiAgXCIlT1dcIjogXCIlV1wiLFxuICBcIiVPeVwiOiBcIiV5XCJcbiB9O1xuIGZvciAodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzEpIHtcbiAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZShuZXcgUmVnRXhwKHJ1bGUsIFwiZ1wiKSwgRVhQQU5TSU9OX1JVTEVTXzFbcnVsZV0pO1xuIH1cbiB2YXIgV0VFS0RBWVMgPSBbIFwiU3VuZGF5XCIsIFwiTW9uZGF5XCIsIFwiVHVlc2RheVwiLCBcIldlZG5lc2RheVwiLCBcIlRodXJzZGF5XCIsIFwiRnJpZGF5XCIsIFwiU2F0dXJkYXlcIiBdO1xuIHZhciBNT05USFMgPSBbIFwiSmFudWFyeVwiLCBcIkZlYnJ1YXJ5XCIsIFwiTWFyY2hcIiwgXCJBcHJpbFwiLCBcIk1heVwiLCBcIkp1bmVcIiwgXCJKdWx5XCIsIFwiQXVndXN0XCIsIFwiU2VwdGVtYmVyXCIsIFwiT2N0b2JlclwiLCBcIk5vdmVtYmVyXCIsIFwiRGVjZW1iZXJcIiBdO1xuIGZ1bmN0aW9uIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsIGRpZ2l0cywgY2hhcmFjdGVyKSB7XG4gIHZhciBzdHIgPSB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSB8fCBcIlwiO1xuICB3aGlsZSAoc3RyLmxlbmd0aCA8IGRpZ2l0cykge1xuICAgc3RyID0gY2hhcmFjdGVyWzBdICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG4gfVxuIGZ1bmN0aW9uIGxlYWRpbmdOdWxscyh2YWx1ZSwgZGlnaXRzKSB7XG4gIHJldHVybiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLCBkaWdpdHMsIFwiMFwiKTtcbiB9XG4gZnVuY3Rpb24gY29tcGFyZUJ5RGF5KGRhdGUxLCBkYXRlMikge1xuICBmdW5jdGlvbiBzZ24odmFsdWUpIHtcbiAgIHJldHVybiB2YWx1ZSA8IDAgPyAtMSA6IHZhbHVlID4gMCA/IDEgOiAwO1xuICB9XG4gIHZhciBjb21wYXJlO1xuICBpZiAoKGNvbXBhcmUgPSBzZ24oZGF0ZTEuZ2V0RnVsbFllYXIoKSAtIGRhdGUyLmdldEZ1bGxZZWFyKCkpKSA9PT0gMCkge1xuICAgaWYgKChjb21wYXJlID0gc2duKGRhdGUxLmdldE1vbnRoKCkgLSBkYXRlMi5nZXRNb250aCgpKSkgPT09IDApIHtcbiAgICBjb21wYXJlID0gc2duKGRhdGUxLmdldERhdGUoKSAtIGRhdGUyLmdldERhdGUoKSk7XG4gICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBhcmU7XG4gfVxuIGZ1bmN0aW9uIGdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGgpIHtcbiAgc3dpdGNoIChqYW5Gb3VydGguZ2V0RGF5KCkpIHtcbiAgY2FzZSAwOlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpIC0gMSwgMTEsIDI5KTtcblxuICBjYXNlIDE6XG4gICByZXR1cm4gamFuRm91cnRoO1xuXG4gIGNhc2UgMjpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwgMCwgMyk7XG5cbiAgY2FzZSAzOlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLCAwLCAyKTtcblxuICBjYXNlIDQ6XG4gICByZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksIDAsIDEpO1xuXG4gIGNhc2UgNTpcbiAgIHJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSAtIDEsIDExLCAzMSk7XG5cbiAgY2FzZSA2OlxuICAgcmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpIC0gMSwgMTEsIDMwKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpIHtcbiAgdmFyIHRoaXNEYXRlID0gYWRkRGF5cyhuZXcgRGF0ZShkYXRlLnRtX3llYXIgKyAxOTAwLCAwLCAxKSwgZGF0ZS50bV95ZGF5KTtcbiAgdmFyIGphbkZvdXJ0aFRoaXNZZWFyID0gbmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSwgMCwgNCk7XG4gIHZhciBqYW5Gb3VydGhOZXh0WWVhciA9IG5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCkgKyAxLCAwLCA0KTtcbiAgdmFyIGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIgPSBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoVGhpc1llYXIpO1xuICB2YXIgZmlyc3RXZWVrU3RhcnROZXh0WWVhciA9IGdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhOZXh0WWVhcik7XG4gIGlmIChjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnRUaGlzWWVhciwgdGhpc0RhdGUpIDw9IDApIHtcbiAgIGlmIChjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnROZXh0WWVhciwgdGhpc0RhdGUpIDw9IDApIHtcbiAgICByZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKSArIDE7XG4gICB9XG4gICByZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKTtcbiAgfVxuICByZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKSAtIDE7XG4gfVxuIHZhciBFWFBBTlNJT05fUlVMRVNfMiA9IHtcbiAgXCIlYVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gV0VFS0RBWVNbZGF0ZS50bV93ZGF5XS5zdWJzdHJpbmcoMCwgMyk7XG4gIH0sXG4gIFwiJUFcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIFdFRUtEQVlTW2RhdGUudG1fd2RheV07XG4gIH0sXG4gIFwiJWJcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIE1PTlRIU1tkYXRlLnRtX21vbl0uc3Vic3RyaW5nKDAsIDMpO1xuICB9LFxuICBcIiVCXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBNT05USFNbZGF0ZS50bV9tb25dO1xuICB9LFxuICBcIiVDXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciB5ZWFyID0gZGF0ZS50bV95ZWFyICsgMTkwMDtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoeWVhciAvIDEwMCB8IDAsIDIpO1xuICB9LFxuICBcIiVkXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5LCAyKTtcbiAgfSxcbiAgXCIlZVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ1NvbWV0aGluZyhkYXRlLnRtX21kYXksIDIsIFwiIFwiKTtcbiAgfSxcbiAgXCIlZ1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKS50b1N0cmluZygpLnN1YnN0cmluZygyKTtcbiAgfSxcbiAgXCIlR1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKTtcbiAgfSxcbiAgXCIlSFwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1faG91ciwgMik7XG4gIH0sXG4gIFwiJUlcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgdmFyIHR3ZWx2ZUhvdXIgPSBkYXRlLnRtX2hvdXI7XG4gICBpZiAodHdlbHZlSG91ciA9PSAwKSB0d2VsdmVIb3VyID0gMTI7IGVsc2UgaWYgKHR3ZWx2ZUhvdXIgPiAxMikgdHdlbHZlSG91ciAtPSAxMjtcbiAgIHJldHVybiBsZWFkaW5nTnVsbHModHdlbHZlSG91ciwgMik7XG4gIH0sXG4gIFwiJWpcIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXkgKyBhcnJheVN1bShpc0xlYXBZZWFyKGRhdGUudG1feWVhciArIDE5MDApID8gTU9OVEhfREFZU19MRUFQIDogTU9OVEhfREFZU19SRUdVTEFSLCBkYXRlLnRtX21vbiAtIDEpLCAzKTtcbiAgfSxcbiAgXCIlbVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fbW9uICsgMSwgMik7XG4gIH0sXG4gIFwiJU1cIjogZnVuY3Rpb24oZGF0ZSkge1xuICAgcmV0dXJuIGxlYWRpbmdOdWxscyhkYXRlLnRtX21pbiwgMik7XG4gIH0sXG4gIFwiJW5cIjogZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gXCJcXG5cIjtcbiAgfSxcbiAgXCIlcFwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICBpZiAoZGF0ZS50bV9ob3VyID49IDAgJiYgZGF0ZS50bV9ob3VyIDwgMTIpIHtcbiAgICByZXR1cm4gXCJBTVwiO1xuICAgfVxuICAgcmV0dXJuIFwiUE1cIjtcbiAgfSxcbiAgXCIlU1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKGRhdGUudG1fc2VjLCAyKTtcbiAgfSxcbiAgXCIldFwiOiBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBcIlxcdFwiO1xuICB9LFxuICBcIiV1XCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBkYXRlLnRtX3dkYXkgfHwgNztcbiAgfSxcbiAgXCIlVVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgZGF5cyA9IGRhdGUudG1feWRheSArIDcgLSBkYXRlLnRtX3dkYXk7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKE1hdGguZmxvb3IoZGF5cyAvIDcpLCAyKTtcbiAgfSxcbiAgXCIlVlwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICB2YXIgdmFsID0gTWF0aC5mbG9vcigoZGF0ZS50bV95ZGF5ICsgNyAtIChkYXRlLnRtX3dkYXkgKyA2KSAlIDcpIC8gNyk7XG4gICBpZiAoKGRhdGUudG1fd2RheSArIDM3MSAtIGRhdGUudG1feWRheSAtIDIpICUgNyA8PSAyKSB7XG4gICAgdmFsKys7XG4gICB9XG4gICBpZiAoIXZhbCkge1xuICAgIHZhbCA9IDUyO1xuICAgIHZhciBkZWMzMSA9IChkYXRlLnRtX3dkYXkgKyA3IC0gZGF0ZS50bV95ZGF5IC0gMSkgJSA3O1xuICAgIGlmIChkZWMzMSA9PSA0IHx8IGRlYzMxID09IDUgJiYgaXNMZWFwWWVhcihkYXRlLnRtX3llYXIgJSA0MDAgLSAxKSkge1xuICAgICB2YWwrKztcbiAgICB9XG4gICB9IGVsc2UgaWYgKHZhbCA9PSA1Mykge1xuICAgIHZhciBqYW4xID0gKGRhdGUudG1fd2RheSArIDM3MSAtIGRhdGUudG1feWRheSkgJSA3O1xuICAgIGlmIChqYW4xICE9IDQgJiYgKGphbjEgIT0gMyB8fCAhaXNMZWFwWWVhcihkYXRlLnRtX3llYXIpKSkgdmFsID0gMTtcbiAgIH1cbiAgIHJldHVybiBsZWFkaW5nTnVsbHModmFsLCAyKTtcbiAgfSxcbiAgXCIld1wiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gZGF0ZS50bV93ZGF5O1xuICB9LFxuICBcIiVXXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciBkYXlzID0gZGF0ZS50bV95ZGF5ICsgNyAtIChkYXRlLnRtX3dkYXkgKyA2KSAlIDc7XG4gICByZXR1cm4gbGVhZGluZ051bGxzKE1hdGguZmxvb3IoZGF5cyAvIDcpLCAyKTtcbiAgfSxcbiAgXCIleVwiOiBmdW5jdGlvbihkYXRlKSB7XG4gICByZXR1cm4gKGRhdGUudG1feWVhciArIDE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpO1xuICB9LFxuICBcIiVZXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBkYXRlLnRtX3llYXIgKyAxOTAwO1xuICB9LFxuICBcIiV6XCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHZhciBvZmYgPSBkYXRlLnRtX2dtdG9mZjtcbiAgIHZhciBhaGVhZCA9IG9mZiA+PSAwO1xuICAgb2ZmID0gTWF0aC5hYnMob2ZmKSAvIDYwO1xuICAgb2ZmID0gb2ZmIC8gNjAgKiAxMDAgKyBvZmYgJSA2MDtcbiAgIHJldHVybiAoYWhlYWQgPyBcIitcIiA6IFwiLVwiKSArIFN0cmluZyhcIjAwMDBcIiArIG9mZikuc2xpY2UoLTQpO1xuICB9LFxuICBcIiVaXCI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgIHJldHVybiBkYXRlLnRtX3pvbmU7XG4gIH0sXG4gIFwiJSVcIjogZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gXCIlXCI7XG4gIH1cbiB9O1xuIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLyUlL2csIFwiXFwwXFwwXCIpO1xuIGZvciAodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzIpIHtcbiAgaWYgKHBhdHRlcm4uaW5jbHVkZXMocnVsZSkpIHtcbiAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UobmV3IFJlZ0V4cChydWxlLCBcImdcIiksIEVYUEFOU0lPTl9SVUxFU18yW3J1bGVdKGRhdGUpKTtcbiAgfVxuIH1cbiBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC9cXDBcXDAvZywgXCIlXCIpO1xuIHZhciBieXRlcyA9IGludEFycmF5RnJvbVN0cmluZyhwYXR0ZXJuLCBmYWxzZSk7XG4gaWYgKGJ5dGVzLmxlbmd0aCA+IG1heHNpemUpIHtcbiAgcmV0dXJuIDA7XG4gfVxuIHdyaXRlQXJyYXlUb01lbW9yeShieXRlcywgcyk7XG4gcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIDE7XG59XG5cbmZ1bmN0aW9uIF9zdHJmdGltZV9sKHMsIG1heHNpemUsIGZvcm1hdCwgdG0sIGxvYykge1xuIHJldHVybiBfc3RyZnRpbWUocywgbWF4c2l6ZSwgZm9ybWF0LCB0bSk7XG59XG5cbmZ1bmN0aW9uIF91Y252X2Nsb3NlXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfY2xvc2VfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNudl9jb252ZXJ0RXhfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNudl9jb252ZXJ0RXhfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNudl9vcGVuXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjbnZfb3Blbl82NFwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91Y252X3RvQWxnb3JpdGhtaWNfNjQoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdWNudl90b0FsZ29yaXRobWljXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9jbG9zZV82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfY2xvc2VfNjRcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdWNzZGV0X2RldGVjdF82NCgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1Y3NkZXRfZGV0ZWN0XzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9nZXRDb25maWRlbmNlXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9nZXRDb25maWRlbmNlXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9nZXROYW1lXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9nZXROYW1lXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9vcGVuXzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9vcGVuXzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vjc2RldF9zZXRUZXh0XzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVjc2RldF9zZXRUZXh0XzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekNsb3NlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekNsb3NlXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekNsb3NlQ3VycmVudEZpbGUoKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56Q2xvc2VDdXJyZW50RmlsZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHZXRDdXJyZW50RmlsZUluZm8oKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R2V0Q3VycmVudEZpbGVJbmZvXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekdldEN1cnJlbnRGaWxlSW5mbzY0KCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdldEN1cnJlbnRGaWxlSW5mbzY0XCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3VuekdldEdsb2JhbEluZm8oKSB7XG4gZXJyKFwibWlzc2luZyBmdW5jdGlvbjogdW56R2V0R2xvYmFsSW5mb1wiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpHb1RvRmlyc3RGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdvVG9GaXJzdEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56R29Ub05leHRGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekdvVG9OZXh0RmlsZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF91bnpMb2NhdGVGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuekxvY2F0ZUZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56T3BlbigpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vuek9wZW4yKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuek9wZW4yXCIpO1xuIGFib3J0KC0xKTtcbn1cblxuZnVuY3Rpb24gX3Vuek9wZW5DdXJyZW50RmlsZSgpIHtcbiBlcnIoXCJtaXNzaW5nIGZ1bmN0aW9uOiB1bnpPcGVuQ3VycmVudEZpbGVcIik7XG4gYWJvcnQoLTEpO1xufVxuXG5mdW5jdGlvbiBfdW56UmVhZEN1cnJlbnRGaWxlKCkge1xuIGVycihcIm1pc3NpbmcgZnVuY3Rpb246IHVuelJlYWRDdXJyZW50RmlsZVwiKTtcbiBhYm9ydCgtMSk7XG59XG5cbmZ1bmN0aW9uIF9wcm9jX2V4aXQoY29kZSkge1xuIEVYSVRTVEFUVVMgPSBjb2RlO1xuIGlmICgha2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XG4gIGlmIChNb2R1bGVbXCJvbkV4aXRcIl0pIE1vZHVsZVtcIm9uRXhpdFwiXShjb2RlKTtcbiAgQUJPUlQgPSB0cnVlO1xuIH1cbiBxdWl0Xyhjb2RlLCBuZXcgRXhpdFN0YXR1cyhjb2RlKSk7XG59XG5cbmZ1bmN0aW9uIGV4aXRKUyhzdGF0dXMsIGltcGxpY2l0KSB7XG4gRVhJVFNUQVRVUyA9IHN0YXR1cztcbiBjaGVja1VuZmx1c2hlZENvbnRlbnQoKTtcbiBpZiAoa2VlcFJ1bnRpbWVBbGl2ZSgpICYmICFpbXBsaWNpdCkge1xuICB2YXIgbXNnID0gYHByb2dyYW0gZXhpdGVkICh3aXRoIHN0YXR1czogJHtzdGF0dXN9KSwgYnV0IGtlZXBSdW50aW1lQWxpdmUoKSBpcyBzZXQgKGNvdW50ZXI9JHtydW50aW1lS2VlcGFsaXZlQ291bnRlcn0pIGR1ZSB0byBhbiBhc3luYyBvcGVyYXRpb24sIHNvIGhhbHRpbmcgZXhlY3V0aW9uIGJ1dCBub3QgZXhpdGluZyB0aGUgcnVudGltZSBvciBwcmV2ZW50aW5nIGZ1cnRoZXIgYXN5bmMgZXhlY3V0aW9uICh5b3UgY2FuIHVzZSBlbXNjcmlwdGVuX2ZvcmNlX2V4aXQsIGlmIHlvdSB3YW50IHRvIGZvcmNlIGEgdHJ1ZSBzaHV0ZG93bilgO1xuICByZWFkeVByb21pc2VSZWplY3QobXNnKTtcbiAgZXJyKG1zZyk7XG4gfVxuIF9wcm9jX2V4aXQoc3RhdHVzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXhjZXB0aW9uKGUpIHtcbiBpZiAoZSBpbnN0YW5jZW9mIEV4aXRTdGF0dXMgfHwgZSA9PSBcInVud2luZFwiKSB7XG4gIHJldHVybiBFWElUU1RBVFVTO1xuIH1cbiBjaGVja1N0YWNrQ29va2llKCk7XG4gaWYgKGUgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IpIHtcbiAgaWYgKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50KCkgPD0gMCkge1xuICAgZXJyKFwiU3RhY2sgb3ZlcmZsb3cgZGV0ZWN0ZWQuICBZb3UgY2FuIHRyeSBpbmNyZWFzaW5nIC1zU1RBQ0tfU0laRSAoY3VycmVudGx5IHNldCB0byA2NTUzNilcIik7XG4gIH1cbiB9XG4gcXVpdF8oMSwgZSk7XG59XG5cbmZ1bmN0aW9uIGdldENGdW5jKGlkZW50KSB7XG4gdmFyIGZ1bmMgPSBNb2R1bGVbXCJfXCIgKyBpZGVudF07XG4gYXNzZXJ0KGZ1bmMsIFwiQ2Fubm90IGNhbGwgdW5rbm93biBmdW5jdGlvbiBcIiArIGlkZW50ICsgXCIsIG1ha2Ugc3VyZSBpdCBpcyBleHBvcnRlZFwiKTtcbiByZXR1cm4gZnVuYztcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4T25TdGFjayhzdHIpIHtcbiB2YXIgc2l6ZSA9IGxlbmd0aEJ5dGVzVVRGOChzdHIpICsgMTtcbiB2YXIgcmV0ID0gc3RhY2tBbGxvYyhzaXplKTtcbiBzdHJpbmdUb1VURjgoc3RyLCByZXQsIHNpemUpO1xuIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNjYWxsKGlkZW50LCByZXR1cm5UeXBlLCBhcmdUeXBlcywgYXJncywgb3B0cykge1xuIHZhciB0b0MgPSB7XG4gIFwic3RyaW5nXCI6IHN0ciA9PiB7XG4gICB2YXIgcmV0ID0gMDtcbiAgIGlmIChzdHIgIT09IG51bGwgJiYgc3RyICE9PSB1bmRlZmluZWQgJiYgc3RyICE9PSAwKSB7XG4gICAgcmV0ID0gc3RyaW5nVG9VVEY4T25TdGFjayhzdHIpO1xuICAgfVxuICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgXCJhcnJheVwiOiBhcnIgPT4ge1xuICAgdmFyIHJldCA9IHN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7XG4gICB3cml0ZUFycmF5VG9NZW1vcnkoYXJyLCByZXQpO1xuICAgcmV0dXJuIHJldDtcbiAgfVxuIH07XG4gZnVuY3Rpb24gY29udmVydFJldHVyblZhbHVlKHJldCkge1xuICBpZiAocmV0dXJuVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgcmV0dXJuIFVURjhUb1N0cmluZyhyZXQpO1xuICB9XG4gIGlmIChyZXR1cm5UeXBlID09PSBcImJvb2xlYW5cIikgcmV0dXJuIEJvb2xlYW4ocmV0KTtcbiAgcmV0dXJuIHJldDtcbiB9XG4gdmFyIGZ1bmMgPSBnZXRDRnVuYyhpZGVudCk7XG4gdmFyIGNBcmdzID0gW107XG4gdmFyIHN0YWNrID0gMDtcbiBhc3NlcnQocmV0dXJuVHlwZSAhPT0gXCJhcnJheVwiLCAnUmV0dXJuIHR5cGUgc2hvdWxkIG5vdCBiZSBcImFycmF5XCIuJyk7XG4gaWYgKGFyZ3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICB2YXIgY29udmVydGVyID0gdG9DW2FyZ1R5cGVzW2ldXTtcbiAgIGlmIChjb252ZXJ0ZXIpIHtcbiAgICBpZiAoc3RhY2sgPT09IDApIHN0YWNrID0gc3RhY2tTYXZlKCk7XG4gICAgY0FyZ3NbaV0gPSBjb252ZXJ0ZXIoYXJnc1tpXSk7XG4gICB9IGVsc2Uge1xuICAgIGNBcmdzW2ldID0gYXJnc1tpXTtcbiAgIH1cbiAgfVxuIH1cbiB2YXIgcmV0ID0gZnVuYy5hcHBseShudWxsLCBjQXJncyk7XG4gZnVuY3Rpb24gb25Eb25lKHJldCkge1xuICBpZiAoc3RhY2sgIT09IDApIHN0YWNrUmVzdG9yZShzdGFjayk7XG4gIHJldHVybiBjb252ZXJ0UmV0dXJuVmFsdWUocmV0KTtcbiB9XG4gcmV0ID0gb25Eb25lKHJldCk7XG4gcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gY2hlY2tJbmNvbWluZ01vZHVsZUFQSSgpIHtcbiBpZ25vcmVkTW9kdWxlUHJvcChcImZldGNoU2V0dGluZ3NcIik7XG59XG5cbnZhciB3YXNtSW1wb3J0cyA9IHtcbiBcIlhNTF9HZXRCdWZmZXJcIjogX1hNTF9HZXRCdWZmZXIsXG4gXCJYTUxfR2V0RXJyb3JDb2RlXCI6IF9YTUxfR2V0RXJyb3JDb2RlLFxuIFwiWE1MX1BhcnNlXCI6IF9YTUxfUGFyc2UsXG4gXCJYTUxfUGFyc2VCdWZmZXJcIjogX1hNTF9QYXJzZUJ1ZmZlcixcbiBcIlhNTF9QYXJzZXJDcmVhdGVcIjogX1hNTF9QYXJzZXJDcmVhdGUsXG4gXCJYTUxfUGFyc2VyRnJlZVwiOiBfWE1MX1BhcnNlckZyZWUsXG4gXCJYTUxfUmVzdW1lUGFyc2VyXCI6IF9YTUxfUmVzdW1lUGFyc2VyLFxuIFwiWE1MX1NldENoYXJhY3RlckRhdGFIYW5kbGVyXCI6IF9YTUxfU2V0Q2hhcmFjdGVyRGF0YUhhbmRsZXIsXG4gXCJYTUxfU2V0RWxlbWVudEhhbmRsZXJcIjogX1hNTF9TZXRFbGVtZW50SGFuZGxlcixcbiBcIlhNTF9TZXRVc2VyRGF0YVwiOiBfWE1MX1NldFVzZXJEYXRhLFxuIFwiWE1MX1N0b3BQYXJzZXJcIjogX1hNTF9TdG9wUGFyc2VyLFxuIFwiX19hc3NlcnRfZmFpbFwiOiBfX19hc3NlcnRfZmFpbCxcbiBcIl9fZGxzeW1cIjogX19fZGxzeW0sXG4gXCJfX3N5c2NhbGxfX25ld3NlbGVjdFwiOiBfX19zeXNjYWxsX19uZXdzZWxlY3QsXG4gXCJfX3N5c2NhbGxfYmluZFwiOiBfX19zeXNjYWxsX2JpbmQsXG4gXCJfX3N5c2NhbGxfY29ubmVjdFwiOiBfX19zeXNjYWxsX2Nvbm5lY3QsXG4gXCJfX3N5c2NhbGxfZmFjY2Vzc2F0XCI6IF9fX3N5c2NhbGxfZmFjY2Vzc2F0LFxuIFwiX19zeXNjYWxsX2ZjbnRsNjRcIjogX19fc3lzY2FsbF9mY250bDY0LFxuIFwiX19zeXNjYWxsX2ZzdGF0NjRcIjogX19fc3lzY2FsbF9mc3RhdDY0LFxuIFwiX19zeXNjYWxsX2Z0cnVuY2F0ZTY0XCI6IF9fX3N5c2NhbGxfZnRydW5jYXRlNjQsXG4gXCJfX3N5c2NhbGxfZ2V0ZGVudHM2NFwiOiBfX19zeXNjYWxsX2dldGRlbnRzNjQsXG4gXCJfX3N5c2NhbGxfZ2V0cGVlcm5hbWVcIjogX19fc3lzY2FsbF9nZXRwZWVybmFtZSxcbiBcIl9fc3lzY2FsbF9nZXRzb2Nrb3B0XCI6IF9fX3N5c2NhbGxfZ2V0c29ja29wdCxcbiBcIl9fc3lzY2FsbF9pb2N0bFwiOiBfX19zeXNjYWxsX2lvY3RsLFxuIFwiX19zeXNjYWxsX2xzdGF0NjRcIjogX19fc3lzY2FsbF9sc3RhdDY0LFxuIFwiX19zeXNjYWxsX21rZGlyYXRcIjogX19fc3lzY2FsbF9ta2RpcmF0LFxuIFwiX19zeXNjYWxsX25ld2ZzdGF0YXRcIjogX19fc3lzY2FsbF9uZXdmc3RhdGF0LFxuIFwiX19zeXNjYWxsX29wZW5hdFwiOiBfX19zeXNjYWxsX29wZW5hdCxcbiBcIl9fc3lzY2FsbF9yZWN2ZnJvbVwiOiBfX19zeXNjYWxsX3JlY3Zmcm9tLFxuIFwiX19zeXNjYWxsX3JlbmFtZWF0XCI6IF9fX3N5c2NhbGxfcmVuYW1lYXQsXG4gXCJfX3N5c2NhbGxfcm1kaXJcIjogX19fc3lzY2FsbF9ybWRpcixcbiBcIl9fc3lzY2FsbF9zZW5kdG9cIjogX19fc3lzY2FsbF9zZW5kdG8sXG4gXCJfX3N5c2NhbGxfc29ja2V0XCI6IF9fX3N5c2NhbGxfc29ja2V0LFxuIFwiX19zeXNjYWxsX3N0YXQ2NFwiOiBfX19zeXNjYWxsX3N0YXQ2NCxcbiBcIl9fc3lzY2FsbF91bmxpbmthdFwiOiBfX19zeXNjYWxsX3VubGlua2F0LFxuIFwiX190aHJvd19leGNlcHRpb25fd2l0aF9zdGFja190cmFjZVwiOiBfX190aHJvd19leGNlcHRpb25fd2l0aF9zdGFja190cmFjZSxcbiBcIl9lbXNjcmlwdGVuX2dldF9ub3dfaXNfbW9ub3RvbmljXCI6IF9fZW1zY3JpcHRlbl9nZXRfbm93X2lzX21vbm90b25pYyxcbiBcIl9sb2NhbHRpbWVfanNcIjogX19sb2NhbHRpbWVfanMsXG4gXCJfdHpzZXRfanNcIjogX190enNldF9qcyxcbiBcImFib3J0XCI6IF9hYm9ydCxcbiBcImRsb3BlblwiOiBfZGxvcGVuLFxuIFwiZHVja2RiX3dlYl9mc19kaXJlY3RvcnlfY3JlYXRlXCI6IF9kdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9jcmVhdGUsXG4gXCJkdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9leGlzdHNcIjogX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2V4aXN0cyxcbiBcImR1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2xpc3RfZmlsZXNcIjogX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X2xpc3RfZmlsZXMsXG4gXCJkdWNrZGJfd2ViX2ZzX2RpcmVjdG9yeV9yZW1vdmVcIjogX2R1Y2tkYl93ZWJfZnNfZGlyZWN0b3J5X3JlbW92ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZmlsZV9jbG9zZVwiOiBfZHVja2RiX3dlYl9mc19maWxlX2Nsb3NlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX2V4aXN0c1wiOiBfZHVja2RiX3dlYl9mc19maWxlX2V4aXN0cyxcbiBcImR1Y2tkYl93ZWJfZnNfZmlsZV9nZXRfbGFzdF9tb2RpZmllZF90aW1lXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfZ2V0X2xhc3RfbW9kaWZpZWRfdGltZSxcbiBcImR1Y2tkYl93ZWJfZnNfZmlsZV9tb3ZlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfbW92ZSxcbiBcImR1Y2tkYl93ZWJfZnNfZmlsZV9vcGVuXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfb3BlbixcbiBcImR1Y2tkYl93ZWJfZnNfZmlsZV9yZWFkXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfcmVhZCxcbiBcImR1Y2tkYl93ZWJfZnNfZmlsZV90cnVuY2F0ZVwiOiBfZHVja2RiX3dlYl9mc19maWxlX3RydW5jYXRlLFxuIFwiZHVja2RiX3dlYl9mc19maWxlX3dyaXRlXCI6IF9kdWNrZGJfd2ViX2ZzX2ZpbGVfd3JpdGUsXG4gXCJkdWNrZGJfd2ViX2ZzX2dldF9kZWZhdWx0X2RhdGFfcHJvdG9jb2xcIjogX2R1Y2tkYl93ZWJfZnNfZ2V0X2RlZmF1bHRfZGF0YV9wcm90b2NvbCxcbiBcImR1Y2tkYl93ZWJfZnNfZ2xvYlwiOiBfZHVja2RiX3dlYl9mc19nbG9iLFxuIFwiZHVja2RiX3dlYl90ZXN0X3BsYXRmb3JtX2ZlYXR1cmVcIjogX2R1Y2tkYl93ZWJfdGVzdF9wbGF0Zm9ybV9mZWF0dXJlLFxuIFwiZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NhbGxcIjogX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jYWxsLFxuIFwiZW1zY3JpcHRlbl9jb25zb2xlX2Vycm9yXCI6IF9lbXNjcmlwdGVuX2NvbnNvbGVfZXJyb3IsXG4gXCJlbXNjcmlwdGVuX2RhdGVfbm93XCI6IF9lbXNjcmlwdGVuX2RhdGVfbm93LFxuIFwiZW1zY3JpcHRlbl9nZXRfaGVhcF9tYXhcIjogX2Vtc2NyaXB0ZW5fZ2V0X2hlYXBfbWF4LFxuIFwiZW1zY3JpcHRlbl9nZXRfbm93XCI6IF9lbXNjcmlwdGVuX2dldF9ub3csXG4gXCJlbXNjcmlwdGVuX21lbWNweV9iaWdcIjogX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyxcbiBcImVtc2NyaXB0ZW5fcmVzaXplX2hlYXBcIjogX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsXG4gXCJlbnZpcm9uX2dldFwiOiBfZW52aXJvbl9nZXQsXG4gXCJlbnZpcm9uX3NpemVzX2dldFwiOiBfZW52aXJvbl9zaXplc19nZXQsXG4gXCJmZF9jbG9zZVwiOiBfZmRfY2xvc2UsXG4gXCJmZF9mZHN0YXRfZ2V0XCI6IF9mZF9mZHN0YXRfZ2V0LFxuIFwiZmRfcHJlYWRcIjogX2ZkX3ByZWFkLFxuIFwiZmRfcHdyaXRlXCI6IF9mZF9wd3JpdGUsXG4gXCJmZF9yZWFkXCI6IF9mZF9yZWFkLFxuIFwiZmRfc2Vla1wiOiBfZmRfc2VlayxcbiBcImZkX3N5bmNcIjogX2ZkX3N5bmMsXG4gXCJmZF93cml0ZVwiOiBfZmRfd3JpdGUsXG4gXCJnZXRhZGRyaW5mb1wiOiBfZ2V0YWRkcmluZm8sXG4gXCJnZXRlbnRyb3B5XCI6IF9nZXRlbnRyb3B5LFxuIFwiZ2V0bmFtZWluZm9cIjogX2dldG5hbWVpbmZvLFxuIFwic3RyZnRpbWVfbFwiOiBfc3RyZnRpbWVfbCxcbiBcInVjbnZfY2xvc2VfNjRcIjogX3VjbnZfY2xvc2VfNjQsXG4gXCJ1Y252X2NvbnZlcnRFeF82NFwiOiBfdWNudl9jb252ZXJ0RXhfNjQsXG4gXCJ1Y252X29wZW5fNjRcIjogX3VjbnZfb3Blbl82NCxcbiBcInVjbnZfdG9BbGdvcml0aG1pY182NFwiOiBfdWNudl90b0FsZ29yaXRobWljXzY0LFxuIFwidWNzZGV0X2Nsb3NlXzY0XCI6IF91Y3NkZXRfY2xvc2VfNjQsXG4gXCJ1Y3NkZXRfZGV0ZWN0XzY0XCI6IF91Y3NkZXRfZGV0ZWN0XzY0LFxuIFwidWNzZGV0X2dldENvbmZpZGVuY2VfNjRcIjogX3Vjc2RldF9nZXRDb25maWRlbmNlXzY0LFxuIFwidWNzZGV0X2dldE5hbWVfNjRcIjogX3Vjc2RldF9nZXROYW1lXzY0LFxuIFwidWNzZGV0X29wZW5fNjRcIjogX3Vjc2RldF9vcGVuXzY0LFxuIFwidWNzZGV0X3NldFRleHRfNjRcIjogX3Vjc2RldF9zZXRUZXh0XzY0LFxuIFwidW56Q2xvc2VcIjogX3VuekNsb3NlLFxuIFwidW56Q2xvc2VDdXJyZW50RmlsZVwiOiBfdW56Q2xvc2VDdXJyZW50RmlsZSxcbiBcInVuekdldEN1cnJlbnRGaWxlSW5mb1wiOiBfdW56R2V0Q3VycmVudEZpbGVJbmZvLFxuIFwidW56R2V0Q3VycmVudEZpbGVJbmZvNjRcIjogX3VuekdldEN1cnJlbnRGaWxlSW5mbzY0LFxuIFwidW56R2V0R2xvYmFsSW5mb1wiOiBfdW56R2V0R2xvYmFsSW5mbyxcbiBcInVuekdvVG9GaXJzdEZpbGVcIjogX3VuekdvVG9GaXJzdEZpbGUsXG4gXCJ1bnpHb1RvTmV4dEZpbGVcIjogX3VuekdvVG9OZXh0RmlsZSxcbiBcInVuekxvY2F0ZUZpbGVcIjogX3VuekxvY2F0ZUZpbGUsXG4gXCJ1bnpPcGVuXCI6IF91bnpPcGVuLFxuIFwidW56T3BlbjJcIjogX3Vuek9wZW4yLFxuIFwidW56T3BlbkN1cnJlbnRGaWxlXCI6IF91bnpPcGVuQ3VycmVudEZpbGUsXG4gXCJ1bnpSZWFkQ3VycmVudEZpbGVcIjogX3VuelJlYWRDdXJyZW50RmlsZVxufTtcblxudmFyIGFzbSA9IGNyZWF0ZVdhc20oKTtcblxudmFyIF9fX3dhc21fY2FsbF9jdG9ycyA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX3dhc21fY2FsbF9jdG9yc1wiKTtcblxudmFyIF9tYWluID0gTW9kdWxlW1wiX21haW5cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibWFpblwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX2dsb2JfYWRkX3BhdGggPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nbG9iX2FkZF9wYXRoXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2xvYl9hZGRfcGF0aFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2NsZWFyX3Jlc3BvbnNlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfY2xlYXJfcmVzcG9uc2VcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jbGVhcl9yZXNwb25zZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZhaWxfd2l0aCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZhaWxfd2l0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZhaWxfd2l0aFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3Jlc2V0ID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcmVzZXRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9yZXNldFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2Nvbm5lY3QgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jb25uZWN0XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfY29ubmVjdFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2Rpc2Nvbm5lY3QgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9kaXNjb25uZWN0XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZGlzY29ubmVjdFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGVzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZmx1c2hfZmlsZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mbHVzaF9maWxlc1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZsdXNoX2ZpbGUgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mbHVzaF9maWxlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZmx1c2hfZmlsZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX29wZW4gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9vcGVuXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfb3BlblwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2dldF9nbG9iYWxfZmlsZV9pbmZvID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X2dsb2JhbF9maWxlX2luZm9cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9nZXRfZ2xvYmFsX2ZpbGVfaW5mb1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0cyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0c1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2NvbGxlY3RfZmlsZV9zdGF0c1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2V4cG9ydF9maWxlX3N0YXRzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZXhwb3J0X2ZpbGVfc3RhdHNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9leHBvcnRfZmlsZV9zdGF0c1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX2Ryb3BfZmlsZXMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19kcm9wX2ZpbGVzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZHJvcF9maWxlc1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvcyA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvc1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX2dsb2JfZmlsZV9pbmZvc1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfaWQgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9mc19nZXRfZmlsZV9pbmZvX2J5X2lkXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfZnNfZ2V0X2ZpbGVfaW5mb19ieV9pZFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2ZzX2dldF9maWxlX2luZm9fYnlfbmFtZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfdXJsID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV91cmxcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX3VybFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2ZzX3JlZ2lzdGVyX2ZpbGVfYnVmZmVyID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZnNfcmVnaXN0ZXJfZmlsZV9idWZmZXJcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9mc19yZWdpc3Rlcl9maWxlX2J1ZmZlclwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19idWZmZXIgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fYnVmZmVyXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfY29weV9maWxlX3RvX2J1ZmZlclwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2NvcHlfZmlsZV90b19wYXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfY29weV9maWxlX3RvX3BhdGhcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9jb3B5X2ZpbGVfdG9fcGF0aFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2dldF92ZXJzaW9uID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X3ZlcnNpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9nZXRfdmVyc2lvblwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2dldF9mZWF0dXJlX2ZsYWdzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X2ZlYXR1cmVfZmxhZ3NcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9nZXRfZmVhdHVyZV9mbGFnc1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX3Rva2VuaXplID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfdG9rZW5pemVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl90b2tlbml6ZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3VkZl9zY2FsYXJfY3JlYXRlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfdWRmX3NjYWxhcl9jcmVhdGVcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl91ZGZfc2NhbGFyX2NyZWF0ZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3ByZXBhcmVkX2NyZWF0ZSA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX2NyZWF0ZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3ByZXBhcmVkX2NyZWF0ZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3ByZXBhcmVkX2Nsb3NlID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcHJlcGFyZWRfY2xvc2VcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wcmVwYXJlZF9jbG9zZVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3ByZXBhcmVkX3J1biA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3ByZXBhcmVkX3J1blwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3ByZXBhcmVkX3J1blwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3ByZXBhcmVkX3NlbmQgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wcmVwYXJlZF9zZW5kXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcHJlcGFyZWRfc2VuZFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3F1ZXJ5X3J1biA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3F1ZXJ5X3J1blwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3F1ZXJ5X3J1blwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfc3RhcnQgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X3N0YXJ0XCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9zdGFydFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfcG9sbFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3BlbmRpbmdfcXVlcnlfY2FuY2VsID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfcGVuZGluZ19xdWVyeV9jYW5jZWxcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9wZW5kaW5nX3F1ZXJ5X2NhbmNlbFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX3F1ZXJ5X2ZldGNoX3Jlc3VsdHMgPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9xdWVyeV9mZXRjaF9yZXN1bHRzXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfcXVlcnlfZmV0Y2hfcmVzdWx0c1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2dldF90YWJsZW5hbWVzID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfZ2V0X3RhYmxlbmFtZXNcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9nZXRfdGFibGVuYW1lc1wiKTtcblxudmFyIF9kdWNrZGJfd2ViX2luc2VydF9hcnJvd19mcm9tX2lwY19zdHJlYW0gPSBNb2R1bGVbXCJfZHVja2RiX3dlYl9pbnNlcnRfYXJyb3dfZnJvbV9pcGNfc3RyZWFtXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR1Y2tkYl93ZWJfaW5zZXJ0X2Fycm93X2Zyb21faXBjX3N0cmVhbVwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2luc2VydF9jc3ZfZnJvbV9wYXRoID0gTW9kdWxlW1wiX2R1Y2tkYl93ZWJfaW5zZXJ0X2Nzdl9mcm9tX3BhdGhcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHVja2RiX3dlYl9pbnNlcnRfY3N2X2Zyb21fcGF0aFwiKTtcblxudmFyIF9kdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aCA9IE1vZHVsZVtcIl9kdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkdWNrZGJfd2ViX2luc2VydF9qc29uX2Zyb21fcGF0aFwiKTtcblxudmFyIF9fX2Vycm5vX2xvY2F0aW9uID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcIl9fZXJybm9fbG9jYXRpb25cIik7XG5cbnZhciBfZmZsdXNoID0gTW9kdWxlW1wiX2ZmbHVzaFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJmZmx1c2hcIik7XG5cbnZhciBfaHRvbmwgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiaHRvbmxcIik7XG5cbnZhciBfaHRvbnMgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiaHRvbnNcIik7XG5cbnZhciBfbnRvaHMgPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwibnRvaHNcIik7XG5cbnZhciBfbWFsbG9jID0gTW9kdWxlW1wiX21hbGxvY1wiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJtYWxsb2NcIik7XG5cbnZhciBfZnJlZSA9IE1vZHVsZVtcIl9mcmVlXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImZyZWVcIik7XG5cbnZhciBfX190cmFwID0gZnVuY3Rpb24oKSB7XG4gcmV0dXJuIChfX190cmFwID0gTW9kdWxlW1wiYXNtXCJdW1wiX190cmFwXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2luaXQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2luaXRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2ZyZWUgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVlID0gTW9kdWxlW1wiYXNtXCJdW1wiZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZVwiXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZSA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2Jhc2UgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlXCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSBmdW5jdGlvbigpIHtcbiByZXR1cm4gKF9lbXNjcmlwdGVuX3N0YWNrX2dldF9lbmQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9lbmRcIl0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgc3RhY2tTYXZlID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrU2F2ZVwiKTtcblxudmFyIHN0YWNrUmVzdG9yZSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJzdGFja1Jlc3RvcmVcIik7XG5cbnZhciBzdGFja0FsbG9jID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcInN0YWNrQWxsb2NcIik7XG5cbnZhciBfZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudCA9IGZ1bmN0aW9uKCkge1xuIHJldHVybiAoX2Vtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQgPSBNb2R1bGVbXCJhc21cIl1bXCJlbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50XCJdKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIF9fX2N4YV9kZWNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50ID0gTW9kdWxlW1wiX19fY3hhX2RlY3JlbWVudF9leGNlcHRpb25fcmVmY291bnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19jeGFfZGVjcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiKTtcblxudmFyIF9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50ID0gTW9kdWxlW1wiX19fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnRcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiKTtcblxudmFyIF9fX3Rocm93bl9vYmplY3RfZnJvbV91bndpbmRfZXhjZXB0aW9uID0gTW9kdWxlW1wiX19fdGhyb3duX29iamVjdF9mcm9tX3Vud2luZF9leGNlcHRpb25cIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiX190aHJvd25fb2JqZWN0X2Zyb21fdW53aW5kX2V4Y2VwdGlvblwiKTtcblxudmFyIF9fX2dldF9leGNlcHRpb25fbWVzc2FnZSA9IE1vZHVsZVtcIl9fX2dldF9leGNlcHRpb25fbWVzc2FnZVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJfX2dldF9leGNlcHRpb25fbWVzc2FnZVwiKTtcblxudmFyIGR5bkNhbGxfamlqaSA9IE1vZHVsZVtcImR5bkNhbGxfamlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppamlcIik7XG5cbnZhciBkeW5DYWxsX2lpaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9paWlpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlpaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfaWlpaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWlpaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpaWlpampcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWpqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWpqaVwiKTtcblxudmFyIGR5bkNhbGxfaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2ppID0gTW9kdWxlW1wiZHluQ2FsbF9qaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpalwiKTtcblxudmFyIGR5bkNhbGxfdmlqID0gTW9kdWxlW1wiZHluQ2FsbF92aWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpcIik7XG5cbnZhciBkeW5DYWxsX3ZqamlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZqamlqaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92amppamlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWpqamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpampqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpampqaVwiKTtcblxudmFyIGR5bkNhbGxfdmpqaWkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZqamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmpqaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlpaWppID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlpaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfamlpaWogPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWpcIik7XG5cbnZhciBkeW5DYWxsX2ppamppaiA9IE1vZHVsZVtcImR5bkNhbGxfamlqamlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqamlqXCIpO1xuXG52YXIgZHluQ2FsbF9paWlqID0gTW9kdWxlW1wiZHluQ2FsbF9paWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlpalwiKTtcblxudmFyIGR5bkNhbGxfdmlqamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpampqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlqampcIik7XG5cbnZhciBkeW5DYWxsX3ZpamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWpqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqalwiKTtcblxudmFyIGR5bkNhbGxfamlpamlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlqaWlcIik7XG5cbnZhciBkeW5DYWxsX2ppamlpaSA9IE1vZHVsZVtcImR5bkNhbGxfamlqaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaWlpXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWlpaWkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlpaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpamlpaWppID0gTW9kdWxlW1wiZHluQ2FsbF92aWppaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpamlpaWppXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlpalwiKTtcblxudmFyIGR5bkNhbGxfamlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqaWogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlqaWlqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpamlpalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWlpampcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamppXCIpO1xuXG52YXIgZHluQ2FsbF92aWppaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWppaVwiKTtcblxudmFyIGR5bkNhbGxfaWlpaWlqaSA9IE1vZHVsZVtcImR5bkNhbGxfaWlpaWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2lpaWlpamlcIik7XG5cbnZhciBkeW5DYWxsX2lpaiA9IE1vZHVsZVtcImR5bkNhbGxfaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9paWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfaWlpampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9paWlqalwiKTtcblxudmFyIGR5bkNhbGxfaWlqaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2lpamlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlqaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWppXCIpO1xuXG52YXIgZHluQ2FsbF9paWppID0gTW9kdWxlW1wiZHluQ2FsbF9paWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWlqaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpampqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqampcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqaiA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWpqXCIpO1xuXG52YXIgZHluQ2FsbF9qaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqalwiKTtcblxudmFyIGR5bkNhbGxfamlpaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qaWlpaWlcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaWlpXCIpO1xuXG52YXIgZHluQ2FsbF9qaWkgPSBNb2R1bGVbXCJkeW5DYWxsX2ppaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2ppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaWpcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWpcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlqID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpalwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9qID0gTW9kdWxlW1wiZHluQ2FsbF9qXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWppaWlpamogPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqaWlpaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWppaWlpampcIik7XG5cbnZhciBkeW5DYWxsX2ppaWlpaiA9IE1vZHVsZVtcImR5bkNhbGxfamlpaWlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlqXCIpO1xuXG52YXIgZHluQ2FsbF9qaiA9IE1vZHVsZVtcImR5bkNhbGxfampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9qalwiKTtcblxudmFyIGR5bkNhbGxfaWogPSBNb2R1bGVbXCJkeW5DYWxsX2lqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfaWpcIik7XG5cbnZhciBkeW5DYWxsX2lqamogPSBNb2R1bGVbXCJkeW5DYWxsX2lqampcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF9pampqXCIpO1xuXG52YXIgZHluQ2FsbF9qampkID0gTW9kdWxlW1wiZHluQ2FsbF9qampkXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfampqZFwiKTtcblxudmFyIGR5bkNhbGxfampqampqZCA9IE1vZHVsZVtcImR5bkNhbGxfampqampqZFwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX2pqampqamRcIik7XG5cbnZhciBkeW5DYWxsX2ppaiA9IE1vZHVsZVtcImR5bkNhbGxfamlqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqXCIpO1xuXG52YXIgZHluQ2FsbF92aWlpamlpaWppaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpaWppaWlqaWlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlpaWppaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpamlqaWlpaSA9IE1vZHVsZVtcImR5bkNhbGxfdmlpamlqaWlpaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppamlpaWlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppID0gTW9kdWxlW1wiZHluQ2FsbF92aWlqaVwiXSA9IGNyZWF0ZUV4cG9ydFdyYXBwZXIoXCJkeW5DYWxsX3ZpaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpaWpqID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpaWpqXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaWlqalwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWppID0gTW9kdWxlW1wiZHluQ2FsbF92aWlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWlpamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlpamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlpaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWppaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWppaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlqaWlpaVwiKTtcblxudmFyIGR5bkNhbGxfdmlpaWppamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWlqaWppXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfdmlpaWppamlcIik7XG5cbnZhciBkeW5DYWxsX3ZpaWppamkgPSBNb2R1bGVbXCJkeW5DYWxsX3ZpaWppamlcIl0gPSBjcmVhdGVFeHBvcnRXcmFwcGVyKFwiZHluQ2FsbF92aWlqaWppXCIpO1xuXG52YXIgZHluQ2FsbF9qaWlpID0gTW9kdWxlW1wiZHluQ2FsbF9qaWlpXCJdID0gY3JlYXRlRXhwb3J0V3JhcHBlcihcImR5bkNhbGxfamlpaVwiKTtcblxuTW9kdWxlW1wic3RhY2tBbGxvY1wiXSA9IHN0YWNrQWxsb2M7XG5cbk1vZHVsZVtcInN0YWNrU2F2ZVwiXSA9IHN0YWNrU2F2ZTtcblxuTW9kdWxlW1wic3RhY2tSZXN0b3JlXCJdID0gc3RhY2tSZXN0b3JlO1xuXG5Nb2R1bGVbXCJjY2FsbFwiXSA9IGNjYWxsO1xuXG52YXIgbWlzc2luZ0xpYnJhcnlTeW1ib2xzID0gWyBcImdldEhvc3RCeU5hbWVcIiwgXCJ0cmF2ZXJzZVN0YWNrXCIsIFwiZ2V0Q2FsbHN0YWNrXCIsIFwiZW1zY3JpcHRlbkxvZ1wiLCBcImNvbnZlcnRQQ3RvU291cmNlTG9jYXRpb25cIiwgXCJyZWFkRW1Bc21BcmdzXCIsIFwianN0b2lfc1wiLCBcImxpc3Rlbk9uY2VcIiwgXCJhdXRvUmVzdW1lQXVkaW9Db250ZXh0XCIsIFwiZHluQ2FsbExlZ2FjeVwiLCBcImdldER5bkNhbGxlclwiLCBcImR5bkNhbGxcIiwgXCJydW50aW1lS2VlcGFsaXZlUHVzaFwiLCBcInJ1bnRpbWVLZWVwYWxpdmVQb3BcIiwgXCJjYWxsVXNlckNhbGxiYWNrXCIsIFwibWF5YmVFeGl0XCIsIFwic2FmZVNldFRpbWVvdXRcIiwgXCJhc21qc01hbmdsZVwiLCBcImFzeW5jTG9hZFwiLCBcImFsaWduTWVtb3J5XCIsIFwibW1hcEFsbG9jXCIsIFwiSGFuZGxlQWxsb2NhdG9yXCIsIFwiZ2V0TmF0aXZlVHlwZVNpemVcIiwgXCJTVEFDS19TSVpFXCIsIFwiU1RBQ0tfQUxJR05cIiwgXCJQT0lOVEVSX1NJWkVcIiwgXCJBU1NFUlRJT05TXCIsIFwid3JpdGVJNTNUb0k2NFwiLCBcIndyaXRlSTUzVG9JNjRDbGFtcGVkXCIsIFwid3JpdGVJNTNUb0k2NFNpZ25hbGluZ1wiLCBcIndyaXRlSTUzVG9VNjRDbGFtcGVkXCIsIFwid3JpdGVJNTNUb1U2NFNpZ25hbGluZ1wiLCBcInJlYWRJNTNGcm9tVTY0XCIsIFwiY29udmVydEkzMlBhaXJUb0k1M1wiLCBcImNvbnZlcnRVMzJQYWlyVG9JNTNcIiwgXCJjd3JhcFwiLCBcInVsZWIxMjhFbmNvZGVcIiwgXCJzaWdUb1dhc21UeXBlc1wiLCBcImdlbmVyYXRlRnVuY1R5cGVcIiwgXCJjb252ZXJ0SnNGdW5jdGlvblRvV2FzbVwiLCBcImdldEVtcHR5VGFibGVTbG90XCIsIFwidXBkYXRlVGFibGVNYXBcIiwgXCJnZXRGdW5jdGlvbkFkZHJlc3NcIiwgXCJhZGRGdW5jdGlvblwiLCBcInJlbW92ZUZ1bmN0aW9uXCIsIFwicmVhbGx5TmVnYXRpdmVcIiwgXCJ1blNpZ25cIiwgXCJzdHJMZW5cIiwgXCJyZVNpZ25cIiwgXCJmb3JtYXRTdHJpbmdcIiwgXCJpbnRBcnJheVRvU3RyaW5nXCIsIFwiQXNjaWlUb1N0cmluZ1wiLCBcIlVURjE2VG9TdHJpbmdcIiwgXCJzdHJpbmdUb1VURjE2XCIsIFwibGVuZ3RoQnl0ZXNVVEYxNlwiLCBcIlVURjMyVG9TdHJpbmdcIiwgXCJzdHJpbmdUb1VURjMyXCIsIFwibGVuZ3RoQnl0ZXNVVEYzMlwiLCBcInJlZ2lzdGVyS2V5RXZlbnRDYWxsYmFja1wiLCBcIm1heWJlQ1N0cmluZ1RvSnNTdHJpbmdcIiwgXCJmaW5kRXZlbnRUYXJnZXRcIiwgXCJmaW5kQ2FudmFzRXZlbnRUYXJnZXRcIiwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiwgXCJmaWxsTW91c2VFdmVudERhdGFcIiwgXCJyZWdpc3Rlck1vdXNlRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyV2hlZWxFdmVudENhbGxiYWNrXCIsIFwicmVnaXN0ZXJVaUV2ZW50Q2FsbGJhY2tcIiwgXCJyZWdpc3RlckZvY3VzRXZlbnRDYWxsYmFja1wiLCBcImZpbGxEZXZpY2VPcmllbnRhdGlvbkV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyRGV2aWNlT3JpZW50YXRpb25FdmVudENhbGxiYWNrXCIsIFwiZmlsbERldmljZU1vdGlvbkV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyRGV2aWNlTW90aW9uRXZlbnRDYWxsYmFja1wiLCBcInNjcmVlbk9yaWVudGF0aW9uXCIsIFwiZmlsbE9yaWVudGF0aW9uQ2hhbmdlRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJPcmllbnRhdGlvbkNoYW5nZUV2ZW50Q2FsbGJhY2tcIiwgXCJmaWxsRnVsbHNjcmVlbkNoYW5nZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyRnVsbHNjcmVlbkNoYW5nZUV2ZW50Q2FsbGJhY2tcIiwgXCJKU0V2ZW50c19yZXF1ZXN0RnVsbHNjcmVlblwiLCBcIkpTRXZlbnRzX3Jlc2l6ZUNhbnZhc0ZvckZ1bGxzY3JlZW5cIiwgXCJyZWdpc3RlclJlc3RvcmVPbGRTdHlsZVwiLCBcImhpZGVFdmVyeXRoaW5nRXhjZXB0R2l2ZW5FbGVtZW50XCIsIFwicmVzdG9yZUhpZGRlbkVsZW1lbnRzXCIsIFwic2V0TGV0dGVyYm94XCIsIFwic29mdEZ1bGxzY3JlZW5SZXNpemVXZWJHTFJlbmRlclRhcmdldFwiLCBcImRvUmVxdWVzdEZ1bGxzY3JlZW5cIiwgXCJmaWxsUG9pbnRlcmxvY2tDaGFuZ2VFdmVudERhdGFcIiwgXCJyZWdpc3RlclBvaW50ZXJsb2NrQ2hhbmdlRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyUG9pbnRlcmxvY2tFcnJvckV2ZW50Q2FsbGJhY2tcIiwgXCJyZXF1ZXN0UG9pbnRlckxvY2tcIiwgXCJmaWxsVmlzaWJpbGl0eUNoYW5nZUV2ZW50RGF0YVwiLCBcInJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUV2ZW50Q2FsbGJhY2tcIiwgXCJyZWdpc3RlclRvdWNoRXZlbnRDYWxsYmFja1wiLCBcImZpbGxHYW1lcGFkRXZlbnREYXRhXCIsIFwicmVnaXN0ZXJHYW1lcGFkRXZlbnRDYWxsYmFja1wiLCBcInJlZ2lzdGVyQmVmb3JlVW5sb2FkRXZlbnRDYWxsYmFja1wiLCBcImZpbGxCYXR0ZXJ5RXZlbnREYXRhXCIsIFwiYmF0dGVyeVwiLCBcInJlZ2lzdGVyQmF0dGVyeUV2ZW50Q2FsbGJhY2tcIiwgXCJzZXRDYW52YXNFbGVtZW50U2l6ZVwiLCBcImdldENhbnZhc0VsZW1lbnRTaXplXCIsIFwiZGVtYW5nbGVcIiwgXCJkZW1hbmdsZUFsbFwiLCBcImpzU3RhY2tUcmFjZVwiLCBcInN0YWNrVHJhY2VcIiwgXCJjaGVja1dhc2lDbG9ja1wiLCBcIndhc2lSaWdodHNUb011c2xPRmxhZ3NcIiwgXCJ3YXNpT0ZsYWdzVG9NdXNsT0ZsYWdzXCIsIFwiY3JlYXRlRHluY2FsbFdyYXBwZXJcIiwgXCJzZXRJbW1lZGlhdGVXcmFwcGVkXCIsIFwiY2xlYXJJbW1lZGlhdGVXcmFwcGVkXCIsIFwicG9seWZpbGxTZXRJbW1lZGlhdGVcIiwgXCJnZXRQcm9taXNlXCIsIFwibWFrZVByb21pc2VcIiwgXCJpZHNUb1Byb21pc2VzXCIsIFwibWFrZVByb21pc2VDYWxsYmFja1wiLCBcInNldE1haW5Mb29wXCIsIFwiaGVhcE9iamVjdEZvcldlYkdMVHlwZVwiLCBcImhlYXBBY2Nlc3NTaGlmdEZvcldlYkdMSGVhcFwiLCBcIndlYmdsX2VuYWJsZV9BTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIsIFwid2ViZ2xfZW5hYmxlX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0XCIsIFwid2ViZ2xfZW5hYmxlX1dFQkdMX2RyYXdfYnVmZmVyc1wiLCBcIndlYmdsX2VuYWJsZV9XRUJHTF9tdWx0aV9kcmF3XCIsIFwiZW1zY3JpcHRlbldlYkdMR2V0XCIsIFwiY29tcHV0ZVVucGFja0FsaWduZWRJbWFnZVNpemVcIiwgXCJjb2xvckNoYW5uZWxzSW5HbFRleHR1cmVGb3JtYXRcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRUZXhQaXhlbERhdGFcIiwgXCJfX2dsR2VuT2JqZWN0XCIsIFwiZW1zY3JpcHRlbldlYkdMR2V0VW5pZm9ybVwiLCBcIndlYmdsR2V0VW5pZm9ybUxvY2F0aW9uXCIsIFwid2ViZ2xQcmVwYXJlVW5pZm9ybUxvY2F0aW9uc0JlZm9yZUZpcnN0VXNlXCIsIFwid2ViZ2xHZXRMZWZ0QnJhY2VQb3NcIiwgXCJlbXNjcmlwdGVuV2ViR0xHZXRWZXJ0ZXhBdHRyaWJcIiwgXCJfX2dsR2V0QWN0aXZlQXR0cmliT3JVbmlmb3JtXCIsIFwid3JpdGVHTEFycmF5XCIsIFwicmVnaXN0ZXJXZWJHbEV2ZW50Q2FsbGJhY2tcIiwgXCJydW5BbmRBYm9ydElmRXJyb3JcIiwgXCJTRExfdW5pY29kZVwiLCBcIlNETF90dGZDb250ZXh0XCIsIFwiU0RMX2F1ZGlvXCIsIFwiR0xGV19XaW5kb3dcIiwgXCJBTExPQ19OT1JNQUxcIiwgXCJBTExPQ19TVEFDS1wiLCBcImFsbG9jYXRlXCIsIFwid3JpdGVTdHJpbmdUb01lbW9yeVwiLCBcIndyaXRlQXNjaWlUb01lbW9yeVwiIF07XG5cbm1pc3NpbmdMaWJyYXJ5U3ltYm9scy5mb3JFYWNoKG1pc3NpbmdMaWJyYXJ5U3ltYm9sKTtcblxudmFyIHVuZXhwb3J0ZWRTeW1ib2xzID0gWyBcInJ1blwiLCBcImFkZE9uUHJlUnVuXCIsIFwiYWRkT25Jbml0XCIsIFwiYWRkT25QcmVNYWluXCIsIFwiYWRkT25FeGl0XCIsIFwiYWRkT25Qb3N0UnVuXCIsIFwiYWRkUnVuRGVwZW5kZW5jeVwiLCBcInJlbW92ZVJ1bkRlcGVuZGVuY3lcIiwgXCJGU19jcmVhdGVGb2xkZXJcIiwgXCJGU19jcmVhdGVQYXRoXCIsIFwiRlNfY3JlYXRlRGF0YUZpbGVcIiwgXCJGU19jcmVhdGVMYXp5RmlsZVwiLCBcIkZTX2NyZWF0ZUxpbmtcIiwgXCJGU19jcmVhdGVEZXZpY2VcIiwgXCJGU191bmxpbmtcIiwgXCJvdXRcIiwgXCJlcnJcIiwgXCJjYWxsTWFpblwiLCBcImFib3J0XCIsIFwia2VlcFJ1bnRpbWVBbGl2ZVwiLCBcIndhc21NZW1vcnlcIiwgXCJnZXRUZW1wUmV0MFwiLCBcInNldFRlbXBSZXQwXCIsIFwid3JpdGVTdGFja0Nvb2tpZVwiLCBcImNoZWNrU3RhY2tDb29raWVcIiwgXCJwdHJUb1N0cmluZ1wiLCBcInplcm9NZW1vcnlcIiwgXCJleGl0SlNcIiwgXCJnZXRIZWFwTWF4XCIsIFwiZW1zY3JpcHRlbl9yZWFsbG9jX2J1ZmZlclwiLCBcIkVOVlwiLCBcIk1PTlRIX0RBWVNfUkVHVUxBUlwiLCBcIk1PTlRIX0RBWVNfTEVBUFwiLCBcIk1PTlRIX0RBWVNfUkVHVUxBUl9DVU1VTEFUSVZFXCIsIFwiTU9OVEhfREFZU19MRUFQX0NVTVVMQVRJVkVcIiwgXCJpc0xlYXBZZWFyXCIsIFwieWRheUZyb21EYXRlXCIsIFwiYXJyYXlTdW1cIiwgXCJhZGREYXlzXCIsIFwiRVJSTk9fQ09ERVNcIiwgXCJFUlJOT19NRVNTQUdFU1wiLCBcInNldEVyck5vXCIsIFwiaW5ldFB0b240XCIsIFwiaW5ldE50b3A0XCIsIFwiaW5ldFB0b242XCIsIFwiaW5ldE50b3A2XCIsIFwicmVhZFNvY2thZGRyXCIsIFwid3JpdGVTb2NrYWRkclwiLCBcIkROU1wiLCBcIlByb3RvY29sc1wiLCBcIlNvY2tldHNcIiwgXCJpbml0UmFuZG9tRmlsbFwiLCBcInJhbmRvbUZpbGxcIiwgXCJ0aW1lcnNcIiwgXCJ3YXJuT25jZVwiLCBcIlVOV0lORF9DQUNIRVwiLCBcInJlYWRFbUFzbUFyZ3NBcnJheVwiLCBcImpzdG9pX3FcIiwgXCJnZXRFeGVjdXRhYmxlTmFtZVwiLCBcImhhbmRsZUV4Y2VwdGlvblwiLCBcInJlYWRJNTNGcm9tSTY0XCIsIFwiY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWRcIiwgXCJnZXRDRnVuY1wiLCBcImZyZWVUYWJsZUluZGV4ZXNcIiwgXCJmdW5jdGlvbnNJblRhYmxlTWFwXCIsIFwic2V0VmFsdWVcIiwgXCJnZXRWYWx1ZVwiLCBcIlBBVEhcIiwgXCJQQVRIX0ZTXCIsIFwiVVRGOERlY29kZXJcIiwgXCJVVEY4QXJyYXlUb1N0cmluZ1wiLCBcIlVURjhUb1N0cmluZ1wiLCBcInN0cmluZ1RvVVRGOEFycmF5XCIsIFwic3RyaW5nVG9VVEY4XCIsIFwibGVuZ3RoQnl0ZXNVVEY4XCIsIFwiaW50QXJyYXlGcm9tU3RyaW5nXCIsIFwic3RyaW5nVG9Bc2NpaVwiLCBcIlVURjE2RGVjb2RlclwiLCBcInN0cmluZ1RvTmV3VVRGOFwiLCBcInN0cmluZ1RvVVRGOE9uU3RhY2tcIiwgXCJ3cml0ZUFycmF5VG9NZW1vcnlcIiwgXCJKU0V2ZW50c1wiLCBcInNwZWNpYWxIVE1MVGFyZ2V0c1wiLCBcImN1cnJlbnRGdWxsc2NyZWVuU3RyYXRlZ3lcIiwgXCJyZXN0b3JlT2xkV2luZG93ZWRTdHlsZVwiLCBcIkV4aXRTdGF0dXNcIiwgXCJnZXRFbnZTdHJpbmdzXCIsIFwiZmx1c2hfTk9fRklMRVNZU1RFTVwiLCBcImRsb3Blbk1pc3NpbmdFcnJvclwiLCBcInByb21pc2VNYXBcIiwgXCJnZXRFeGNlcHRpb25NZXNzYWdlQ29tbW9uXCIsIFwiZ2V0Q3BwRXhjZXB0aW9uVGFnXCIsIFwiZ2V0Q3BwRXhjZXB0aW9uVGhyb3duT2JqZWN0RnJvbVdlYkFzc2VtYmx5RXhjZXB0aW9uXCIsIFwiaW5jcmVtZW50RXhjZXB0aW9uUmVmY291bnRcIiwgXCJkZWNyZW1lbnRFeGNlcHRpb25SZWZjb3VudFwiLCBcImdldEV4Y2VwdGlvbk1lc3NhZ2VcIiwgXCJCcm93c2VyXCIsIFwid2dldFwiLCBcIlNZU0NBTExTXCIsIFwiZ2V0U29ja2V0RnJvbUZEXCIsIFwiZ2V0U29ja2V0QWRkcmVzc1wiLCBcInRlbXBGaXhlZExlbmd0aEFycmF5XCIsIFwibWluaVRlbXBXZWJHTEZsb2F0QnVmZmVyc1wiLCBcIm1pbmlUZW1wV2ViR0xJbnRCdWZmZXJzXCIsIFwiR0xcIiwgXCJlbXNjcmlwdGVuX3dlYmdsX3Bvd2VyX3ByZWZlcmVuY2VzXCIsIFwiQUxcIiwgXCJHTFVUXCIsIFwiRUdMXCIsIFwiR0xFV1wiLCBcIklEQlN0b3JlXCIsIFwiU0RMXCIsIFwiU0RMX2dmeFwiLCBcIkdMRldcIiwgXCJhbGxvY2F0ZVVURjhcIiwgXCJhbGxvY2F0ZVVURjhPblN0YWNrXCIsIFwiU09DS0ZTXCIsIFwiRlNcIiBdO1xuXG51bmV4cG9ydGVkU3ltYm9scy5mb3JFYWNoKHVuZXhwb3J0ZWRSdW50aW1lU3ltYm9sKTtcblxudmFyIGNhbGxlZFJ1bjtcblxuZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gZnVuY3Rpb24gcnVuQ2FsbGVyKCkge1xuIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiBpZiAoIWNhbGxlZFJ1bikgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyO1xufTtcblxuZnVuY3Rpb24gY2FsbE1haW4oKSB7XG4gYXNzZXJ0KHJ1bkRlcGVuZGVuY2llcyA9PSAwLCAnY2Fubm90IGNhbGwgbWFpbiB3aGVuIGFzeW5jIGRlcGVuZGVuY2llcyByZW1haW4hIChsaXN0ZW4gb24gTW9kdWxlW1wib25SdW50aW1lSW5pdGlhbGl6ZWRcIl0pJyk7XG4gYXNzZXJ0KF9fQVRQUkVSVU5fXy5sZW5ndGggPT0gMCwgXCJjYW5ub3QgY2FsbCBtYWluIHdoZW4gcHJlUnVuIGZ1bmN0aW9ucyByZW1haW4gdG8gYmUgY2FsbGVkXCIpO1xuIHZhciBlbnRyeUZ1bmN0aW9uID0gX21haW47XG4gdmFyIGFyZ2MgPSAwO1xuIHZhciBhcmd2ID0gMDtcbiB0cnkge1xuICB2YXIgcmV0ID0gZW50cnlGdW5jdGlvbihhcmdjLCBhcmd2KTtcbiAgZXhpdEpTKHJldCwgdHJ1ZSk7XG4gIHJldHVybiByZXQ7XG4gfSBjYXRjaCAoZSkge1xuICByZXR1cm4gaGFuZGxlRXhjZXB0aW9uKGUpO1xuIH1cbn1cblxuZnVuY3Rpb24gc3RhY2tDaGVja0luaXQoKSB7XG4gX2Vtc2NyaXB0ZW5fc3RhY2tfaW5pdCgpO1xuIHdyaXRlU3RhY2tDb29raWUoKTtcbn1cblxuZnVuY3Rpb24gcnVuKCkge1xuIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gIHJldHVybjtcbiB9XG4gc3RhY2tDaGVja0luaXQoKTtcbiBwcmVSdW4oKTtcbiBpZiAocnVuRGVwZW5kZW5jaWVzID4gMCkge1xuICByZXR1cm47XG4gfVxuIGZ1bmN0aW9uIGRvUnVuKCkge1xuICBpZiAoY2FsbGVkUnVuKSByZXR1cm47XG4gIGNhbGxlZFJ1biA9IHRydWU7XG4gIE1vZHVsZVtcImNhbGxlZFJ1blwiXSA9IHRydWU7XG4gIGlmIChBQk9SVCkgcmV0dXJuO1xuICBpbml0UnVudGltZSgpO1xuICBwcmVNYWluKCk7XG4gIHJlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtcbiAgaWYgKE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKSBNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSgpO1xuICBpZiAoc2hvdWxkUnVuTm93KSBjYWxsTWFpbigpO1xuICBwb3N0UnVuKCk7XG4gfVxuIGlmIChNb2R1bGVbXCJzZXRTdGF0dXNcIl0pIHtcbiAgTW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiUnVubmluZy4uLlwiKTtcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgTW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiXCIpO1xuICAgfSwgMSk7XG4gICBkb1J1bigpO1xuICB9LCAxKTtcbiB9IGVsc2Uge1xuICBkb1J1bigpO1xuIH1cbiBjaGVja1N0YWNrQ29va2llKCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrVW5mbHVzaGVkQ29udGVudCgpIHtcbiB2YXIgb2xkT3V0ID0gb3V0O1xuIHZhciBvbGRFcnIgPSBlcnI7XG4gdmFyIGhhcyA9IGZhbHNlO1xuIG91dCA9IGVyciA9IHggPT4ge1xuICBoYXMgPSB0cnVlO1xuIH07XG4gdHJ5IHtcbiAgZmx1c2hfTk9fRklMRVNZU1RFTSgpO1xuIH0gY2F0Y2ggKGUpIHt9XG4gb3V0ID0gb2xkT3V0O1xuIGVyciA9IG9sZEVycjtcbiBpZiAoaGFzKSB7XG4gIHdhcm5PbmNlKFwic3RkaW8gc3RyZWFtcyBoYWQgY29udGVudCBpbiB0aGVtIHRoYXQgd2FzIG5vdCBmbHVzaGVkLiB5b3Ugc2hvdWxkIHNldCBFWElUX1JVTlRJTUUgdG8gMSAoc2VlIHRoZSBGQVEpLCBvciBtYWtlIHN1cmUgdG8gZW1pdCBhIG5ld2xpbmUgd2hlbiB5b3UgcHJpbnRmIGV0Yy5cIik7XG4gIHdhcm5PbmNlKFwiKHRoaXMgbWF5IGFsc28gYmUgZHVlIHRvIG5vdCBpbmNsdWRpbmcgZnVsbCBmaWxlc3lzdGVtIHN1cHBvcnQgLSB0cnkgYnVpbGRpbmcgd2l0aCAtc0ZPUkNFX0ZJTEVTWVNURU0pXCIpO1xuIH1cbn1cblxuaWYgKE1vZHVsZVtcInByZUluaXRcIl0pIHtcbiBpZiAodHlwZW9mIE1vZHVsZVtcInByZUluaXRcIl0gPT0gXCJmdW5jdGlvblwiKSBNb2R1bGVbXCJwcmVJbml0XCJdID0gWyBNb2R1bGVbXCJwcmVJbml0XCJdIF07XG4gd2hpbGUgKE1vZHVsZVtcInByZUluaXRcIl0ubGVuZ3RoID4gMCkge1xuICBNb2R1bGVbXCJwcmVJbml0XCJdLnBvcCgpKCk7XG4gfVxufVxuXG52YXIgc2hvdWxkUnVuTm93ID0gdHJ1ZTtcblxuaWYgKE1vZHVsZVtcIm5vSW5pdGlhbFJ1blwiXSkgc2hvdWxkUnVuTm93ID0gZmFsc2U7XG5cbnJ1bigpO1xuXG5cbiAgcmV0dXJuIER1Y2tEQi5yZWFkeVxufVxuXG4pO1xufSkoKTtcbmV4cG9ydCBkZWZhdWx0IER1Y2tEQjsiLCAiaW1wb3J0IER1Y2tEQldhc20gZnJvbSAnLi9kdWNrZGItZWguanMnO1xyXG5pbXBvcnQgeyBEdWNrREJCcm93c2VyQmluZGluZ3MgfSBmcm9tICcuL2JpbmRpbmdzX2Jyb3dzZXJfYmFzZSc7XHJcbmltcG9ydCB7IER1Y2tEQk1vZHVsZSB9IGZyb20gJy4vZHVja2RiX21vZHVsZSc7XHJcbmltcG9ydCB7IER1Y2tEQlJ1bnRpbWUgfSBmcm9tICcuL3J1bnRpbWUnO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2cnO1xyXG5cclxuLyoqIER1Y2tEQiBiaW5kaW5ncyBmb3IgdGhlIGJyb3dzZXIgKi9cclxuZXhwb3J0IGNsYXNzIER1Y2tEQiBleHRlbmRzIER1Y2tEQkJyb3dzZXJCaW5kaW5ncyB7XHJcbiAgICAvKiogQ29uc3RydWN0b3IgKi9cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcclxuICAgICAgICBsb2dnZXI6IExvZ2dlcixcclxuICAgICAgICBydW50aW1lOiBEdWNrREJSdW50aW1lLFxyXG4gICAgICAgIG1haW5Nb2R1bGVVUkw6IHN0cmluZyxcclxuICAgICAgICBwdGhyZWFkV29ya2VyVVJMOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKGxvZ2dlciwgcnVudGltZSwgbWFpbk1vZHVsZVVSTCwgcHRocmVhZFdvcmtlclVSTCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEluc3RhbnRpYXRlIHRoZSBiaW5kaW5ncyAqL1xyXG4gICAgcHJvdGVjdGVkIGluc3RhbnRpYXRlSW1wbChtb2R1bGVPdmVycmlkZXM6IFBhcnRpYWw8RHVja0RCTW9kdWxlPik6IFByb21pc2U8RHVja0RCTW9kdWxlPiB7XHJcbiAgICAgICAgcmV0dXJuIER1Y2tEQldhc20oe1xyXG4gICAgICAgICAgICAuLi5tb2R1bGVPdmVycmlkZXMsXHJcbiAgICAgICAgICAgIGluc3RhbnRpYXRlV2FzbTogdGhpcy5pbnN0YW50aWF0ZVdhc20uYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgbG9jYXRlRmlsZTogdGhpcy5sb2NhdGVGaWxlLmJpbmQodGhpcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IER1Y2tEQjtcclxuIiwgImV4cG9ydCAqIGZyb20gJy4uL2JpbmRpbmdzJztcclxuZXhwb3J0ICogZnJvbSAnLi4vbG9nJztcclxuZXhwb3J0ICogZnJvbSAnLi4vcGxhdGZvcm0nO1xyXG5leHBvcnQgKiBmcm9tICcuLi9zdGF0dXMnO1xyXG5leHBvcnQgKiBmcm9tICcuLi92ZXJzaW9uJztcclxuZXhwb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vYmluZGluZ3MvcnVudGltZSc7XHJcbmV4cG9ydCB7IERFRkFVTFRfUlVOVElNRSB9IGZyb20gJy4uL2JpbmRpbmdzL3J1bnRpbWUnO1xyXG5leHBvcnQgeyBCUk9XU0VSX1JVTlRJTUUgfSBmcm9tICcuLi9iaW5kaW5ncy9ydW50aW1lX2Jyb3dzZXInO1xyXG5cclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgRHVja0RCUnVudGltZSwgRHVja0RCQmluZGluZ3MgfSBmcm9tICcuLi9iaW5kaW5ncyc7XHJcbmltcG9ydCB7IER1Y2tEQkJ1bmRsZXMsIGdldFBsYXRmb3JtRmVhdHVyZXMgfSBmcm9tICcuLi9wbGF0Zm9ybSc7XHJcbmltcG9ydCB7IER1Y2tEQiBhcyBEdWNrREJNVlAgfSBmcm9tICcuLi9iaW5kaW5ncy9iaW5kaW5nc19icm93c2VyX212cCc7XHJcbmltcG9ydCB7IER1Y2tEQiBhcyBEdWNrREJOZXh0IH0gZnJvbSAnLi4vYmluZGluZ3MvYmluZGluZ3NfYnJvd3Nlcl9laCc7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRHVja0RCKFxyXG4gICAgYnVuZGxlczogRHVja0RCQnVuZGxlcyxcclxuICAgIGxvZ2dlcjogTG9nZ2VyLFxyXG4gICAgcnVudGltZTogRHVja0RCUnVudGltZSxcclxuKTogUHJvbWlzZTxEdWNrREJCaW5kaW5ncz4ge1xyXG4gICAgY29uc3QgcGxhdGZvcm0gPSBhd2FpdCBnZXRQbGF0Zm9ybUZlYXR1cmVzKCk7XHJcbiAgICBpZiAocGxhdGZvcm0ud2FzbUV4Y2VwdGlvbnMpIHtcclxuICAgICAgICBpZiAoYnVuZGxlcy5laCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IER1Y2tEQk5leHQobG9nZ2VyLCBydW50aW1lLCBidW5kbGVzLmVoIS5tYWluTW9kdWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IER1Y2tEQk1WUChsb2dnZXIsIHJ1bnRpbWUsIGJ1bmRsZXMubXZwLm1haW5Nb2R1bGUpO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgeyBBc3luY0R1Y2tEQiB9IGZyb20gJy4vYXN5bmNfYmluZGluZ3MnO1xyXG5pbXBvcnQgeyBMb2dMZXZlbCwgTG9nVG9waWMsIExvZ09yaWdpbiwgTG9nRXZlbnQgfSBmcm9tICcuLi9sb2cnO1xyXG5pbXBvcnQgeyBBcnJvd0luc2VydE9wdGlvbnMsIENTVkluc2VydE9wdGlvbnMsIEpTT05JbnNlcnRPcHRpb25zIH0gZnJvbSAnLi4vYmluZGluZ3MvaW5zZXJ0X29wdGlvbnMnO1xyXG5cclxuLyoqIEEgdGhpbiBoZWxwZXIgdG8gbWVtb2l6ZSB0aGUgY29ubmVjdGlvbiBpZCAqL1xyXG5leHBvcnQgY2xhc3MgQXN5bmNEdWNrREJDb25uZWN0aW9uIHtcclxuICAgIC8qKiBUaGUgYXN5bmMgZHVja2RiICovXHJcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2JpbmRpbmdzOiBBc3luY0R1Y2tEQjtcclxuICAgIC8qKiBUaGUgY29ubiBoYW5kbGUgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBfY29ubjogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJpbmRpbmdzOiBBc3luY0R1Y2tEQiwgY29ubjogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5fYmluZGluZ3MgPSBiaW5kaW5ncztcclxuICAgICAgICB0aGlzLl9jb25uID0gY29ubjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQWNjZXNzIHRoZSBkYXRhYmFzZSBiaW5kaW5ncyAqL1xyXG4gICAgcHVibGljIGdldCBiaW5kaW5ncygpOiBBc3luY0R1Y2tEQiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEaXNjb25uZWN0IGZyb20gdGhlIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY2xvc2UoKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmRpbmdzLmRpc2Nvbm5lY3QodGhpcy5fY29ubik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEJyYXZlIHNvdWxzIG1heSB1c2UgdGhpcyBmdW5jdGlvbiB0byBjb25zdW1lIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24gaWQgKi9cclxuICAgIHB1YmxpYyB1c2VVbnNhZmU8Uj4oY2FsbGJhY2s6IChiaW5kaW5nczogQXN5bmNEdWNrREIsIGNvbm46IG51bWJlcikgPT4gUikge1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9iaW5kaW5ncywgdGhpcy5fY29ubik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJ1biBhIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcXVlcnk8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYXJyb3cuRGF0YVR5cGUgfSA9IGFueT4odGV4dDogc3RyaW5nKTogUHJvbWlzZTxhcnJvdy5UYWJsZTxUPj4ge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmxvZ2dlci5sb2coe1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxyXG4gICAgICAgICAgICBvcmlnaW46IExvZ09yaWdpbi5BU1lOQ19EVUNLREIsXHJcbiAgICAgICAgICAgIHRvcGljOiBMb2dUb3BpYy5RVUVSWSxcclxuICAgICAgICAgICAgZXZlbnQ6IExvZ0V2ZW50LlJVTixcclxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgdGhpcy5fYmluZGluZ3MucnVuUXVlcnkodGhpcy5fY29ubiwgdGV4dCk7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihidWZmZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N5bmMoKSwgXCJSZWFkZXIgaXMgbm90IHN5bmNcIik7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQocmVhZGVyLmlzRmlsZSgpLCBcIlJlYWRlciBpcyBub3QgZmlsZVwiKTtcclxuICAgICAgICByZXR1cm4gbmV3IGFycm93LlRhYmxlKHJlYWRlciBhcyBhcnJvdy5SZWNvcmRCYXRjaEZpbGVSZWFkZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBTZW5kIGEgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBhc3luYyBzZW5kPFQgZXh0ZW5kcyB7IFtrZXk6IHN0cmluZ106IGFycm93LkRhdGFUeXBlIH0gPSBhbnk+KFxyXG4gICAgICAgIHRleHQ6IHN0cmluZyxcclxuICAgICk6IFByb21pc2U8YXJyb3cuQXN5bmNSZWNvcmRCYXRjaFN0cmVhbVJlYWRlcjxUPj4ge1xyXG4gICAgICAgIHRoaXMuX2JpbmRpbmdzLmxvZ2dlci5sb2coe1xyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgICAgICAgIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxyXG4gICAgICAgICAgICBvcmlnaW46IExvZ09yaWdpbi5BU1lOQ19EVUNLREIsXHJcbiAgICAgICAgICAgIHRvcGljOiBMb2dUb3BpYy5RVUVSWSxcclxuICAgICAgICAgICAgZXZlbnQ6IExvZ0V2ZW50LlJVTixcclxuICAgICAgICAgICAgdmFsdWU6IHRleHQsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGhlYWRlciA9IGF3YWl0IHRoaXMuX2JpbmRpbmdzLnN0YXJ0UGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4sIHRleHQpO1xyXG4gICAgICAgIHdoaWxlIChoZWFkZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBoZWFkZXIgPSBhd2FpdCB0aGlzLl9iaW5kaW5ncy5wb2xsUGVuZGluZ1F1ZXJ5KHRoaXMuX2Nvbm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpdGVyID0gbmV3IEFzeW5jUmVzdWx0U3RyZWFtSXRlcmF0b3IodGhpcy5fYmluZGluZ3MsIHRoaXMuX2Nvbm4sIGhlYWRlcik7XHJcbiAgICAgICAgY29uc3QgcmVhZGVyID0gYXdhaXQgYXJyb3cuUmVjb3JkQmF0Y2hSZWFkZXIuZnJvbTxUPihpdGVyKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNBc3luYygpKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTdHJlYW0oKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlYWRlciBhcyB1bmtub3duIGFzIGFycm93LkFzeW5jUmVjb3JkQmF0Y2hTdHJlYW1SZWFkZXI8VD47IC8vIFhYWFxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDYW5jZWwgYSBxdWVyeSB0aGF0IHdhcyBzZW50IGVhcmxpZXIgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjYW5jZWxTZW50KCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9iaW5kaW5ncy5jYW5jZWxQZW5kaW5nUXVlcnkodGhpcy5fY29ubik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEdldCB0YWJsZSBuYW1lcyAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdldFRhYmxlTmFtZXMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYmluZGluZ3MuZ2V0VGFibGVOYW1lcyh0aGlzLl9jb25uLCBxdWVyeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENyZWF0ZSBhIHByZXBhcmVkIHN0YXRlbWVudCAqL1xyXG4gICAgcHVibGljIGFzeW5jIHByZXBhcmU8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYXJyb3cuRGF0YVR5cGUgfSA9IGFueT4oXHJcbiAgICAgICAgdGV4dDogc3RyaW5nLFxyXG4gICAgKTogUHJvbWlzZTxBc3luY1ByZXBhcmVkU3RhdGVtZW50PiB7XHJcbiAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IHRoaXMuX2JpbmRpbmdzLmNyZWF0ZVByZXBhcmVkKHRoaXMuX2Nvbm4sIHRleHQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQXN5bmNQcmVwYXJlZFN0YXRlbWVudDxUPih0aGlzLl9iaW5kaW5ncywgdGhpcy5fY29ubiwgc3RtdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEluc2VydCBhbiBhcnJvdyB0YWJsZSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGluc2VydEFycm93VGFibGUodGFibGU6IGFycm93LlRhYmxlLCBvcHRpb25zOiBBcnJvd0luc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBhcnJvdy50YWJsZVRvSVBDKHRhYmxlLCAnc3RyZWFtJyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbnNlcnRBcnJvd0Zyb21JUENTdHJlYW0oYnVmZmVyLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKiBJbnNlcnQgYW4gYXJyb3cgdGFibGUgZnJvbSBhbiBpcGMgc3RyZWFtICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKGJ1ZmZlcjogVWludDhBcnJheSwgb3B0aW9uczogQXJyb3dJbnNlcnRPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5fYmluZGluZ3MuaW5zZXJ0QXJyb3dGcm9tSVBDU3RyZWFtKHRoaXMuX2Nvbm4sIGJ1ZmZlciwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGNzdiBmaWxlIGZyb20gcGF0aCAqL1xyXG4gICAgcHVibGljIGFzeW5jIGluc2VydENTVkZyb21QYXRoKHRleHQ6IHN0cmluZywgb3B0aW9uczogQ1NWSW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMuX2JpbmRpbmdzLmluc2VydENTVkZyb21QYXRoKHRoaXMuX2Nvbm4sIHRleHQsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqIEluc2VydCBqc29uIGZpbGUgZnJvbSBwYXRoICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0SlNPTkZyb21QYXRoKHRleHQ6IHN0cmluZywgb3B0aW9uczogSlNPTkluc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLl9iaW5kaW5ncy5pbnNlcnRKU09ORnJvbVBhdGgodGhpcy5fY29ubiwgdGV4dCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKiBBbiBhc3luYyByZXN1bHQgc3RyZWFtIGl0ZXJhdG9yICovXHJcbmV4cG9ydCBjbGFzcyBBc3luY1Jlc3VsdFN0cmVhbUl0ZXJhdG9yIGltcGxlbWVudHMgQXN5bmNJdGVyYWJsZTxVaW50OEFycmF5PiB7XHJcbiAgICAvKiogRmlyc3QgY2h1bms/ICovXHJcbiAgICBwcm90ZWN0ZWQgX2ZpcnN0OiBib29sZWFuO1xyXG4gICAgLyoqIFJlYWNoZWQgZW5kIG9mIHN0cmVhbT8gKi9cclxuICAgIHByb3RlY3RlZCBfZGVwbGV0ZWQ6IGJvb2xlYW47XHJcbiAgICAvKiogSW4tZmxpZ2h0ICovXHJcbiAgICBwcm90ZWN0ZWQgX2luRmxpZ2h0OiBQcm9taXNlPFVpbnQ4QXJyYXk+IHwgbnVsbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGI6IEFzeW5jRHVja0RCLFxyXG4gICAgICAgIHByb3RlY3RlZCByZWFkb25seSBjb25uOiBudW1iZXIsXHJcbiAgICAgICAgcHJvdGVjdGVkIHJlYWRvbmx5IGhlYWRlcjogVWludDhBcnJheSxcclxuICAgICkge1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9kZXBsZXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2luRmxpZ2h0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBuZXh0KCk6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VWludDhBcnJheT4+IHtcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiB0aGlzLmhlYWRlciB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVwbGV0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG51bGwgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjogVWludDhBcnJheTtcclxuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBidWZmZXIgPSBhd2FpdCB0aGlzLl9pbkZsaWdodDtcclxuICAgICAgICAgICAgdGhpcy5faW5GbGlnaHQgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IGF3YWl0IHRoaXMuZGIuZmV0Y2hRdWVyeVJlc3VsdHModGhpcy5jb25uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVwbGV0ZWQgPSBidWZmZXIubGVuZ3RoID09IDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZXBsZXRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbkZsaWdodCA9IHRoaXMuZGIuZmV0Y2hRdWVyeVJlc3VsdHModGhpcy5jb25uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZG9uZTogdGhpcy5fZGVwbGV0ZWQsXHJcbiAgICAgICAgICAgIHZhbHVlOiBidWZmZXIsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogQSB0aGluIGhlbHBlciB0byBiaW5kIHRoZSBwcmVwYXJlZCBzdGF0ZW1lbnQgaWQgKi9cclxuZXhwb3J0IGNsYXNzIEFzeW5jUHJlcGFyZWRTdGF0ZW1lbnQ8VCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogYXJyb3cuRGF0YVR5cGUgfSA9IGFueT4ge1xyXG4gICAgLyoqIFRoZSBiaW5kaW5ncyAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGJpbmRpbmdzOiBBc3luY0R1Y2tEQjtcclxuICAgIC8qKiBUaGUgY29ubmVjdGlvbiBpZCAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IGNvbm5lY3Rpb25JZDogbnVtYmVyO1xyXG4gICAgLyoqIFRoZSBzdGF0ZW1lbnQgaWQgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBzdGF0ZW1lbnRJZDogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBDb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoYmluZGluZ3M6IEFzeW5jRHVja0RCLCBjb25uZWN0aW9uSWQ6IG51bWJlciwgc3RhdGVtZW50SWQ6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSBiaW5kaW5ncztcclxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcclxuICAgICAgICB0aGlzLnN0YXRlbWVudElkID0gc3RhdGVtZW50SWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENsb3NlIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY2xvc2UoKSB7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5iaW5kaW5ncy5jbG9zZVByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUnVuIGEgcHJlcGFyZWQgc3RhdGVtZW50ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcXVlcnkoLi4ucGFyYW1zOiBhbnlbXSk6IFByb21pc2U8YXJyb3cuVGFibGU8VD4+IHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCB0aGlzLmJpbmRpbmdzLnJ1blByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGFycm93LlJlY29yZEJhdGNoUmVhZGVyLmZyb208VD4oYnVmZmVyKTtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChyZWFkZXIuaXNTeW5jKCkpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0ZpbGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBhcnJvdy5UYWJsZShyZWFkZXIgYXMgYXJyb3cuUmVjb3JkQmF0Y2hGaWxlUmVhZGVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU2VuZCBhIHByZXBhcmVkIHN0YXRlbWVudCAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNlbmQoLi4ucGFyYW1zOiBhbnlbXSk6IFByb21pc2U8YXJyb3cuQXN5bmNSZWNvcmRCYXRjaFN0cmVhbVJlYWRlcjxUPj4ge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGF3YWl0IHRoaXMuYmluZGluZ3Muc2VuZFByZXBhcmVkKHRoaXMuY29ubmVjdGlvbklkLCB0aGlzLnN0YXRlbWVudElkLCBwYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgQXN5bmNSZXN1bHRTdHJlYW1JdGVyYXRvcih0aGlzLmJpbmRpbmdzLCB0aGlzLmNvbm5lY3Rpb25JZCwgaGVhZGVyKTtcclxuICAgICAgICBjb25zdCByZWFkZXIgPSBhd2FpdCBhcnJvdy5SZWNvcmRCYXRjaFJlYWRlci5mcm9tPFQ+KGl0ZXIpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc0FzeW5jKCkpO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHJlYWRlci5pc1N0cmVhbSgpKTtcclxuICAgICAgICByZXR1cm4gcmVhZGVyIGFzIHVua25vd24gYXMgYXJyb3cuQXN5bmNSZWNvcmRCYXRjaFN0cmVhbVJlYWRlcjxUPjsgLy8gWFhYXHJcbiAgICB9XHJcbn1cclxuIiwgImltcG9ydCB7IENTVkluc2VydE9wdGlvbnMsIEpTT05JbnNlcnRPcHRpb25zLCBBcnJvd0luc2VydE9wdGlvbnMgfSBmcm9tICcuLi9iaW5kaW5ncy9pbnNlcnRfb3B0aW9ucyc7XHJcbmltcG9ydCB7IExvZ0VudHJ5VmFyaWFudCB9IGZyb20gJy4uL2xvZyc7XHJcbmltcG9ydCB7IFNjcmlwdFRva2VucyB9IGZyb20gJy4uL2JpbmRpbmdzL3Rva2Vucyc7XHJcbmltcG9ydCB7IEZpbGVTdGF0aXN0aWNzIH0gZnJvbSAnLi4vYmluZGluZ3MvZmlsZV9zdGF0cyc7XHJcbmltcG9ydCB7IER1Y2tEQkNvbmZpZyB9IGZyb20gJy4uL2JpbmRpbmdzL2NvbmZpZyc7XHJcbmltcG9ydCB7IFdlYkZpbGUgfSBmcm9tICcuLi9iaW5kaW5ncy93ZWJfZmlsZSc7XHJcbmltcG9ydCB7IEluc3RhbnRpYXRpb25Qcm9ncmVzcyB9IGZyb20gJy4uL2JpbmRpbmdzL3Byb2dyZXNzJztcclxuaW1wb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vYmluZGluZ3MnO1xyXG5cclxuZXhwb3J0IHR5cGUgQ29ubmVjdGlvbklEID0gbnVtYmVyO1xyXG5leHBvcnQgdHlwZSBTdGF0ZW1lbnRJRCA9IG51bWJlcjtcclxuXHJcbmV4cG9ydCBlbnVtIFdvcmtlclJlcXVlc3RUeXBlIHtcclxuICAgIENBTkNFTF9QRU5ESU5HX1FVRVJZID0gJ0NBTkNFTF9QRU5ESU5HX1FVRVJZJyxcclxuICAgIENMT1NFX1BSRVBBUkVEID0gJ0NMT1NFX1BSRVBBUkVEJyxcclxuICAgIENPTExFQ1RfRklMRV9TVEFUSVNUSUNTID0gJ0NPTExFQ1RfRklMRV9TVEFUSVNUSUNTJyxcclxuICAgIENPTk5FQ1QgPSAnQ09OTkVDVCcsXHJcbiAgICBDT1BZX0ZJTEVfVE9fQlVGRkVSID0gJ0NPUFlfRklMRV9UT19CVUZGRVInLFxyXG4gICAgQ09QWV9GSUxFX1RPX1BBVEggPSAnQ09QWV9GSUxFX1RPX1BBVEgnLFxyXG4gICAgQ1JFQVRFX1BSRVBBUkVEID0gJ0NSRUFURV9QUkVQQVJFRCcsXHJcbiAgICBESVNDT05ORUNUID0gJ0RJU0NPTk5FQ1QnLFxyXG4gICAgRFJPUF9GSUxFID0gJ0RST1BfRklMRScsXHJcbiAgICBEUk9QX0ZJTEVTID0gJ0RST1BfRklMRVMnLFxyXG4gICAgRVhQT1JUX0ZJTEVfU1RBVElTVElDUyA9ICdFWFBPUlRfRklMRV9TVEFUSVNUSUNTJyxcclxuICAgIEZFVENIX1FVRVJZX1JFU1VMVFMgPSAnRkVUQ0hfUVVFUllfUkVTVUxUUycsXHJcbiAgICBGTFVTSF9GSUxFUyA9ICdGTFVTSF9GSUxFUycsXHJcbiAgICBHRVRfRkVBVFVSRV9GTEFHUyA9ICdHRVRfRkVBVFVSRV9GTEFHUycsXHJcbiAgICBHRVRfVEFCTEVfTkFNRVMgPSAnR0VUX1RBQkxFX05BTUVTJyxcclxuICAgIEdFVF9WRVJTSU9OID0gJ0dFVF9WRVJTSU9OJyxcclxuICAgIEdMT0JfRklMRV9JTkZPUyA9ICdHTE9CX0ZJTEVfSU5GT1MnLFxyXG4gICAgSU5TRVJUX0FSUk9XX0ZST01fSVBDX1NUUkVBTSA9ICdJTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNJyxcclxuICAgIElOU0VSVF9DU1ZfRlJPTV9QQVRIID0gJ0lNUE9SVF9DU1ZfRlJPTV9QQVRIJyxcclxuICAgIElOU0VSVF9KU09OX0ZST01fUEFUSCA9ICdJTVBPUlRfSlNPTl9GUk9NX1BBVEgnLFxyXG4gICAgSU5TVEFOVElBVEUgPSAnSU5TVEFOVElBVEUnLFxyXG4gICAgT1BFTiA9ICdPUEVOJyxcclxuICAgIFBJTkcgPSAnUElORycsXHJcbiAgICBQT0xMX1BFTkRJTkdfUVVFUlkgPSAnUE9MTF9QRU5ESU5HX1FVRVJZJyxcclxuICAgIFJFR0lTVEVSX0ZJTEVfQlVGRkVSID0gJ1JFR0lTVEVSX0ZJTEVfQlVGRkVSJyxcclxuICAgIFJFR0lTVEVSX0ZJTEVfSEFORExFID0gJ1JFR0lTVEVSX0ZJTEVfSEFORExFJyxcclxuICAgIFJFR0lTVEVSX0ZJTEVfVVJMID0gJ1JFR0lTVEVSX0ZJTEVfVVJMJyxcclxuICAgIFJFU0VUID0gJ1JFU0VUJyxcclxuICAgIFJVTl9QUkVQQVJFRCA9ICdSVU5fUFJFUEFSRUQnLFxyXG4gICAgUlVOX1FVRVJZID0gJ1JVTl9RVUVSWScsXHJcbiAgICBTRU5EX1BSRVBBUkVEID0gJ1NFTkRfUFJFUEFSRUQnLFxyXG4gICAgU1RBUlRfUEVORElOR19RVUVSWSA9ICdTVEFSVF9QRU5ESU5HX1FVRVJZJyxcclxuICAgIFRPS0VOSVpFID0gJ1RPS0VOSVpFJyxcclxufVxyXG5cclxuZXhwb3J0IGVudW0gV29ya2VyUmVzcG9uc2VUeXBlIHtcclxuICAgIENPTk5FQ1RJT05fSU5GTyA9ICdDT05ORUNUSU9OX0lORk8nLFxyXG4gICAgRVJST1IgPSAnRVJST1InLFxyXG4gICAgRkVBVFVSRV9GTEFHUyA9ICdGRUFUVVJFX0ZMQUdTJyxcclxuICAgIEZJTEVfQlVGRkVSID0gJ0ZJTEVfQlVGRkVSJyxcclxuICAgIEZJTEVfSU5GT1MgPSAnRklMRV9JTkZPUycsXHJcbiAgICBGSUxFX1NJWkUgPSAnRklMRV9TSVpFJyxcclxuICAgIEZJTEVfU1RBVElTVElDUyA9ICdGSUxFX1NUQVRJU1RJQ1MnLFxyXG4gICAgSU5TVEFOVElBVEVfUFJPR1JFU1MgPSAnSU5TVEFOVElBVEVfUFJPR1JFU1MnLFxyXG4gICAgTE9HID0gJ0xPRycsXHJcbiAgICBPSyA9ICdPSycsXHJcbiAgICBQUkVQQVJFRF9TVEFURU1FTlRfSUQgPSAnUFJFUEFSRURfU1RBVEVNRU5UX0lEJyxcclxuICAgIFFVRVJZX1BMQU4gPSAnUVVFUllfUExBTicsXHJcbiAgICBRVUVSWV9SRVNVTFQgPSAnUVVFUllfUkVTVUxUJyxcclxuICAgIFFVRVJZX1JFU1VMVF9DSFVOSyA9ICdRVUVSWV9SRVNVTFRfQ0hVTksnLFxyXG4gICAgUVVFUllfUkVTVUxUX0hFQURFUiA9ICdRVUVSWV9SRVNVTFRfSEVBREVSJyxcclxuICAgIFFVRVJZX1JFU1VMVF9IRUFERVJfT1JfTlVMTCA9ICdRVUVSWV9SRVNVTFRfSEVBREVSX09SX05VTEwnLFxyXG4gICAgUkVHSVNURVJFRF9GSUxFID0gJ1JFR0lTVEVSRURfRklMRScsXHJcbiAgICBTQ1JJUFRfVE9LRU5TID0gJ1NDUklQVF9UT0tFTlMnLFxyXG4gICAgU1VDQ0VTUyA9ICdTVUNDRVNTJyxcclxuICAgIFRBQkxFX05BTUVTID0gJ1RBQkxFX05BTUVTJyxcclxuICAgIFZFUlNJT05fU1RSSU5HID0gJ1ZFUlNJT05fU1RSSU5HJyxcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgV29ya2VyUmVxdWVzdDxULCBQPiA9IHtcclxuICAgIHJlYWRvbmx5IG1lc3NhZ2VJZDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgdHlwZTogVDtcclxuICAgIHJlYWRvbmx5IGRhdGE6IFA7XHJcbn07XHJcblxyXG5leHBvcnQgdHlwZSBXb3JrZXJSZXNwb25zZTxULCBQPiA9IHtcclxuICAgIHJlYWRvbmx5IG1lc3NhZ2VJZDogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgcmVxdWVzdElkOiBudW1iZXI7XHJcbiAgICByZWFkb25seSB0eXBlOiBUO1xyXG4gICAgcmVhZG9ubHkgZGF0YTogUDtcclxufTtcclxuXHJcbmV4cG9ydCB0eXBlIFdvcmtlclRhc2tSZXR1cm5UeXBlPFQgZXh0ZW5kcyBXb3JrZXJUYXNrVmFyaWFudD4gPSBUIGV4dGVuZHMgV29ya2VyVGFzazxhbnksIGFueSwgaW5mZXIgUD4gPyBQIDogbmV2ZXI7XHJcblxyXG5leHBvcnQgY2xhc3MgV29ya2VyVGFzazxULCBELCBQPiB7XHJcbiAgICByZWFkb25seSB0eXBlOiBUO1xyXG4gICAgcmVhZG9ubHkgZGF0YTogRDtcclxuICAgIHByb21pc2U6IFByb21pc2U8UD47XHJcbiAgICBwcm9taXNlUmVzb2x2ZXI6ICh2YWx1ZTogUCB8IFByb21pc2VMaWtlPFA+KSA9PiB2b2lkID0gKCkgPT4ge307XHJcbiAgICBwcm9taXNlUmVqZWN0ZXI6ICh2YWx1ZTogYW55KSA9PiB2b2lkID0gKCkgPT4ge307XHJcblxyXG4gICAgY29uc3RydWN0b3IodHlwZTogVCwgZGF0YTogRCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZTxQPihcclxuICAgICAgICAgICAgKHJlc29sdmU6ICh2YWx1ZTogUCB8IFByb21pc2VMaWtlPFA+KSA9PiB2b2lkLCByZWplY3Q6IChyZWFzb24/OiB2b2lkKSA9PiB2b2lkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb21pc2VSZWplY3RlciA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBXb3JrZXJSZXF1ZXN0VmFyaWFudCA9XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuQ0xPU0VfUFJFUEFSRUQsIFtDb25uZWN0aW9uSUQsIFN0YXRlbWVudElEXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5DQU5DRUxfUEVORElOR19RVUVSWSwgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLCBbc3RyaW5nLCBib29sZWFuXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNULCBudWxsPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19CVUZGRVIsIHN0cmluZz5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fUEFUSCwgW3N0cmluZywgc3RyaW5nXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsIFtDb25uZWN0aW9uSUQsIHN0cmluZ10+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCwgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRSwgc3RyaW5nPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkRST1BfRklMRVMsIG51bGw+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuRVhQT1JUX0ZJTEVfU1RBVElTVElDUywgc3RyaW5nPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLkZFVENIX1FVRVJZX1JFU1VMVFMsIG51bWJlcj5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5GTFVTSF9GSUxFUywgbnVsbD5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfRkVBVFVSRV9GTEFHUywgbnVsbD5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVEFCTEVfTkFNRVMsIFtudW1iZXIsIHN0cmluZ10+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuR0VUX1ZFUlNJT04sIG51bGw+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuR0xPQl9GSUxFX0lORk9TLCBzdHJpbmc+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8XHJcbiAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNLFxyXG4gICAgICAgICAgW251bWJlciwgVWludDhBcnJheSwgQXJyb3dJbnNlcnRPcHRpb25zIHwgdW5kZWZpbmVkXVxyXG4gICAgICA+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0NTVl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgQ1NWSW5zZXJ0T3B0aW9uc10+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0pTT05fRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIEpTT05JbnNlcnRPcHRpb25zXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNUQU5USUFURSwgW3N0cmluZywgc3RyaW5nIHwgbnVsbF0+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuT1BFTiwgRHVja0RCQ29uZmlnPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlBJTkcsIG51bGw+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLCBudW1iZXI+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9CVUZGRVIsIFtzdHJpbmcsIFVpbnQ4QXJyYXldPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfSEFORExFLCBbc3RyaW5nLCBhbnksIER1Y2tEQkRhdGFQcm90b2NvbCwgYm9vbGVhbl0+XHJcbiAgICB8IFdvcmtlclJlcXVlc3Q8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9VUkwsIFtzdHJpbmcsIHN0cmluZywgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5SRVNFVCwgbnVsbD5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlciwgYW55W11dPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlJVTl9RVUVSWSwgW251bWJlciwgc3RyaW5nXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5TRU5EX1BSRVBBUkVELCBbbnVtYmVyLCBudW1iZXIsIGFueVtdXT5cclxuICAgIHwgV29ya2VyUmVxdWVzdDxXb3JrZXJSZXF1ZXN0VHlwZS5TVEFSVF9QRU5ESU5HX1FVRVJZLCBbbnVtYmVyLCBzdHJpbmddPlxyXG4gICAgfCBXb3JrZXJSZXF1ZXN0PFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFLCBzdHJpbmc+O1xyXG5cclxuZXhwb3J0IHR5cGUgV29ya2VyUmVzcG9uc2VWYXJpYW50ID1cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkNPTk5FQ1RJT05fSU5GTywgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuRVJST1IsIGFueT5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkZFQVRVUkVfRkxBR1MsIG51bWJlcj5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfQlVGRkVSLCBVaW50OEFycmF5PlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuRklMRV9JTkZPUywgV2ViRmlsZVtdPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuRklMRV9TSVpFLCBudW1iZXI+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NUQVRJU1RJQ1MsIEZpbGVTdGF0aXN0aWNzPlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuSU5TVEFOVElBVEVfUFJPR1JFU1MsIEluc3RhbnRpYXRpb25Qcm9ncmVzcz5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLkxPRywgTG9nRW50cnlWYXJpYW50PlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuT0ssIG51bGw+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5QUkVQQVJFRF9TVEFURU1FTlRfSUQsIG51bWJlcj5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1BMQU4sIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFQsIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfQ0hVTkssIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfSEVBREVSLCBVaW50OEFycmF5PlxyXG4gICAgfCBXb3JrZXJSZXNwb25zZTxXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0hFQURFUl9PUl9OVUxMLCBVaW50OEFycmF5IHwgbnVsbD5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlNDUklQVF9UT0tFTlMsIFNjcmlwdFRva2Vucz5cclxuICAgIHwgV29ya2VyUmVzcG9uc2U8V29ya2VyUmVzcG9uc2VUeXBlLlNVQ0NFU1MsIGJvb2xlYW4+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5UQUJMRV9OQU1FUywgc3RyaW5nW10+XHJcbiAgICB8IFdvcmtlclJlc3BvbnNlPFdvcmtlclJlc3BvbnNlVHlwZS5WRVJTSU9OX1NUUklORywgc3RyaW5nPjtcclxuXHJcbmV4cG9ydCB0eXBlIFdvcmtlclRhc2tWYXJpYW50ID1cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DT0xMRUNUX0ZJTEVfU1RBVElTVElDUywgW3N0cmluZywgYm9vbGVhbl0sIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ0xPU0VfUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlcl0sIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09OTkVDVCwgbnVsbCwgQ29ubmVjdGlvbklEPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPUFlfRklMRV9UT19CVUZGRVIsIHN0cmluZywgVWludDhBcnJheT5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fUEFUSCwgW3N0cmluZywgc3RyaW5nXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsIFtudW1iZXIsIHN0cmluZ10sIG51bWJlcj5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5ESVNDT05ORUNULCBDb25uZWN0aW9uSUQsIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFLCBzdHJpbmcsIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbCwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTLCBzdHJpbmcsIEZpbGVTdGF0aXN0aWNzPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkZFVENIX1FVRVJZX1JFU1VMVFMsIENvbm5lY3Rpb25JRCwgVWludDhBcnJheT5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5GTFVTSF9GSUxFUywgbnVsbCwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfRkVBVFVSRV9GTEFHUywgbnVsbCwgbnVtYmVyPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9UQUJMRV9OQU1FUywgW251bWJlciwgc3RyaW5nXSwgc3RyaW5nW10+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuR0VUX1ZFUlNJT04sIG51bGwsIHN0cmluZz5cclxuICAgIHwgV29ya2VyVGFzazxcclxuICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9BUlJPV19GUk9NX0lQQ19TVFJFQU0sXHJcbiAgICAgICAgICBbbnVtYmVyLCBVaW50OEFycmF5LCBBcnJvd0luc2VydE9wdGlvbnMgfCB1bmRlZmluZWRdLFxyXG4gICAgICAgICAgbnVsbFxyXG4gICAgICA+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0NTVl9GUk9NX1BBVEgsIFtudW1iZXIsIHN0cmluZywgQ1NWSW5zZXJ0T3B0aW9uc10sIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0pTT05fRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIEpTT05JbnNlcnRPcHRpb25zXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5JTlNUQU5USUFURSwgW3N0cmluZywgc3RyaW5nIHwgbnVsbF0sIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuT1BFTiwgRHVja0RCQ29uZmlnLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlBJTkcsIG51bGwsIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9CVUZGRVIsIFtzdHJpbmcsIFVpbnQ4QXJyYXldLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfSEFORExFLCBbc3RyaW5nLCBhbnksIER1Y2tEQkRhdGFQcm90b2NvbCwgYm9vbGVhbl0sIG51bGw+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9VUkwsIFtzdHJpbmcsIHN0cmluZywgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXSwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1MsIHN0cmluZywgV2ViRmlsZVtdPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFU0VULCBudWxsLCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRCwgW251bWJlciwgbnVtYmVyLCBhbnlbXV0sIFVpbnQ4QXJyYXk+XHJcbiAgICB8IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLCBbQ29ubmVjdGlvbklELCBzdHJpbmddLCBVaW50OEFycmF5PlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNUQVJUX1BFTkRJTkdfUVVFUlksIFtDb25uZWN0aW9uSUQsIHN0cmluZ10sIFVpbnQ4QXJyYXkgfCBudWxsPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlBPTExfUEVORElOR19RVUVSWSwgQ29ubmVjdGlvbklELCBVaW50OEFycmF5IHwgbnVsbD5cclxuICAgIHwgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DQU5DRUxfUEVORElOR19RVUVSWSwgQ29ubmVjdGlvbklELCBib29sZWFuPlxyXG4gICAgfCBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFLCBzdHJpbmcsIFNjcmlwdFRva2Vucz47XHJcbiIsICJpbXBvcnQge1xyXG4gICAgV29ya2VyUmVxdWVzdFR5cGUsXHJcbiAgICBXb3JrZXJSZXNwb25zZVR5cGUsXHJcbiAgICBXb3JrZXJSZXNwb25zZVZhcmlhbnQsXHJcbiAgICBXb3JrZXJUYXNrVmFyaWFudCxcclxuICAgIFdvcmtlclRhc2ssXHJcbiAgICBDb25uZWN0aW9uSUQsXHJcbiAgICBXb3JrZXJUYXNrUmV0dXJuVHlwZSxcclxufSBmcm9tICcuL3dvcmtlcl9yZXF1ZXN0JztcclxuaW1wb3J0IHsgQXN5bmNEdWNrREJCaW5kaW5ncyB9IGZyb20gJy4vYXN5bmNfYmluZGluZ3NfaW50ZXJmYWNlJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nJztcclxuaW1wb3J0IHsgQXN5bmNEdWNrREJDb25uZWN0aW9uIH0gZnJvbSAnLi9hc3luY19jb25uZWN0aW9uJztcclxuaW1wb3J0IHsgQ1NWSW5zZXJ0T3B0aW9ucywgSlNPTkluc2VydE9wdGlvbnMsIEFycm93SW5zZXJ0T3B0aW9ucyB9IGZyb20gJy4uL2JpbmRpbmdzL2luc2VydF9vcHRpb25zJztcclxuaW1wb3J0IHsgU2NyaXB0VG9rZW5zIH0gZnJvbSAnLi4vYmluZGluZ3MvdG9rZW5zJztcclxuaW1wb3J0IHsgRmlsZVN0YXRpc3RpY3MgfSBmcm9tICcuLi9iaW5kaW5ncy9maWxlX3N0YXRzJztcclxuaW1wb3J0IHsgRHVja0RCQ29uZmlnIH0gZnJvbSAnLi4vYmluZGluZ3MvY29uZmlnJztcclxuaW1wb3J0IHsgSW5zdGFudGlhdGlvblByb2dyZXNzIH0gZnJvbSAnLi4vYmluZGluZ3MvcHJvZ3Jlc3MnO1xyXG5pbXBvcnQgeyBhcnJvd1RvU1FMRmllbGQgfSBmcm9tICcuLi9qc29uX3R5cGVkZWYnO1xyXG5pbXBvcnQgeyBXZWJGaWxlIH0gZnJvbSAnLi4vYmluZGluZ3Mvd2ViX2ZpbGUnO1xyXG5pbXBvcnQgeyBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuLi9iaW5kaW5ncyc7XHJcblxyXG5jb25zdCBURVhUX0VOQ09ERVIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuXHJcbmV4cG9ydCBjbGFzcyBBc3luY0R1Y2tEQiBpbXBsZW1lbnRzIEFzeW5jRHVja0RCQmluZGluZ3Mge1xyXG4gICAgLyoqIFRoZSBtZXNzYWdlIGhhbmRsZXIgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBfb25NZXNzYWdlSGFuZGxlcjogKGV2ZW50OiBNZXNzYWdlRXZlbnQpID0+IHZvaWQ7XHJcbiAgICAvKiogVGhlIGVycm9yIGhhbmRsZXIgKi9cclxuICAgIHByb3RlY3RlZCByZWFkb25seSBfb25FcnJvckhhbmRsZXI6IChldmVudDogRXJyb3JFdmVudCkgPT4gdm9pZDtcclxuICAgIC8qKiBUaGUgY2xvc2UgaGFuZGxlciAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9vbkNsb3NlSGFuZGxlcjogKCkgPT4gdm9pZDtcclxuXHJcbiAgICAvKiogSW5zdGFudGlhdGUgdGhlIG1vZHVsZSAqL1xyXG4gICAgcHJvdGVjdGVkIF9vbkluc3RhbnRpYXRpb25Qcm9ncmVzczogKChwOiBJbnN0YW50aWF0aW9uUHJvZ3Jlc3MpID0+IHZvaWQpW10gPSBbXTtcclxuXHJcbiAgICAvKiogVGhlIGxvZ2dlciAqL1xyXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IF9sb2dnZXI6IExvZ2dlcjtcclxuICAgIC8qKiBUaGUgd29ya2VyICovXHJcbiAgICBwcm90ZWN0ZWQgX3dvcmtlcjogV29ya2VyIHwgbnVsbCA9IG51bGw7XHJcbiAgICAvKiogVGhlIHByb21pc2UgZm9yIHRoZSB3b3JrZXIgc2h1dGRvd24gKi9cclxuICAgIHByb3RlY3RlZCBfd29ya2VyU2h1dGRvd25Qcm9taXNlOiBQcm9taXNlPG51bGw+IHwgbnVsbCA9IG51bGw7XHJcbiAgICAvKiogTWFrZSB0aGUgd29ya2VyIGFzIHRlcm1pbmF0ZWQgKi9cclxuICAgIHByb3RlY3RlZCBfd29ya2VyU2h1dGRvd25SZXNvbHZlcjogKHZhbHVlOiBQcm9taXNlTGlrZTxudWxsPiB8IG51bGwpID0+IHZvaWQgPSAoKSA9PiB7fTtcclxuXHJcbiAgICAvKiogVGhlIG5leHQgbWVzc2FnZSBpZCAqL1xyXG4gICAgcHJvdGVjdGVkIF9uZXh0TWVzc2FnZUlkID0gMDtcclxuICAgIC8qKiBUaGUgcGVuZGluZyByZXF1ZXN0cyAqL1xyXG4gICAgcHJvdGVjdGVkIF9wZW5kaW5nUmVxdWVzdHM6IE1hcDxudW1iZXIsIFdvcmtlclRhc2tWYXJpYW50PiA9IG5ldyBNYXAoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2dnZXI6IExvZ2dlciwgd29ya2VyOiBXb3JrZXIgfCBudWxsID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IGxvZ2dlcjtcclxuICAgICAgICB0aGlzLl9vbk1lc3NhZ2VIYW5kbGVyID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9vbkVycm9ySGFuZGxlciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29uQ2xvc2VIYW5kbGVyID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgaWYgKHdvcmtlciAhPSBudWxsKSB0aGlzLmF0dGFjaCh3b3JrZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIGxvZ2dlciAqL1xyXG4gICAgcHVibGljIGdldCBsb2dnZXIoKTogTG9nZ2VyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9nZ2VyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBBdHRhY2ggdG8gd29ya2VyICovXHJcbiAgICBwcm90ZWN0ZWQgYXR0YWNoKHdvcmtlcjogV29ya2VyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlSGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25FcnJvckhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlci5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uQ2xvc2VIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2UgPSBuZXcgUHJvbWlzZTxudWxsPihcclxuICAgICAgICAgICAgKHJlc29sdmU6ICh2YWx1ZTogUHJvbWlzZUxpa2U8bnVsbD4gfCBudWxsKSA9PiB2b2lkLCBfcmVqZWN0OiAocmVhc29uPzogdm9pZCkgPT4gdm9pZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyU2h1dGRvd25SZXNvbHZlciA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogRGV0YWNoIGZyb20gd29ya2VyICovXHJcbiAgICBwdWJsaWMgZGV0YWNoKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2VIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl93b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9ySGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25DbG9zZUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyU2h1dGRvd25SZXNvbHZlcihudWxsKTtcclxuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blByb21pc2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUmVzb2x2ZXIgPSAoKSA9PiB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogS2lsbCB0aGUgd29ya2VyICovXHJcbiAgICBwdWJsaWMgYXN5bmMgdGVybWluYXRlKCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmICghdGhpcy5fd29ya2VyKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgIC8vYXdhaXQgdGhpcy5fd29ya2VyU2h1dGRvd25Qcm9taXNlOyBUT0RPIGRlYWRsb2NraW5nIGluIGthcm1hP1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyU2h1dGRvd25Qcm9taXNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93b3JrZXJTaHV0ZG93blJlc29sdmVyID0gKCkgPT4ge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFBvc3QgYSB0YXNrICovXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgcG9zdFRhc2s8VyBleHRlbmRzIFdvcmtlclRhc2tWYXJpYW50PihcclxuICAgICAgICB0YXNrOiBXLFxyXG4gICAgICAgIHRyYW5zZmVyOiBBcnJheUJ1ZmZlcltdID0gW10sXHJcbiAgICApOiBQcm9taXNlPFdvcmtlclRhc2tSZXR1cm5UeXBlPFc+PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl93b3JrZXIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignY2Fubm90IHNlbmQgYSBtZXNzYWdlIHNpbmNlIHRoZSB3b3JrZXIgaXMgbm90IHNldCEnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1pZCA9IHRoaXMuX25leHRNZXNzYWdlSWQrKztcclxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuc2V0KG1pZCwgdGFzayk7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IG1pZCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHRhc2sudHlwZSxcclxuICAgICAgICAgICAgICAgIGRhdGE6IHRhc2suZGF0YSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHJhbnNmZXIsXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gKGF3YWl0IHRhc2sucHJvbWlzZSkgYXMgV29ya2VyVGFza1JldHVyblR5cGU8Vz47XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlY2VpdmVkIGEgbWVzc2FnZSAqL1xyXG4gICAgcHJvdGVjdGVkIG9uTWVzc2FnZShldmVudDogTWVzc2FnZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgLy8gVW5hc3NvY2lhdGVkIHJlc3BvbnNlcz9cclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGV2ZW50LmRhdGEgYXMgV29ya2VyUmVzcG9uc2VWYXJpYW50O1xyXG4gICAgICAgIHN3aXRjaCAocmVzcG9uc2UudHlwZSkge1xyXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGZhaWxlZD9cclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXNwb25zZVR5cGUuTE9HOiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIubG9nKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhbGwgcHJvZ3Jlc3MgY2FsbGJhY2tcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXNwb25zZVR5cGUuSU5TVEFOVElBVEVfUFJPR1JFU1M6IHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLl9vbkluc3RhbnRpYXRpb25Qcm9ncmVzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHAocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCBhc3NvY2lhdGVkIHRhc2tcclxuICAgICAgICBjb25zdCB0YXNrID0gdGhpcy5fcGVuZGluZ1JlcXVlc3RzLmdldChyZXNwb25zZS5yZXF1ZXN0SWQpO1xyXG4gICAgICAgIGlmICghdGFzaykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHVuYXNzb2NpYXRlZCByZXNwb25zZTogWyR7cmVzcG9uc2UucmVxdWVzdElkfSwgJHtyZXNwb25zZS50eXBlLnRvU3RyaW5nKCl9XWApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5kZWxldGUocmVzcG9uc2UucmVxdWVzdElkKTtcclxuXHJcbiAgICAgICAgLy8gUmVxdWVzdCBmYWlsZWQ/XHJcbiAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkVSUk9SKSB7XHJcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIEZpcmVmb3ggbm90IGJlaW5nIGFibGUgdG8gcGVyZm9ybSBzdHJ1Y3R1cmVkLWNsb25lIG9uIE5hdGl2ZSBFcnJvcnNcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU1NjYwNFxyXG4gICAgICAgICAgICBjb25zdCBlID0gbmV3IEVycm9yKHJlc3BvbnNlLmRhdGEubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGUubmFtZSA9IHJlc3BvbnNlLmRhdGEubmFtZTtcclxuICAgICAgICAgICAgZS5zdGFjayA9IHJlc3BvbnNlLmRhdGEuc3RhY2s7XHJcbiAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlamVjdGVyKGUpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdGhlcndpc2UgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSB0YXNrcyBmaXJzdFxyXG4gICAgICAgIHN3aXRjaCAodGFzay50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ0xPU0VfUFJFUEFSRUQ6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ09MTEVDVF9GSUxFX1NUQVRJU1RJQ1M6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEg6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVDpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEU6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUzpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5GTFVTSF9GSUxFUzpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNOlxyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRIOlxyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9KU09OX0ZST01fUEFUSDpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOOlxyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlBJTkc6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9CVUZGRVI6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEU6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9VUkw6XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuUkVTRVQ6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNUQU5USUFURTpcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSW5zdGFudGlhdGlvblByb2dyZXNzID0gW107XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuT0spIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1M6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRklMRV9JTkZPUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlZFUlNJT05fU1RSSU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuR0VUX0ZFQVRVUkVfRkxBR1M6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuRkVBVFVSRV9GTEFHUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkdFVF9UQUJMRV9OQU1FUzpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5UQUJMRV9OQU1FUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlNDUklQVF9UT0tFTlMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkZJTEVfQlVGRkVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuRVhQT1JUX0ZJTEVfU1RBVElTVElDUzpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5GSUxFX1NUQVRJU1RJQ1MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNUOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLkNPTk5FQ1RJT05fSU5GTykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRDpcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUVVFUlk6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRDpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfSEVBREVSKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWTpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5RVUVSWV9SRVNVTFRfSEVBREVSX09SX05VTEwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5QT0xMX1BFTkRJTkdfUVVFUlk6XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PSBXb3JrZXJSZXNwb25zZVR5cGUuUVVFUllfUkVTVUxUX0hFQURFUl9PUl9OVUxMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFzay5wcm9taXNlUmVzb2x2ZXIocmVzcG9uc2UuZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgV29ya2VyUmVxdWVzdFR5cGUuQ0FOQ0VMX1BFTkRJTkdfUVVFUlk6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkluc3RhbnRpYXRpb25Qcm9ncmVzcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlNVQ0NFU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBXb3JrZXJSZXF1ZXN0VHlwZS5GRVRDSF9RVUVSWV9SRVNVTFRTOlxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnR5cGUgPT0gV29ya2VyUmVzcG9uc2VUeXBlLlFVRVJZX1JFU1VMVF9DSFVOSykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhc2sucHJvbWlzZVJlc29sdmVyKHJlc3BvbnNlLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFdvcmtlclJlcXVlc3RUeXBlLkNSRUFURV9QUkVQQVJFRDpcclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09IFdvcmtlclJlc3BvbnNlVHlwZS5QUkVQQVJFRF9TVEFURU1FTlRfSUQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXNrLnByb21pc2VSZXNvbHZlcihyZXNwb25zZS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFzay5wcm9taXNlUmVqZWN0ZXIobmV3IEVycm9yKGB1bmV4cGVjdGVkIHJlc3BvbnNlIHR5cGU6ICR7cmVzcG9uc2UudHlwZS50b1N0cmluZygpfWApKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVjZWl2ZWQgYW4gZXJyb3IgKi9cclxuICAgIHByb3RlY3RlZCBvbkVycm9yKGV2ZW50OiBFcnJvckV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihldmVudCk7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihgZXJyb3IgaW4gZHVja2RiIHdvcmtlcjogJHtldmVudC5tZXNzYWdlfWApO1xyXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgd29ya2VyIHdhcyBjbG9zZWQgKi9cclxuICAgIHByb3RlY3RlZCBvbkNsb3NlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlclNodXRkb3duUmVzb2x2ZXIobnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaXplICE9IDApIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGB3b3JrZXIgdGVybWluYXRlZCB3aXRoICR7dGhpcy5fcGVuZGluZ1JlcXVlc3RzLnNpemV9IHBlbmRpbmcgcmVxdWVzdHNgKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVzZXQgdGhlIGR1Y2tkYiAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlc2V0KCk6IFByb21pc2U8bnVsbD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRVNFVCwgbnVsbCwgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuUkVTRVQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBQaW5nIHRoZSB3b3JrZXIgdGhyZWFkICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcGluZygpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsLCBudWxsPihXb3JrZXJSZXF1ZXN0VHlwZS5QSU5HLCBudWxsKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG4gICAgLyoqIFRyeSB0byBkcm9wIGEgZmlsZSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGRyb3BGaWxlKG5hbWU6IHN0cmluZyk6IFByb21pc2U8bnVsbD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5EUk9QX0ZJTEUsIHN0cmluZywgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFLCBuYW1lKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuICAgIC8qKiBUcnkgdG8gZHJvcCBmaWxlcyAqL1xyXG4gICAgcHVibGljIGFzeW5jIGRyb3BGaWxlcygpOiBQcm9taXNlPG51bGw+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbCwgbnVsbD4oV29ya2VyUmVxdWVzdFR5cGUuRFJPUF9GSUxFUywgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogRmx1c2ggYWxsIGZpbGVzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZmx1c2hGaWxlcygpOiBQcm9taXNlPG51bGw+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkxVU0hfRklMRVMsIG51bGwsIG51bGw+KFdvcmtlclJlcXVlc3RUeXBlLkZMVVNIX0ZJTEVTLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3BlbiB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBpbnN0YW50aWF0ZShcclxuICAgICAgICBtYWluTW9kdWxlVVJMOiBzdHJpbmcsXHJcbiAgICAgICAgcHRocmVhZFdvcmtlclVSTDogc3RyaW5nIHwgbnVsbCA9IG51bGwsXHJcbiAgICAgICAgcHJvZ3Jlc3M6IChwcm9ncmVzczogSW5zdGFudGlhdGlvblByb2dyZXNzKSA9PiB2b2lkID0gX3AgPT4ge30sXHJcbiAgICApOiBQcm9taXNlPG51bGw+IHtcclxuICAgICAgICB0aGlzLl9vbkluc3RhbnRpYXRpb25Qcm9ncmVzcy5wdXNoKHByb2dyZXNzKTtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TVEFOVElBVEUsIFtzdHJpbmcsIHN0cmluZyB8IG51bGxdLCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TVEFOVElBVEUsXHJcbiAgICAgICAgICAgIFttYWluTW9kdWxlVVJMLCBwdGhyZWFkV29ya2VyVVJMXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGhlIHZlcnNpb24gKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRWZXJzaW9uKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OLCBudWxsLCBzdHJpbmc+KFdvcmtlclJlcXVlc3RUeXBlLkdFVF9WRVJTSU9OLCBudWxsKTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKiogR2V0IHRoZSBmZWF0dXJlIGZsYWdzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0RmVhdHVyZUZsYWdzKCk6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkdFVF9GRUFUVVJFX0ZMQUdTLCBudWxsLCBudW1iZXI+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfRkVBVFVSRV9GTEFHUyxcclxuICAgICAgICAgICAgbnVsbCxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGZlYXR1cmUgPSBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBPcGVuIGEgbmV3IGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgb3Blbihjb25maWc6IER1Y2tEQkNvbmZpZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5PUEVOLCBEdWNrREJDb25maWcsIG51bGw+KFdvcmtlclJlcXVlc3RUeXBlLk9QRU4sIGNvbmZpZyk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVG9rZW5pemUgYSBzY3JpcHQgdGV4dCAqL1xyXG4gICAgcHVibGljIGFzeW5jIHRva2VuaXplKHRleHQ6IHN0cmluZyk6IFByb21pc2U8U2NyaXB0VG9rZW5zPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlRPS0VOSVpFLCBzdHJpbmcsIFNjcmlwdFRva2Vucz4oV29ya2VyUmVxdWVzdFR5cGUuVE9LRU5JWkUsIHRleHQpO1xyXG4gICAgICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29ubmVjdCB0byB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0SW50ZXJuYWwoKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09OTkVDVCwgbnVsbCwgQ29ubmVjdGlvbklEPihXb3JrZXJSZXF1ZXN0VHlwZS5DT05ORUNULCBudWxsKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29ubmVjdCB0byB0aGUgZGF0YWJhc2UgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8QXN5bmNEdWNrREJDb25uZWN0aW9uPiB7XHJcbiAgICAgICAgY29uc3QgY2lkID0gYXdhaXQgdGhpcy5jb25uZWN0SW50ZXJuYWwoKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFzeW5jRHVja0RCQ29ubmVjdGlvbih0aGlzLCBjaWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBEaXNjb25uZWN0IGZyb20gdGhlIGRhdGFiYXNlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZGlzY29ubmVjdChjb25uOiBDb25uZWN0aW9uSUQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCwgQ29ubmVjdGlvbklELCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRElTQ09OTkVDVCxcclxuICAgICAgICAgICAgY29ubixcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJ1biBhIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcnVuUXVlcnkoY29ubjogQ29ubmVjdGlvbklELCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLCBbQ29ubmVjdGlvbklELCBzdHJpbmddLCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUlVOX1FVRVJZLFxyXG4gICAgICAgICAgICBbY29ubiwgdGV4dF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogU3RhcnQgYSBwZW5kaW5nIHF1ZXJ5ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgc3RhcnRQZW5kaW5nUXVlcnkoY29ubjogQ29ubmVjdGlvbklELCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNUQVJUX1BFTkRJTkdfUVVFUlksIFtDb25uZWN0aW9uSUQsIHN0cmluZ10sIFVpbnQ4QXJyYXkgfCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuU1RBUlRfUEVORElOR19RVUVSWSxcclxuICAgICAgICAgICAgW2Nvbm4sIHRleHRdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogUG9sbCBhIHBlbmRpbmcgcXVlcnkgKi9cclxuICAgIHB1YmxpYyBhc3luYyBwb2xsUGVuZGluZ1F1ZXJ5KGNvbm46IENvbm5lY3Rpb25JRCk6IFByb21pc2U8VWludDhBcnJheSB8IG51bGw+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLCBDb25uZWN0aW9uSUQsIFVpbnQ4QXJyYXkgfCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUE9MTF9QRU5ESU5HX1FVRVJZLFxyXG4gICAgICAgICAgICBjb25uLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogQ2FuY2VsIGEgcGVuZGluZyBxdWVyeSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGNhbmNlbFBlbmRpbmdRdWVyeShjb25uOiBDb25uZWN0aW9uSUQpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ0FOQ0VMX1BFTkRJTkdfUVVFUlksIENvbm5lY3Rpb25JRCwgYm9vbGVhbj4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNBTkNFTF9QRU5ESU5HX1FVRVJZLFxyXG4gICAgICAgICAgICBjb25uLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZldGNoIHF1ZXJ5IHJlc3VsdHMgKi9cclxuICAgIHB1YmxpYyBhc3luYyBmZXRjaFF1ZXJ5UmVzdWx0cyhjb25uOiBDb25uZWN0aW9uSUQpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUywgQ29ubmVjdGlvbklELCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRkVUQ0hfUVVFUllfUkVTVUxUUyxcclxuICAgICAgICAgICAgY29ubixcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBHZXQgdGFibGUgbmFtZXMgKi9cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUYWJsZU5hbWVzKGNvbm46IG51bWJlciwgdGV4dDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HRVRfVEFCTEVfTkFNRVMsIFtudW1iZXIsIHN0cmluZ10sIHN0cmluZ1tdPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuR0VUX1RBQkxFX05BTUVTLFxyXG4gICAgICAgICAgICBbY29ubiwgdGV4dF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUHJlcGFyZSBhIHN0YXRlbWVudCBhbmQgcmV0dXJuIGl0cyBpZGVudGlmaWVyICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlUHJlcGFyZWQoY29ubjogbnVtYmVyLCB0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5DUkVBVEVfUFJFUEFSRUQsIFtudW1iZXIsIHN0cmluZ10sIG51bWJlcj4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNSRUFURV9QUkVQQVJFRCxcclxuICAgICAgICAgICAgW2Nvbm4sIHRleHRdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogQ2xvc2UgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgKi9cclxuICAgIHB1YmxpYyBhc3luYyBjbG9zZVByZXBhcmVkKGNvbm46IG51bWJlciwgc3RhdGVtZW50OiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ0xPU0VfUFJFUEFSRUQsIFtudW1iZXIsIG51bWJlcl0sIG51bGw+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DTE9TRV9QUkVQQVJFRCxcclxuICAgICAgICAgICAgW2Nvbm4sIHN0YXRlbWVudF0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG4gICAgLyoqIEV4ZWN1dGUgYSBwcmVwYXJlZCBzdGF0ZW1lbnQgYW5kIHJldHVybiB0aGUgZnVsbCByZXN1bHQgKi9cclxuICAgIHB1YmxpYyBhc3luYyBydW5QcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJVTl9QUkVQQVJFRCwgW0Nvbm5lY3Rpb25JRCwgbnVtYmVyLCBhbnlbXV0sIFVpbnQ4QXJyYXk+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SVU5fUFJFUEFSRUQsXHJcbiAgICAgICAgICAgIFtjb25uLCBzdGF0ZW1lbnQsIHBhcmFtc10sXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuICAgIC8qKiBFeGVjdXRlIGEgcHJlcGFyZWQgc3RhdGVtZW50IGFuZCBzdHJlYW0gdGhlIHJlc3VsdCAqL1xyXG4gICAgcHVibGljIGFzeW5jIHNlbmRQcmVwYXJlZChjb25uOiBudW1iZXIsIHN0YXRlbWVudDogbnVtYmVyLCBwYXJhbXM6IGFueVtdKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlNFTkRfUFJFUEFSRUQsIFtDb25uZWN0aW9uSUQsIG51bWJlciwgYW55W11dLCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuU0VORF9QUkVQQVJFRCxcclxuICAgICAgICAgICAgW2Nvbm4sIHN0YXRlbWVudCwgcGFyYW1zXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG4gICAgLyoqIEdsb2IgZmlsZSBpbmZvcyAqL1xyXG4gICAgcHVibGljIGFzeW5jIGdsb2JGaWxlcyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPFdlYkZpbGVbXT4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5HTE9CX0ZJTEVfSU5GT1MsIHN0cmluZywgV2ViRmlsZVtdPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuR0xPQl9GSUxFX0lORk9TLFxyXG4gICAgICAgICAgICBwYXRoLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogUmVnaXN0ZXIgZmlsZSB0ZXh0ICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJGaWxlVGV4dChuYW1lOiBzdHJpbmcsIHRleHQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFRFWFRfRU5DT0RFUi5lbmNvZGUodGV4dCk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlckZpbGVCdWZmZXIobmFtZSwgYnVmZmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgcGF0aC4gKi9cclxuICAgIHB1YmxpYyBhc3luYyByZWdpc3RlckZpbGVVUkwoXHJcbiAgICAgICAgbmFtZTogc3RyaW5nLFxyXG4gICAgICAgIHVybDogc3RyaW5nLFxyXG4gICAgICAgIHByb3RvOiBEdWNrREJEYXRhUHJvdG9jb2wsXHJcbiAgICAgICAgZGlyZWN0SU86IGJvb2xlYW4sXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAodXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdXJsID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCxcclxuICAgICAgICAgICAgW3N0cmluZywgc3RyaW5nLCBEdWNrREJEYXRhUHJvdG9jb2wsIGJvb2xlYW5dLFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgPihXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX1VSTCwgW25hbWUsIHVybCwgcHJvdG8sIGRpcmVjdElPXSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVnaXN0ZXIgYW4gZW1wdHkgZmlsZSBidWZmZXIuICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIobmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSLCBbc3RyaW5nLCBVaW50OEFycmF5XSwgbnVsbD4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLlJFR0lTVEVSX0ZJTEVfQlVGRkVSLFxyXG4gICAgICAgICAgICBbbmFtZSwgbmV3IFVpbnQ4QXJyYXkoKV0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZWdpc3RlciBhIGZpbGUgYnVmZmVyLiAqL1xyXG4gICAgcHVibGljIGFzeW5jIHJlZ2lzdGVyRmlsZUJ1ZmZlcihuYW1lOiBzdHJpbmcsIGJ1ZmZlcjogVWludDhBcnJheSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUiwgW3N0cmluZywgVWludDhBcnJheV0sIG51bGw+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5SRUdJU1RFUl9GSUxFX0JVRkZFUixcclxuICAgICAgICAgICAgW25hbWUsIGJ1ZmZlcl0sXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtidWZmZXIuYnVmZmVyXSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFJlZ2lzdGVyIGEgZmlsZSBoYW5kbGUuICovXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJGaWxlSGFuZGxlPEhhbmRsZVR5cGU+KFxyXG4gICAgICAgIG5hbWU6IHN0cmluZyxcclxuICAgICAgICBoYW5kbGU6IEhhbmRsZVR5cGUsXHJcbiAgICAgICAgcHJvdG9jb2w6IER1Y2tEQkRhdGFQcm90b2NvbCxcclxuICAgICAgICBkaXJlY3RJTzogYm9vbGVhbixcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsXHJcbiAgICAgICAgICAgIFtzdHJpbmcsIGFueSwgRHVja0RCRGF0YVByb3RvY29sLCBib29sZWFuXSxcclxuICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgID4oV29ya2VyUmVxdWVzdFR5cGUuUkVHSVNURVJfRklMRV9IQU5ETEUsIFtuYW1lLCBoYW5kbGUsIHByb3RvY29sLCBkaXJlY3RJT10pO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzaywgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFbmFibGUgZmlsZSBzdGF0aXN0aWNzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY29sbGVjdEZpbGVTdGF0aXN0aWNzKG5hbWU6IHN0cmluZywgZW5hYmxlOiBib29sZWFuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLCBbc3RyaW5nLCBib29sZWFuXSwgbnVsbD4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLkNPTExFQ1RfRklMRV9TVEFUSVNUSUNTLFxyXG4gICAgICAgICAgICBbbmFtZSwgZW5hYmxlXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzaywgW10pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBFeHBvcnQgZmlsZSBzdGF0aXN0aWNzICovXHJcbiAgICBwdWJsaWMgYXN5bmMgZXhwb3J0RmlsZVN0YXRpc3RpY3MobmFtZTogc3RyaW5nKTogUHJvbWlzZTxGaWxlU3RhdGlzdGljcz4ge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSBuZXcgV29ya2VyVGFzazxXb3JrZXJSZXF1ZXN0VHlwZS5FWFBPUlRfRklMRV9TVEFUSVNUSUNTLCBzdHJpbmcsIEZpbGVTdGF0aXN0aWNzPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuRVhQT1JUX0ZJTEVfU1RBVElTVElDUyxcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2ssIFtdKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQ29weSBhIGZpbGUgdG8gYSBidWZmZXIuICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY29weUZpbGVUb0J1ZmZlcihuYW1lOiBzdHJpbmcpOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUiwgc3RyaW5nLCBVaW50OEFycmF5PihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX0JVRkZFUixcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3RUYXNrKHRhc2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBDb3B5IGEgZmlsZSB0byBhIHBhdGguICovXHJcbiAgICBwdWJsaWMgYXN5bmMgY29weUZpbGVUb1BhdGgobmFtZTogc3RyaW5nLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuQ09QWV9GSUxFX1RPX1BBVEgsIFtzdHJpbmcsIHN0cmluZ10sIG51bGw+KFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5DT1BZX0ZJTEVfVE9fUEFUSCxcclxuICAgICAgICAgICAgW25hbWUsIHBhdGhdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogSW5zZXJ0IGFycm93IGZyb20gYW4gaXBjIHN0cmVhbSAqL1xyXG4gICAgcHVibGljIGFzeW5jIGluc2VydEFycm93RnJvbUlQQ1N0cmVhbShcclxuICAgICAgICBjb25uOiBDb25uZWN0aW9uSUQsXHJcbiAgICAgICAgYnVmZmVyOiBVaW50OEFycmF5LFxyXG4gICAgICAgIG9wdGlvbnM/OiBBcnJvd0luc2VydE9wdGlvbnMsXHJcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSAwKSByZXR1cm47XHJcbiAgICAgICAgLy8gUGFzcyB0byB0aGUgd29ya2VyXHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFxyXG4gICAgICAgICAgICBXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNLFxyXG4gICAgICAgICAgICBbbnVtYmVyLCBVaW50OEFycmF5LCBBcnJvd0luc2VydE9wdGlvbnMgfCB1bmRlZmluZWRdLFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgPihXb3JrZXJSZXF1ZXN0VHlwZS5JTlNFUlRfQVJST1dfRlJPTV9JUENfU1RSRUFNLCBbY29ubiwgYnVmZmVyLCBvcHRpb25zXSk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrLCBbYnVmZmVyLmJ1ZmZlcl0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEluc2VydCBhIGNzdiBmaWxlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0Q1NWRnJvbVBhdGgoY29ubjogQ29ubmVjdGlvbklELCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IENTVkluc2VydE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICAvLyBGbGF0dGVuIHRoZSB0YWJsZSBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29sdW1ucyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb3B0aW9ucy5jb2x1bW5zKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gb3B0aW9ucy5jb2x1bW5zW2tdO1xyXG4gICAgICAgICAgICAgICAgb3V0LnB1c2goYXJyb3dUb1NRTEZpZWxkKGssIHR5cGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zLmNvbHVtbnNGbGF0ID0gb3V0O1xyXG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jb2x1bW5zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUGFzcyB0byB0aGUgd29ya2VyXHJcbiAgICAgICAgY29uc3QgdGFzayA9IG5ldyBXb3JrZXJUYXNrPFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9DU1ZfRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIENTVkluc2VydE9wdGlvbnNdLCBudWxsPihcclxuICAgICAgICAgICAgV29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0NTVl9GUk9NX1BBVEgsXHJcbiAgICAgICAgICAgIFtjb25uLCBwYXRoLCBvcHRpb25zXSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGF3YWl0IHRoaXMucG9zdFRhc2sodGFzayk7XHJcbiAgICB9XHJcbiAgICAvKiogSW5zZXJ0IGEganNvbiBmaWxlICovXHJcbiAgICBwdWJsaWMgYXN5bmMgaW5zZXJ0SlNPTkZyb21QYXRoKGNvbm46IENvbm5lY3Rpb25JRCwgcGF0aDogc3RyaW5nLCBvcHRpb25zOiBKU09OSW5zZXJ0T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIC8vIEZsYXR0ZW4gdGhlIHRhYmxlIG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucy5jb2x1bW5zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3V0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBvcHRpb25zLmNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLmNvbHVtbnNba107XHJcbiAgICAgICAgICAgICAgICBvdXQucHVzaChhcnJvd1RvU1FMRmllbGQoaywgdHlwZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29sdW1uc0ZsYXQgPSBvdXQ7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNvbHVtbnM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQYXNzIHRvIHRoZSB3b3JrZXJcclxuICAgICAgICBjb25zdCB0YXNrID0gbmV3IFdvcmtlclRhc2s8V29ya2VyUmVxdWVzdFR5cGUuSU5TRVJUX0pTT05fRlJPTV9QQVRILCBbbnVtYmVyLCBzdHJpbmcsIEpTT05JbnNlcnRPcHRpb25zXSwgbnVsbD4oXHJcbiAgICAgICAgICAgIFdvcmtlclJlcXVlc3RUeXBlLklOU0VSVF9KU09OX0ZST01fUEFUSCxcclxuICAgICAgICAgICAgW2Nvbm4sIHBhdGgsIG9wdGlvbnNdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wb3N0VGFzayh0YXNrKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0IFdvcmtlciBmcm9tICd3ZWItd29ya2VyJztcclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVXb3JrZXIodXJsOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwpO1xyXG4gICAgY29uc3Qgd29ya2VyU2NyaXB0ID0gYXdhaXQgZmV0Y2gocmVxdWVzdCk7XHJcbiAgICBjb25zdCB3b3JrZXJVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGF3YWl0IHdvcmtlclNjcmlwdC5ibG9iKCkpO1xyXG4gICAgcmV0dXJuIG5ldyBXb3JrZXIod29ya2VyVVJMKTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBWZWN0b3IgfSBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgeyBEdWNrREJRdWVyeUNvbmZpZyB9IGZyb20gJy4uL3NyYy8nO1xyXG5cclxuLy8gVGhlIG1heCBpbnRlcnZhbCBpbiBtaWNyb3NlYyBmcm9tIER1Y2tEQiBpcyA4MyB5ZWFycyAzIG1vbnRocyA5OTkgZGF5cyAwMDoxNjozOS45OTk5OTksIHdpdGggbW9udGhzIGFzIDMwIGRheXMuXHJcbi8vIE5vdGUgdGhhdCBkdWUgdG8gQXJyb3cgSlMgbm90IHN1cHBvcnRpbmcgdGhlIGR1cmF0aW9uIHR5cGUsIHRoZSBjYXN0RHVyYXRpb25Ub0ludGVydmFsIG9wdGlvbiBpcyB1c2VkIGZvciBpbnRlcnZhbHMuXHJcbi8vIFRoaXMgaGFzIGEgc2lkZS1lZmZlY3QgdGhhdCB3aGlsZSB0aGUgdmFsdWUgaXMgaW4gbWljcm9zZWNvbmRzLCBpdCBvbmx5IGhhcyBtaWxsaXNlY29uZCBhY2N1cmFjeS4gVGhpcyBpc1xyXG4vLyBiZWNhdXNlIER1Y2tEQiBlbWl0cyBpbnRlcnZhbHMgaW4gbWlsbGlzZWNvbmRzIGFuZCB0aGUgQXJyb3cgVGltZTY0IHR5cGUgZG9lcyBub3Qgc3VwcG9ydCBtaWxsaXNlY29uZHMgYXMgdW5pdC5cclxuLy9jb25zdCBNQVhfSU5URVJWQUxfVVMgPSAoKCg4MyAqICgxMiAqIDMwKSArIDMgKiAzMCArIDk5OSkgKiAyNCAqIDYwICsgMTYpICogNjAgKyAzOSkgKiAxMDAwMDAwICsgOTk5MDAwO1xyXG5cclxuLy8gSlMgRGF0ZSBhdCArLy04NjQwMDAwMDAwMDAwMDAwbXNcclxuY29uc3QgTUlOSU1VTV9EQVRFX1NUUiA9ICctMjcxODIxLTA0LTIwJztcclxuY29uc3QgTUlOSU1VTV9EQVRFID0gbmV3IERhdGUoRGF0ZS5VVEMoLTI3MTgyMSwgMywgMjApKTtcclxuY29uc3QgTUFYSU1VTV9EQVRFX1NUUiA9ICcyNzU3NjAtMDktMTMnO1xyXG5jb25zdCBNQVhJTVVNX0RBVEUgPSBuZXcgRGF0ZShEYXRlLlVUQygyNzU3NjAsIDgsIDEzKSk7XHJcblxyXG4vLyBBbGwgY29sdW1ucyBjb250YWluIDMgdmFsdWVzOiBbbWluX3ZhbHVlLCBtYXhfdmFsdWUsIG51bGxdXHJcbnR5cGUgQW5zd2VyT2JqZWN0VHlwZSA9IHtcclxuICAgIFtrZXk6IHN0cmluZ106IGFueVtdO1xyXG59O1xyXG5cclxuaW50ZXJmYWNlIEFsbFR5cGVzVGVzdCB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBxdWVyeTogc3RyaW5nO1xyXG4gICAgc2tpcDogc3RyaW5nW107XHJcbiAgICBhbnN3ZXJNYXA6IEFuc3dlck9iamVjdFR5cGU7XHJcbiAgICBhbnN3ZXJDb3VudDogbnVtYmVyO1xyXG4gICAgcXVlcnlDb25maWc6IER1Y2tEQlF1ZXJ5Q29uZmlnIHwgbnVsbDtcclxufVxyXG5cclxuLy8gVGhlc2UgdHlwZXMgY3VycmVudGx5IGRvIG5vdCB3b3JrIGluIER1Y2tEQi1XQVNNXHJcbi8vIHRpbWVzdGFtcF94eCBhbmQgZGF0ZV90eiB0eXBlcyB3aWxsIHNvb24gYmUgZnVsbHkgc3VwcG9ydGVkIGJ5IGR1Y2tkYiBhbmQgc2hvdWxkIGJlIGFkZGVkIHRoZW4uXHJcbi8vIGh1Z2VpbnQsIGRlY18xOF8zLCBkZWMzOF8xMCBhbmQgdXVpZCByZXF1aXJlIEpTIEJpZ0ludHMgZm9yIGZ1bGwgc3VwcG9ydCwgd2hpY2ggaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgYnkgQXJyb3dKU1xyXG5jb25zdCBOT1RfSU1QTEVNRU5URURfVFlQRVMgPSBbXHJcbiAgICAndGltZXN0YW1wX3MnLFxyXG4gICAgJ3RpbWVzdGFtcF9tcycsXHJcbiAgICAndGltZXN0YW1wX25zJyxcclxuICAgICd0aW1lc3RhbXBfdHonLFxyXG4gICAgJ2h1Z2VpbnQnLFxyXG4gICAgJ2RlY18xOF82JyxcclxuICAgICdkZWMzOF8xMCcsXHJcbiAgICAndXVpZCcsXHJcbiAgICAnbWFwJyxcclxuICAgICdqc29uJyxcclxuICAgICdkYXRlX2FycmF5JyxcclxuICAgICd0aW1lc3RhbXBfYXJyYXknLFxyXG4gICAgJ3RpbWVzdGFtcHR6X2FycmF5JyxcclxuXTtcclxuXHJcbi8vIFRoZXNlIHR5cGVzIGFyZSBzdXBwb3J0ZWQsIGJ1dCBub3QgdGhlIGZ1bGwgcmFuZ2UgcmV0dXJuZWQgZnJvbSB0aGUgdGVzdF9hbGxfdHlwZXMoKSB0YWJsZSBmdW5jdGlvbiwgaGVyZSB3ZSBkZWZpbmVcclxuLy8gdGhlIGxpbWl0cyB3ZSBkbyBleHBlY3QgdG8gYmUgc3VwcG9ydGVkLlxyXG5jb25zdCBQQVJUSUFMTFlfSU1QTEVNRU5URURfVFlQRVMgPSBbJ2RhdGUnLCAndGltZXN0YW1wJ107XHJcbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQOiBBbnN3ZXJPYmplY3RUeXBlID0ge1xyXG4gICAgZGF0ZTogW01JTklNVU1fREFURS52YWx1ZU9mKCksIE1BWElNVU1fREFURS52YWx1ZU9mKCksIG51bGxdLFxyXG4gICAgdGltZXN0YW1wOiBbTUlOSU1VTV9EQVRFLnZhbHVlT2YoKSwgTUFYSU1VTV9EQVRFLnZhbHVlT2YoKSwgbnVsbF0sXHJcbn07XHJcblxyXG4vLyBTdWJxdWVyaWVzIHRoYXQgcmV0dXJuIHRoZSBsaW1pdHMgb2YgdGhlIHN1YnNldCBvZiB0aGUgZnVsbCByYW5nZSB0aGF0IGlzIGltcGxlbWVudGVkXHJcbmNvbnN0IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFU19TVUJTVElUVVRJT05TID0gW1xyXG4gICAgYChTRUxFQ1QgYXJyYXlfZXh0cmFjdChbJyR7TUlOSU1VTV9EQVRFX1NUUn0nOjpEYXRlLCcke01BWElNVU1fREFURV9TVFJ9Jzo6RGF0ZSxudWxsXSxpICsgMSkpIGFzIGRhdGVgLFxyXG4gICAgYChTRUxFQ1QgYXJyYXlfZXh0cmFjdChbJyR7TUlOSU1VTV9EQVRFX1NUUn0nOjpUaW1lc3RhbXAsJyR7TUFYSU1VTV9EQVRFX1NUUn0nOjpUaW1lc3RhbXAsbnVsbF0saSArIDEpKSBhcyB0aW1lc3RhbXBgLFxyXG5dO1xyXG5cclxuLy8gVGhlc2UgdHlwZXMgZG8gbm90IHdvcmsgd2l0aCBkZWZhdWx0IGNvbmZpZ3VyYXRpb24sIGJ1dCBoYXZlXHJcbmNvbnN0IFRZUEVTX1JFUVVJUklOR19DVVNUT01fQ09ORklHID0gWydkZWNfNF8xJywgJ2RlY185XzQnXTtcclxuXHJcbi8vIFR5cGVzIHRoYXQgYXJlIGZ1bGx5IHN1cHBvcnRlZC5cclxuY29uc3QgRlVMTFlfSU1QTEVNRU5URURfQU5TV0VSX01BUDogQW5zd2VyT2JqZWN0VHlwZSA9IHtcclxuICAgIGJvb2w6IFtmYWxzZSwgdHJ1ZSwgbnVsbF0sXHJcbiAgICB0aW55aW50OiBbLTEyOCwgMTI3LCBudWxsXSxcclxuICAgIHNtYWxsaW50OiBbLTMyNzY4LCAzMjc2NywgbnVsbF0sXHJcbiAgICBpbnQ6IFstMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0NywgbnVsbF0sXHJcbiAgICB1dGlueWludDogWzAsIDI1NSwgbnVsbF0sXHJcbiAgICB1c21hbGxpbnQ6IFswLCA2NTUzNSwgbnVsbF0sXHJcbiAgICB1aW50OiBbMCwgNDI5NDk2NzI5NSwgbnVsbF0sXHJcbiAgICB1YmlnaW50OiBbQmlnSW50KDApLCBCaWdJbnQoJzE4NDQ2NzQ0MDczNzA5NTUxNjE1JyksIG51bGxdLFxyXG4gICAgYmlnaW50OiBbQmlnSW50KCctOTIyMzM3MjAzNjg1NDc3NTgwOCcpLCBCaWdJbnQoJzkyMjMzNzIwMzY4NTQ3NzU4MDcnKSwgbnVsbF0sXHJcblxyXG4gICAgLy8gTm90ZSB0aGF0IHdlIG11bHRpcGx5IGJ5IHRob3VzYW5kIChhbmQgYWRkIDk5OSBmb3IgdGhlIG1heCkgYmVjYXVzZSB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgRHVja0RCIGlzIGluIG1pY3Jvc2Vjb25kcyxcclxuICAgIC8vIHdoZXJlYXMgdGhlIERhdGUgb2JqZWN0IGlzIGluIG1pbGxpc2Vjb25kcy5cclxuICAgIHRpbWU6IFtCaWdJbnQoMCksIEJpZ0ludChuZXcgRGF0ZSgnMTk3MC0wMS0wMVQyMzo1OTo1OS45OTkrMDA6MDAnKS52YWx1ZU9mKCkpICogQmlnSW50KDEwMDApICsgQmlnSW50KDk5OSksIG51bGxdLFxyXG4gICAgdGltZV90ejogW1xyXG4gICAgICAgIEJpZ0ludCgwKSxcclxuICAgICAgICBCaWdJbnQobmV3IERhdGUoJzE5NzAtMDEtMDFUMjM6NTk6NTkuOTk5KzAwOjAwJykudmFsdWVPZigpKSAqIEJpZ0ludCgxMDAwKSArIEJpZ0ludCg5OTkpLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICBdLFxyXG4gICAgaW50ZXJ2YWw6IFtuZXcgSW50MzJBcnJheShbMCwwXSksICBuZXcgSW50MzJBcnJheShbMCwwXSksIG51bGxdLFxyXG5cclxuICAgIGZsb2F0OiBbLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgMy40MDI4MjM0NjYzODUyODg2ZTM4LCBudWxsXSxcclxuICAgIGRvdWJsZTogWy0xLjc5NzY5MzEzNDg2MjMxNTdlMzA4LCAxLjc5NzY5MzEzNDg2MjMxNTdlMzA4LCBudWxsXSxcclxuICAgIHZhcmNoYXI6IFsnXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2JywgJ2dvb1xceDAwc2UnLCBudWxsXSxcclxuICAgIHNtYWxsX2VudW06IFsnRFVDS19EVUNLX0VOVU0nLCAnR09PU0UnLCBudWxsXSxcclxuICAgIG1lZGl1bV9lbnVtOiBbJ2VudW1fMCcsICdlbnVtXzI5OScsIG51bGxdLFxyXG4gICAgbGFyZ2VfZW51bTogWydlbnVtXzAnLCAnZW51bV82OTk5OScsIG51bGxdLFxyXG5cclxuICAgIGludF9hcnJheTogW1tdLCBbNDIsIDk5OSwgbnVsbCwgbnVsbCwgLTQyXSwgbnVsbF0sXHJcbiAgICBkb3VibGVfYXJyYXk6IFtbXSwgWzQyLjAsIE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSwgbnVsbCwgLTQyLjBdLCBudWxsXSxcclxuICAgIHZhcmNoYXJfYXJyYXk6IFtbXSwgWydcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODYnLCAnZ29vc2UnLCBudWxsLCAnJ10sIG51bGxdLFxyXG4gICAgbmVzdGVkX2ludF9hcnJheTogW1tdLCBbW10sIFs0MiwgOTk5LCBudWxsLCBudWxsLCAtNDJdLCBudWxsLCBbXSwgWzQyLCA5OTksIG51bGwsIG51bGwsIC00Ml1dLCBudWxsXSxcclxuXHJcbiAgICBzdHJ1Y3Q6IFsne1wiYVwiOm51bGwsXCJiXCI6bnVsbH0nLCAne1wiYVwiOjQyLFwiYlwiOlwiXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XCJ9JywgbnVsbF0sXHJcbiAgICBzdHJ1Y3Rfb2ZfYXJyYXlzOiBbXHJcbiAgICAgICAgJ3tcImFcIjpudWxsLFwiYlwiOm51bGx9JyxcclxuICAgICAgICAne1wiYVwiOls0Miw5OTksbnVsbCxudWxsLC00Ml0sXCJiXCI6W1wiXHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XHVEODNFXHVERDg2XCIsXCJnb29zZVwiLG51bGwsXCJcIl19JyxcclxuICAgICAgICBudWxsLFxyXG4gICAgXSxcclxuICAgIGFycmF5X29mX3N0cnVjdHM6IFtbXSwgWyd7XCJhXCI6bnVsbCxcImJcIjpudWxsfScsICd7XCJhXCI6NDIsXCJiXCI6XCJcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcIn0nLCBudWxsXSwgbnVsbF0sXHJcblxyXG4gICAgLy8gWFhYIHNvbWV0aW1lcyB0aHJvd3NcclxuICAgIC8vIG1hcDogWyd7fScsICd7XCJrZXkxXCI6XCJcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcdUQ4M0VcdUREODZcIixcImtleTJcIjpcImdvb3NlXCJ9JywgbnVsbF0sXHJcbiAgICBibG9iOiBbXHJcbiAgICAgICAgVWludDhBcnJheS5mcm9tKFtcclxuICAgICAgICAgICAgMTE2LCAxMDQsIDEwNSwgMTE1LCAxMDUsIDExNSwgOTcsIDEwOCwgMTExLCAxMTAsIDEwMywgOTgsIDEwOCwgMTExLCA5OCwgMCwgMTE5LCAxMDUsIDExNiwgMTA0LCAxMTAsIDExNyxcclxuICAgICAgICAgICAgMTA4LCAxMDgsIDk4LCAxMjEsIDExNiwgMTAxLCAxMTUsXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgVWludDhBcnJheS5mcm9tKFswLCAwLCAwLCA5N10pLFxyXG4gICAgICAgIG51bGwsXHJcbiAgICBdLFxyXG59O1xyXG5cclxuLy8gUmVwbGFjZW1lbnRzIGZvciB0aGUgdmFsdWVzIHdlIGtub3dpbmdseSBkb24ndCBzdXBwb3J0IGZyb20gdGhlIHRlc3RfYWxsX3R5cGVzIHF1ZXJ5XHJcbmNvbnN0IFJFUExBQ0VfQ09MVU1OUyA9IFBBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFUy5jb25jYXQoTk9UX0lNUExFTUVOVEVEX1RZUEVTKS5jb25jYXQoVFlQRVNfUkVRVUlSSU5HX0NVU1RPTV9DT05GSUcpO1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrKHY6IGFueSk6IGFueSB7XHJcbiAgICBpZiAodiA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgaWYgKHYgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICBjb25zdCByZXQgPSBBcnJheS5mcm9tKHYudG9BcnJheSgpKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXYuaXNWYWxpZChpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0W2ldID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5wYWNrKHJldCk7XHJcbiAgICB9IGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IHJldDogYW55ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHVucGFjayh2W2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0gZWxzZSBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH0gZWxzZSBpZiAodi50b0pTT04gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2LnRvSlNPTigpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0VmFsdWUoeDogYW55KTogYW55IHtcclxuICAgIGlmICh0eXBlb2YgeD8udmFsdWVPZiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiB4LnZhbHVlT2YoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IEFMTF9UWVBFU19URVNUOiBBbGxUeXBlc1Rlc3RbXSA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnZnVsbHkgc3VwcG9ydGVkIHR5cGVzJyxcclxuICAgICAgICBxdWVyeTogYFNFTEVDVCAqIFJFUExBQ0UoJ25vdF9pbXBsZW1lbnRlZCcgYXMgbWFwKSBGUk9NIHRlc3RfYWxsX3R5cGVzKClgLFxyXG4gICAgICAgIHNraXA6IFJFUExBQ0VfQ09MVU1OUyxcclxuICAgICAgICBhbnN3ZXJNYXA6IEZVTExZX0lNUExFTUVOVEVEX0FOU1dFUl9NQVAsXHJcbiAgICAgICAgYW5zd2VyQ291bnQ6IFJFUExBQ0VfQ09MVU1OUy5sZW5ndGggKyBPYmplY3Qua2V5cyhGVUxMWV9JTVBMRU1FTlRFRF9BTlNXRVJfTUFQKS5sZW5ndGgsXHJcbiAgICAgICAgcXVlcnlDb25maWc6IG51bGwsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdwYXJ0aWFsbHkgc3VwcG9ydGVkIHR5cGVzJyxcclxuICAgICAgICBxdWVyeTogYFNFTEVDVCAke1BBUlRJQUxMWV9JTVBMRU1FTlRFRF9UWVBFU19TVUJTVElUVVRJT05TLmpvaW4oJywgJyl9XHJcbiAgICAgICAgICAgICAgICBGUk9NIHJhbmdlKDAsIDMpIHRibChpKWAsXHJcbiAgICAgICAgc2tpcDogW10sXHJcbiAgICAgICAgYW5zd2VyTWFwOiBQQVJUSUFMTFlfSU1QTEVNRU5URURfQU5TV0VSX01BUCxcclxuICAgICAgICBhbnN3ZXJDb3VudDogUEFSVElBTExZX0lNUExFTUVOVEVEX1RZUEVTLmxlbmd0aCxcclxuICAgICAgICBxdWVyeUNvbmZpZzogbnVsbCxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3R5cGVzIHdpdGggY3VzdG9tIGNvbmZpZycsXHJcbiAgICAgICAgcXVlcnk6IGBTRUxFQ1QgJHtUWVBFU19SRVFVSVJJTkdfQ1VTVE9NX0NPTkZJRy5qb2luKCcsJyl9IEZST00gdGVzdF9hbGxfdHlwZXMoKWAsXHJcbiAgICAgICAgc2tpcDogW10sXHJcbiAgICAgICAgYW5zd2VyTWFwOiB7XHJcbiAgICAgICAgICAgIGRlY180XzE6IFstOTk5LjkwMDAwMDAwMDAwMDEsIDk5OS45MDAwMDAwMDAwMDAxLCBudWxsXSxcclxuICAgICAgICAgICAgZGVjXzlfNDogWy05OTk5OS45OTk5MDAwMDAwMSwgOTk5OTkuOTk5OTAwMDAwMDEsIG51bGxdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYW5zd2VyQ291bnQ6IFRZUEVTX1JFUVVJUklOR19DVVNUT01fQ09ORklHLmxlbmd0aCxcclxuICAgICAgICBxdWVyeUNvbmZpZzoge1xyXG4gICAgICAgICAgICBjYXN0RGVjaW1hbFRvRG91YmxlOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICB9LFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBbGxUeXBlcyhkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb24gfCBudWxsO1xyXG5cclxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xyXG4gICAgICAgIGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnVGVzdCBBbGwgVHlwZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEFMTF9UWVBFU19URVNUKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlc3QucXVlcnlDb25maWcpIGRiKCkub3Blbih7IHF1ZXJ5OiB0ZXN0LnF1ZXJ5Q29uZmlnIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLm51bUNvbHMpLnRvRXF1YWwodGVzdC5hbnN3ZXJDb3VudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2tpcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0ZXN0LnNraXApIHtcclxuICAgICAgICAgICAgICAgICAgICBza2lwLnNldChzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5udW1Db2xzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gcmVzdWx0cy5zY2hlbWEuZmllbGRzW2ldLm5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJiaXRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gcmVzdWx0cy5nZXRDaGlsZEF0KGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwLmdldChuYW1lKSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbCkubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbD8ubGVuZ3RoKS5ub3QudG9FcXVhbCgwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHVucGFjayhnZXRWYWx1ZShjb2whLmdldCgwKSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzBdKTsgLy8gTWluXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHVucGFjayhnZXRWYWx1ZShjb2whLmdldCgxKSkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzFdKTsgLy8gTWF4XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbCEuZ2V0KDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzJdKTsgLy8gTnVsbFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBbGxUeXBlc0FzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbm4pIHtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjb25uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdUZXN0IEFsbCBUeXBlcyBBc3luYycsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgQUxMX1RZUEVTX1RFU1QpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdC5xdWVyeUNvbmZpZykgZGIoKS5vcGVuKHsgcXVlcnk6IHRlc3QucXVlcnlDb25maWcgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0cy5udW1Db2xzKS50b0VxdWFsKHRlc3QuYW5zd2VyQ291bnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGVzdC5za2lwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcC5zZXQocywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubnVtQ29sczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHJlc3VsdHMuc2NoZW1hLmZpZWxkc1tpXS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiYml0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHJlc3VsdHMuZ2V0Q2hpbGRBdChpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcC5nZXQobmFtZSkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChjb2wpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChjb2w/Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChPYmplY3Qua2V5cyh0ZXN0LmFuc3dlck1hcCkpLnRvQ29udGFpbihuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodW5wYWNrKGdldFZhbHVlKGNvbCEuZ2V0KDApKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aXRoQ29udGV4dChuYW1lICsgJ3wnICsgY29sPy50b1N0cmluZygpICsgJ3xbMF0nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9FcXVhbCh0ZXN0LmFuc3dlck1hcFtuYW1lXVswXSk7IC8vIE1pblxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh1bnBhY2soZ2V0VmFsdWUoY29sIS5nZXQoMSkpKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLndpdGhDb250ZXh0KG5hbWUgKyAnfCcgKyBjb2w/LnRvU3RyaW5nKCkgKyAnfFsxXScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b0VxdWFsKHRlc3QuYW5zd2VyTWFwW25hbWVdWzFdKTsgLy8gTWF4XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGNvbCEuZ2V0KDIpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAud2l0aENvbnRleHQobmFtZSArICd8JyArIGNvbD8udG9TdHJpbmcoKSArICd8WzJdJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvRXF1YWwodGVzdC5hbnN3ZXJNYXBbbmFtZV1bMl0pOyAvLyBOdWxsXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCB7IGdldFMzUGFyYW1zLCBTM1BhcmFtcywgUzNQYXlsb2FkUGFyYW1zLCBjcmVhdGVTM0hlYWRlcnMsIHVyaUVuY29kZSwgZ2V0SFRUUFVybCB9IGZyb20gJy4uL3NyYy91dGlscyc7XHJcbmltcG9ydCB7IEFzeW5jRHVja0RCQ29ubmVjdGlvbiwgRHVja0RCQmluZGluZ3MsIER1Y2tEQkJpbmRpbmdzQmFzZSwgRHVja0RCTW9kdWxlIH0gZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCBCUk9XU0VSX1JVTlRJTUUgZnJvbSAnLi4vc3JjL2JpbmRpbmdzL3J1bnRpbWVfYnJvd3Nlcic7XHJcblxyXG4vLyBTMyBjb25maWcgZm9yIHRlc3RzXHJcbmNvbnN0IEJVQ0tFVF9OQU1FID0gJ3Rlc3QtYnVja2V0JztcclxuY29uc3QgQUNDRVNTX0tFWV9JRCA9ICdTM1JWRVInO1xyXG5jb25zdCBBQ0NFU1NfS0VZX1NFQ1JFVCA9ICdTM1JWRVInO1xyXG5jb25zdCBTM19FTkRQT0lOVCA9ICdodHRwOi8vbG9jYWxob3N0OjQ5MjMnO1xyXG5jb25zdCBTM19SRUdJT04gPSAnZXUtd2VzdC0xJztcclxuXHJcbmVudW0gQVdTQ29uZmlnVHlwZSB7XHJcbiAgICBFTVBUWSxcclxuICAgIFZBTElELFxyXG4gICAgSU5WQUxJRCxcclxufVxyXG5jb25zdCBzZXRBd3NDb25maWcgPSBhc3luYyBmdW5jdGlvbiAoY29ubjogQXN5bmNEdWNrREJDb25uZWN0aW9uLCB0eXBlOiBBV1NDb25maWdUeXBlID0gQVdTQ29uZmlnVHlwZS5WQUxJRCkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLkVNUFRZOlxyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3JlZ2lvbj0nJztcIik7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfYWNjZXNzX2tleV9pZD0nJztcIik7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfc2VjcmV0X2FjY2Vzc19rZXk9Jyc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49Jyc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfZW5kcG9pbnQ9JyR7UzNfRU5EUE9JTlR9JztgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLlZBTElEOlxyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfcmVnaW9uPScke1MzX1JFR0lPTn0nO2ApO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfYWNjZXNzX2tleV9pZD0nJHtBQ0NFU1NfS0VZX0lEfSc7YCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYFNFVCBzM19zZWNyZXRfYWNjZXNzX2tleT0nJHtBQ0NFU1NfS0VZX1NFQ1JFVH0nO2ApO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49Jyc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBTRVQgczNfZW5kcG9pbnQ9JyR7UzNfRU5EUE9JTlR9JztgKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBV1NDb25maWdUeXBlLklOVkFMSUQ6XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfcmVnaW9uPSdhLXZlcnktcmVtb3RlLWFuZC1ub24tZXhpc3RlbnQtczMtcmVnaW9uJztcIik7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXCJTRVQgczNfYWNjZXNzX2tleV9pZD0nVEhJU0FDQ0VTU0tFWUlESVNOT1RWQUxJRCc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PSdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCc7XCIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KFwiU0VUIHMzX3Nlc3Npb25fdG9rZW49J0lOVkFMSURTRVNTSU9OVE9LRU4nO1wiKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgU0VUIHMzX2VuZHBvaW50PScke1MzX0VORFBPSU5UfSc7YCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RIVFRQRlMoc2RiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbiB8IG51bGw7XHJcblxyXG4gICAgY29uc3QgZ2V0TW9kdWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCBtb2R1bGU6IER1Y2tEQk1vZHVsZSB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIGNvbm4hLnVzZVVuc2FmZSgoYmluZGluZ3M6IER1Y2tEQkJpbmRpbmdzLCBjb25fbnVtYmVyOiBudW1iZXIpID0+IHtcclxuICAgICAgICAgICAgbW9kdWxlID0gKGJpbmRpbmdzIGFzIER1Y2tEQkJpbmRpbmdzQmFzZSkubW9kO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV4cGVjdChtb2R1bGUpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgcmV0dXJuIG1vZHVsZTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZXNldCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICBzZGIoKS5yZXNldCgpO1xyXG4gICAgICAgIGNvbm4gPSBzZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9O1xyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiBhd2FpdCByZXNldCgpKTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiBhd2FpdCByZXNldCgpKTtcclxuXHJcbiAgICBkZXNjcmliZSgnSFRUUEZTJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCdzMyBjb25maWcgaXMgc2V0IGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gZ2V0TW9kdWxlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBhcmUgZW1wdHlcclxuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm8gPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlRXBvY2ggPSBnbG9iYWxGaWxlSW5mbyEuY2FjaGVFcG9jaDtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZykudG9CZURlZmluZWQoKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZz8ucmVnaW9uKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvPy5zM0NvbmZpZz8uYWNjZXNzS2V5SWQpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5zZWNyZXRBY2Nlc3NLZXkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QoZ2xvYmFsRmlsZUluZm8/LnMzQ29uZmlnPy5lbmRwb2ludCkudG9FcXVhbCgnJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb25maXJtIHNldHRpbmdzIGFyZSBjb3JyZWN0bHkgc2V0XHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX3JlZ2lvbj0nYS12ZXJ5LXJlbW90ZS1hbmQtbm9uLWV4aXN0ZW50LXMzLXJlZ2lvbic7XCIpO1xyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19hY2Nlc3Nfa2V5X2lkPSdUSElTQUNDRVNTS0VZSURJU05PVFZBTElEJztcIik7XHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX3NlY3JldF9hY2Nlc3Nfa2V5PSdUSElTU0VDUkVUQUNDRVNTS0VZSVNOT1RWQUxJRCc7XCIpO1xyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19zZXNzaW9uX3Rva2VuPSdBTklDRVNFU1NJT05UT0tFTic7XCIpO1xyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0nczMuc29tZS5zb3J0Lm9mLmNsb3VkJztcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvVXBkYXRlZCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvVXBkYXRlZD8uczNDb25maWcpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mb1VwZGF0ZWQ/LmNhY2hlRXBvY2gpLnRvRXF1YWwoY2FjaGVFcG9jaCArIDUpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBnZXRTM1BhcmFtcyhnbG9iYWxGaWxlSW5mb1VwZGF0ZWQ/LnMzQ29uZmlnLCAnczM6Ly90ZXN0LWJ1Y2tldC90ZXN0ZmlsZS50eHQnLCAnR0VUJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMudXJsKS50b0VxdWFsKCcvdGVzdGZpbGUudHh0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMucXVlcnkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLmhvc3QpLnRvRXF1YWwoJ3Rlc3QtYnVja2V0LnMzLnNvbWUuc29ydC5vZi5jbG91ZCcpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnJlZ2lvbikudG9FcXVhbCgnYS12ZXJ5LXJlbW90ZS1hbmQtbm9uLWV4aXN0ZW50LXMzLXJlZ2lvbicpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnNlcnZpY2UpLnRvRXF1YWwoJ3MzJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXMubWV0aG9kKS50b0VxdWFsKCdHRVQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5hY2Nlc3NLZXlJZCkudG9FcXVhbCgnVEhJU0FDQ0VTU0tFWUlESVNOT1RWQUxJRCcpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zLnNlY3JldEFjY2Vzc0tleSkudG9FcXVhbCgnVEhJU1NFQ1JFVEFDQ0VTU0tFWUlTTk9UVkFMSUQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtcy5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJ0FOSUNFU0VTU0lPTlRPS0VOJyk7XHJcblxyXG4gICAgICAgICAgICAvLyBDb3ZlciBmdWxsIGh0dHAgZW5kcG9pbnQgY29uZmlnXHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdodHRwOi8vbG9jYWxob3N0OjEzMzcnO1wiKTtcclxuICAgICAgICAgICAgY29uc3QgZ2xvYmFsRmlsZUluZm9GdWxsSHR0cEVuZHBvaW50ID0gQlJPV1NFUl9SVU5USU1FLmdldEdsb2JhbEZpbGVJbmZvKG1vZHVsZSEpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJhbXNGdWxsSHR0cEVuZHBvaW50ID0gZ2V0UzNQYXJhbXMoXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxGaWxlSW5mb0Z1bGxIdHRwRW5kcG9pbnQ/LnMzQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgJ3MzOi8vdGVzdC1idWNrZXQvdGVzdGZpbGUudHh0JyxcclxuICAgICAgICAgICAgICAgICdHRVQnLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zRnVsbEh0dHBFbmRwb2ludC5ob3N0KS50b0VxdWFsKCdsb2NhbGhvc3Q6MTMzNycpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzZXQgc2hvdWxkIGNsZWFyIGNvbmZpZ1xyXG4gICAgICAgICAgICBhd2FpdCByZXNldCgpO1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0NsZWFyZWQgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0NsZWFyZWQgPSBnZXRTM1BhcmFtcyhnbG9iYWxGaWxlSW5mb0NsZWFyZWQ/LnMzQ29uZmlnLCAnczM6Ly90ZXN0LWJ1Y2tldC90ZXN0ZmlsZS50eHQnLCAnR0VUJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLnVybCkudG9FcXVhbCgnL3Rlc3RmaWxlLnR4dCcpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5xdWVyeSkudG9FcXVhbCgnJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJhbXNDbGVhcmVkLmhvc3QpLnRvRXF1YWwoJ3Rlc3QtYnVja2V0LnMzLmFtYXpvbmF3cy5jb20nKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQucmVnaW9uKS50b0VxdWFsKCcnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQuc2VydmljZSkudG9FcXVhbCgnczMnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQubWV0aG9kKS50b0VxdWFsKCdHRVQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHBhcmFtc0NsZWFyZWQuYWNjZXNzS2V5SWQpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5zZWNyZXRBY2Nlc3NLZXkpLnRvRXF1YWwoJycpO1xyXG4gICAgICAgICAgICBleHBlY3QocGFyYW1zQ2xlYXJlZC5zZXNzaW9uVG9rZW4pLnRvRXF1YWwoJycpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgndXJsIHBhcnNpbmcgaXMgY29ycmVjdCcsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbW9kdWxlID0gZ2V0TW9kdWxlKCk7XHJcblxyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0nJztcIik7XHJcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbEZpbGVJbmZvRGVmYXVsdCA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvRGVmYXVsdD8uczNDb25maWcpLnRvQmVEZWZpbmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRVcmwgPSBnZXRIVFRQVXJsKGdsb2JhbEZpbGVJbmZvRGVmYXVsdD8uczNDb25maWcsIGBzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3QtZmlsZS5jc3ZgKTtcclxuICAgICAgICAgICAgZXhwZWN0KGRlZmF1bHRVcmwpLnRvRXF1YWwoYGh0dHBzOi8vJHtCVUNLRVRfTkFNRX0uczMuYW1hem9uYXdzLmNvbS90ZXN0LWZpbGUuY3N2YCk7XHJcblxyXG4gICAgICAgICAgICBjb25uIS5xdWVyeShcIlNFVCBzM19lbmRwb2ludD0naHR0cHM6Ly9kdWNrZGJsYWJzLmNvbSc7XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0Z1bGxVcmwgPSBCUk9XU0VSX1JVTlRJTUUuZ2V0R2xvYmFsRmlsZUluZm8obW9kdWxlISk7XHJcbiAgICAgICAgICAgIGV4cGVjdChnbG9iYWxGaWxlSW5mb0Z1bGxVcmw/LnMzQ29uZmlnKS50b0JlRGVmaW5lZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsVXJsID0gZ2V0SFRUUFVybChnbG9iYWxGaWxlSW5mb0Z1bGxVcmw/LnMzQ29uZmlnLCBgczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChmdWxsVXJsKS50b0VxdWFsKGBodHRwczovL2R1Y2tkYmxhYnMuY29tLyR7QlVDS0VUX05BTUV9L3Rlc3QtZmlsZS5jc3ZgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KFwiU0VUIHMzX2VuZHBvaW50PSdkdWNrZGJsYWJzLmNvbSc7XCIpO1xyXG4gICAgICAgICAgICBjb25zdCBnbG9iYWxGaWxlSW5mb0RvbWFpbiA9IEJST1dTRVJfUlVOVElNRS5nZXRHbG9iYWxGaWxlSW5mbyhtb2R1bGUhKTtcclxuICAgICAgICAgICAgZXhwZWN0KGdsb2JhbEZpbGVJbmZvRG9tYWluPy5zM0NvbmZpZykudG9CZURlZmluZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgZG9tYWluT25seVVybCA9IGdldEhUVFBVcmwoZ2xvYmFsRmlsZUluZm9Eb21haW4/LnMzQ29uZmlnLCBgczM6Ly8ke0JVQ0tFVF9OQU1FfS90ZXN0LWZpbGUuY3N2YCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChkb21haW5Pbmx5VXJsKS50b0VxdWFsKGBodHRwczovLyR7QlVDS0VUX05BTUV9LmR1Y2tkYmxhYnMuY29tL3Rlc3QtZmlsZS5jc3ZgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gdmFsaWRhdGUgYXV0aG9yaXphdGlvbiBoZWFkZXJzIGZvciBrbm93biByZXF1ZXN0cywgYmFzZWQgb246IGh0dHBzOi8vY3phay5wbC8yMDE1LzA5LzE1L3MzLXJlc3QtYXBpLXdpdGgtY3VybC5odG1sXHJcbiAgICAgICAgaXQoJ3MzIGhlbHBlciBwYXNzZXMgdmFsaWRhdGlvbicsICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGVzdFBhcmFtczE6IFMzUGFyYW1zID0ge1xyXG4gICAgICAgICAgICAgICAgdXJsOiAnLycsXHJcbiAgICAgICAgICAgICAgICBxdWVyeTogJycsXHJcbiAgICAgICAgICAgICAgICBob3N0OiAnbXktcHJlY2lvdXMtYnVja2V0LnMzLmFtYXpvbmF3cy5jb20nLFxyXG4gICAgICAgICAgICAgICAgcmVnaW9uOiAndXMtZWFzdC0xJyxcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdzMycsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6ICdBS0lBSU9TRk9ETk43RVhBTVBMRScsXHJcbiAgICAgICAgICAgICAgICBzZWNyZXRBY2Nlc3NLZXk6ICd3SmFsclhVdG5GRU1JL0s3TURFTkcvYlB4UmZpQ1lFWEFNUExFS0VZJyxcclxuICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogJycsXHJcbiAgICAgICAgICAgICAgICBkYXRlTm93OiAnMjAxNTA5MTUnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZXRpbWVOb3c6ICcyMDE1MDkxNVQxMjQ1MDBaJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlUzNIZWFkZXJzKHRlc3RQYXJhbXMxKS5nZXQoJ0F1dGhvcml6YXRpb24nKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChcclxuICAgICAgICAgICAgICAgICdBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9QUtJQUlPU0ZPRE5ON0VYQU1QTEUvMjAxNTA5MTUvdXMtZWFzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1ob3N0O3gtYW16LWNvbnRlbnQtc2hhMjU2O3gtYW16LWRhdGUsIFNpZ25hdHVyZT0xODIwNzJlYjUzZDg1YzM2YjJkNzkxYTFmYTQ2YTEyZDIzNDU0ZWMxZTkyMWIwMjA3NWMyM2FlZTQwMTY2ZDVhJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbm9uaWNhbF9xdWVyeV9zdHJpbmcgPSAnZGVsaW1pdGVyPSUyRiZlbmNvZGluZy10eXBlPXVybCZsaXN0LXR5cGU9MiZwcmVmaXg9JzsgLy8gYXdzIHMzIGxzIDxidWNrZXQ+XHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQYXJhbXMyOiBTM1BhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogJy8nLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6IGNhbm9uaWNhbF9xdWVyeV9zdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBob3N0OiAnbXktcHJlY2lvdXMtYnVja2V0LnMzLmV1LXdlc3QtMS5hbWF6b25hd3MuY29tJyxcclxuICAgICAgICAgICAgICAgIHJlZ2lvbjogJ2V1LXdlc3QtMScsXHJcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiAnczMnLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgICAgICAgICAgIGFjY2Vzc0tleUlkOiAnQVNJQVlTUElPWURUSFRCSUlUVkMnLFxyXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAndnMxQlpQeFNMMnFWQVJCU2c1dkNNS0pzYXZDb0VQbG8vSFNIUmFWZScsXHJcbiAgICAgICAgICAgICAgICBzZXNzaW9uVG9rZW46XHJcbiAgICAgICAgICAgICAgICAgICAgJ0lRb0piM0pwWjJsdVgyVmpFTlgvLy8vLy8vLy8vd0VhQ1dWMUxYZGxjM1F0TVNKSE1FVUNJUURmanpzOUJZSHJFWERNVS9OUitQSFYxdVNUcjdDU1ZTUWRqS1NmaVBSTGRnSWdDQ3p0RjBWTWJpOSt1SEhBZkJWS2hWNHQ5TWxVclFnM1ZBT0lzTHhyV3lvcWxBSUlIUkFBR2d3MU9EazBNelE0T1RZMk1UUWlET0dsMkRzWXhFTmNLQ2JoK2lyeEFSZTkxZmFJK2h3VWhUNjBzTUdSRmcwR1dlZktuUGNsSDR1UkZ6Y3pyRE9jSmxBQWFRUko3S09zVDhCckpsclkxalNnamtPN1BrVmpQcDkydmk2bEpYNzdiZzk5TWtVVEpBY3RpT0ttZDg0WHZBRTViRmMvakZicWVjaHRCalh6b3BBUGtLc0d1YXFBaENlblhuRnQ2Y3dxK0xaaWt2L05KR1Z3N1RScGhMVitBcTlQU0w5WHdkeklnc1cycVh3ZTFjM3J4RE5qNTN5U3RSWkhWZ2dkeEowT2dIeDV2MDQwYzk4Z0ZwaHpTVUxIeWcwT1k2d21DTVRZY3N3cGI0a08ySUlpNkFpRDljWTI1VGx3UEtSS1BpNUNkQnNUUG55VGVXNjJ1N1B2d0swZlRTeTRadUpVdUdLUW5IMmNLbUNYcXVFd29PSEVpUVk2blFIOWZ6WS9FREdITVJ4V1doeHUwSGlxSWZzdUZxQzdHUzBwMFRvS1FFK3B6TnN2VndNalpjK0tJTElERFFwZENXUkl3dTUzSTVQWnkyQ3ZrKzN5NFhMdmRaS1FDc0FLcWVPYzRjOTRVQVM0Tm1VVDdtQ0RPdVJWMGNMQlZNOEYwSllCR3JVeHlJK1lvSXZIaFFXbW5STHVLZ1RiNVBrRjdaV3JYQkhGV0c1L3RaRE92QmJiYUNXVGxSQ0w5YjBWcGc1K0JNLzgxeGQ4akNoUDR3ODMnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZU5vdzogJzIwMjEwOTA0JyxcclxuICAgICAgICAgICAgICAgIGRhdGV0aW1lTm93OiAnMjAyMTA5MDRUMTIxNzQ2WicsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBjcmVhdGVTM0hlYWRlcnModGVzdFBhcmFtczIpLmdldCgnQXV0aG9yaXphdGlvbicpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0MikudG9FcXVhbChcclxuICAgICAgICAgICAgICAgICdBV1M0LUhNQUMtU0hBMjU2IENyZWRlbnRpYWw9QVNJQVlTUElPWURUSFRCSUlUVkMvMjAyMTA5MDQvZXUtd2VzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1ob3N0O3gtYW16LWNvbnRlbnQtc2hhMjU2O3gtYW16LWRhdGU7eC1hbXotc2VjdXJpdHktdG9rZW4sIFNpZ25hdHVyZT00ZDlkNmI1OWQ3ODM2YjY0ODVmNmFkODIyZGU5N2JlNDAyODdkYTMwMzQ3ZDgzMDQyZWE3ZmJlZDUzMGRjNGMwJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRlc3RQYXJhbXMzOiBTM1BhcmFtcyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogJy9jb3JyZWN0X2F1dGhfdGVzdC5jc3YnLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6ICcnLFxyXG4gICAgICAgICAgICAgICAgaG9zdDogJ3Rlc3QtYnVja2V0LWNlaXZlcmFuLnMzLmFtYXpvbmF3cy5jb20nLFxyXG4gICAgICAgICAgICAgICAgcmVnaW9uOiAnZXUtd2VzdC0xJyxcclxuICAgICAgICAgICAgICAgIHNlcnZpY2U6ICdzMycsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQVVQnLFxyXG4gICAgICAgICAgICAgICAgYWNjZXNzS2V5SWQ6ICdTM1JWRVInLFxyXG4gICAgICAgICAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiAnUzNSVkVSJyxcclxuICAgICAgICAgICAgICAgIHNlc3Npb25Ub2tlbjogJycsXHJcbiAgICAgICAgICAgICAgICBkYXRlTm93OiAnMjAyMjAxMjEnLFxyXG4gICAgICAgICAgICAgICAgZGF0ZXRpbWVOb3c6ICcyMDIyMDEyMVQxNDE0NTJaJyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdGVzdDNQYXlsb2FkUGFyYW1zOiBTM1BheWxvYWRQYXJhbXMgPSB7XHJcbiAgICAgICAgICAgICAgICBjb250ZW50SGFzaDogJzI4YTBjZjZhYzVjNGNiNzM3OTMwOTFmZTZlY2M2YTY4YmY5MDg1NWFjOTE4NjE1ODc0ODE1OGY1MDI0MWJiMGMnLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICd0ZXh0L2RhdGE7Y2hhcnNldD11dGYtOCcsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDMgPSBjcmVhdGVTM0hlYWRlcnModGVzdFBhcmFtczMsIHRlc3QzUGF5bG9hZFBhcmFtcykuZ2V0KCdBdXRob3JpemF0aW9uJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQzKS50b0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgJ0FXUzQtSE1BQy1TSEEyNTYgQ3JlZGVudGlhbD1TM1JWRVIvMjAyMjAxMjEvZXUtd2VzdC0xL3MzL2F3czRfcmVxdWVzdCwgU2lnbmVkSGVhZGVycz1jb250ZW50LXR5cGU7aG9zdDt4LWFtei1jb250ZW50LXNoYTI1Njt4LWFtei1kYXRlLCBTaWduYXR1cmU9NWQ5YTZjYmZhYTc4YTZkMGYyYWI3ZGYwNDQ1ZTJmMWNjOWM4MGNkMzY1NWFjN2RlOWU3MjE5YzAzNmYyM2YwMicsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvY2F0ZWdvcnk9Qm9va3MvJykpLnRvRXF1YWwoJy9jYXRlZ29yeSUzREJvb2tzLycpO1xyXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvP2NhdGVnb3J5PUJvb2tzJnRpdGxlPUR1Y2tzIFJldHJlYXQvJykpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICAnLyUzRmNhdGVnb3J5JTNEQm9va3MlMjZ0aXRsZSUzRER1Y2tzJTIwUmV0cmVhdC8nLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QodXJpRW5jb2RlKCcvP2NhdGVnb3J5PUJvb2tzJnRpdGxlPUR1Y2tzIFJldHJlYXQvJywgdHJ1ZSkpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICAnJTJGJTNGY2F0ZWdvcnklM0RCb29rcyUyNnRpdGxlJTNERHVja3MlMjBSZXRyZWF0JTJGJyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdEhUVFBGU0FzeW5jKFxyXG4gICAgYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXHJcbiAgICByZXNvbHZlRGF0YTogKHVybDogc3RyaW5nKSA9PiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPixcclxuICAgIGJhc2VEaXI6IHN0cmluZyxcclxuKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGw7XHJcblxyXG4gICAgLy8gUFVUcyBhbiBTMyBmaWxlIHRvIHRoZSBTMyB0ZXN0IHNlcnZlclxyXG4gICAgY29uc3QgcHV0VGVzdEZpbGVUb1MzID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVOYW1lOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nLCB0ZXN0X2RhdGE6IFVpbnQ4QXJyYXkgfCBudWxsKSB7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCd0ZXN0X2ZpbGUucGFycXVldCcsIHRlc3RfZGF0YSEpO1xyXG4gICAgICAgIGlmICghY29ubikge1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiwgQVdTQ29uZmlnVHlwZS5WQUxJRCk7XHJcbiAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHRlc3RfdGFibGUgQVMgKFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCd0ZXN0X2ZpbGUucGFycXVldCcpKTtgKTtcclxuICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDT1BZIHRlc3RfdGFibGUgVE8gJ3MzOi8vJHtCVUNLRVRfTkFNRX0vJHtmaWxlTmFtZX0uJHtmb3JtYXR9JyAoRk9STUFUICcke2Zvcm1hdH0nKTtgKTtcclxuICAgICAgICBhd2FpdCBhZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFJlcXVpcmVzIGFuIG9wZW4gY29ublxyXG4gICAgY29uc3QgYXNzZXJ0VGVzdEZpbGVSZXN1bHRDb3JyZWN0ID0gYXN5bmMgZnVuY3Rpb24gKHJlc3VsdDogYW55LCB0ZXN0X2RhdGE6IFVpbnQ4QXJyYXkgfCBudWxsKSB7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCd0ZXN0X2ZpbGVfYmFzZWxpbmUucGFycXVldCcsIHRlc3RfZGF0YSEpO1xyXG4gICAgICAgIGF3YWl0IGNvbm4hLnF1ZXJ5KGBTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2NhbigndGVzdF9maWxlX2Jhc2VsaW5lLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAvLyBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCkudG9BcnJheSgpKS50b0VxdWFsKHJlc3VsdF9iYXNlbGluZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBSZXNldCBkYXRhYmFzZXMgYmV0d2VlbiB0ZXN0c1xyXG4gICAgY29uc3QgcmVzZXQgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgYWRiKCkucmVzZXQoKTtcclxuICAgICAgICBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgfTtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4gYXdhaXQgcmVzZXQoKSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4gYXdhaXQgcmVzZXQoKSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0hUVFBGUyBBc3luYycsICgpID0+IHtcclxuICAgICAgICBpdCgnY2FuIGZldGNoIGh0dHBzIGZpbGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uIS5xdWVyeShcclxuICAgICAgICAgICAgICAgIGBzZWxlY3QgKiBmcm9tIFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2R1Y2tkYi9kdWNrZGItd2FzbS9tYXN0ZXIvZGF0YS90ZXN0LmNzdlwiO2AsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGV4cGVjdChCaWdJbnQocmVzdWx0cy5nZXRDaGlsZEF0KDIpPy5nZXQoMikpKS50b0VxdWFsKEJpZ0ludCg5bikpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnY2FuIHJlYWQgYW5kIHdyaXRlIGNzdiBmaWxlIGZyb20gUzMgd2l0aCBjb3JyZWN0IGF1dGggY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hKTtcclxuICAgICAgICAgICAgYXdhaXQgcHV0VGVzdEZpbGVUb1MzKCdjb3JyZWN0X2F1dGhfdGVzdCcsICdjc3YnLCBkYXRhKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0c193aXRoX2F1dGggPSBhd2FpdCBjb25uIS5xdWVyeShgc2VsZWN0ICogZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vY29ycmVjdF9hdXRoX3Rlc3QuY3N2XCI7YCk7XHJcbiAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBhc3NlcnRUZXN0RmlsZVJlc3VsdENvcnJlY3QocmVzdWx0c193aXRoX2F1dGgsIGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnY2FuIHJlYWQgYW5kIHdyaXRlIHBhcnF1ZXQgZmlsZSBmcm9tIFMzIHdpdGggY29ycmVjdCBhdXRoIGNyZWRlbnRpYWxzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHB1dFRlc3RGaWxlVG9TMygnY29ycmVjdF9hdXRoX3Rlc3QnLCAncGFycXVldCcsIGRhdGEpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzX3dpdGhfYXV0aCA9IGF3YWl0IGNvbm4hLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgYHNlbGVjdCAqIGZyb20gXCJzMzovLyR7QlVDS0VUX05BTUV9L2NvcnJlY3RfYXV0aF90ZXN0LnBhcnF1ZXRcIjtgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgYXNzZXJ0VGVzdEZpbGVSZXN1bHRDb3JyZWN0KHJlc3VsdHNfd2l0aF9hdXRoLCBkYXRhKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ2NhbiBub3QgcmVhZCBhIGZpbGUgd2l0aCBpbmNvcnJlY3QgY3JlZGVudGlhbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBhd2FpdCBwdXRUZXN0RmlsZVRvUzMoJ2luY29ycmVjdF9hdXRoX3Rlc3QnLCAncGFycXVldCcsIGRhdGEpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXRBd3NDb25maWcoY29ubiEsIEFXU0NvbmZpZ1R5cGUuSU5WQUxJRCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29ubiEucXVlcnkoYHNlbGVjdCAqIGZyb20gXCJzMzovLyR7QlVDS0VUX05BTUV9L2luY29ycmVjdF9hdXRoX3Rlc3QuY3N2XCI7YCksXHJcbiAgICAgICAgICAgICkudG9CZVJlamVjdGVkKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdwcm9wZXJseSBpbnZhbGlkYXRlcyBmaWxlIGNhY2hlcyBvbiBzZXR0aW5ncyB1cGRhdGUuJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzb2x2ZURhdGEoJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHB1dFRlc3RGaWxlVG9TMygnZmlsZV9jYWNoZV9pbnZhbGlkYXRpb25fdGVzdCcsICdwYXJxdWV0JywgZGF0YSk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldEF3c0NvbmZpZyhjb25uISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHNfY29ycmVjdCA9IGF3YWl0IGNvbm4hLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgYHNlbGVjdCBsX3BhcnRrZXkgZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vZmlsZV9jYWNoZV9pbnZhbGlkYXRpb25fdGVzdC5wYXJxdWV0XCIgbGltaXQgMTtgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0c19jb3JyZWN0LmdldENoaWxkQXQoMCk/LmdldCgwKSkudG9FcXVhbCgxNTUyKTtcclxuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hLCBBV1NDb25maWdUeXBlLklOVkFMSUQpO1xyXG4gICAgICAgICAgICBhd2FpdCBleHBlY3RBc3luYyhcclxuICAgICAgICAgICAgICAgIGNvbm4hLnF1ZXJ5KGBzZWxlY3QgYXZnKGxfcGFydGtleSkgZnJvbSBcInMzOi8vJHtCVUNLRVRfTkFNRX0vbGluZWl0ZW0ucGFycXVldFwiO2ApLFxyXG4gICAgICAgICAgICApLnRvQmVSZWplY3RlZCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnd3JpdGUgYWZ0ZXIgcmVhZCB0aHJvd3MgaW5jb3JyZWN0IGZsYWcgZXJyb3Igd2l0aG91dCBkcm9wcGluZyBmaWxlcycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgc2V0QXdzQ29uZmlnKGNvbm4hKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubiEucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgQ09QWSAoU0VMRUNUICogRlJPTSByYW5nZSgxMDAwLDEwMTApIHRibChpKSkgVE8gJ3MzOi8vJHtCVUNLRVRfTkFNRX0vdGVzdF93cml0dGVuLmNzdicgKEZPUk1BVCAnY3N2Jyk7YCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubiEucXVlcnkoYFNFTEVDVCAqIEZST00gXCJzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3Rfd3JpdHRlbi5jc3ZcIjtgKTtcclxuICAgICAgICAgICAgZXhwZWN0KE51bWJlcigocmVzdWx0LmdldENoaWxkQXQoMCk/LmdldCg2KSkpKS50b0VxdWFsKE51bWJlcigxMDA2KSk7XHJcbiAgICAgICAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKFxyXG4gICAgICAgICAgICAgICAgY29ubiEucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgYENPUFkgKFNFTEVDVCAqIEZST00gcmFuZ2UoMjAwMCwyMDEwKSB0YmwoaSkpIFRPICdzMzovLyR7QlVDS0VUX05BTUV9L3Rlc3Rfd3JpdHRlbi5jc3YnIChGT1JNQVQgJ2NzdicpO2AsXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICApLnRvQmVSZWplY3RlZFdpdGhFcnJvcignSW52YWxpZCBFcnJvcjogRmlsZSBpcyBub3Qgb3BlbmVkIGluIHdyaXRlIG1vZGUnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5pbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCB7IER1Y2tEQkFjY2Vzc01vZGUsIER1Y2tEQkRhdGFQcm90b2NvbCB9IGZyb20gJy4uL3NyYy8nO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RCaW5kaW5ncyhkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzLCBiYXNlVVJMOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0R1Y2tEQkJpbmRpbmdzJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdlcnJvciBoYW5kbGluZycsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ0lOVkFMSUQgU1FMJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnNlbmQoJ0lOVkFMSUQnKTtcclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChlcnJvcikubm90LnRvQmUobnVsbCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnQ2hlY2sgdmVyc2lvbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1ZlcnNpb24gY2hlY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gY29ubi5xdWVyeTx7IG5hbWU6IGFycm93LlV0ZjggfT4oXHJcbiAgICAgICAgICAgICAgICAgICAgXCJzZWxlY3QgKiBmcm9tIChzZWxlY3QgdmVyc2lvbigpKSB3aGVyZSB2ZXJzaW9uKCkgIT0gJ3YwLjAuMS1kZXYwJztcIixcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gdmVyc2lvbi50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvL2Rlc2NyaWJlKCdPcGVuJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIFhYWCBhcHBhcmVudGx5IHN5bmNocm9ub3VzIFhIUiBvbiB0aGUgbWFpbiB0aHJlYWQgZG9lcyBub3QgYWxsb3cgZm9yIGFycmF5YnVmZmVyIHJlc3BvbnNlIHR5cGU/XHJcbiAgICAgICAgLy8gaXQoJ1JlbW90ZSBUUENIIDBfMDEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlVVJMKCd0cGNoXzBfMDEuZGInLCBgJHtiYXNlVVJMfS90cGNoLzBfMDEvZHVja2RiL2RiYCk7XHJcbiAgICAgICAgLy8gICAgIGRiKCkub3BlbigndHBjaF8wXzAxLmRiJyk7XHJcbiAgICAgICAgLy8gfSk7XHJcbiAgICAgICAgLy99KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ1Jlc2V0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgndGFibGUgbXVzdCBkaXNhcHBlYXInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KCdDUkVBVEUgVEFCTEUgZm9vIChhIGludCknKTtcclxuICAgICAgICAgICAgICAgIGxldCB0YWJsZSA9IGNvbm4ucXVlcnk8eyBuYW1lOiBhcnJvdy5VdGY4IH0+KCdQUkFHTUEgc2hvd190YWJsZXM7Jyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm93cyA9IHRhYmxlLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzLmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzWzBdPy5uYW1lKS50b0VxdWFsKCdmb28nKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbm4gPSBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIHRhYmxlID0gY29ubi5xdWVyeTx7IG5hbWU6IGFycm93LlV0ZjggfT4oJ1BSQUdNQSBzaG93X3RhYmxlczsnKTtcclxuICAgICAgICAgICAgICAgIHJvd3MgPSB0YWJsZS50b0FycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qocm93cy5sZW5ndGgpLnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnUHJlcGFyZWQgU3RhdGVtZW50JywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnTWF0ZXJpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGNvbm4ucHJlcGFyZSgnU0VMRUNUIHY6OklOVEVHRVIgKyA/IEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdG10LnF1ZXJ5KDIzNCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMTAwMDEpO1xyXG4gICAgICAgICAgICAgICAgc3RtdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTdHJlYW1pbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gY29ubi5wcmVwYXJlKCdTRUxFQ1Qgdjo6SU5URUdFUiArID8gQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAxMDAwMCkgYXMgdCh2KTsnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHN0bXQuc2VuZCgyMzQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpemUgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiBzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGJhdGNoLm51bVJvd3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3Qoc2l6ZSkudG9CZSgxMDAwMSk7XHJcbiAgICAgICAgICAgICAgICBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpdCgnVHlwZWNoZWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHR5cGVjaGVjayAoXHJcbiAgICAgICAgICAgICAgICAgICAgYSBCT09MRUFOIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBiIFRJTllJTlQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgU01BTExJTlQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGQgSU5URUdFUiBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZSBCSUdJTlQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGYgRkxPQVQgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGcgRE9VQkxFIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBoIENIQVIoMTEpIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBpIFZBUkNIQVIoMTEpIERFRkFVTFQgTlVMTFxyXG4gICAgICAgICAgICAgICAgKWApO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0bXQgPSBjb25uLnByZXBhcmUoJ0lOU0VSVCBJTlRPIHR5cGVjaGVjayBWQUxVRVMoPyw/LD8sPyw/LD8sPyw/LD8pJyk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KHRydWUsIDEwMCwgMTBfMDAwLCAxXzAwMF8wMDAsIDVfMDAwXzAwMF8wMDAsIDAuNSwgTWF0aC5QSSwgJ2hlbGxvIHdvcmxkJywgJ2hpJyksXHJcbiAgICAgICAgICAgICAgICApLm5vdC50b1Rocm93KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAndGVzdCcsIC8vIHZhcmNoYXIgZm9yIGJvb2xcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICApLnRvVGhyb3coKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCgoKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCwgLy8gc21hbGxpbnQgZm9yIHRpbnlpbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlbGxvIHdvcmxkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpJyxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgKS50b1Rocm93KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCwgLy8gaW50IGZvciBzbWFsbGludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDVfMDAwXzAwMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5QSSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hlbGxvIHdvcmxkJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2hpJyxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgKS50b1Rocm93KCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoKCkgPT5cclxuICAgICAgICAgICAgICAgICAgICBzdG10LnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCwgLy8gYmlnaW50IGZvciBpbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICAgICApLnRvVGhyb3coKTtcclxuICAgICAgICAgICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBc3luY0JpbmRpbmdzKFxyXG4gICAgYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXHJcbiAgICBiYXNlVVJMOiBzdHJpbmcsXHJcbiAgICBiYXNlRGlyUHJvdG86IER1Y2tEQkRhdGFQcm90b2NvbCxcclxuKTogdm9pZCB7XHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHt9KTtcclxuXHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGFkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBhZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdCaW5kaW5ncycsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnT3BlbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1JlbW90ZSBUUENIIDBfMDEnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5yZWdpc3RlckZpbGVVUkwoJ3RwY2hfMF8wMS5kYicsIGAke2Jhc2VVUkx9L3RwY2gvMF8wMS9kdWNrZGIvZGJgLCBiYXNlRGlyUHJvdG8sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICd0cGNoXzBfMDEuZGInLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgICAgICBhOiBhcnJvdy5JbnQ7XHJcbiAgICAgICAgICAgICAgICB9Pignc2VsZWN0IGNvdW50KCopOjpJTlRFR0VSIGFzIGEgZnJvbSBsaW5laXRlbScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IHRhYmxlLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzLmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyb3dzWzBdPy5hKS50b0VxdWFsKDYwMTc1KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRlc2NyaWJlKCdQYXRjaGluZycsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ0NvdW50KCopIERlZmF1bHQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RCaWdJbnRUb0RvdWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0IDE6OkJJR0lOVCcpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHMubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHNbMF0udHlwZUlkKS50b0VxdWFsKGFycm93LlR5cGUuSW50KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQ291bnQoKikgTm8gQmlnSW50JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXN0QmlnSW50VG9Eb3VibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0IDE6OkJJR0lOVCcpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHMubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlLnNjaGVtYS5maWVsZHNbMF0udHlwZUlkKS50b0VxdWFsKGFycm93LlR5cGUuRmxvYXQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ1ByZXBhcmVkIFN0YXRlbWVudCcsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ01hdGVyaWFsaXplZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgY29ubi5wcmVwYXJlKCdTRUxFQ1QgdiArID8gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG10LnF1ZXJ5KDIzNCk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMTAwMDEpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTdHJlYW1pbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IGNvbm4ucHJlcGFyZSgnU0VMRUNUIHY6OklOVEVHRVIgKyA/IEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7Jyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzdG10LnNlbmQoMjM0KTtcclxuICAgICAgICAgICAgICAgIGxldCBzaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2Ygc3RyZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBiYXRjaC5udW1Sb3dzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHNpemUpLnRvQmUoMTAwMDEpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1R5cGVjaGVjaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDUkVBVEUgVEFCTEUgdHlwZWNoZWNrIChcclxuICAgICAgICAgICAgICAgICAgICBhIEJPT0xFQU4gREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGIgVElOWUlOVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgYyBTTUFMTElOVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZCBJTlRFR0VSIERFRkFVTFQgTlVMTCxcclxuICAgICAgICAgICAgICAgICAgICBlIEJJR0lOVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZiBGTE9BVCBERUZBVUxUIE5VTEwsXHJcbiAgICAgICAgICAgICAgICAgICAgZyBET1VCTEUgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGggQ0hBUigxMSkgREVGQVVMVCBOVUxMLFxyXG4gICAgICAgICAgICAgICAgICAgIGkgVkFSQ0hBUigxMSkgREVGQVVMVCBOVUxMXHJcbiAgICAgICAgICAgICAgICApYCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IGNvbm4ucHJlcGFyZSgnSU5TRVJUIElOVE8gdHlwZWNoZWNrIFZBTFVFUyg/LD8sPyw/LD8sPyw/LD8sPyknKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RUb1Rocm93ID0gYXN5bmMgKGZuOiAoKSA9PiBQcm9taXNlPHZvaWQ+KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRocm93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBmbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh0aHJvd2VkKS50b0JlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXN0JywgLy8gdmFyY2hhciBmb3IgYm9vbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMV8wMDBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaScsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0VG9UaHJvdyhhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5xdWVyeShcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTBfMDAwLCAvLyBzbWFsbGludCBmb3IgdGlueWludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAxMF8wMDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMV8wMDBfMDAwLCAvLyBpbnQgZm9yIHNtYWxsaW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDFfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgNV8wMDBfMDAwXzAwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMC41LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLlBJLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVsbG8gd29ybGQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaGknLFxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdFRvVGhyb3coYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLCAvLyBiaWdpbnQgZm9yIGludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA1XzAwMF8wMDBfMDAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguUEksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoZWxsbyB3b3JsZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdoaScsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ0FjY2Vzc01vZGUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdSRUFEX09OTFknLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBleHBlY3RBc3luYyhcclxuICAgICAgICAgICAgICAgICAgICBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzTW9kZTogRHVja0RCQWNjZXNzTW9kZS5SRUFEX09OTFksXHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICApLnRvQmVSZWplY3RlZFdpdGhFcnJvcigvQ2Fubm90IGxhdW5jaCBpbi1tZW1vcnkgZGF0YWJhc2UgaW4gcmVhZC1vbmx5IG1vZGUvKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGl0KCdSRUFEX1dSSVRFJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZXhwZWN0QXN5bmMoXHJcbiAgICAgICAgICAgICAgICAgICAgYWRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2Vzc01vZGU6IER1Y2tEQkFjY2Vzc01vZGUuUkVBRF9XUklURSxcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICkudG9CZVJlc29sdmVkKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkZXNjcmliZSgnQ2FuY2VsbGF0aW9uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnaGVsbG8gY2FuY2VsJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHF1ZXJ5IHBvbGxpbmcgaW50ZXJ2YWwgdG8gMCB0byBwb2xsIDEgdGFzayBhdCBhIHRpbWVcclxuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlQb2xsaW5nSW50ZXJ2YWw6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4udXNlVW5zYWZlKChkYiwgaWQpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgZGIuc3RhcnRQZW5kaW5nUXVlcnkoaWQsICdTRUxFQ1QgU1VNKGkpIEZST00gcmFuZ2UoMTAwMDAwMCkgdGJsKGkpOycpLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxPSyA9IGF3YWl0IGNvbm4udXNlVW5zYWZlKChkYiwgaWQpID0+IGRiLmNhbmNlbFBlbmRpbmdRdWVyeShpZCkpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGNhbmNlbE9LKS50b0JlVHJ1ZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvbGxlZEhlYWRlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9sbGVkRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBwb2xsZWRIZWFkZXIgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PiBkYi5wb2xsUGVuZGluZ1F1ZXJ5KGlkKSk7XHJcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2xsZWRFcnJvciA9IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocG9sbGVkSGVhZGVyKS50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEVycm9yKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChwb2xsZWRFcnJvci50b1N0cmluZygpKS50b0VxdWFsKCdFcnJvcjogcXVlcnkgd2FzIGNhbmNlbGVkJyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxlZEFnYWluID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoY2FuY2VsZWRBZ2FpbikudG9CZUZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgY29ubmVjdGlvbiBpcyBkZXN0cm95ZWQgb3Igbm90IHdoZW4gd2UgY2FuY2VsIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoJ3NlbGVjdCA0Mjo6aW50ZWdlcjsnKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzLmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnbm9vcCBjYW5jZWwnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UG9sbGluZ0ludGVydmFsOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PlxyXG4gICAgICAgICAgICAgICAgICAgIGRiLnN0YXJ0UGVuZGluZ1F1ZXJ5KGlkLCAnU0VMRUNUIFNVTShpKSBGUk9NIHJhbmdlKDEwMDAwMDApIHRibChpKTsnKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvbGxlZEhlYWRlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9sbGVkRXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBleGVjdXRlIDEgdGFzayBhdCBhIHRpbWUsIHNvIHRoaXMgbWF5IHRha2UgbXVsdGlwbGUgcG9sbHNcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocG9sbGVkSGVhZGVyID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9sbGVkSGVhZGVyID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIucG9sbFBlbmRpbmdRdWVyeShpZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbGxlZEVycm9yID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChwb2xsZWRIZWFkZXIpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHBvbGxlZEVycm9yKS50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsT0sgPSBhd2FpdCBjb25uLnVzZVVuc2FmZSgoZGIsIGlkKSA9PiBkYi5jYW5jZWxQZW5kaW5nUXVlcnkoaWQpKTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdChjYW5jZWxPSykudG9CZUZhbHNlKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbm90aGVyT25lID0gYXdhaXQgY29ubi51c2VVbnNhZmUoKGRiLCBpZCkgPT4gZGIuY2FuY2VsUGVuZGluZ1F1ZXJ5KGlkKSk7XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoYW5vdGhlck9uZSkudG9CZUZhbHNlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuXHJcbmNvbnN0IHRlc3RSb3dzID0gMTAwMDA7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdEJhdGNoU3RyZWFtKGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Fycm93IFJlY29yZC1CYXRjaGVzIFJvdy1NYWpvcicsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3chLnYpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdCSUdJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKEJpZ0ludChpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgYmF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdyEudikudG9CZShTdHJpbmcoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXJyb3cgUmVjb3JkLUJhdGNoZXMgQ29sdW1uLU1ham9yJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAxMjcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKyspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBiYXRjaC5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShTdHJpbmcoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXJyb3cgVGFibGUgUm93LU1ham9yJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrICYgMTI3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKysgJiAzMjc2Nyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdJTlRFR0VSJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6SU5URUdFUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYpLnRvQmUoQmlnSW50KGkrKykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3c/LnYudmFsdWVPZigpKS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Fycm93IFRhYmxlIENvbHVtbi1NYWpvcicsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMTI3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ1NNQUxMSU5UJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAzMjc2Nyk6OlNNQUxMSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdCSUdJTlQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpCSUdJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoQmlnSW50KGkrKykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU1RSSU5HJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6VkFSQ0hBUiBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShTdHJpbmcoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcblxyXG5jb25zdCB0ZXN0Um93cyA9IDEwMDAwO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBc3luY0JhdGNoU3RyZWFtKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uO1xyXG5cclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXN5bmNEdWNrREInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ3BpbmcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucGluZygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0Fycm93IFJlY29yZC1CYXRjaGVzIFJvdy1NYWpvcicsICgpID0+IHtcclxuICAgICAgICBkZXNjcmliZSgnc2luZ2xlIGNvbHVtbicsICgpID0+IHtcclxuICAgICAgICAgICAgaXQoJ1RJTllJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDEyNyk6OlRJTllJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBiYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93IS52KS50b0JlKGkrKyAmIDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKEJpZ0ludChpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgZGVzY3JpYmUoJ3NjcmlwdHMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCd0ZXN0MScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgeCwgKHNpbih2KSAqIDEwMCArIDEwMCk6OklOVEVHRVIgQVMgeSBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KVxyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdChiYXRjaC5udW1Db2xzKS50b0JlKDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIGJhdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdChyb3chLngpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdBcnJvdyBSZWNvcmQtQmF0Y2hlcyBDb2x1bW4tTWFqb3InLCAoKSA9PiB7XHJcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyAmIDEyNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtQ29scykudG9CZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYmF0Y2guZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKGkrKyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKEJpZ0ludChpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bUNvbHMpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGJhdGNoLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdBcnJvdyBUYWJsZSBSb3ctTWFqb3InLCAoKSA9PiB7XHJcbiAgICAgICAgZGVzY3JpYmUoJ3NpbmdsZSBjb2x1bW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdUSU5ZSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1QgKHYgJiAxMjcpOjpUSU5ZSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKysgJiAxMjcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3Qocm93Py52KS50b0JlKGkrKyAmIDMyNzY3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0lOVEVHRVInLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpJTlRFR0VSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShpKyspO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnQklHSU5UJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBjb25uLnF1ZXJ5KGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgdjo6QklHSU5UIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udikudG9CZShCaWdJbnQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHJvdz8udi52YWx1ZU9mKCkpLnRvQmUoU3RyaW5nKGkrKykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQXJyb3cgVGFibGUgQ29sdW1uLU1ham9yJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCdzaW5nbGUgY29sdW1uJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpdCgnVElOWUlOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUICh2ICYgMTI3KTo6VElOWUlOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShpKysgJiAxMjcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnU01BTExJTlQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCAodiAmIDMyNzY3KTo6U01BTExJTlQgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrICYgMzI3NjcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXhwZWN0KGkpLnRvQmUodGVzdFJvd3MgKyAxKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpdCgnSU5URUdFUicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OklOVEVHRVIgQVMgdiBGUk9NIGdlbmVyYXRlX3NlcmllcygwLCAke3Rlc3RSb3dzfSkgYXMgdCh2KTtcclxuICAgICAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRhYmxlLmdldENoaWxkQXQoMCkhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KHYpLnRvQmUoaSsrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaXQoJ0JJR0lOVCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgY29ubi5xdWVyeShgXHJcbiAgICAgICAgICAgICAgICAgICAgU0VMRUNUIHY6OkJJR0lOVCBBUyB2IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsICR7dGVzdFJvd3N9KSBhcyB0KHYpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGFibGUuZ2V0Q2hpbGRBdCgwKSEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QodikudG9CZShCaWdJbnQoaSsrKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBlY3QoaSkudG9CZSh0ZXN0Um93cyArIDEpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGl0KCdTVFJJTkcnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IGNvbm4ucXVlcnkoYFxyXG4gICAgICAgICAgICAgICAgICAgIFNFTEVDVCB2OjpWQVJDSEFSIEFTIHYgRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgJHt0ZXN0Um93c30pIGFzIHQodik7XHJcbiAgICAgICAgICAgICAgICBgKTtcclxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB0YWJsZS5nZXRDaGlsZEF0KDApISkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdCh2KS50b0JlKFN0cmluZyhpKyspKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4cGVjdChpKS50b0JlKHRlc3RSb3dzICsgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0RmlsZXN5c3RlbShcclxuICAgIGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIsXHJcbiAgICByZXNvbHZlRGF0YTogKHVybDogc3RyaW5nKSA9PiBQcm9taXNlPFVpbnQ4QXJyYXkgfCBudWxsPixcclxuICAgIGJhc2VEaXI6IHN0cmluZyxcclxuICAgIGJhc2VEaXJQcm90bzogZHVja2RiLkR1Y2tEQkRhdGFQcm90b2NvbCxcclxuKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ0ZpbGUgYnVmZmVyIHJlZ2lzdHJhdGlvbicsICgpID0+IHtcclxuICAgICAgICBjb25zdCB0ZXN0ID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFNFTEVDVCBtYXRybnIgRlJPTSBwYXJxdWV0X3NjYW4oJ3N0dWRlbnRlbi5wYXJxdWV0Jyk7YCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChiYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludCB9PihiYXRjaGVzKTtcclxuICAgICAgICAgICAgZXhwZWN0KHRhYmxlLmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChcclxuICAgICAgICAgICAgICAgIG5ldyBJbnQzMkFycmF5KFsyNDAwMiwgMjU0MDMsIDI2MTIwLCAyNjgzMCwgMjc1NTAsIDI4MTA2LCAyOTEyMCwgMjk1NTVdKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGl0KCdGaWxlIGJ1ZmZlciB1c2VkIG9uY2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcclxuICAgICAgICAgICAgYXdhaXQgdGVzdCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0KCdGaWxlIGJ1ZmZlciByZWdpc3RlcmVkIHR3aWNlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50czAgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50czEgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMwKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzMSkubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzMCEpO1xyXG4gICAgICAgICAgICBhd2FpdCB0ZXN0KCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzMSEpO1xyXG4gICAgICAgICAgICBhd2FpdCB0ZXN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaXQoJ0ZpbGUgYnVmZmVyIHVzZWQgdHdpY2UnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcclxuICAgICAgICAgICAgYXdhaXQgdGVzdCgpO1xyXG4gICAgICAgICAgICBhd2FpdCB0ZXN0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnUGFycXVldCBTY2FucycsICgpID0+IHtcclxuICAgICAgICBpdCgnc2luZ2xlIHRhYmxlIGZyb20gYnVmZmVyJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzISk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbm4uc2VuZChgU0VMRUNUIG1hdHJuciBGUk9NIHBhcnF1ZXRfc2Nhbignc3R1ZGVudGVuLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hlcy5wdXNoKGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IG5ldyBhcnJvdy5UYWJsZTx7IG1hdHJucjogYXJyb3cuSW50IH0+KGJhdGNoZXMpO1xyXG4gICAgICAgICAgICBleHBlY3QodGFibGUuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgbmV3IEludDMyQXJyYXkoWzI0MDAyLCAyNTQwMywgMjYxMjAsIDI2ODMwLCAyNzU1MCwgMjgxMDYsIDI5MTIwLCAyOTU1NV0pLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc2ltcGxlIGpvaW4nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgY29uc3QgaG9lcmVuID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvaG9lcmVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgY29uc3Qgdm9ybGVzdW5nZW4gPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS92b3JsZXN1bmdlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChob2VyZW4pLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICBleHBlY3Qodm9ybGVzdW5nZW4pLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50cyEpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignaG9lcmVuLnBhcnF1ZXQnLCBob2VyZW4hKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3Zvcmxlc3VuZ2VuLnBhcnF1ZXQnLCB2b3JsZXN1bmdlbiEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBcclxuICAgICAgICAgICAgICAgICAgICBTRUxFQ1Qgc3R1ZGVudHMubWF0cm5yLCB2b3JsZXN1bmdlbi50aXRlbFxyXG4gICAgICAgICAgICAgICAgICAgIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpIHN0dWRlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgSU5ORVIgSk9JTiBwYXJxdWV0X3NjYW4oJ2hvZXJlbi5wYXJxdWV0JykgaG9lcmVuIE9OIChzdHVkZW50cy5tYXRybnIgPSBob2VyZW4ubWF0cm5yKVxyXG4gICAgICAgICAgICAgICAgICAgIElOTkVSIEpPSU4gcGFycXVldF9zY2FuKCd2b3JsZXN1bmdlbi5wYXJxdWV0Jykgdm9ybGVzdW5nZW4gT04gKHZvcmxlc3VuZ2VuLnZvcmxuciA9IGhvZXJlbi52b3JsbnIpO1xyXG4gICAgICAgICAgICAgICAgYCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGJhdGNoZXMucHVzaChiYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdGFibGUgPSBhd2FpdCBuZXcgYXJyb3cuVGFibGU8eyBtYXRybnI6IGFycm93LkludDsgdGl0ZWw6IGFycm93LlV0ZjggfT4oYmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5udW1Db2xzKS50b0JlKDIpO1xyXG4gICAgICAgICAgICBjb25zdCBmbGF0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBmbGF0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJucjogcm93Py5tYXRybnIsXHJcbiAgICAgICAgICAgICAgICAgICAgdGl0ZWw6IHJvdz8udGl0ZWw/LnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleHBlY3QoZmxhdCkudG9FcXVhbChbXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjYxMjAsIHRpdGVsOiAnR3J1bmR6XHUwMEZDZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjc1NTAsIHRpdGVsOiAnR3J1bmR6XHUwMEZDZ2UnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjc1NTAsIHRpdGVsOiAnTG9naWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnRXRoaWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnV2lzc2Vuc2NoYWZ0c3RoZW9yaWUnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnQmlvZXRoaWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjgxMDYsIHRpdGVsOiAnRGVyIFdpZW5lciBLcmVpcycgfSxcclxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdHcnVuZHpcdTAwRkNnZScgfSxcclxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdFdGhpaycgfSxcclxuICAgICAgICAgICAgICAgIHsgbWF0cm5yOiAyOTEyMCwgdGl0ZWw6ICdNXHUwMEU0ZXV0aWsnIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjk1NTUsIHRpdGVsOiAnR2xhdWJlIHVuZCBXaXNzZW4nIH0sXHJcbiAgICAgICAgICAgICAgICB7IG1hdHJucjogMjU0MDMsIHRpdGVsOiAnR2xhdWJlIHVuZCBXaXNzZW4nIH0sXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ1dyaXRpbmcnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ0NvcHkgVG8gQ1NWIEJ1ZmZlcicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3R1ZGVudHMgPSBhd2FpdCByZXNvbHZlRGF0YSgnL3VuaS9zdHVkZW50ZW4ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBleHBlY3Qoc3R1ZGVudHMpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcignc3R1ZGVudGVuLnBhcnF1ZXQnLCBzdHVkZW50cyEpO1xyXG4gICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRW1wdHlGaWxlQnVmZmVyKCdzdHVkZW50cy5jc3YnKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzIEFTIFNFTEVDVCAqIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBDT1BZIHN0dWRlbnRzIFRPICdzdHVkZW50cy5jc3YnIFdJVEggKEhFQURFUiAxLCBERUxJTUlURVIgJzsnLCBGT1JNQVQgQ1NWKTtgKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgc3R1ZGVudHNgKTtcclxuICAgICAgICAgICAgY29uc3Qgb3V0QnVmZmVyID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50cy5jc3YnKTtcclxuICAgICAgICAgICAgZXhwZWN0KG91dEJ1ZmZlcikubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZShvdXRCdWZmZXIhKTtcclxuICAgICAgICAgICAgZXhwZWN0KHRleHQpLnRvQmUoYG1hdHJucjtuYW1lO3NlbWVzdGVyXHJcbjI0MDAyO1hlbm9rcmF0ZXM7MThcclxuMjU0MDM7Sm9uYXM7MTJcclxuMjYxMjA7RmljaHRlOzEwXHJcbjI2ODMwO0FyaXN0b3hlbm9zOzhcclxuMjc1NTA7U2Nob3BlbmhhdWVyOzZcclxuMjgxMDY7Q2FybmFwOzNcclxuMjkxMjA7VGhlb3BocmFzdG9zOzJcclxuMjk1NTU7RmV1ZXJiYWNoOzJcclxuYCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdDb3B5IFRvIFBhcnF1ZXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0dWRlbnRzID0gYXdhaXQgcmVzb2x2ZURhdGEoJy91bmkvc3R1ZGVudGVuLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgZXhwZWN0KHN0dWRlbnRzKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoJ3N0dWRlbnRlbi5wYXJxdWV0Jywgc3R1ZGVudHMhKTtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckVtcHR5RmlsZUJ1ZmZlcignc3R1ZGVudHMyLnBhcnF1ZXQnKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzMiBBUyBTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2Nhbignc3R1ZGVudGVuLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ09QWSBzdHVkZW50czIgVE8gJ3N0dWRlbnRzMi5wYXJxdWV0JyAoRk9STUFUIFBBUlFVRVQpO2ApO1xyXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJ3N0dWRlbnRzMi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh1cmwpLm5vdC50b0JlTnVsbCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnQ29weSBUbyBQYXJxdWV0IEFuZCBMb2FkIEFnYWluJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdHVkZW50cyA9IGF3YWl0IHJlc29sdmVEYXRhKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzdHVkZW50cykubm90LnRvQmVOdWxsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlQnVmZmVyKCdzdHVkZW50ZW4ucGFycXVldCcsIHN0dWRlbnRzISk7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJFbXB0eUZpbGVCdWZmZXIoJ3N0dWRlbnRzMy5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYENSRUFURSBUQUJMRSBzdHVkZW50czMgQVMgU0VMRUNUICogRlJPTSBwYXJxdWV0X3NjYW4oJ3N0dWRlbnRlbi5wYXJxdWV0Jyk7YCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYENPUFkgc3R1ZGVudHMzIFRPICdzdHVkZW50czMucGFycXVldCcgKEZPUk1BVCBQQVJRVUVUKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgdXJsID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCdzdHVkZW50czMucGFycXVldCcpO1xyXG4gICAgICAgICAgICBleHBlY3QodXJsKS5ub3QudG9CZU51bGwoKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgQ1JFQVRFIFRBQkxFIHN0dWRlbnRzNCBBUyBTRUxFQ1QgKiBGUk9NIHBhcnF1ZXRfc2Nhbignc3R1ZGVudHMzLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gc3R1ZGVudHM0O2ApO1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgbmV3IGFycm93LlRhYmxlPHsgbWF0cm5yOiBhcnJvdy5JbnQgfT4oYmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShbMjQwMDIsIDI1NDAzLCAyNjEyMCwgMjY4MzAsIDI3NTUwLCAyODEwNiwgMjkxMjAsIDI5NTU1XSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnRmlsZSBhY2Nlc3MnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ1NtYWxsIFBhcnF1ZXQgZmlsZScsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVVUkwoJ3N0dWRlbnRlbi5wYXJxdWV0JywgYCR7YmFzZURpcn0vdW5pL3N0dWRlbnRlbi5wYXJxdWV0YCwgYmFzZURpclByb3RvLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29ubi5zZW5kKGBTRUxFQ1QgbWF0cm5yIEZST00gcGFycXVldF9zY2FuKCdzdHVkZW50ZW4ucGFycXVldCcpO2ApO1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBiYXRjaGVzLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gYXdhaXQgbmV3IGFycm93LlRhYmxlPHsgbWF0cm5yOiBhcnJvdy5JbnQgfT4oYmF0Y2hlcyk7XHJcbiAgICAgICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwoXHJcbiAgICAgICAgICAgICAgICBuZXcgSW50MzJBcnJheShbMjQwMDIsIDI1NDAzLCAyNjEyMCwgMjY4MzAsIDI3NTUwLCAyODEwNiwgMjkxMjAsIDI5NTU1XSksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdMYXJnZSBQYXJxdWV0IGZpbGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlVVJMKFxyXG4gICAgICAgICAgICAgICAgJ2xpbmVpdGVtLnBhcnF1ZXQnLFxyXG4gICAgICAgICAgICAgICAgYCR7YmFzZURpcn0vdHBjaC8wXzAxL3BhcnF1ZXQvbGluZWl0ZW0ucGFycXVldGAsXHJcbiAgICAgICAgICAgICAgICBiYXNlRGlyUHJvdG8sXHJcbiAgICAgICAgICAgICAgICB0cnVlLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb25uLnNlbmQoYFNFTEVDVCBjb3VudCgqKTo6SU5URUdFUiBhcyBjbnQgRlJPTSBwYXJxdWV0X3NjYW4oJ2xpbmVpdGVtLnBhcnF1ZXQnKTtgKTtcclxuICAgICAgICAgICAgY29uc3QgYmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hlcy5wdXNoKGJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IGF3YWl0IG5ldyBhcnJvdy5UYWJsZTx7IGNudDogYXJyb3cuSW50IH0+KGJhdGNoZXMpO1xyXG4gICAgICAgICAgICBleHBlY3QodGFibGUuZ2V0Q2hpbGRBdCgwKT8uZ2V0KDApKS50b0JlR3JlYXRlclRoYW4oNjBfMDAwKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlc2NyaWJlKCdFeHBvcnQnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ0dlbmVyYXRlIFNlcmllcyBhcyBDU1YnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0NSRUFURSBUQUJMRSBmb28gQVMgU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KScpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBFWFBPUlQgREFUQUJBU0UgJy90bXAvZHVja2RiZXhwb3J0Y3N2J2ApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRiKCkuZ2xvYkZpbGVzKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi8qJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzKS5ub3QudG9FcXVhbChbXSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9FcXVhbCgzKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVzID0gcmVzdWx0cy5tYXAoZmlsZSA9PiBmaWxlLmZpbGVOYW1lKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChmaWxlbmFtZXMpLnRvRXF1YWwoW1xyXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnLFxyXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0Y3N2L2xvYWQuc3FsJyxcclxuICAgICAgICAgICAgICAgICcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9zY2hlbWEuc3FsJyxcclxuICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjc3ZfYnVmZmVyX3V0ZjggPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnKTtcclxuICAgICAgICAgICAgY29uc3QgbG9hZF9zY3JpcHRfdXRmOCA9IGF3YWl0IGRiKCkuY29weUZpbGVUb0J1ZmZlcignL3RtcC9kdWNrZGJleHBvcnRjc3YvbG9hZC5zcWwnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydGNzdi9zY2hlbWEuc3FsJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChsb2FkX3NjcmlwdF91dGY4Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChzY2hlbWFfc2NyaXB0X3V0ZjgubGVuZ3RoKS5ub3QudG9FcXVhbCgwKTtcclxuICAgICAgICAgICAgZXhwZWN0KGNzdl9idWZmZXJfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbG9hZF9zY3JpcHQgPSBkZWNvZGVyLmRlY29kZShsb2FkX3NjcmlwdF91dGY4KTtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdCA9IGRlY29kZXIuZGVjb2RlKHNjaGVtYV9zY3JpcHRfdXRmOCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNzdl9idWZmZXIgPSBkZWNvZGVyLmRlY29kZShjc3ZfYnVmZmVyX3V0ZjgpO1xyXG4gICAgICAgICAgICBleHBlY3QobG9hZF9zY3JpcHQudHJpbSgpKS50b0VxdWFsKFxyXG4gICAgICAgICAgICAgICAgYENPUFkgZm9vIEZST00gJy90bXAvZHVja2RiZXhwb3J0Y3N2L2Zvby5jc3YnIChGT1JNQVQgJ2NzdicsIHF1b3RlICdcIicsIGRlbGltaXRlciAnLCcsIGhlYWRlciAwKTtgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBleHBlY3Qoc2NoZW1hX3NjcmlwdC50cmltKCkpLnRvRXF1YWwoYENSRUFURSBUQUJMRSBmb28odiBCSUdJTlQpO2ApO1xyXG4gICAgICAgICAgICBleHBlY3QoY3N2X2J1ZmZlci50cmltKCkpLnRvRXF1YWwoYDFcXG4yXFxuM1xcbjRcXG41YCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdHZW5lcmF0ZSBTZXJpZXMgYXMgUGFycXVldCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeSgnQ1JFQVRFIFRBQkxFIGZvbyBBUyBTRUxFQ1QgKiBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCA1KSB0KHYpJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYEVYUE9SVCBEQVRBQkFTRSAnL3RtcC9kdWNrZGJleHBvcnRwYXJxdWV0JyAoRk9STUFUIFBBUlFVRVQpYCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZGIoKS5nbG9iRmlsZXMoJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC8qJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzKS5ub3QudG9FcXVhbChbXSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRzLmxlbmd0aCkudG9FcXVhbCgzKTtcclxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWVzID0gcmVzdWx0cy5tYXAoZmlsZSA9PiBmaWxlLmZpbGVOYW1lKS5zb3J0KCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChmaWxlbmFtZXMpLnRvRXF1YWwoW1xyXG4gICAgICAgICAgICAgICAgJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcsXHJcbiAgICAgICAgICAgICAgICAnL3RtcC9kdWNrZGJleHBvcnRwYXJxdWV0L2xvYWQuc3FsJyxcclxuICAgICAgICAgICAgICAgICcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvc2NoZW1hLnNxbCcsXHJcbiAgICAgICAgICAgIF0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcGFycXVldF9idWZmZXIgPSBhd2FpdCBkYigpLmNvcHlGaWxlVG9CdWZmZXIoJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcpO1xyXG4gICAgICAgICAgICBjb25zdCBsb2FkX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvbG9hZC5zcWwnKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hX3NjcmlwdF91dGY4ID0gYXdhaXQgZGIoKS5jb3B5RmlsZVRvQnVmZmVyKCcvdG1wL2R1Y2tkYmV4cG9ydHBhcnF1ZXQvc2NoZW1hLnNxbCcpO1xyXG4gICAgICAgICAgICBleHBlY3QobG9hZF9zY3JpcHRfdXRmOC5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG4gICAgICAgICAgICBleHBlY3Qoc2NoZW1hX3NjcmlwdF91dGY4Lmxlbmd0aCkubm90LnRvRXF1YWwoMCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJxdWV0X2J1ZmZlci5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgU0VMRUNUIHY6OmludGVnZXIgRlJPTSBwYXJxdWV0X3NjYW4oJy90bXAvZHVja2RiZXhwb3J0cGFycXVldC9mb28ucGFycXVldCcpYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZXhwZWN0KGNvbnRlbnQubnVsbENvdW50KS50b0VxdWFsKDApO1xyXG4gICAgICAgICAgICBleHBlY3QoY29udGVudC5udW1Sb3dzKS50b0VxdWFsKDUpO1xyXG4gICAgICAgICAgICBleHBlY3QoY29udGVudC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzEsIDIsIDMsIDQsIDVdKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZSgnQ29weScsICgpID0+IHtcclxuICAgICAgICBpdCgnR2VuZXJhdGUgU2VyaWVzIGFzIFBhcnF1ZXQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgQ09QWSAoU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgNSkgdCh2KSkgVE8gJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcgKEZPUk1BVCAncGFycXVldCcpYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGRiKCkuZ2xvYkZpbGVzKCcvdG1wL2R1Y2tkYmNvcHl0ZXN0KicpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cykubm90LnRvRXF1YWwoW10pO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0cy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lcyA9IHJlc3VsdHMubWFwKGZpbGUgPT4gZmlsZS5maWxlTmFtZSkuc29ydCgpO1xyXG4gICAgICAgICAgICBleHBlY3QoZmlsZW5hbWVzKS50b0VxdWFsKFsnL3RtcC9kdWNrZGJjb3B5dGVzdC5wYXJxdWV0J10pO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJxdWV0X2J1ZmZlciA9IGF3YWl0IGRiKCkuY29weUZpbGVUb0J1ZmZlcignL3RtcC9kdWNrZGJjb3B5dGVzdC5wYXJxdWV0Jyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChwYXJxdWV0X2J1ZmZlci5sZW5ndGgpLm5vdC50b0VxdWFsKDApO1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgY29ubi5xdWVyeShgU0VMRUNUIHY6OmludGVnZXIgRlJPTSBwYXJxdWV0X3NjYW4oJy90bXAvZHVja2RiY29weXRlc3QucGFycXVldCcpYCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50Lm51bVJvd3MpLnRvRXF1YWwoNSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChjb250ZW50LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbMSwgMiwgMywgNCwgNV0pKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW4ge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgdmFsdWVzOiBhbnlbXTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVUYWJsZSh0YWJsZTogYXJyb3cuVGFibGUsIGV4cGVjdGVkOiBDb2x1bW5bXSk6IHZvaWQge1xyXG4gICAgLy8gQ2hlY2sgY29sdW1uIGNvdW50XHJcbiAgICBjb25zdCBjb2xDb3VudCA9IGV4cGVjdGVkLmxlbmd0aDtcclxuICAgIGV4cGVjdCh0YWJsZS5udW1Db2xzKS50b0VxdWFsKGNvbENvdW50KTtcclxuICAgIGlmIChjb2xDb3VudCA9PSAwKSByZXR1cm47XHJcblxyXG4gICAgLy8gQ2hlY2sgY29sdW1uc1xyXG4gICAgY29uc3Qgcm93Q291bnQgPSBleHBlY3RlZFswXS52YWx1ZXMubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgKytpKSB7XHJcbiAgICAgICAgZXhwZWN0KGV4cGVjdGVkW2ldLnZhbHVlcy5sZW5ndGgpLnRvRXF1YWwocm93Q291bnQpO1xyXG4gICAgICAgIGV4cGVjdCh0YWJsZS5nZXRDaGlsZEF0KGkpPy5sZW5ndGgpLnRvRXF1YWwocm93Q291bnQpO1xyXG4gICAgICAgIGV4cGVjdCh0YWJsZS5zY2hlbWEuZmllbGRzW2ldPy5uYW1lKS50b0VxdWFsKGV4cGVjdGVkW2ldLm5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXBhcmUgdGhlIGFjdHVhbCB2YWx1ZXNcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sQ291bnQ7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IGNvbCA9IHRhYmxlLmdldENoaWxkQXQoaSkhO1xyXG4gICAgICAgIGNvbnN0IGhhdmUgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd0NvdW50OyArK2opIHtcclxuICAgICAgICAgICAgaGF2ZS5wdXNoKGNvbC5nZXQoaikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHBlY3QoTnVtYmVyKGhhdmUpKS50b0VxdWFsKE51bWJlcihleHBlY3RlZFtpXS52YWx1ZXMpKTtcclxuICAgIH1cclxufVxyXG4iLCAiaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBDb2x1bW4sIGNvbXBhcmVUYWJsZSB9IGZyb20gJy4vdGFibGVfdGVzdCc7XHJcblxyXG4vLy8gVW5mb3J0dW5hdGVseSwgYXJyb3cuVGFibGUuZnJvbSBkb2VzIG5vdCBidWlsZCBhIHByb3BlciBTY2hlbWEuXHJcbi8vLyBXaGVuIGl0IGRvZXMsIHdlIG1pZ2h0IHdhbnQgdG8gc3dpdGNoIGJhY2sgdG8gYXJyb3cuVGFibGUgaGVyZSBpbnN0ZWFkXHJcbi8vLyBvZiBhcnJvdyBTY2hlbWEgKyBBcnJvd0JhdGNoLlxyXG5pbnRlcmZhY2UgQXJyb3dJbnNlcnRUZXN0IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIHNjaGVtYTogYXJyb3cuU2NoZW1hO1xyXG4gICAgYmF0Y2hlczogQXJyb3dCYXRjaFtdO1xyXG4gICAgb3B0aW9uczogZHVja2RiLkFycm93SW5zZXJ0T3B0aW9ucztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICBleHBlY3RlZENvbHVtbnM6IENvbHVtbltdO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgQXJyb3dCYXRjaCB7XHJcbiAgICBudW1Sb3dzOiBudW1iZXI7XHJcbiAgICBjb2x1bW5zOiBhcnJvdy5EYXRhW107XHJcbn1cclxuXHJcbmNvbnN0IGJ1aWxkVXRmOEFycmF5ID0gKHZhbHVlczogc3RyaW5nW10pID0+IHtcclxuICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgYXJyb3cuVXRmOEJ1aWxkZXIoe1xyXG4gICAgICAgIHR5cGU6IG5ldyBhcnJvdy5VdGY4KCksXHJcbiAgICB9KTtcclxuICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcclxuICAgICAgICBidWlsZGVyLmFwcGVuZCh2KTtcclxuICAgIH1cclxuICAgIGJ1aWxkZXIuZmluaXNoKCk7XHJcbiAgICByZXR1cm4gYnVpbGRlci5mbHVzaCgpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlWEludDMyKG46IG51bWJlciwgY29sczogbnVtYmVyKTogbnVtYmVyW11bXSB7XHJcbiAgICBjb25zdCBjb2x1bW5zID0gW107XHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7ICsraikge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbi5wdXNoKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2x1bW5zO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVBcnJvd1hJbnQzMihuOiBudW1iZXIsIGNvbHM6IG51bWJlcik6IFthcnJvdy5TY2hlbWEsIGFycm93LlJlY29yZEJhdGNoW11dIHtcclxuICAgIGNvbnN0IGNvbHVtbnMgPSBnZW5lcmF0ZVhJbnQzMihuLCBjb2xzKTtcclxuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyArK2opIHtcclxuICAgICAgICBmaWVsZHMucHVzaChuZXcgYXJyb3cuRmllbGQoYHYke2p9YCwgbmV3IGFycm93LkludDMyKCkpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBhcnJvdy5TY2hlbWEoZmllbGRzKTtcclxuICAgIGNvbnN0IGJhdGNoZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKSB7XHJcbiAgICAgICAgY29uc3Qgcm93cyA9IE1hdGgubWluKDEwMDAsIG4gLSBpKTtcclxuICAgICAgICBjb25zdCBkYXRhID0gYXJyb3cubWFrZURhdGEoe1xyXG4gICAgICAgICAgICB0eXBlOiBuZXcgYXJyb3cuU3RydWN0KGZpZWxkcyksXHJcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjb2x1bW5zLm1hcChjID0+XHJcbiAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbmV3IEludDMyQXJyYXkoYy5zbGljZShpLCBpICsgcm93cykpLFxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmF0Y2hlcy5wdXNoKG5ldyBhcnJvdy5SZWNvcmRCYXRjaChzY2hlbWEsIGRhdGEpKTtcclxuICAgICAgICBpICs9IHJvd3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3NjaGVtYSwgYmF0Y2hlc107XHJcbn1cclxuXHJcbmNvbnN0IEFSUk9XX0lOU0VSVF9URVNUUzogQXJyb3dJbnNlcnRUZXN0W10gPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ludGVnZXJzXzEnLFxyXG4gICAgICAgIHNjaGVtYTogbmV3IGFycm93LlNjaGVtYShbXHJcbiAgICAgICAgICAgIG5ldyBhcnJvdy5GaWVsZCgnYScsIG5ldyBhcnJvdy5JbnQzMigpKSxcclxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdiJywgbmV3IGFycm93LkludDMyKCkpLFxyXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2MnLCBuZXcgYXJyb3cuSW50MzIoKSksXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgYmF0Y2hlczogW1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBudW1Sb3dzOiAzLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDMyKCksIGRhdGE6IG5ldyBJbnQzMkFycmF5KFsxLCA0LCA3XSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSwgZGF0YTogbmV3IEludDMyQXJyYXkoWzIsIDUsIDhdKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMywgNiwgOV0pIH0pLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnY29tYmluZWRfMScsXHJcbiAgICAgICAgc2NoZW1hOiBuZXcgYXJyb3cuU2NoZW1hKFtcclxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdhJywgbmV3IGFycm93LkludDMyKCkpLFxyXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2InLCBuZXcgYXJyb3cuSW50MTYoKSksXHJcbiAgICAgICAgICAgIG5ldyBhcnJvdy5GaWVsZCgnYycsIG5ldyBhcnJvdy5VdGY4KCkpLFxyXG4gICAgICAgIF0pLFxyXG4gICAgICAgIGJhdGNoZXM6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbnVtUm93czogMyxcclxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQzMigpLCBkYXRhOiBuZXcgSW50MzJBcnJheShbMSwgNCwgN10pIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDE2KCksIGRhdGE6IG5ldyBJbnQxNkFycmF5KFsyLCA1LCA4XSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVdGY4QXJyYXkoWyczJywgJzYnLCAnOSddKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXHJcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdiJywgdmFsdWVzOiBbMiwgNSwgOF0gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYycsIHZhbHVlczogWyczJywgJzYnLCAnOSddIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2NvbWJpbmVkXzInLFxyXG4gICAgICAgIHNjaGVtYTogbmV3IGFycm93LlNjaGVtYShbXHJcbiAgICAgICAgICAgIG5ldyBhcnJvdy5GaWVsZCgnYScsIG5ldyBhcnJvdy5JbnQzMigpKSxcclxuICAgICAgICAgICAgbmV3IGFycm93LkZpZWxkKCdiJywgbmV3IGFycm93LkludDE2KCkpLFxyXG4gICAgICAgICAgICBuZXcgYXJyb3cuRmllbGQoJ2MnLCBuZXcgYXJyb3cuVXRmOCgpKSxcclxuICAgICAgICBdKSxcclxuICAgICAgICBiYXRjaGVzOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG51bVJvd3M6IDMsXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyb3cubWFrZURhdGEoeyB0eXBlOiBuZXcgYXJyb3cuSW50MzIoKSwgZGF0YTogbmV3IEludDMyQXJyYXkoWzEsIDQsIDddKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQxNigpLCBkYXRhOiBuZXcgSW50MTZBcnJheShbMiwgNSwgOF0pIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkVXRmOEFycmF5KFsnMycsICc2JywgJzknXSksXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBudW1Sb3dzOiAyLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogW1xyXG4gICAgICAgICAgICAgICAgICAgIGFycm93Lm1ha2VEYXRhKHsgdHlwZTogbmV3IGFycm93LkludDMyKCksIGRhdGE6IG5ldyBJbnQzMkFycmF5KFsxMCwgMTNdKSB9KSxcclxuICAgICAgICAgICAgICAgICAgICBhcnJvdy5tYWtlRGF0YSh7IHR5cGU6IG5ldyBhcnJvdy5JbnQxNigpLCBkYXRhOiBuZXcgSW50MTZBcnJheShbMTEsIDE0XSkgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRVdGY4QXJyYXkoWycxMicsICcxNSddKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXHJcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2EnLCB2YWx1ZXM6IFsxLCA0LCA3LCAxMCwgMTNdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4LCAxMSwgMTRdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFsnMycsICc2JywgJzknLCAnMTInLCAnMTUnXSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG5dO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RBcnJvd0luc2VydChkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnQXJyb3cgaW5zZXJ0IGZyb20gaXRlcmFibGUnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEFSUk9XX0lOU0VSVF9URVNUUykge1xyXG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbm4ucXVlcnkoYERST1AgVEFCTEUgSUYgRVhJU1RTICR7dGVzdC5vcHRpb25zLnNjaGVtYSB8fCAnbWFpbid9LiR7dGVzdC5vcHRpb25zLm5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaGVzID0gdGVzdC5iYXRjaGVzLm1hcChiID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYXJyb3cubWFrZURhdGEoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBuZXcgYXJyb3cuU3RydWN0KHRlc3Quc2NoZW1hLmZpZWxkcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBiLmNvbHVtbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhcnJvdy5SZWNvcmRCYXRjaCh0ZXN0LnNjaGVtYSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlID0gbmV3IGFycm93LlRhYmxlKHRlc3Quc2NoZW1hLCBiYXRjaGVzKTtcclxuICAgICAgICAgICAgICAgIGNvbm4uaW5zZXJ0QXJyb3dUYWJsZSh0YWJsZSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0QXJyb3dJbnNlcnRBc3luYyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdBcnJvdyBhc3luYyBpbnNlcnQgZnJvbSBpdGVyYWJsZScsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgQVJST1dfSU5TRVJUX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoZXMgPSB0ZXN0LmJhdGNoZXMubWFwKGIgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhcnJvdy5tYWtlRGF0YSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG5ldyBhcnJvdy5TdHJ1Y3QodGVzdC5zY2hlbWEuZmllbGRzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IGIuY29sdW1ucyxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFycm93LlJlY29yZEJhdGNoKHRlc3Quc2NoZW1hLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGUgPSBuZXcgYXJyb3cuVGFibGUodGVzdC5zY2hlbWEsIGJhdGNoZXMpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRBcnJvd1RhYmxlKHRhYmxlLCB0ZXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdBcnJvdyBhc3luYyBpbnNlcnQgZnJvbSB0YWJsZScsICgpID0+IHtcclxuICAgICAgICBpdCgnc2ltcGxlIGludGVnZXJzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyBpbnNlcnRfZnJvbV90YWJsZWApO1xyXG4gICAgICAgICAgICBjb25zdCB0YWJsZSA9IG5ldyBhcnJvdy5UYWJsZSh7XHJcbiAgICAgICAgICAgICAgICBhOiBhcnJvdy5tYWtlVmVjdG9yKG5ldyBJbnQzMkFycmF5KFsxLCA0LCA3XSkpLFxyXG4gICAgICAgICAgICAgICAgYjogYXJyb3cubWFrZVZlY3RvcihuZXcgSW50MzJBcnJheShbMiwgNSwgOF0pKSxcclxuICAgICAgICAgICAgICAgIGM6IGFycm93LnZlY3RvckZyb21BcnJheTxhcnJvdy5VdGY4PihbJzMnLCAnNicsICc5J10pLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRBcnJvd1RhYmxlKHRhYmxlLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnaW5zZXJ0X2Zyb21fdmVjdG9ycycsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgY29ubi5xdWVyeSgnc2VsZWN0ICogZnJvbSBpbnNlcnRfZnJvbV92ZWN0b3JzJyk7XHJcbiAgICAgICAgICAgIGNvbXBhcmVUYWJsZShyZXN1bHRzLCBbXHJcbiAgICAgICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICAgICAgeyBuYW1lOiAnYycsIHZhbHVlczogWyczJywgJzYnLCAnOSddIH0sXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcbmltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuaW1wb3J0IHsgRHVja0RCRGF0YVByb3RvY29sIH0gZnJvbSAnLi4vc3JjLyc7XHJcbmltcG9ydCB7IENvbHVtbiwgY29tcGFyZVRhYmxlIH0gZnJvbSAnLi90YWJsZV90ZXN0JztcclxuXHJcbmZ1bmN0aW9uIGRlc2NyaWJlQnJvd3NlcihkZXNjcmlwdGlvbjogc3RyaW5nLCBzcGVjRGVmaW5pdGlvbnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uLCBzcGVjRGVmaW5pdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XHJcblxyXG5pbnRlcmZhY2UgSlNPTkluc2VydFRlc3Qge1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgaW5wdXQ6IHN0cmluZztcclxuICAgIG9wdGlvbnM6IGR1Y2tkYi5KU09OSW5zZXJ0T3B0aW9ucztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICBleHBlY3RlZENvbHVtbnM6IENvbHVtbltdO1xyXG59XHJcblxyXG5jb25zdCBKU09OX0lOU0VSVF9URVNUUzogSlNPTkluc2VydFRlc3RbXSA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAncm93c19pbnRlZ2VycycsXHJcbiAgICAgICAgaW5wdXQ6IGBbXHJcbiAgICAgICAgICAgIHtcImFcIjoxLCBcImJcIjoyLCBcImNcIjozfSxcclxuICAgICAgICAgICAge1wiYVwiOjQsIFwiYlwiOjUsIFwiY1wiOjZ9LFxyXG4gICAgICAgICAgICB7XCJhXCI6NywgXCJiXCI6OCwgXCJjXCI6OX0sXHJcbiAgICAgICAgXWAsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcclxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFszLCA2LCA5XSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdjb2xzX2ludGVnZXJzJyxcclxuICAgICAgICBpbnB1dDogYHtcclxuICAgICAgICAgICAgXCJhXCI6IFsxLCA0LCA3XSxcclxuICAgICAgICAgICAgXCJiXCI6IFsyLCA1LCA4XSxcclxuICAgICAgICAgICAgXCJjXCI6IFszLCA2LCA5XVxyXG4gICAgICAgIH1gLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnb3B0aW9uc18xJyxcclxuICAgICAgICBpbnB1dDogYFtcclxuICAgICAgICAgICAge1wiYVwiOjEsIFwiYlwiOjIsIFwiY1wiOjN9LFxyXG4gICAgICAgICAgICB7XCJhXCI6NCwgXCJiXCI6NSwgXCJjXCI6Nn0sXHJcbiAgICAgICAgICAgIHtcImFcIjo3LCBcImJcIjo4LCBcImNcIjo5fSxcclxuICAgICAgICBdYCxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICAgICAgc2hhcGU6IGR1Y2tkYi5KU09OVGFibGVTaGFwZS5ST1dfQVJSQVksXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcclxuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxyXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuVXRmOCgpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbJzMnLCAnNicsICc5J10gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXTtcclxuXHJcbmNvbnN0IFRFU1RfRklMRSA9ICdURVNUJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0SlNPTkluc2VydChkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnSlNPTiBJbnNlcnQgU3luYycsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgSlNPTl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcihURVNUX0ZJTEUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBjb25uLmluc2VydEpTT05Gcm9tUGF0aChURVNUX0ZJTEUsIHRlc3Qub3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gY29ubi5xdWVyeSh0ZXN0LnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGNvbXBhcmVUYWJsZShyZXN1bHRzLCB0ZXN0LmV4cGVjdGVkQ29sdW1ucyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdEpTT05JbnNlcnRBc3luYyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdKU09OIEluc2VydCBCdWZmZXIgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEpTT05fSU5TRVJUX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVCdWZmZXIoVEVTVF9GSUxFLCBidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRKU09ORnJvbVBhdGgoVEVTVF9GSUxFLCB0ZXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBkZXNjcmliZUJyb3dzZXIoJ0pTT04gSW5zZXJ0IEJsb2IgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIEpTT05fSU5TRVJUX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgRFJPUCBUQUJMRSBJRiBFWElTVFMgJHt0ZXN0Lm9wdGlvbnMuc2NoZW1hIHx8ICdtYWluJ30uJHt0ZXN0Lm9wdGlvbnMubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGVuY29kZXIuZW5jb2RlKHRlc3QuaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGRiKCkucmVnaXN0ZXJGaWxlSGFuZGxlKFRFU1RfRklMRSwgYmxvYiwgRHVja0RCRGF0YVByb3RvY29sLkJST1dTRVJfRklMRVJFQURFUiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5pbnNlcnRKU09ORnJvbVBhdGgoVEVTVF9GSUxFLCB0ZXN0Lm9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IGNvbm4ucXVlcnkodGVzdC5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBjb21wYXJlVGFibGUocmVzdWx0cywgdGVzdC5leHBlY3RlZENvbHVtbnMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBEdWNrREJEYXRhUHJvdG9jb2wgfSBmcm9tICcuLi9zcmMvJztcclxuaW1wb3J0IHsgQ29sdW1uLCBjb21wYXJlVGFibGUgfSBmcm9tICcuL3RhYmxlX3Rlc3QnO1xyXG5cclxuZnVuY3Rpb24gZGVzY3JpYmVCcm93c2VyKGRlc2NyaXB0aW9uOiBzdHJpbmcsIHNwZWNEZWZpbml0aW9uczogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgZGVzY3JpYmUoZGVzY3JpcHRpb24sIHNwZWNEZWZpbml0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcclxuXHJcbmludGVyZmFjZSBDU1ZJbnNlcnRUZXN0IHtcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGlucHV0OiBzdHJpbmc7XHJcbiAgICBvcHRpb25zOiBkdWNrZGIuQ1NWSW5zZXJ0T3B0aW9ucztcclxuICAgIHF1ZXJ5OiBzdHJpbmc7XHJcbiAgICBleHBlY3RlZENvbHVtbnM6IENvbHVtbltdO1xyXG59XHJcblxyXG5jb25zdCBDU1ZfSU5TRVJUX1RFU1RTOiBDU1ZJbnNlcnRUZXN0W10gPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2ludGVnZXJzX2F1dG9fMScsXHJcbiAgICAgICAgaW5wdXQ6IGBcImFcIixcImJcIixcImNcIlxyXG4xLDIsM1xyXG40LDUsNlxyXG43LDgsOVxyXG5gLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6ICdjJywgdmFsdWVzOiBbMywgNiwgOV0gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnaW50ZWdlcnNfYXV0b18yJyxcclxuICAgICAgICBpbnB1dDogYGEsYixjXHJcbjEsMiwzXHJcbjQsNSw2XHJcbjcsOCw5XHJcbmAsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcclxuICAgICAgICAgICAgbmFtZTogJ2ZvbycsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFszLCA2LCA5XSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdpbnRlZ2Vyc19hdXRvXzMnLFxyXG4gICAgICAgIGlucHV0OiBgYSxiLGNgLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMCcsIHZhbHVlczogWydhJ10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMScsIHZhbHVlczogWydiJ10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnY29sdW1uMicsIHZhbHVlczogWydjJ10gfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnaW50ZWdlcnNfYXV0b18yJyxcclxuICAgICAgICBpbnB1dDogYGFcclxuMVxyXG40XHJcbjdcclxuYCxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbycsXHJcbiAgICAgICAgZXhwZWN0ZWRDb2x1bW5zOiBbeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH1dLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnb3B0aW9uc18xJyxcclxuICAgICAgICBpbnB1dDogYDEsMiwzXHJcbjQsNSw2XHJcbjcsOCw5XHJcbmAsXHJcbiAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBzY2hlbWE6ICdtYWluJyxcclxuICAgICAgICAgICAgbmFtZTogJ2ZvbzInLFxyXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZXRlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiB7XHJcbiAgICAgICAgICAgICAgICBhOiBuZXcgYXJyb3cuSW50MTYoKSxcclxuICAgICAgICAgICAgICAgIGI6IG5ldyBhcnJvdy5JbnQzMigpLFxyXG4gICAgICAgICAgICAgICAgYzogbmV3IGFycm93LlV0ZjgoKSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHF1ZXJ5OiAnU0VMRUNUICogRlJPTSBtYWluLmZvbzInLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2MnLCB2YWx1ZXM6IFsnMycsICc2JywgJzknXSB9LFxyXG4gICAgICAgIF0sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdvcHRpb25zXzInLFxyXG4gICAgICAgIGlucHV0OiBgMXwyfDAxLzAyLzIwMjBcclxuNHw1fDAxLzAzLzIwMjBcclxuN3w4fDAxLzA0LzIwMjBcclxuYCxcclxuICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICBuYW1lOiAnZm9vJyxcclxuICAgICAgICAgICAgZGV0ZWN0OiBmYWxzZSxcclxuICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgZGVsaW1pdGVyOiAnfCcsXHJcbiAgICAgICAgICAgIGRhdGVGb3JtYXQ6ICclbS8lZC8lWScsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcclxuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxyXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuRGF0ZURheSgpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcXVlcnk6ICdTRUxFQ1QgKiBGUk9NIG1haW4uZm9vJyxcclxuICAgICAgICBleHBlY3RlZENvbHVtbnM6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiAnYScsIHZhbHVlczogWzEsIDQsIDddIH0sXHJcbiAgICAgICAgICAgIHsgbmFtZTogJ2InLCB2YWx1ZXM6IFsyLCA1LCA4XSB9LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnYycsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygyMDIwLCAwLCAyKSksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoRGF0ZS5VVEMoMjAyMCwgMCwgMykpLFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKERhdGUuVVRDKDIwMjAsIDAsIDQpKSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ29wdGlvbnNfMycsXHJcbiAgICAgICAgaW5wdXQ6IGAxfDJ8MjA6MzI6NDUgMTk5Mi0wMy0wMlxyXG40fDV8MjA6MzI6NTAgMTk5Mi0wMy0wMlxyXG43fDh8MjA6MzI6NTUgMTk5Mi0wMy0wMlxyXG5gLFxyXG4gICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgc2NoZW1hOiAnbWFpbicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgICAgICBkZXRlY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICBoZWFkZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBkZWxpbWl0ZXI6ICd8JyxcclxuICAgICAgICAgICAgcXVvdGU6IFwiJ1wiLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXBGb3JtYXQ6ICclSDolTTolUyAlWS0lbS0lZCcsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IHtcclxuICAgICAgICAgICAgICAgIGE6IG5ldyBhcnJvdy5JbnQxNigpLFxyXG4gICAgICAgICAgICAgICAgYjogbmV3IGFycm93LkludDMyKCksXHJcbiAgICAgICAgICAgICAgICBjOiBuZXcgYXJyb3cuVGltZXN0YW1wU2Vjb25kKCksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgICAgICBxdWVyeTogJ1NFTEVDVCAqIEZST00gbWFpbi5mb28nLFxyXG4gICAgICAgIGV4cGVjdGVkQ29sdW1uczogW1xyXG4gICAgICAgICAgICB7IG5hbWU6ICdhJywgdmFsdWVzOiBbMSwgNCwgN10gfSxcclxuICAgICAgICAgICAgeyBuYW1lOiAnYicsIHZhbHVlczogWzIsIDUsIDhdIH0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdjJyxcclxuICAgICAgICAgICAgICAgIHZhbHVlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKERhdGUuVVRDKDE5OTIsIDIsIDIsIDIwLCAzMiwgNDUpKS5nZXRUaW1lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoRGF0ZS5VVEMoMTk5MiwgMiwgMiwgMjAsIDMyLCA1MCkpLmdldFRpbWUoKSxcclxuICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyLCAyMCwgMzIsIDU1KSkuZ2V0VGltZSgpLFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgfSxcclxuXTtcclxuXHJcbmNvbnN0IFRFU1RfRklMRSA9ICdURVNUJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0Q1NWSW5zZXJ0KGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuRHVja0RCQ29ubmVjdGlvbjtcclxuXHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdDU1YgSW5zZXJ0IFN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcihURVNUX0ZJTEUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0Q1NWSW5zZXJ0QXN5bmMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb247XHJcblxyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnQ1NWIEluc2VydCBCdWZmZXIgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBkYigpLnJlZ2lzdGVyRmlsZUJ1ZmZlcihURVNUX0ZJTEUsIGJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmVCcm93c2VyKCdDU1YgSW5zZXJ0IEJsb2IgQXN5bmMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIENTVl9JTlNFUlRfVEVTVFMpIHtcclxuICAgICAgICAgICAgaXQodGVzdC5uYW1lLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KGBEUk9QIFRBQkxFIElGIEVYSVNUUyAke3Rlc3Qub3B0aW9ucy5zY2hlbWEgfHwgJ21haW4nfS4ke3Rlc3Qub3B0aW9ucy5uYW1lfWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gZW5jb2Rlci5lbmNvZGUodGVzdC5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVIYW5kbGUoVEVTVF9GSUxFLCBibG9iLCBEdWNrREJEYXRhUHJvdG9jb2wuQlJPV1NFUl9GSUxFUkVBREVSLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydENTVkZyb21QYXRoKFRFU1RfRklMRSwgdGVzdC5vcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBjb25uLnF1ZXJ5KHRlc3QucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgY29tcGFyZVRhYmxlKHJlc3VsdHMsIHRlc3QuZXhwZWN0ZWRDb2x1bW5zKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi9zcmMvJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0VG9rZW5pemF0aW9uKGRiOiAoKSA9PiBkdWNrZGIuRHVja0RCQmluZGluZ3MpOiB2b2lkIHtcclxuICAgIGRlc2NyaWJlKCdUb2tlbml6ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ1NFTEVDVCAxJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBleHBlY3QoZGIoKS50b2tlbml6ZSgnU0VMRUNUIDEnKSkudG9FcXVhbCh7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzOiBbMCwgN10sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDFdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpdCgnU0VMRUNUICogRlJPTSByZWdpb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4cGVjdChkYigpLnRva2VuaXplKCdTRUxFQ1QgKiBGUk9NIHJlZ2lvbicpKS50b0VxdWFsKHtcclxuICAgICAgICAgICAgICAgIG9mZnNldHM6IFswLCA3LCA5LCAxNF0sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDMsIDQsIDBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRva2VuaXphdGlvbkFzeW5jKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGRlc2NyaWJlKCdUb2tlbml6ZXInLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJ1NFTEVDVCAxJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBleHBlY3QoYXdhaXQgZGIoKS50b2tlbml6ZSgnU0VMRUNUIDEnKSkudG9FcXVhbCh7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzOiBbMCwgN10sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDFdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpdCgnU0VMRUNUICogRlJPTSByZWdpb24nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGV4cGVjdChhd2FpdCBkYigpLnRva2VuaXplKCdTRUxFQ1QgKiBGUk9NIHJlZ2lvbicpKS50b0VxdWFsKHtcclxuICAgICAgICAgICAgICAgIG9mZnNldHM6IFswLCA3LCA5LCAxNF0sXHJcbiAgICAgICAgICAgICAgICB0eXBlczogWzQsIDMsIDQsIDBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vc3JjLyc7XHJcblxyXG5pbnRlcmZhY2UgVGFibGVOYW1lVGVzdCB7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBpbnB1dDogc3RyaW5nO1xyXG4gICAgdGFibGVzOiBzdHJpbmdbXTtcclxufVxyXG5cclxuY29uc3QgVEFCTEVOQU1FX1RFU1RTOiBUYWJsZU5hbWVUZXN0W10gPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3N0YW5kYXJkJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnZmV0Y2hfc3BlY2lmaWMnLFxyXG4gICAgICAgIGlucHV0OiAnU0VMRUNUIGNvbF9hIEZST00gbXlfdGFibGUnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbXVsdGlwbGVfdGFibGVzJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUxLCBteV90YWJsZTIsIG15X3RhYmxlMycsXHJcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlMScsICdteV90YWJsZTInLCAnbXlfdGFibGUzJ10sXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdzYW1lX3RhYmxlX211bHRpcGxlX3RpbWVzJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCBjb2xfYSBGUk9NIG15X3RhYmxlLCBteV90YWJsZSBtMiwgbXlfdGFibGUgbTMnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnc3VicXVlcmllcycsXHJcbiAgICAgICAgaW5wdXQ6ICdTRUxFQ1QgKiBGUk9NIChTRUxFQ1QgKiBGUk9NIChTRUxFQ1QgKiBGUk9NIG15X3RhYmxlKSBibGEpIGJsYTMnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZSddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnam9pbicsXHJcbiAgICAgICAgaW5wdXQ6ICdTRUxFQ1QgY29sX2EgRlJPTSBteV90YWJsZSBKT0lOIG15X3RhYmxlMiBPTiAobXlfdGFibGUuY29sX2I9bXlfdGFibGUyLmNvbF9kKScsXHJcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJywgJ215X3RhYmxlMiddLFxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnc2NhbGFyX3N1YnF1ZXJ5JyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAoU0VMRUNUIENPVU5UKCopIEZST00gbXlfdGFibGUpJyxcclxuICAgICAgICB0YWJsZXM6IFsnbXlfdGFibGUnXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3NldF9vcGVyYXRpb25zJyxcclxuICAgICAgICBpbnB1dDogJ1NFTEVDVCAqIEZST00gbXlfdGFibGUgVU5JT04gQUxMIFNFTEVDVCAqIEZST00gbXlfdGFibGUyIElOVEVSU0VDVCBTRUxFQ1QgKiBGUk9NIG15X3RhYmxlMycsXHJcbiAgICAgICAgdGFibGVzOiBbJ215X3RhYmxlJywgJ215X3RhYmxlMicsICdteV90YWJsZTMnXSxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3dpbmRvd19mdW5jdGlvbnMnLFxyXG4gICAgICAgIGlucHV0OiAnU0VMRUNUIHJvd19udW1iZXIoKSBPVkVSIChPUkRFUiBCWSAoU0VMRUNUIGkraiBGUk9NIG15X3RhYmxlMikpIEZST00gbXlfdGFibGUnLFxyXG4gICAgICAgIHRhYmxlczogWydteV90YWJsZScsICdteV90YWJsZTInXSxcclxuICAgIH0sXHJcbl07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFRhYmxlTmFtZXMoZGI6ICgpID0+IGR1Y2tkYi5EdWNrREJCaW5kaW5ncyk6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5EdWNrREJDb25uZWN0aW9uO1xyXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XHJcbiAgICAgICAgY29ubiA9IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgIH0pO1xyXG4gICAgZGVzY3JpYmUoJ1RhYmxlTmFtZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IG9mIFRBQkxFTkFNRV9URVNUUykge1xyXG4gICAgICAgICAgICBpdCh0ZXN0Lm5hbWUsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhYmxlcyA9IGNvbm4uZ2V0VGFibGVOYW1lcyh0ZXN0LmlucHV0KTtcclxuICAgICAgICAgICAgICAgIGV4cGVjdCh0YWJsZXMpLnRvRXF1YWwodGVzdC50YWJsZXMpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RUYWJsZU5hbWVzQXN5bmMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb247XHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnVGFibGVOYW1lcyBBc3luYycsICgpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgVEFCTEVOQU1FX1RFU1RTKSB7XHJcbiAgICAgICAgICAgIGl0KHRlc3QubmFtZSwgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFibGVzID0gYXdhaXQgY29ubi5nZXRUYWJsZU5hbWVzKHRlc3QuaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0KHRhYmxlcykudG9FcXVhbCh0ZXN0LnRhYmxlcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vLi4vc3JjJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kdWNrZGIvZHVja2RiLXdhc20vaXNzdWVzLzMzMlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdDMzMihkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbjtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgIH0pO1xyXG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgIH0pO1xyXG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJzMzMicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5yZWdpc3RlckZpbGVUZXh0KFxyXG4gICAgICAgICAgICAgICAgJ1Byb2R1Y3RzLmNzdicsXHJcbiAgICAgICAgICAgICAgICBgUHJvZHVjdEdyb3VwLFByb2R1Y3QsWWVhcixRdWFydGVyLFJldmVudWUsVW5pdHMsQ291bnQsUHJvZHVjdCBLZXksUmVzZWxsZXIsUHJvZHVjdCBJbmZvLFF1YXJ0ZXJBc051bWJlclxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDE4LFExLDEwMyw3LDEsMjAxOC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTgsUTEsMTAyLDQsMSwyMDE4LVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOSxRMSw5OCwxMiwxLDIwMTktUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDE4LFExLDEwNCwzLDEsMjAxOC1RMSxTYW1zdW5nLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMTksUTEsODMsNywxLDIwMTktUTEsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLFRoZWF0ZXIsMjAxOCxRMSwxNyw0LDEsMjAxOC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLFRoZWF0ZXIsMjAxOSxRMSwyMCw3LDEsMjAxOS1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLE1vdmllcywyMDE4LFExLDI1LDEyLDEsMjAxOC1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuTWVkaWEsTW92aWVzLDIwMTksUTEsMjYsMTMsMSwyMDE5LVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOCxRMiwxMDUsNSwxLDIwMTgtUTIsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDE5LFEyLDgyLDE1LDEsMjAxOS1RMixMRyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDE4LFEyLDk5LDQsMSwyMDE4LVEyLExHLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXHJcbkVsZWN0cm9uaWNzLENvbXB1dGVyLDIwMTksUTIsODQsMjAsMSwyMDE5LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuTWVkaWEsVGhlYXRlciwyMDE4LFEyLDE3LDQsMSwyMDE4LVEyLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxUaGVhdGVyLDIwMTksUTIsMjIsNSwxLDIwMTktUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxOCxRMiwyNSwxMiwxLDIwMTgtUTIsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxOSxRMiwyNiwxNCwxLDIwMTktUTIsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwyXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMDAsUTEsMTAzLDcsMSwyMDAwLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAwMSxRMSwxMDIsNCwxLDIwMDEtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDAyLFExLDk4LDEyLDEsMjAwMi1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAwMyxRMSwxMDQsMywxLDIwMDMtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDA0LFExLDgzLDcsMSwyMDA0LVExLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuTWVkaWEsVGhlYXRlciwyMDA1LFExLDE3LDQsMSwyMDA1LVExLEdvb2dsZSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5NZWRpYSxUaGVhdGVyLDIwMDYsUTEsMjAsNywxLDIwMDYtUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5NZWRpYSxNb3ZpZXMsMjAwNyxRMSwyNSwxMiwxLDIwMDctUTEsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMVxyXG5NZWRpYSxNb3ZpZXMsMjAwOCxRMSwyNiwxMywxLDIwMDgtUTEsTWljcm9zb2Z0LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMDksUTIsMTA1LDUsMSwyMDA5LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxMCxRMiw4MiwxNSwxLDIwMTAtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDExLFEyLDk5LDQsMSwyMDExLVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAxMixRMiw4NCwyMCwxLDIwMTItUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxUaGVhdGVyLDIwMTMsUTIsMTcsNCwxLDIwMTMtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxUaGVhdGVyLDIwMTQsUTIsMjIsNSwxLDIwMTQtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxNSxRMiwyNSwxMiwxLDIwMTUtUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxNixRMiwyNiwxNCwxLDIwMTYtUTIsU2Ftc3VuZyxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5NZWRpYSxNb3ZpZXMsMjAxNyxRMSwyNiwxMywxLDIwMTctUTEsR29vZ2xlLEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMTgsUTIsMTA1LDUsMSwyMDE4LVEyLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAxOSxRMiw4MiwxNSwxLDIwMTktUTIsU29ueSxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxDb21wdXRlciwyMDIwLFEyLDk5LDQsMSwyMDIwLVEyLE1pY3Jvc29mdCxGb3JtYXQ9WE1MOyA8UHJvcGVydGllcz5cdTIwMjYsMlxyXG5FbGVjdHJvbmljcyxQaG9uZSwyMDIwLFExLDEwMyw3LDEsMjAyMC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbkVsZWN0cm9uaWNzLFBob25lLDIwMjAsUTIsMTAyLDQsMSwyMDIwLVEyLFNhbXN1bmcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDJcclxuRWxlY3Ryb25pY3MsUGhvbmUsMjAyMCxRMyw5OCwxMiwxLDIwMjAtUTMsTEcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDNcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAyMCxRNCwxMDQsMywxLDIwMjAtUTQsTEcsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDRcclxuRWxlY3Ryb25pY3MsQ29tcHV0ZXIsMjAyMCxRMSw4Myw3LDEsMjAyMC1RMSxTb255LEZvcm1hdD1YTUw7IDxQcm9wZXJ0aWVzPlx1MjAyNiwxXHJcbk1lZGlhLFRoZWF0ZXIsMjAyMCxRMSwxNyw0LDEsMjAyMC1RMSxNaWNyb3NvZnQsRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuTWVkaWEsVGhlYXRlciwyMDIwLFExLDIwLDcsMSwyMDIwLVExLFNvbnksRm9ybWF0PVhNTDsgPFByb3BlcnRpZXM+XHUyMDI2LDFcclxuYCxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShcIkNSRUFURSBUQUJMRSBwcm9kdWN0cyBBUyBTRUxFQ1QgKiBGUk9NICdQcm9kdWN0cy5jc3YnXCIpO1xyXG4gICAgICAgICAgICBjb25zdCBhbGwgPSBhd2FpdCBjb25uLnF1ZXJ5KCdTRUxFQ1QgKiBGUk9NIHByb2R1Y3RzJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChhbGwuc2NoZW1hLmZpZWxkcy5sZW5ndGgpLnRvQmUoMTEpO1xyXG4gICAgICAgICAgICBleHBlY3QoYWxsLnNjaGVtYS5maWVsZHNbMF0ubmFtZSkudG9CZSgnUHJvZHVjdEdyb3VwJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluc2Vuc2l0aXZlID0gYXdhaXQgY29ubi5xdWVyeTx7XHJcbiAgICAgICAgICAgICAgICBQcm9kdWN0R3JvdXA6IGFycm93LlV0Zjg7XHJcbiAgICAgICAgICAgIH0+KCdTRUxFQ1QgcHJvZHVjdGdyb3VwIEZST00gcHJvZHVjdHMgR1JPVVAgQlkgcHJvZHVjdGdyb3VwJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChpbnNlbnNpdGl2ZS5zY2hlbWEuZmllbGRzLmxlbmd0aCkudG9CZSgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KGluc2Vuc2l0aXZlLnNjaGVtYS5maWVsZHNbMF0ubmFtZSkudG9CZSgnUHJvZHVjdEdyb3VwJyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChpbnNlbnNpdGl2ZS50b0FycmF5KCkubGVuZ3RoKS50b0VxdWFsKDIpO1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KCdEUk9QIFRBQkxFIHByb2R1Y3RzJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XHJcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy8zMzRcclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3QzMzQoYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGRlc2NyaWJlKCdHaXRIdWIgaXNzdWVzJywgKCkgPT4ge1xyXG4gICAgICAgIGRlc2NyaWJlKCczMzQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGl0KCdDU1YgaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChgZGF0YS5jc3ZgLCAnMXxmb29cXG4yfGJhclxcbicpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0Q1NWRnJvbVBhdGgoJ2RhdGEuY3N2Jywge1xyXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogJ21haW4nLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdmb28nLFxyXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXI6ICd8JyxcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDE6IG5ldyBhcnJvdy5JbnQzMigpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wyOiBuZXcgYXJyb3cuVXRmOCgpLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0RST1AgVEFCTEUgSUYgRVhJU1RTIGZvbycpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkuZHJvcEZpbGUoJ2RhdGEuY3N2Jyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpdCgnSlNPTiByb3cgaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChcclxuICAgICAgICAgICAgICAgICAgICAncm93cy5qc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBgW1xyXG4gICAgICAgICAgICAgICAgICAgIHsgXCJjb2wxXCI6IDEsIFwiY29sMlwiOiBcImZvb1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgeyBcImNvbDFcIjogMiwgXCJjb2wyXCI6IFwiYmFyXCIgfSxcclxuICAgICAgICAgICAgICAgIF1gLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmluc2VydEpTT05Gcm9tUGF0aCgncm93cy5qc29uJywgeyBuYW1lOiAncm93cycgfSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLnF1ZXJ5KCdEUk9QIFRBQkxFIElGIEVYSVNUUyByb3dzJyk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZGIoKS5kcm9wRmlsZSgncm93cy5qc29uJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpdCgnSlNPTiBjb2x1bW4gaW5zZXJ0JywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRiKCkucmVnaXN0ZXJGaWxlVGV4dChcclxuICAgICAgICAgICAgICAgICAgICAnY29sdW1ucy5qc29uJyxcclxuICAgICAgICAgICAgICAgICAgICBge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiY29sMVwiOiBbMSwgMl0sXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb2wyXCI6IFtcImZvb1wiLCBcImJhclwiXVxyXG4gICAgICAgICAgICAgICAgfWAsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uaW5zZXJ0SlNPTkZyb21QYXRoKCdjb2x1bW5zLmpzb24nLCB7IG5hbWU6ICdjb2x1bW5zJyB9KTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoJ0RST1AgVEFCTEUgSUYgRVhJU1RTIGNvbHVtbnMnKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGFkYigpLmRyb3BGaWxlKCdjb2x1bW5zLmpzb24nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGl0KCdRdWVyeSByZXN1bHQgbWF0ZXJpYWxpemVkJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29ubiA9IGF3YWl0IGFkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnk8eyB2OiBhcnJvdy5JbnQgfT4oYFxyXG4gICAgICAgICAgICAgICAgU0VMRUNUICogRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwKSB0KHYpXHJcbiAgICAgICAgICAgIGApO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1F1ZXJ5IHJlc3VsdCBzdHJlYW1lZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIGF3YWl0IGNvbm4uc2VuZDx7IHY6IGFycm93LkludCB9PihgXHJcbiAgICAgICAgICAgICAgICBTRUxFQ1QgKiBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDApIHQodilcclxuICAgICAgICAgICAgYCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHBlY3QoYmF0Y2gubnVtUm93cykudG9CZUdyZWF0ZXJUaGFuKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1ByZXBhcmVkIHN0YXRlbWVudCBtYXRlcmlhbGl6ZWQnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uID0gYXdhaXQgYWRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RtdCA9IGF3YWl0IGNvbm4ucHJlcGFyZShgU0VMRUNUIHYgKyA/IEZST00gZ2VuZXJhdGVfc2VyaWVzKDAsIDEwMDAwKSBhcyB0KHYpO2ApO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5xdWVyeSgyMzQpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc3RtdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaXQoJ1ByZXBhcmVkIHN0YXRlbWVudCBzdHJlYW1lZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm4gPSBhd2FpdCBhZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdG10ID0gYXdhaXQgY29ubi5wcmVwYXJlKGBTRUxFQ1QgdiArID8gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMCwgMTAwMDApIGFzIHQodik7YCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIGF3YWl0IHN0bXQuc2VuZCgyMzQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0KGJhdGNoLm51bVJvd3MpLnRvQmVHcmVhdGVyVGhhbigwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGF3YWl0IHN0bXQuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XHJcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy8zOTNcclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3QzOTMoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgY29ubiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdHaXRIdWIgaXNzdWVzJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCczOTMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICBjYXN0VGltZXN0YW1wVG9EYXRlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhvdXRDYXN0ID0gYXdhaXQgY29ubi5xdWVyeTx7XHJcbiAgICAgICAgICAgICAgICB0czogYXJyb3cuVGltZXN0YW1wTWlsbGlzZWNvbmQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgVElNRVNUQU1QICcxOTkyLTAzLTIyIDAxOjAyOjAzJyBhcyB0c2ApO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0V2l0aG91dENhc3QudG9BcnJheSgpWzBdPy50cykudG9FcXVhbChuZXcgRGF0ZShEYXRlLlVUQygxOTkyLCAyLCAyMiwgMSwgMiwgMykpLmdldFRpbWUoKSk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzdFRpbWVzdGFtcFRvRGF0ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhDYXN0ID0gYXdhaXQgY29ubi5xdWVyeTx7XHJcbiAgICAgICAgICAgICAgICB0czogYXJyb3cuRGF0ZU1pbGxpc2Vjb25kO1xyXG4gICAgICAgICAgICB9PihgU0VMRUNUIFRJTUVTVEFNUCAnMTk5Mi0wMy0yMiAwMTowMjowMycgYXMgdHNgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhDYXN0LnRvQXJyYXkoKVswXT8udHMpLnRvRXF1YWwobmV3IERhdGUoRGF0ZS5VVEMoMTk5MiwgMiwgMjIsIDEsIDIsIDMpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uLy4uL3NyYyc7XHJcbmltcG9ydCAqIGFzIGFycm93IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZHVja2RiL2R1Y2tkYi13YXNtL2lzc3Vlcy80NDhcclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3Q0NDgoZGI6ICgpID0+IGR1Y2tkYi5Bc3luY0R1Y2tEQik6IHZvaWQge1xyXG4gICAgbGV0IGNvbm46IGR1Y2tkYi5Bc3luY0R1Y2tEQkNvbm5lY3Rpb24gfCBudWxsID0gbnVsbDtcclxuICAgIGJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBhZnRlckVhY2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgIGlmIChjb25uKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4uY2xvc2UoKTtcclxuICAgICAgICAgICAgY29ubiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IGRiKCkuZmx1c2hGaWxlcygpO1xyXG4gICAgICAgIGF3YWl0IGRiKCkuZHJvcEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGRlc2NyaWJlKCdHaXRIdWIgaXNzdWVzJywgKCkgPT4ge1xyXG4gICAgICAgIGl0KCc0NDgnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5xdWVyeShgY3JlYXRlIHRlbXAgdGFibGUgdGVzdDQ0OChpIGludGVnZXIpYCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm4ucXVlcnkoYGluc2VydCBpbnRvIHRlc3Q0NDggdmFsdWVzICgxKSwoMiksKDEpYCk7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb25uLnF1ZXJ5KGBzZWxlY3QgKiBmcm9tIHRlc3Q0NDhgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMyk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxLCAyLCAxXSkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCBjb25uLnF1ZXJ5PHsgaTogYXJyb3cuTWFwXzxhcnJvdy5JbnQzMiwgYXJyb3cuVWludDY0PiB9Pihgc2VsZWN0IGhpc3RvZ3JhbShpKSBmcm9tIHRlc3Q0NDhgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0JlKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvQmUoMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gcmVzdWx0LmdldENoaWxkQXQoMCkhLnRvQXJyYXkoKTtcclxuICAgICAgICAgICAgZXhwZWN0KGFycmF5Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KGFycmF5WzBdLnRvU3RyaW5nKCkpLnRvRXF1YWwoJ3sxOiAyLCAyOiAxfScpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi8uLi9zcmMnO1xyXG5pbXBvcnQgKiBhcyBhcnJvdyBmcm9tICdhcGFjaGUtYXJyb3cnO1xyXG5cclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2R1Y2tkYi9kdWNrZGItd2FzbS9pc3N1ZXMvNDcwXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZXN0NDcwKGRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIGxldCBjb25uOiBkdWNrZGIuQXN5bmNEdWNrREJDb25uZWN0aW9uIHwgbnVsbCA9IG51bGw7XHJcbiAgICBiZWZvcmVFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgIH0pO1xyXG4gICAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICBhd2FpdCBjb25uLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBhd2FpdCBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcbiAgICBkZXNjcmliZSgnR2l0SHViIGlzc3VlcycsICgpID0+IHtcclxuICAgICAgICBpdCgnNDcwJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBCYXNlbGluZSB3aXRob3V0IGNhc3Q6IHdlIGV4cGVjdCBhbiBlcnJvciB0byBiZSB0aHJvd24gYmVjYXVzZSBvZiB0aGUgZHVyYXRpb24gdHlwZSB0aGF0IGlzIGVtaXR0ZWRcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXHJcbiAgICAgICAgICAgICAgICBxdWVyeToge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc3REdXJhdGlvblRvVGltZTY0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgSU5URVJWQUwgJzMnIE1PTlRIIEFTIGludGVydmFsYCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQxLnRvQXJyYXkoKVswXT8uaW50ZXJ2YWw/LnRvU3RyaW5nKCkpLnRvRXF1YWwoJzAsMycpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FzdCBleHBsaWNpdGx5IGVuYWJsZWQ6IFRpbWU2NCB2YWx1ZSBpcyByZXR1cm5lZFxyXG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzdER1cmF0aW9uVG9UaW1lNjQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29ubiA9IGF3YWl0IGRiKCkuY29ubmVjdCgpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRXaXRoQ2FzdCA9IGF3YWl0IGNvbm4ucXVlcnk8e1xyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWw6IGFycm93LlRpbWVNaWNyb3NlY29uZDtcclxuICAgICAgICAgICAgfT4oYFNFTEVDVCBJTlRFUlZBTCAnMycgTU9OVEggQVMgaW50ZXJ2YWxgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhDYXN0LnRvQXJyYXkoKVswXT8uaW50ZXJ2YWw/LnRvU3RyaW5nKCkpLnRvRXF1YWwoJzAsMycpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ2FzdCBzaG91bGQgYmUgb24gYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBhd2FpdCBkYigpLm9wZW4oe1xyXG4gICAgICAgICAgICAgICAgcGF0aDogJzptZW1vcnk6JyxcclxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7fSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aERlZmF1bHQgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgIGludGVydmFsOiBhcnJvdy5UaW1lTWljcm9zZWNvbmQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgSU5URVJWQUwgJzMnIE1PTlRIIEFTIGludGVydmFsYCk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHRXaXRoRGVmYXVsdC50b0FycmF5KClbMF0/LmludGVydmFsPy50b1N0cmluZygpKS50b0VxdWFsKCcwLDMnKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbiIsICJpbXBvcnQgKiBhcyBkdWNrZGIgZnJvbSAnLi4vLi4vc3JjJztcclxuaW1wb3J0ICogYXMgYXJyb3cgZnJvbSAnYXBhY2hlLWFycm93JztcclxuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kdWNrZGIvZHVja2RiLXdhc20vaXNzdWVzLzQ3N1xyXG4vLyBOb3RlIHRoYXQgd2hlbiBBcnJvd0pTIHN1cHBvcnRzIG5lZ2F0aXZlIGRlY2ltYWxzLCBjYXN0RGVjaW1hbFRvRG91YmxlIHNob3VsZCBwcm9iYWJseSBiZSBkZXByZWNhdGVkLlxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdDQ3NyhkYjogKCkgPT4gZHVja2RiLkFzeW5jRHVja0RCKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkFzeW5jRHVja0RCQ29ubmVjdGlvbiB8IG51bGwgPSBudWxsO1xyXG4gICAgYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICB9KTtcclxuICAgIGFmdGVyRWFjaChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgaWYgKGNvbm4pIHtcclxuICAgICAgICAgICAgYXdhaXQgY29ubi5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjb25uID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgZGIoKS5mbHVzaEZpbGVzKCk7XHJcbiAgICAgICAgYXdhaXQgZGIoKS5kcm9wRmlsZXMoKTtcclxuICAgIH0pO1xyXG4gICAgZGVzY3JpYmUoJ0dpdEh1YiBpc3N1ZXMnLCAoKSA9PiB7XHJcbiAgICAgICAgaXQoJzQ3NycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgLy8gQmFzZWxpbmUgd2l0aG91dCBjYXN0OiB3ZSBleHBlY3QgdGhlIG5lZ2F0aXZlIGRlY2ltYWwgdmFsdWVzIHRvIG5vdCB3b3JrIGFjY3VyYXRlbHlcclxuICAgICAgICAgICAgYXdhaXQgZGIoKS5vcGVuKHtcclxuICAgICAgICAgICAgICAgIHBhdGg6ICc6bWVtb3J5OicsXHJcbiAgICAgICAgICAgICAgICBxdWVyeToge30sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25uID0gYXdhaXQgZGIoKS5jb25uZWN0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFdpdGhvdXRDYXN0ID0gYXdhaXQgY29ubi5xdWVyeShgU0VMRUNUICgtMS45KTo6REVDSU1BTCgyLDEpIGFzIGRlY2ltYWxgKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnNjaGVtYS5maWVsZHNbMF0udHlwZS5zY2FsZSkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnNjaGVtYS5maWVsZHNbMF0udHlwZS5wcmVjaXNpb24pLnRvRXF1YWwoMik7XHJcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYXNzZXJ0aW9uIGJyZWFrcywgYXJyb3cgSlMgd2FzIGxpa2VseSB1cGRhdGVkIHRvIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdFdpdGhvdXRDYXN0LnRvQXJyYXkoKVswXT8uZGVjaW1hbCA9PSAtMTkpLnRvQmUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNpbmcgY2FzdERlY2ltYWxUb0RvdWJsZSB3ZSBmb3JjZSBkZWNpbWFscyB0byBiZSBjYXN0IHRvIGRvdWJsZXMsIG5vdGUgdGhlIGluZXZpdGFibGUgaW1wcmVjaXNpb24uXHJcbiAgICAgICAgICAgIGF3YWl0IGRiKCkub3Blbih7XHJcbiAgICAgICAgICAgICAgICBwYXRoOiAnOm1lbW9yeTonLFxyXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcclxuICAgICAgICAgICAgICAgICAgICBjYXN0RGVjaW1hbFRvRG91YmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbm4gPSBhd2FpdCBkYigpLmNvbm5lY3QoKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0V2l0aENhc3QgPSBhd2FpdCBjb25uLnF1ZXJ5PHtcclxuICAgICAgICAgICAgICAgIGRlY2ltYWw6IGFycm93LkZsb2F0NjQ7XHJcbiAgICAgICAgICAgIH0+KGBTRUxFQ1QgKC0xLjkpOjpERUNJTUFMKDIsMSkgYXMgZGVjaW1hbGApO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0V2l0aENhc3QudG9BcnJheSgpWzBdPy5kZWNpbWFsKS50b0VxdWFsKC0xLjkwMDAwMDAwMDAwMDAwMDEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuIiwgImltcG9ydCAqIGFzIGR1Y2tkYiBmcm9tICcuLi8uLi9zcmMvJztcclxuaW1wb3J0IHsgdGVzdDMzMiB9IGZyb20gJy4vZ2l0aHViXzMzMi50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDMzNCB9IGZyb20gJy4vZ2l0aHViXzMzNC50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDM5MyB9IGZyb20gJy4vZ2l0aHViXzM5My50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDQ0OCB9IGZyb20gJy4vZ2l0aHViXzQ0OC50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDQ3MCB9IGZyb20gJy4vZ2l0aHViXzQ3MC50ZXN0JztcclxuaW1wb3J0IHsgdGVzdDQ3NyB9IGZyb20gXCIuL2dpdGh1Yl80NzcudGVzdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RSZWdyZXNzaW9uQXN5bmMoYWRiOiAoKSA9PiBkdWNrZGIuQXN5bmNEdWNrREIpOiB2b2lkIHtcclxuICAgIHRlc3QzMzIoYWRiKTtcclxuICAgIHRlc3QzMzQoYWRiKTtcclxuICAgIHRlc3QzOTMoYWRiKTtcclxuICAgIHRlc3Q0NDgoYWRiKTtcclxuICAgIHRlc3Q0NzAoYWRiKTtcclxuICAgIHRlc3Q0NzcoYWRiKTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy8nO1xyXG5pbXBvcnQgeyBGbG9hdDY0LCBJbnQzMiwgVXRmOCB9IGZyb20gJ2FwYWNoZS1hcnJvdyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVzdFVERihkYjogKCkgPT4gZHVja2RiLkR1Y2tEQkJpbmRpbmdzKTogdm9pZCB7XHJcbiAgICBsZXQgY29ubjogZHVja2RiLkR1Y2tEQkNvbm5lY3Rpb247XHJcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgICAgICBjb25uID0gZGIoKS5jb25uZWN0KCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBhZnRlckVhY2goKCkgPT4ge1xyXG4gICAgICAgIGNvbm4uY2xvc2UoKTtcclxuICAgICAgICBkYigpLmZsdXNoRmlsZXMoKTtcclxuICAgICAgICBkYigpLmRyb3BGaWxlcygpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVzY3JpYmUoJ1VERicsICgpID0+IHtcclxuICAgICAgICBpdCgnc2ltcGxlJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZicsIG5ldyBJbnQzMigpLCBhID0+IGEpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KGpzdWRmKHY6OklOVEVHRVIpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodiknLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbMTAwMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdkb3VibGUnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMicsIG5ldyBGbG9hdDY0KCksIGEgPT4gYSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGYyKHY6OkRPVUJMRSkpOjpET1VCTEUgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEZsb2F0NjRBcnJheShbMTAwMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCcyIGFyZ3MnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMycsIG5ldyBJbnQzMigpLCAoYSwgYikgPT4gYSArIGIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KGpzdWRmMyh2OjpJTlRFR0VSLCB2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzIwMDAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnMyBhcmdzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjNhcmdzJywgbmV3IEludDMyKCksIChhLCBiLCBjKSA9PiBhICsgYiArIGMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgbWF4KGpzdWRmM2FyZ3Modjo6SU5URUdFUiwgdjo6SU5URUdFUiwgdjo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFszMDAwMF0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJzQgYXJncycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY0YXJncycsIG5ldyBJbnQzMigpLCAoYSwgYiwgYywgZCkgPT4gYSArIGIgKyBjICsgZCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoanN1ZGY0YXJncyh2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSLCB2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQwMDAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnbm9hcmdzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjQnLCBuZXcgSW50MzIoKSwgKCkgPT4gNDIpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KCdTRUxFQ1QgbWF4KGpzdWRmNCgpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodiknKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQyXSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGl0KCd3aXRobnVsbHMnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmNScsIG5ldyBJbnQzMigpLCBhID0+IChhID09IG51bGwgPyAtMTAwIDogYSkpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtaW4oanN1ZGY1KChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUikpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFstMTAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc3RyaW5ncGFyYW0nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGpzdWRmNihzOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjYnLCBuZXcgSW50MzIoKSwganN1ZGY2KTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgIFwiU0VMRUNUIG1heChqc3VkZjYoJ3N0cl8nIHx8IHYpKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodilcIixcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzldKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzdHJpbmdwYXJhbW51bGxzJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBqc3VkZjcoczogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmNycsIG5ldyBJbnQzMigpLCBqc3VkZjcpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgXCJTRUxFQ1QgbWF4KGpzdWRmNygoY2FzZSB3aGVuIHYgJSAyID0gMCB0aGVuICdzdHJfJyB8fCB2IGVsc2UgbnVsbCBlbmQpOjpWQVJDSEFSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpXCIsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFs5XSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnbnVsbGludHJldHVybicsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGY4JywgbmV3IEludDMyKCksIGEgPT4gdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICAnU0VMRUNUIG1heChDT0FMRVNDRShqc3VkZjgodjo6SU5URUdFUiksIDQyKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzQyXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc3RyaW5ncmV0dXJuJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25uLmNyZWF0ZVNjYWxhckZ1bmN0aW9uKCdqc3VkZjknLCBuZXcgVXRmOCgpLCBhID0+ICdIZWxsbyAnICsgYSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb25uLnF1ZXJ5KFxyXG4gICAgICAgICAgICAgICAgJ1NFTEVDVCBtYXgoTEVOR1RIKGpzdWRmOSh2OjpJTlRFR0VSKSkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KScsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFsxMV0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ251bGxzdHJpbmdyZXR1cm4nLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMTAnLCBuZXcgVXRmOCgpLCBhID0+IChhICUgMiA9PSAwID8gJ0hlbGxvJyA6IHVuZGVmaW5lZCkpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgICdTRUxFQ1QgQ09VTlQoanN1ZGYxMCh2OjpJTlRFR0VSKSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpJyxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWzUwMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGl0KCdzdHJ1Y3QnLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbm4uY3JlYXRlU2NhbGFyRnVuY3Rpb24oJ2pzdWRmMTEnLCBuZXcgSW50MzIoKSwgYSA9PiAoYS54ID09IG51bGwgPyAtMTAwIDogYS54KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgU0VMRUNUIG1pbihqc3VkZjExKHsneCc6IChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUiwgJ3knOiA0Mn0pKTo6SU5URUdFUiBhcyBmb28gRlJPTSBnZW5lcmF0ZV9zZXJpZXMoMSwgMTAwMDApIGFzIHQodilgLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Sb3dzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bUNvbHMpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8ubGVuZ3RoKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/LnRvQXJyYXkoKSkudG9FcXVhbChuZXcgSW50MzJBcnJheShbLTEwMF0pKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaXQoJ3N0cnVjdG5lc3RlZCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGYxMicsIG5ldyBJbnQzMigpLCBhID0+IChhLngueSA9PSBudWxsID8gLTEwMCA6IGEueC55KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbm4ucXVlcnkoXHJcbiAgICAgICAgICAgICAgICBgU0VMRUNUIG1pbihqc3VkZjEyKHsneCc6IHsneSc6IChjYXNlIHdoZW4gdiAlIDIgPSAwIHRoZW4gdiBlbHNlIG51bGwgZW5kKTo6SU5URUdFUiB9LCAneic6IDQyfSkpOjpJTlRFR0VSIGFzIGZvbyBGUk9NIGdlbmVyYXRlX3NlcmllcygxLCAxMDAwMCkgYXMgdCh2KWAsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0Lm51bVJvd3MpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtQ29scykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy5sZW5ndGgpLnRvRXF1YWwoMSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZ2V0Q2hpbGRBdCgwKT8udG9BcnJheSgpKS50b0VxdWFsKG5ldyBJbnQzMkFycmF5KFstMTAwXSkpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpdCgnc3RydWN0bmVzdGVkbnVsbCcsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgY29ubi5jcmVhdGVTY2FsYXJGdW5jdGlvbignanN1ZGYxMycsIG5ldyBJbnQzMigpLCBhID0+IChhLng/LnkgPT0gbnVsbCA/IC0xMDAgOiBhLnghLnkpKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29ubi5xdWVyeShcclxuICAgICAgICAgICAgICAgIGBTRUxFQ1QgbWluKGpzdWRmMTMoeyd4JzogKGNhc2Ugd2hlbiB2ICUgMiA9IDAgdGhlbiB7J3knOiB2OjpJTlRFR0VSIH0gZWxzZSBudWxsIGVuZCksICd6JzogNDJ9KSk6OklOVEVHRVIgYXMgZm9vIEZST00gZ2VuZXJhdGVfc2VyaWVzKDEsIDEwMDAwKSBhcyB0KHYpYCxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQubnVtUm93cykudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5udW1Db2xzKS50b0VxdWFsKDEpO1xyXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmdldENoaWxkQXQoMCk/Lmxlbmd0aCkudG9FcXVhbCgxKTtcclxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5nZXRDaGlsZEF0KDApPy50b0FycmF5KCkpLnRvRXF1YWwobmV3IEludDMyQXJyYXkoWy0xMDBdKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4iLCAiaW1wb3J0ICogYXMgZHVja2RiX2Jsb2NraW5nIGZyb20gJy4uL3NyYy90YXJnZXRzL2R1Y2tkYi1icm93c2VyLWJsb2NraW5nJztcclxuaW1wb3J0ICogYXMgZHVja2RiIGZyb20gJy4uL3NyYy90YXJnZXRzL2R1Y2tkYic7XHJcbmltcG9ydCAqIGFzIGNoZWNrIGZyb20gJ3dhc20tZmVhdHVyZS1kZXRlY3QnO1xyXG5cclxuLy8gQ29uZmlndXJlIHRoZSB3b3JrZXJcclxuY29uc3QgRFVDS0RCX0JVTkRMRVM6IGR1Y2tkYi5EdWNrREJCdW5kbGVzID0ge1xyXG4gICAgbXZwOiB7XHJcbiAgICAgICAgbWFpbk1vZHVsZTogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItbXZwLndhc20nLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgICAgICBtYWluV29ya2VyOiBuZXcgVVJMKCcvc3RhdGljL2R1Y2tkYi1icm93c2VyLW12cC53b3JrZXIuanMnLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgIH0sXHJcbiAgICBlaDoge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IG5ldyBVUkwoJy9zdGF0aWMvZHVja2RiLWVoLndhc20nLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgICAgICBtYWluV29ya2VyOiBuZXcgVVJMKCcvc3RhdGljL2R1Y2tkYi1icm93c2VyLWVoLndvcmtlci5qcycsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKS5ocmVmLFxyXG4gICAgfSxcclxuICAgIGNvaToge1xyXG4gICAgICAgIG1haW5Nb2R1bGU6IG5ldyBVUkwoJy9zdGF0aWMvZHVja2RiLWNvaS53YXNtJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXHJcbiAgICAgICAgbWFpbldvcmtlcjogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItYnJvd3Nlci1jb2kud29ya2VyLmpzJywgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYsXHJcbiAgICAgICAgcHRocmVhZFdvcmtlcjogbmV3IFVSTCgnL3N0YXRpYy9kdWNrZGItYnJvd3Nlci1jb2kucHRocmVhZC53b3JrZXIuanMnLCB3aW5kb3cubG9jYXRpb24uaHJlZikuaHJlZixcclxuICAgIH0sXHJcbn07XHJcbmxldCBEVUNLREJfQlVORExFOiBkdWNrZGIuRHVja0RCQnVuZGxlIHwgbnVsbCA9IG51bGw7XHJcblxyXG5kZXNjcmliZSgnd2FzbSBjaGVjaycsICgpID0+IHtcclxuICAgIGl0KCd3b3JrZXIgYW5kIHdhc20gdXJscycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIChhd2FpdCBkdWNrZGIuZ2V0UGxhdGZvcm1GZWF0dXJlcygpKS5jcm9zc09yaWdpbklzb2xhdGVkICYmXHJcbiAgICAgICAgICAgIChhd2FpdCBjaGVjay5leGNlcHRpb25zKCkpICYmXHJcbiAgICAgICAgICAgIChhd2FpdCBjaGVjay50aHJlYWRzKCkpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluTW9kdWxlKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEubWFpbk1vZHVsZSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEubWFpbldvcmtlcik7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLmNvaSEucHRocmVhZFdvcmtlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoYXdhaXQgY2hlY2suZXhjZXB0aW9ucygpKSAmJiAhKGF3YWl0IGNoZWNrLnRocmVhZHMoKSkpIHtcclxuICAgICAgICAgICAgZXhwZWN0KERVQ0tEQl9CVU5ETEUhLm1haW5Nb2R1bGUpLnRvRXF1YWwoRFVDS0RCX0JVTkRMRVMuZWghLm1haW5Nb2R1bGUpO1xyXG4gICAgICAgICAgICBleHBlY3QoRFVDS0RCX0JVTkRMRSEubWFpbldvcmtlcikudG9FcXVhbChEVUNLREJfQlVORExFUy5laCEubWFpbldvcmtlcik7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShhd2FpdCBjaGVjay5leGNlcHRpb25zKCkpKSB7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluTW9kdWxlKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLm12cCEubWFpbk1vZHVsZSk7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5tYWluV29ya2VyKS50b0VxdWFsKERVQ0tEQl9CVU5ETEVTLm12cCEubWFpbldvcmtlcik7XHJcbiAgICAgICAgICAgIGV4cGVjdChEVUNLREJfQlVORExFIS5wdGhyZWFkV29ya2VyKS50b0VxdWFsKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuXHJcbi8vIExvYWRpbmcgZGVidWcgc3ltYm9scywgZXNwZWNpYWxseSBmb3IgV0FTTSB0YWtlIGluc2FuZWx5IGxvbmcgc28gd2UganVzdCBkaXNhYmxlIHRoZSB0ZXN0IHRpbWVvdXRcclxuamFzbWluZS5ERUZBVUxUX1RJTUVPVVRfSU5URVJWQUwgPSA2MDAwMDtcclxuXHJcbi8vIFJlc29sdmUgYSBidWZmZXIgYnkgZmV0Y2hpbmcgZnJvbSBkaXNrXHJcbmNvbnN0IHJlc29sdmVCdWZmZXIgPSBhc3luYyAodXJsOiBzdHJpbmcpID0+IHtcclxuICAgIGNvbnN0IHJlcSA9IGF3YWl0IGZldGNoKGAvZGF0YSR7dXJsfWApO1xyXG4gICAgaWYgKCFyZXEub2spIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHJlcS5hcnJheUJ1ZmZlcigpKTtcclxufTtcclxuXHJcbi8vIFJlc29sdmUgdGVzdCBkYXRhXHJcbmNvbnN0IHJlc29sdmVEYXRhID0gYXN5bmMgKHVybDogc3RyaW5nKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHVybCkge1xyXG4gICAgICAgIGNhc2UgJy91bmkvYWxsLnppcCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL2FsbC56aXAnKTtcclxuICAgICAgICBjYXNlICcvdW5pL2Fzc2lzdGVudGVuLnBhcnF1ZXQnOlxyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzb2x2ZUJ1ZmZlcignL3VuaS9hc3Npc3RlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgY2FzZSAnL3VuaS9zdHVkZW50ZW4ucGFycXVldCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL3N0dWRlbnRlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgY2FzZSAnL3VuaS9ob2VyZW4ucGFycXVldCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNvbHZlQnVmZmVyKCcvdW5pL2hvZXJlbi5wYXJxdWV0Jyk7XHJcbiAgICAgICAgY2FzZSAnL3VuaS92b3JsZXN1bmdlbi5wYXJxdWV0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy91bmkvdm9ybGVzdW5nZW4ucGFycXVldCcpO1xyXG4gICAgICAgIGNhc2UgJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0JzpcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc29sdmVCdWZmZXIoJy90cGNoLzBfMDEvcGFycXVldC9saW5laXRlbS5wYXJxdWV0Jyk7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vLyBUZXN0IGVudmlyb25tZW50XHJcbmxldCBkYjogZHVja2RiX2Jsb2NraW5nLkR1Y2tEQkJpbmRpbmdzIHwgbnVsbCA9IG51bGw7XHJcbmxldCBhZGI6IGR1Y2tkYi5Bc3luY0R1Y2tEQiB8IG51bGwgPSBudWxsO1xyXG5sZXQgd29ya2VyOiBXb3JrZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbmJlZm9yZUFsbChhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgZHVja2RiX2Jsb2NraW5nLlZvaWRMb2dnZXIoKTtcclxuICAgIGRiID0gYXdhaXQgZHVja2RiX2Jsb2NraW5nLmNyZWF0ZUR1Y2tEQihEVUNLREJfQlVORExFUywgbG9nZ2VyLCBkdWNrZGJfYmxvY2tpbmcuQlJPV1NFUl9SVU5USU1FKTtcclxuICAgIGF3YWl0IGRiLmluc3RhbnRpYXRlKF8gPT4ge30pO1xyXG5cclxuICAgIERVQ0tEQl9CVU5ETEUgPSBhd2FpdCBkdWNrZGIuc2VsZWN0QnVuZGxlKERVQ0tEQl9CVU5ETEVTKTtcclxuICAgIHdvcmtlciA9IGF3YWl0IGR1Y2tkYi5jcmVhdGVXb3JrZXIoRFVDS0RCX0JVTkRMRSEubWFpbldvcmtlciEpO1xyXG4gICAgYWRiID0gbmV3IGR1Y2tkYi5Bc3luY0R1Y2tEQihsb2dnZXIsIHdvcmtlcik7XHJcbiAgICBhd2FpdCBhZGIuaW5zdGFudGlhdGUoRFVDS0RCX0JVTkRMRSEubWFpbk1vZHVsZSwgRFVDS0RCX0JVTkRMRSEucHRocmVhZFdvcmtlcik7XHJcbn0pO1xyXG5cclxuYWZ0ZXJBbGwoYXN5bmMgKCkgPT4ge1xyXG4gICAgaWYgKHdvcmtlcikgd29ya2VyLnRlcm1pbmF0ZSgpO1xyXG59KTtcclxuXHJcbmltcG9ydCB7IHRlc3RBbGxUeXBlcywgdGVzdEFsbFR5cGVzQXN5bmMgfSBmcm9tICcuL2FsbF90eXBlcy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEhUVFBGUywgdGVzdEhUVFBGU0FzeW5jIH0gZnJvbSAnLi9odHRwZnNfdGVzdCc7XHJcbmltcG9ydCB7IHRlc3RCaW5kaW5ncywgdGVzdEFzeW5jQmluZGluZ3MgfSBmcm9tICcuL2JpbmRpbmdzLnRlc3QnO1xyXG5pbXBvcnQgeyB0ZXN0QmF0Y2hTdHJlYW0gfSBmcm9tICcuL2JhdGNoX3N0cmVhbS50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEFzeW5jQmF0Y2hTdHJlYW0gfSBmcm9tICcuL2JhdGNoX3N0cmVhbV9hc3luYy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEZpbGVzeXN0ZW0gfSBmcm9tICcuL2ZpbGVzeXN0ZW0udGVzdCc7XHJcbmltcG9ydCB7IHRlc3RBcnJvd0luc2VydCwgdGVzdEFycm93SW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9hcnJvdy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdEpTT05JbnNlcnQsIHRlc3RKU09OSW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9qc29uLnRlc3QnO1xyXG5pbXBvcnQgeyB0ZXN0Q1NWSW5zZXJ0LCB0ZXN0Q1NWSW5zZXJ0QXN5bmMgfSBmcm9tICcuL2luc2VydF9jc3YudGVzdCc7XHJcbmltcG9ydCB7IHRlc3RUb2tlbml6YXRpb24sIHRlc3RUb2tlbml6YXRpb25Bc3luYyB9IGZyb20gJy4vdG9rZW5pemVyLnRlc3QnO1xyXG5pbXBvcnQgeyB0ZXN0VGFibGVOYW1lcywgdGVzdFRhYmxlTmFtZXNBc3luYyB9IGZyb20gJy4vdGFibGVuYW1lcy50ZXN0JztcclxuaW1wb3J0IHsgdGVzdFJlZ3Jlc3Npb25Bc3luYyB9IGZyb20gJy4vcmVncmVzc2lvbic7XHJcbmltcG9ydCB7IHRlc3RVREYgfSBmcm9tICcuL3VkZi50ZXN0JztcclxuLy9pbXBvcnQgeyB0ZXN0RVhDRUwgfSBmcm9tICcuL2V4Y2VsLnRlc3QnO1xyXG4vL2ltcG9ydCB7IHRlc3RKU09OIH0gZnJvbSAnLi9qc29uLnRlc3QnO1xyXG5cclxuY29uc3QgYmFzZVVSTCA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XHJcbmNvbnN0IGRhdGFVUkwgPSBgJHtiYXNlVVJMfS9kYXRhYDtcclxuXHJcbnRlc3RIVFRQRlMoKCkgPT4gZGIhKTtcclxudGVzdEhUVFBGU0FzeW5jKCgpID0+IGFkYiEsIHJlc29sdmVEYXRhLCBkYXRhVVJMKTtcclxudGVzdFVERigoKSA9PiBkYiEpO1xyXG50ZXN0VGFibGVOYW1lcygoKSA9PiBkYiEpO1xyXG50ZXN0VGFibGVOYW1lc0FzeW5jKCgpID0+IGFkYiEpO1xyXG50ZXN0UmVncmVzc2lvbkFzeW5jKCgpID0+IGFkYiEpO1xyXG50ZXN0QWxsVHlwZXMoKCkgPT4gZGIhKTtcclxudGVzdEFsbFR5cGVzQXN5bmMoKCkgPT4gYWRiISk7XHJcbnRlc3RCaW5kaW5ncygoKSA9PiBkYiEsIGRhdGFVUkwpO1xyXG50ZXN0QXN5bmNCaW5kaW5ncygoKSA9PiBhZGIhLCBkYXRhVVJMLCBkdWNrZGIuRHVja0RCRGF0YVByb3RvY29sLkhUVFApO1xyXG50ZXN0QmF0Y2hTdHJlYW0oKCkgPT4gZGIhKTtcclxudGVzdEFzeW5jQmF0Y2hTdHJlYW0oKCkgPT4gYWRiISk7XHJcbnRlc3RGaWxlc3lzdGVtKCgpID0+IGFkYiEsIHJlc29sdmVEYXRhLCBkYXRhVVJMLCBkdWNrZGIuRHVja0RCRGF0YVByb3RvY29sLkhUVFApO1xyXG50ZXN0QXJyb3dJbnNlcnQoKCkgPT4gZGIhKTtcclxudGVzdEFycm93SW5zZXJ0QXN5bmMoKCkgPT4gYWRiISk7XHJcbnRlc3RKU09OSW5zZXJ0KCgpID0+IGRiISk7XHJcbnRlc3RKU09OSW5zZXJ0QXN5bmMoKCkgPT4gYWRiISk7XHJcbnRlc3RDU1ZJbnNlcnQoKCkgPT4gZGIhKTtcclxudGVzdENTVkluc2VydEFzeW5jKCgpID0+IGFkYiEpO1xyXG50ZXN0VG9rZW5pemF0aW9uKCgpID0+IGRiISk7XHJcbnRlc3RUb2tlbml6YXRpb25Bc3luYygoKSA9PiBhZGIhKTtcclxuLy90ZXN0RVhDRUwoKCkgPT4gZGIhKTtcclxuLy90ZXN0SlNPTigoKSA9PiBkYiEpO1xyXG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLHdDQUFBQSxVQUFBQyxTQUFBO0FBZUEsVUFBSUM7QUFDSixVQUFJQztBQUNKLFVBQUlDO0FBQ0osVUFBSUM7QUFDSixVQUFJQztBQUNKLFVBQUlDO0FBQ0osVUFBSUM7QUFDSixVQUFJQztBQUNKLFVBQUlDO0FBQ0osVUFBSUM7QUFDSixVQUFJQztB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QVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sSUFBSyxNQUNyRCxVQUFXLE1BQU0sSUFBSyxNQUFRLFVBQVUsS0FBSyxNQUM3QyxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxLQUFNLE1BQ3RELFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sSUFBSyxNQUNyRCxVQUFXLE1BQU0sSUFBSyxNQUFRLFVBQVUsS0FBSyxNQUM3QyxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxLQUFNLE1BQ3RELFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sSUFBSyxNQUNyRCxVQUFXLE1BQU0sSUFBSyxNQUFRLFVBQVUsS0FBSyxNQUM3QyxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxLQUFNLE1BQ3RELFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sSUFBSyxNQUNyRCxVQUFXLE1BQU0sSUFBSyxNQUFRLFVBQVUsS0FBSyxNQUM3QyxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxLQUFNLE1BQ3RELFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sSUFBSyxNQUNyRCxVQUFXLE1BQU0sSUFBSyxNQUFRLFVBQVUsS0FBSyxNQUM3QyxVQUFXLE1BQU0sS0FBTSxNQUFRLFVBQVcsTUFBTSxLQUFNLE1BQ3RELFVBQVcsTUFBTSxLQUFNLE1BQVEsVUFBVyxNQUFNLEtBQU0sTUFDdEQsVUFBVyxNQUFNLEtBQU0sTUFBUSxVQUFXLE1BQU0sSUFBSyxNQUNyRCxVQUFXLE1BQU0sSUFBSyxNQUFRLFVBQVUs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O0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxjQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFVBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsWUFBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxXQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLHFCQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLG1CQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFNBQUEsTUFBQTtBQUVBLElBQUFBLE1BQUFBLE1BQUEsZ0JBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsVUFBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxXQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFdBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsV0FBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxXQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLFlBQUEsTUFBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsWUFBQSxNQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxZQUFBLE1BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGFBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsYUFBQSxPQUFBO0FBQ0EsSUFBQUEsTUFBQUEsTUFBQSxhQUFBLE9BQUE7QUFDQSxJQUFBQSxNQUFBQSxNQUFBLGFBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEscUJBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEscUJBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsMEJBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsMEJBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEseUJBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEsZ0JBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEscUJBQUEsT0FBQTtBQUNBLElBQUFBLE1BQUFBLE1BQUEscUJB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QUEsUUFDcEMsaUJBQWlCO0FBQUEsUUFDakIsYUFBYTtBQUFBLFFBQ2IsU0FBUztBQUFBLFFBQ1QsVUFBVTtBQUFBLFFBQ1Ysa0NBQWtDO0FBQUEsUUFDbEMsa0NBQWtDO0FBQUEsUUFDbEMsc0NBQXNDO0FBQUEsUUFDdEMsa0NBQWtDO0FBQUEsUUFDbEMsNEJBQTRCO0FBQUEsUUFDNUIsNkJBQTZCO0FBQUEsUUFDN0IsNkNBQTZDO0FBQUEsUUFDN0MsMkJBQTJCO0FBQUEsUUFDM0IsMkJBQTJCO0FBQUEsUUFDM0IsMkJBQTJCO0FBQUEsUUFDM0IsK0JBQStCO0FBQUEsUUFDL0IsNEJBQTRCO0FBQUEsUUFDNUIsMkNBQTJDO0FBQUEsUUFDM0Msc0JBQXNCO0FBQUEsUUFDdEIsb0NBQW9DO0FBQUEsUUFDcEMsOEJBQThCO0FBQUEsUUFDOUIsNEJBQTRCO0FBQUEsUUFDNUIsdUJBQXVCO0FBQUEsUUFDdkIsMkJBQTJCO0FBQUEsUUFDM0Isc0JBQXNCO0FBQUEsUUFDdEIseUJBQXlCO0FBQUEsUUFDekIsMEJBQTBCO0FBQUEsUUFDMUIsZUFBZTtBQUFBLFFBQ2YscUJBQXFCO0FBQUEsUUFDckIsWUFBWTtBQUFBLFFBQ1osaUJBQWlCO0FBQUEsUUFDakIsWUFBWTtBQUFBLFFBQ1osYUFBYTtBQUFBLFFBQ2IsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLFFBQ1gsV0FBVztBQUFBLFFBQ1gsWUFBWTtBQUFBLFFBQ1osZUFBZTtBQUFBLFFBQ2YsY0FBYztBQUFBLFFBQ2QsZUFBZTtBQUFBLFFBQ2YsY0FBYztBQUFBLFFBQ2QsaUJBQWlCO0FBQUEsUUFDakIscUJBQXFCO0FBQUEsUUFDckIsZ0JBQWdCO0FBQUEsUUFDaEIseUJBQXlCO0FBQUEsUUFDekIsbUJBQW1CO0FBQUEsUUFDbkIsb0JBQW9CO0FBQUEsUUFDcEIsMkJBQTJCO0FBQUEsUUFDM0IscUJBQXFCO0FBQUEsUUFDckIsa0JBQWtCO0FBQUEsUUFDbEIscUJBQXFCO0FBQUEsUUFDckIsWUFBWTtBQUFBLFFBQ1osdUJBQXVCO0FBQUEsUUFDdkIseUJB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QUFBLFFBQ25CLG9CQUFvQjtBQUFBLFFBQ3BCLGtCQUFrQjtBQUFBLFFBQ2xCLG9CQUFvQjtBQUFBLFFBQ3BCLCtCQUErQjtBQUFBLFFBQy9CLHlCQUF5QjtBQUFBLFFBQ3pCLG1CQUFtQjtBQUFBLFFBQ25CLGtCQUFrQjtBQUFBLFFBQ2xCLGlCQUFpQjtBQUFBLFFBQ2pCLFdBQVc7QUFBQSxRQUNYLHdCQUF3QjtBQUFBLFFBQ3hCLGtCQUFrQjtBQUFBLFFBQ2xCLHFCQUFxQjtBQUFBLFFBQ3JCLHVCQUF1QjtBQUFBLFFBQ3ZCLHFCQUFxQjtBQUFBLFFBQ3JCLHFCQUFxQjtBQUFBLFFBQ3JCLHlCQUF5QjtBQUFBLFFBQ3pCLHdCQUF3QjtBQUFBLFFBQ3hCLHlCQUF5QjtBQUFBLFFBQ3pCLHdCQUF3QjtBQUFBLFFBQ3hCLG1CQUFtQjtBQUFBLFFBQ25CLHFCQUFxQjtBQUFBLFFBQ3JCLHFCQUFxQjtBQUFBLFFBQ3JCLHdCQUF3QjtBQUFBLFFBQ3hCLG9CQUFvQjtBQUFBLFFBQ3BCLHNCQUFzQjtBQUFBLFFBQ3RCLHNCQUFzQjtBQUFBLFFBQ3RCLG1CQUFtQjtBQUFBLFFBQ25CLG9CQUFvQjtBQUFBLFFBQ3BCLG9CQUFvQjtBQUFBLFFBQ3BCLG9CQUFvQjtBQUFBLFFBQ3BCLHNCQUFzQjtBQUFBLFFBQ3RCLHNDQUFzQztBQUFBLFFBQ3RDLG9DQUFvQztBQUFBLFFBQ3BDLGlCQUFpQjtBQUFBLFFBQ2pCLGFBQWE7QUFBQSxRQUNiLFNBQVM7QUFBQSxRQUNULFVBQVU7QUFBQSxRQUNWLGtDQUFrQztBQUFBLFFBQ2xDLGtDQUFrQztBQUFBLFFBQ2xDLHNDQUFzQztBQUFBLFFBQ3RDLGtDQUFrQztBQUFBLFFBQ2xDLDRCQUE0QjtBQUFBLFFBQzVCLDZCQUE2QjtBQUFBLFFBQzdCLDZDQUE2QztBQUFBLFFBQzdDLDJCQUEyQjtBQUFBLFFBQzNCLDJCQUEyQjtBQUFBLFFBQzNCLDJCQUEyQjtBQUFBLFFBQzNCLCtCQUErQjtBQUFBLFFBQy9CLDRCQUE0QjtBQUFBLFFBQzVCLDJDQUEyQztBQUFBLFFBQzNDLHNC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ZWNvcmF0ZSIsICJfX3BhcmFtIiwgIl9fbWV0YWRhdGEiLCAiX19hd2FpdGVyIiwgIl9fZ2VuZXJhdG9yIiwgIl9fZXhwb3J0U3RhciIsICJfX3ZhbHVlcyIsICJfX3JlYWQiLCAiX19zcHJlYWQiLCAiX19zcHJlYWRBcnJheXMiLCAiX19zcHJlYWRBcnJheSIsICJfX2F3YWl0IiwgIl9fYXN5bmNHZW5lcmF0b3IiLCAiX19hc3luY0RlbGVnYXRvciIsICJfX2FzeW5jVmFsdWVzIiwgIl9fbWFrZVRlbXBsYXRlT2JqZWN0IiwgIl9faW1wb3J0U3RhciIsICJfX2ltcG9ydERlZmF1bHQiLCAiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsICJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IiwgIl9fY2xhc3NQcml2YXRlRmllbGRJbiIsICJfX2NyZWF0ZUJpbmRpbmciLCAicm9vdCIsICJ2IiwgImlzMjI0IiwgIm1ldGhvZCIsICJibG9ja3MiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAidHNsaWIiLCAiaXQiLCAic291cmNlIiwgInB1bXAiLCAiaXQiLCAiZXZlbnRzIiwgImVyciIsICJNZXRhZGF0YVZlcnNpb24iLCAiVW5pb25Nb2RlIiwgIlByZWNpc2lvbiIsICJEYXRlVW5pdCIsICJUaW1lVW5pdCIsICJJbnRlcnZhbFVuaXQiLCAiTWVzc2FnZUhlYWRlciIsICJUeXBlIiwgIkJ1ZmZlclR5cGUiLCAieCIsICJfYSIsICJpbnN0YW5jZSIsICJpbnN0YW5jZSIsICJfYSIsICJpbnN0YW5jZSIsICJnZXRCb29sIiwgInNldEJvb2wiLCAic3VtIiwgImJ5dGVMZW5ndGgiLCAibnVsbEJpdG1hcCIsICJsZW5ndGgiLCAiZ2V0Qm9vbCIsICJpbnN0YW5jZSIsICJpbnN0YW5jZSIsICJpbnN0YW5jZSIsICJfYSIsICJfYiIsICJfZCIsICJfYyIsICJpbnN0YW5jZSIsICJiZWdpbiIsICJlbmQiLCAibmV3RGF0YSIsICJfYSIsICJzaXplIiwgIl9hIiwgIl9iIiwgIl9jIiwgIl9kIiwgIkVuY29kaW5nIiwgIkJ1aWxkZXIiLCAiTWV0YWRhdGFWZXJzaW9uIiwgIkVuZGlhbm5lc3MiLCAiRGljdGlvbmFyeUtpbmQiLCAiQmluYXJ5IiwgIkJvb2wiLCAiRGF0ZVVuaXQiLCAiRGF0ZSIsICJEYXRlVW5pdCIsICJEZWNpbWFsIiwgIlRpbWVVbml0IiwgIkZpeGVkU2l6ZUJpbmFyeSIsICJGaXhlZFNpemVMaXN0IiwgIlByZWNpc2lvbiIsICJQcmVjaXNpb24iLCAiSW50ZXJ2YWxVbml0IiwgIkludGVydmFsVW5pdCIsICJMaXN0IiwgIk1hcCIsICJOdWxsIiwgIlRpbWVVbml0IiwgIlRpbWVVbml0IiwgIlVuaW9uTW9kZSIsICJVbmlvbk1vZGUiLCAiVXRmOCIsICJUeXBlIiwgIlR5cGUiLCAiTWV0YWRhdGFWZXJzaW9uIiwgIlNjaGVtYSIsICJGaWVsZCIsICJMb25nIiwgIkJ1aWxkZXIiLCAiQnl0ZUJ1ZmZlciIsICJTY2hlbWEiLCAiZGIiLCAiTG9uZyIsICJfYiIsICJfYyIsICJJbnQ2NCIsICJVaW50NjQiLCAic3VtIiwgIkZpZWxkIiwgIkludDY0IiwgIkZpZWxkIiwgIkZpZWxkIiwgIkZpZWxkIiwgIkZpZWxkIiwgIkZpZWxkIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgImluc3RhbmNlIiwgInR5cGUiLCAiRmllbGQiLCAiX2EiLCAiU2NoZW1hIiwgInNjaGVtYSIsICJGaWVsZCIsICJiYXRjaGVzIiwgIl9jIiwgIl9iIiwgImluc3RhbmNlIiwgImRhdGEiLCAiaW5kaWNlcyIsICJvbGRUb05ldyIsICJfYSIsICJTY2hlbWEiLCAiRmllbGQiLCAiaW5zdGFuY2UiLCAiX2IiLCAiX2EiLCAiQm9keUNvbXByZXNzaW9uTWV0aG9kIiwgIkNvbXByZXNzaW9uVHlwZSIsICJtZXRob2QiLCAiQnVmZmVyIiwgIlJlY29yZEJhdGNoIiwgIkJ1ZmZlciIsICJSZWNvcmRCYXRjaCIsICJNZXNzYWdlSGVhZGVyIiwgIk1ldGFkYXRhVmVyc2lvbiIsICJNZXNzYWdlSGVhZGVyIiwgIkxvbmciLCAiTnVsbCIsICJCaW5hcnkiLCAiQm9vbCIsICJVdGY4IiwgIkRlY2ltYWwiLCAiRGF0ZSIsICJMaXN0IiwgIkZpeGVkU2l6ZUJpbmFyeSIsICJGaXhlZFNpemVMaXN0IiwgIk1hcCIsICJpbnN0YW5jZSIsICJTY2hlbWEiLCAiUmVjb3JkQmF0Y2giLCAiRGljdGlvbmFyeUJhdGNoIiwgIkZpZWxkIiwgIkZpZWxkTm9kZSIsICJzdW0iLCAiTG9uZyIsICJCdWlsZGVyIiwgIkJ5dGVCdWZmZXIiLCAiTWVzc2FnZSIsICJTY2hlbWEiLCAiUmVjb3JkQmF0Y2giLCAiRGljdGlvbmFyeUJhdGNoIiwgIkZpZWxkTm9kZSIsICJGaWVsZCIsICJUeXBlIiwgIkRlY2ltYWwiLCAiRGF0ZSIsICJGaXhlZFNpemVCaW5hcnkiLCAiRml4ZWRTaXplTGlzdCIsICJNYXAiLCAiaW5zdGFuY2UiLCAiQnVmZmVyIiwgIk1lc3NhZ2UiLCAiX2EiLCAiX2IiLCAiX2MiLCAic2VsZiIsICJGaWVsZE5vZGUiLCAiTWVzc2FnZSIsICJSZWNvcmRCYXRjaCIsICJEaWN0aW9uYXJ5QmF0Y2giLCAiaXQiLCAiX2EiLCAicmVhZGVyIiwgInRtcCIsICJkZWNvZGVyIiwgImY2NCIsICJibG9ja3MiLCAiVEVYVF9FTkNPREVSIiwgIndvcmtlciIsICJURVhUX0VOQ09ERVIiLCAiZSIsICJtZXRob2QiLCAieGhyIiwgInJlc3VsdCIsICJEdWNrREIiLCAicmVxdWlyZSIsICJlcnIiLCAiYXNtIiwgImdldEJpbmFyeSIsICJpbnN0YW5jZSIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJnZXRWYWx1ZSIsICJmZCIsICJ0bXAiLCAiTW9kdWxlIiwgIm91dCIsICJmYW1pbHkiLCAidHlwZSIsICJwcm90byIsICJjYW5vbiIsICJhZGRyIiwgInBvcnQiLCAiYWkiLCAic3VtIiwgImRhdGUiLCAicmV0IiwgInJlc3BvbnNlIiwgIkR1Y2tEQiIsICJpbXBvcnRfbWV0YSIsICJEdWNrREIiLCAicmVxdWlyZSIsICJlcnIiLCAiYXNtIiwgImdldEJpbmFyeSIsICJpbnN0YW5jZSIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJnZXRWYWx1ZSIsICJmZCIsICJ0bXAiLCAiTW9kdWxlIiwgIm91dCIsICJmYW1pbHkiLCAidHlwZSIsICJwcm90byIsICJjYW5vbiIsICJhZGRyIiwgInBvcnQiLCAiYWkiLCAic3VtIiwgImRhdGUiLCAicmV0IiwgIkR1Y2tEQiIsICJEdWNrREIiLCAiZGIiLCAiVEVYVF9FTkNPREVSIiwgIndvcmtlciIsICJfcCIsICJXb3JrZXIiLCAiZGIiLCAibW9kdWxlIiwgImFkYiIsICJyZXNvbHZlRGF0YSIsICJkYiIsICJiYXNlVVJMIiwgImFkYiIsICJkYiIsICJ0ZXN0Um93cyIsICJkYiIsICJkZWNvZGVyIiwgImRiIiwgInJlc29sdmVEYXRhIiwgIlNjaGVtYSIsICJGaWVsZCIsICJkYiIsICJlbmNvZGVyIiwgImRiIiwgImRlc2NyaWJlQnJvd3NlciIsICJlbmNvZGVyIiwgIlRFU1RfRklMRSIsICJkYiIsICJkYiIsICJkYiIsICJkYiIsICJhZGIiLCAiZGIiLCAiZGIiLCAiZGIiLCAiZGIiLCAiYWRiIiwgImRiIl0KfQo=
